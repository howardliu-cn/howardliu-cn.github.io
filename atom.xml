<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沉潜飞动</title>
  
  <subtitle>君子藏器于身，待时而动。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.howardliu.cn/"/>
  <updated>2021-10-24T02:34:08.000Z</updated>
  <id>https://www.howardliu.cn/</id>
  
  <author>
    <name>Howard Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot 实战：加载和读取资源文件内容</title>
    <link href="https://www.howardliu.cn/spring-classpath-file-access/"/>
    <id>https://www.howardliu.cn/spring-classpath-file-access/</id>
    <published>2021-10-24T02:34:08.000Z</published>
    <updated>2021-10-24T02:34:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/20211024104517.jpeg" alt="SpringBoot 实战：加载和读取资源文件内容"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/anramb-20789083/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6137612" target="_blank" rel="noopener">Marna Buys</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6137612" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>本文聊一聊在 SpringBoot 应用中，访问加载类路径（classpath）中的文件内容的多种方法。</p><a id="more"></a><h2 id="通过Resource接口"><a href="#通过Resource接口" class="headerlink" title="通过Resource接口"></a>通过<code>Resource</code>接口</h2><p><code>Resource</code>接口抽象出一种更底层的方式管理资源，可以实现通过统一的方式处理各类文件资源。下面是几种获取资源实例的方法。</p><h3 id="手动加载"><a href="#手动加载" class="headerlink" title="手动加载"></a>手动加载</h3><p>访问类路径中的文件，我们可以直接使用<code>ClassPathResource</code>加载内容，比如：</p><pre><code class="java">new ClassPathResource(&quot;data/resource-data.txt&quot;);</code></pre><p>默认情况下，<code>ClassPathResource</code>会在线程的上下文类加载器和默认系统类加载器之间进行选择，以删除样板文件。我们也可以直接指定类加载器，比如：</p><pre><code class="java">new ClassPathResource(&quot;data/resource-data.txt&quot;, this.getClass().getClassLoader());</code></pre><p>或者是通过指定类的类加载器：</p><pre><code class="java">new ClassPathResource(&quot;data/resource-data.txt&quot;, Employee.class.getClassLoader());</code></pre><p>从<code>Resource</code>对象，我们可以很容易的将其转换为<code>InputStream</code>或<code>File</code>对象。</p><p>上面说的方式都是相对于类路径的地址。如果想要指定某个类的相对路径，我们和可以通过指定具体类来定义，比如：</p><pre><code class="java">new ClassPathResource(&quot;../../../data/resource-data.txt&quot;, Example.class).getFile();</code></pre><p>这样就是相对于<code>Example</code>的相对路径了。在实际使用中，不太建议通过类获取其相对路径的文件。这样会将类与文件的相对坐标绑定，如果修改了类的包路径，但是忘记修改文件位置，就会出现错误。而且，大家现在一般是使用 Maven 之类的包管理器管理，可以直接在<code>resources</code>目录中定义配置文件，使用类路径的相对地址加载文件即可。</p><h3 id="通过-Value自动转换"><a href="#通过-Value自动转换" class="headerlink" title="通过@Value自动转换"></a>通过<code>@Value</code>自动转换</h3><p>我们还可以使用<code>@Value</code>直接注入<code>Resource</code>对象，比如：</p><pre><code class="java">@Value(&quot;classpath:data/resource-data.txt&quot;)Resource resourceFile;</code></pre><p><code>@Value</code>还能支持其他的加载协议，比如<code>file:</code>或<code>url:</code>。</p><h3 id="通过ResourceLoader加载"><a href="#通过ResourceLoader加载" class="headerlink" title="通过ResourceLoader加载"></a>通过<code>ResourceLoader</code>加载</h3><p>我们还能使用注入<code>ResourceLoader</code>来实现资源的懒加载，比如，先注入<code>ResourceLoader</code>实例：</p><pre><code class="java">@AutowiredResourceLoader resourceLoader;</code></pre><p>然后在我们需要的地方，通过<code>ResourceLoader</code>实例加载资源：</p><pre><code class="java">resourceLoader.getResource(&quot;classpath:data/resource-data.txt&quot;);</code></pre><p>在 Spring 中，<code>ApplicationContext</code>实现了<code>ResourceLoader</code>，所以，我们也可以直接通过<code>ApplicationContext</code>实例加载资源，比如：</p><pre><code class="java">ApplicationContext context;public Resource loadEmployeesWithApplicationContext() {    return context.getResource(&quot;classpath:data/resource-data.txt&quot;);}</code></pre><h2 id="使用ResourceUtils加载资源"><a href="#使用ResourceUtils加载资源" class="headerlink" title="使用ResourceUtils加载资源"></a>使用<code>ResourceUtils</code>加载资源</h2><p>在 Spring 内部，还提供了一个工具类<code>ResourceUtils</code>，可以很方便的获取类路径中额资源。但是通过这个类的 Javadoc 可以看到，这个类主要是在 Spring 内部使用，也就是说，不太推荐这种用法。不过我们可以了解一下：</p><pre><code class="java">public File loadEmployeesWithSpringInternalClass()   throws FileNotFoundException {    return ResourceUtils.getFile(      &quot;classpath:data/resource-data.txt&quot;);}</code></pre><p>我们可以了解其内部实现，但是还是建议使用其他更加标准的做法。</p><h2 id="读取资源中的内容"><a href="#读取资源中的内容" class="headerlink" title="读取资源中的内容"></a>读取资源中的内容</h2><p>上面都是通过各种方式获取了<code>Resource</code>资源，接下来我们就聊聊如果获取资源对象的数据。</p><p>比如，我们的资源文件内容如下：</p><pre><code class="txt">站点：https://www.howardliu.cn作者：看山公号：看山的小屋 (kanshanshuo)关注公号得福利：不知道多少 G 的资料（电子书、视频等等）</code></pre><h3 id="通过File对象读取"><a href="#通过File对象读取" class="headerlink" title="通过File对象读取"></a>通过<code>File</code>对象读取</h3><p>我们可以使用<code>getFile</code>方法得到<code>File</code>实例，就可以用读取<code>File</code>对象的方式读取文件了，比如：</p><pre><code class="java">@TestFile resource = new ClassPathResource(&quot;data/resource-data.txt&quot;).getFile();String content = new String(Files.readAllBytes(resource.toPath()));</code></pre><p>但是这种方式不适用与读取 jar 包中的文件，鉴于现在很多应用都是通过 FatJar 方式部署，我们还需要找找其他方式。</p><h3 id="通过InputStream对象读取"><a href="#通过InputStream对象读取" class="headerlink" title="通过InputStream对象读取"></a>通过<code>InputStream</code>对象读取</h3><p><code>File</code>对象不适合 jar 包中资源读取的原因在于文件路径格式不一样，所以我们可以直接将资源内容读取为流的形式，这样就没有文件路径的问题了。比如：</p><pre><code class="java">InputStream resource = new ClassPathResource(&quot;data/resource-data.txt&quot;).getInputStream();try (BufferedReader reader = new BufferedReader(new InputStreamReader(resource))) {    String content = reader.lines().collect(Collectors.joining(&quot;\n&quot;));}</code></pre><p>读取完毕。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文从加载资源、读取内容两个方法讲解，给出了多种读取方式。</p><p>《SpringBoot 实战》是一个系列，我会通过实战+原理的方式完整整个专栏，可以关注公众号「看山的小屋」回复 spring 获取源码。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response/">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response-exception/">SpringBoot 实战：如何优雅的处理异常</a></li><li><a href="https://www.howardliu.cn/spring-beanpostprocessor/">SpringBoot 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://www.howardliu.cn/spring-request-recorder/">SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li><li><a href="https://www.howardliu.cn/spring-enum-params/">SpringBoot 实战：优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-enum-params-principle/">SpringBoot 实战：优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody-principle/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-junit5-mockmvc-mockito/">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a></li><li><a href="https://www.howardliu.cn/spring-classpath-file-access/">SpringBoot 实战：加载和读取资源文件内容</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/spring-classpath-file-access/">SpringBoot 实战：加载和读取资源文件内容</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/120930968" target="_blank" rel="noopener">SpringBoot 实战：加载和读取资源文件内容</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文聊一聊在 SpringBoot 应用中，访问加载类路径（classpath）中的文件内容的多种方法。
    
    </summary>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/categories/spring/"/>
    
    
      <category term="Spring" scheme="https://www.howardliu.cn/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="https://www.howardliu.cn/tags/SpringBoot/"/>
    
      <category term="Resource" scheme="https://www.howardliu.cn/tags/Resource/"/>
    
      <category term="InputStream" scheme="https://www.howardliu.cn/tags/InputStream/"/>
    
      <category term="File" scheme="https://www.howardliu.cn/tags/File/"/>
    
  </entry>
  
  <entry>
    <title>我们如何拿到自己满意的薪资呢？这些套路还是需要掌握的</title>
    <link href="https://www.howardliu.cn/we-should-know-when-changing-job/"/>
    <id>https://www.howardliu.cn/we-should-know-when-changing-job/</id>
    <published>2021-10-20T15:04:14.000Z</published>
    <updated>2021-10-20T15:04:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/20211020230809.jpeg" alt="我们如何拿到自己满意的薪资呢？这些套路还是需要掌握的"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/eddiekphoto-23547624/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6680642" target="_blank" rel="noopener">Eddie K</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6680642" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>实力要有，技巧也要有。我不是教你诈，而是有些技巧你需要了解。</p><a id="more"></a><h2 id="定好目标很重要"><a href="#定好目标很重要" class="headerlink" title="定好目标很重要"></a>定好目标很重要</h2><p>既然是谈薪，那就得有自己的一个期望薪资，这个期望薪资不是拍脑袋想出来的，而是需要有依据的。</p><p>说到拍脑袋一词，回想一下，我们是不是在工作中经常吐槽，“领导的某些想法是拍脑袋想出来的”。轮到我们自己做重大决策的时候，我们是否做到有理有据的理性处理呢？要求别人总是容易的，要求自己还是需要一些努力。</p><p>扯远了，继续聊薪资。</p><h3 id="先要明确自己心意"><a href="#先要明确自己心意" class="headerlink" title="先要明确自己心意"></a>先要明确自己心意</h3><p>首先，我们要确定目标收益。这个收益包括薪资、公司福利、社会声誉、自主时间等一些列的因素。</p><p>目前社会发展基本上可以达到零边际成本，简单的说就是分工明确。分工越是明确，某岗位的收益总和不会差太多。比如，同是研发岗，互联网公司的薪资普遍高于国企，但是其他方面，国企直接碾压互联网。互联网薪资高，但普遍要求 996，有时甚至 007，到哪都得背着电脑，随时在线解决问题。国企薪资相对低一些，但是福利待遇好，人文关怀多，工作时间基本上可以保证 965，出去玩不需要带电脑，碰到问题走流程。</p><p>因此，我们首先要知道自己想要什么。全都要的岗位不是没有，而是太少，需要掂量下自己是否够分量。</p><p>所以，世间哪得双全法，总会有一些取舍。在互联网公司羡慕国企的时间自由，在国企又想要互联网的高薪。事之不如意十之八九，想清楚现在要的是什么，别做围城中的人。</p><p>想清楚之后，就需要确定符合这个期望的公司范围。找到这些公司的所有信息，比如，某歌搜、某眼查、亲朋好友打听、同学同行咨询。这些信息会比较庞杂，需要筛选其中的有效信息，最好是能够找到客观信息。依靠这些，可以把目标公司分成几类：</p><ol><li>特别想去</li><li>想去</li><li>不太想去</li><li>打死也不去</li></ol><p>然后看看这些公司岗位要求，这个比较容易了，从招聘网站找就行。然后根据拿自己条件与之匹配，又能有几种情况：</p><ol><li>完全不达标</li><li>现在不达标</li><li>达标</li></ol><p><img src="https://static.howardliu.cn/20211021081537.png" alt="能力匹配模型"></p><p>拿公司分组与自己的能力分组做匹配，可以找到比较适合的公司或岗位。</p><h3 id="再要评定市场价格"><a href="#再要评定市场价格" class="headerlink" title="再要评定市场价格"></a>再要评定市场价格</h3><p>确定了目标公司或者目标岗位，接下来就需要搞清楚对应的薪资范围了。</p><p>之所以只能搞清楚范围，是因为大部分公司都是密薪，明文规定严禁同事之间讨论薪资，私下讨论的情况也存在，如果不是非常要好的朋友，你又怎知他说的是否有水分。还一个原因，薪资结构比较复杂，工资、年终奖、五险一金、期权、股票、过节费、房补、餐补、加班费……所以能够了解一个范围，就已经很好了。</p><p><img src="https://static.howardliu.cn/20211021081836.jpeg" alt="再要评定市场价格"></p><p>一般有下面几种方式：</p><ol><li>咨询前同事。如果有一个恰好刚跳槽的同事，他跳槽的公司正好是你目标公司或者同类公司，那就可以问他了，约出来撸串吃饭，几杯酒下肚，大家就是兄弟。而且还能聊聊原来的薪资，如果聊得好，还能知道其他同事的薪资。</li><li>某脉职言挖掘信息。直接找在某脉的职言频道找人问，总会找到那种喜欢聊天的耿直 boy。多聊几个，聊聊基本工资，聊聊年终奖，期权和股票估计是问不到了。</li><li>某聘找职位。一般来说，招聘平台发布的职位信息，都是标着薪资面议。有的猎头发的职位会标注薪资范围，可以作为判定依据。多找一些相似岗位、相似量级的公司对比，通过取交集的方式，能够筛选出一个大概的数据范围。</li><li>根据自身薪资定位。如果准备是从互联网跳互联网，比较好的是可以根据自己的薪资做判断。目前很多人薪资涨幅比例是 20%，能够达到 50%的就比较少了，直接涨幅 100%就更少了。这个涨幅指的是工资，其他方面的涨幅就看个人了。</li></ol><p>明确了心意，确定了薪资范围。那就需要给自己定一个比较靠谱的目标了，比如，目标公司是什么，期望薪资是多少，准备争取哪种岗位。</p><h2 id="投递简历找准路"><a href="#投递简历找准路" class="headerlink" title="投递简历找准路"></a>投递简历找准路</h2><p>找到心仪的公司之后，接下来就是要投递简历。这里会有几种操作：</p><ol><li>直接投递招聘信息</li><li>找朋友内推</li><li>联系猎头</li></ol><h3 id="自己敲门恐费时"><a href="#自己敲门恐费时" class="headerlink" title="自己敲门恐费时"></a>自己敲门恐费时</h3><p>刚毕业或者工作 1-3 年的，都会在招聘网站找工作。这个时候自己的履历一般，没有能够很吸引人的地方，挂在网上很久都不会有人看，主动投递也会被卡脖子。如果有岗位比较急的，从筛选简历到面试会进行的很快，否则就直接进人才库。这就是卖方市场。</p><p>3-5 年，会出现第一个分水岭，有的人简历一旦挂上去，就会很多人找过来；有的人却是无人问津。第一种，随着工作的深入，经历的项目多了，能力有了很大的提升，成为了大家都喜欢的香饽饽。第二种，5 年工作 1 年经验，一直在做重复的工作，没有什么技术含量，做的项目也都拿不出手。市场不缺普通工，缺的是高级工。</p><p><img src="https://static.howardliu.cn/20211021081940.jpeg" alt="投递简历找准路"></p><p>因此，给 3-5 年的小伙伴一个建议，不要虚度光阴，现在的你已经能够胜任大部分工作，那就去挑战更有难度的工作。走平路甚至走下坡路是最省事的，向上攀爬是辛苦的，“世之奇伟、瑰怪，非常之观，常在于险远”，不要只是羡慕别人看到了美丽的风景，自己也上去看看。</p><p>5-10 年及以后，自己刷简历找工作比较少了，一般会借助熟人内推或者通过猎头了。</p><h3 id="熟人内推挺靠谱"><a href="#熟人内推挺靠谱" class="headerlink" title="熟人内推挺靠谱"></a>熟人内推挺靠谱</h3><p>熟人内推是比较推崇的一种，适合 3 年以后的同学。一般公司都会鼓励内推，理由是“物以类聚人以群分”，优秀的人周围一般也是优秀的人，有很大概率，被内推的人也是能够胜任工作的。而且，为了鼓励本公司内推，帮着公司挖人，还设置了内推奖之类的。</p><p>前几年有句话比较流行“花若盛开，蝴蝶自来”。你是什么样的人，决定了你周围人的样子，同样的，你周围是什么人，也决定了你的样子。我们都生活在社会中，每天与很多人擦肩而过，与很多人协作共事，我们所散发的能量，会吸引相同频率的人。不要去妄图结交大佬，加了微信好友，可能只是对方的小号，亦或是直接被收进某个群组、打上某个标签。当自己成为了大佬，他自然会是你的朋友。</p><p><img src="https://static.howardliu.cn/20211021082245.jpeg" alt="熟人内推挺靠谱"></p><blockquote><p>话说想要内推的可以后台留言细聊</p></blockquote><h3 id="找找猎头也不错"><a href="#找找猎头也不错" class="headerlink" title="找找猎头也不错"></a>找找猎头也不错</h3><p>找猎头也是个不错的选择，当然需要有一定能力后。如果是小白，那这一单成功率不高，猎头自然不会很上心。但这并不妨碍小白的时候就加一些猎头好友，你能够从他的朋友圈一些业内动态。而且，可以告诉他自己的下一个目标，问问有没有什么要求（一定会有的），然后就可以有的放矢的朝着那个方向使劲了。</p><p>这里给猎头同学正名，不要把他们当成假想敌，其实你和猎头才是一伙的。因为最后拿提成时，猎头的提成是根据你的职级和薪资确定的。明白了吧，在你拿到 offer 入职之前，他都会帮你很多。我认识好几个这么优秀的猎头，如果需要可以加我微信，推荐给你。</p><p><img src="https://static.howardliu.cn/20211021082447.jpeg" alt="找找猎头也不错"></p><h2 id="面试博弈小妙招"><a href="#面试博弈小妙招" class="headerlink" title="面试博弈小妙招"></a>面试博弈小妙招</h2><p>前面都做好了之后，就该进入到面试环节，面试就是纯看实力和运气的过程，没有什么取巧的妙招，只能稳扎稳打的准备。所以，这里只有正常面试 ok 之后的谈薪技巧。</p><h3 id="谈薪博弈先锚定"><a href="#谈薪博弈先锚定" class="headerlink" title="谈薪博弈先锚定"></a>谈薪博弈先锚定</h3><p>有的面试技巧会告诉你，被问到期望薪资的时候，要说一个范围，不要直接说固定值，这样也能有迂回的空间。但是，是否有想过，你给自己的迂回空间，恰恰让对方知道了你的底线。比如 5000-8000，对方给出 5000 的薪资，这个 offer 你是接还是不接，接了心理不舒服，不接又在自己给出的范围。所以，直接给出一个自己的期望值，这个值是高于你的底线的。</p><p>这里需要强调一下，我们所给出的期望薪资，不是拍脑袋的，而是根据前期的调研给出的相对合理的薪资。比如市场普遍的范围在 6000-9000，你直接要 10000。这样不会让对方高看你，只是从侧面告诉对方你不懂行情，可以随意忽悠你了。</p><p>心理学上有个锚定效应，简单的说，结果会偏向先提出期望值的一方。</p><p><img src="https://static.howardliu.cn/20211021082535.jpeg" alt="谈薪博弈先锚定"></p><p>这里再说一个技巧，就是告诉对方期望薪资之前，要问一下面试公司的薪酬结构、五险一金缴纳情况、福利情况等，最好在眉头紧锁，假装自己核算（真的算也行，但这需要一定的心算能力），然后给出结果。是不是显得很专业，是不是这样的结果更能让对方信服。</p><h3 id="入职时间留出-buffer"><a href="#入职时间留出-buffer" class="headerlink" title="入职时间留出 buffer"></a>入职时间留出 buffer</h3><p>有时候，在最终发 offer 前，面试官会问入职时间。假设你现在是离职状态，非常急着找工作，也不要直接回答随时，因为你不可能随时。我所面试的公司，都会在发 offer 之后，要求背调，一般会委托背调公司进行，时间大约在 2-3 天。然后入职需要的手续、证件等，公司还需要提前准备，所以完全不可能今天发 offer，明天就能入职。</p><p>回答随时，只会让面试官感觉你很着急入职，可能在薪资上再压一压。这里再给 HR 正名，压薪资的真不一定是 HR，也有可能是你的上级领导。上级领导需要控人力成本，HR 负责你入离职，所以，谁最有可能压你的工资呢？</p><p>如果是在职，标准的回答是：收到 offer 之后，会立马提交离职信息，准备交接工作，按照规定，需要 1 个月的离职交接时间，我会争取能够提前，所以月内可以到岗。</p><p>如果是离职状态，标准回答是：收到 offer 之后，会开始为入职做准备，同时也会协调好自己的时间，如果公司比较着急，可以 1 周内到岗。</p><h3 id="晋升路径问清楚"><a href="#晋升路径问清楚" class="headerlink" title="晋升路径问清楚"></a>晋升路径问清楚</h3><p>这是一个建议，是可选项。问情况晋升路径。我们工作说白了就是升职加薪，然后实现自我价值。如果不能升职，很有可能加薪无望。所以，一定要知道升职的路径。</p><p><img src="https://static.howardliu.cn/20211021082714.jpeg" alt="晋升路径问清楚"></p><p>说起这个，奉劝一下小伙伴，换工作，我们不能只考虑加薪，不考虑职位。有时候，我们在原单位职位已经达到一定等级，然后开始找到一个薪资不错的工作，但是职级降了。如果是你，你会怎么选？</p><p>我的建议是，如果原来只是个小组长，降为普通组员，那无关痛痒，自己看心情决定。但是如果原来是总监，降为小组长，就需要考虑一下了。这种变动差距太大，你的话语权、决策权，甚至是你所能产生的能量，都缩小太多。这个时候不是考虑是否要换工作，而是需要认真思考自己的定位是否准确。是原来的职位太高，还是自己面试时候降得太低？如果这点没有想清楚，建议还是不要一时冲动。</p><h2 id="祝君早日心自由"><a href="#祝君早日心自由" class="headerlink" title="祝君早日心自由"></a>祝君早日心自由</h2><p>最后就是祝福，升职加薪，早日实现自由。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/when-to-leave-your-programming-job/">程序员什么时候该考虑辞职</a></li><li><a href="https://www.howardliu.cn/why-it-is-difficult-to-get-high-salaries-for-iters/">IT 人为什么难以拿高薪？</a></li><li><a href="https://www.howardliu.cn/we-should-know-when-changing-job/">我们如何拿到自己满意的薪资呢？这些套路还是需要掌握的</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/we-should-know-when-changing-job/">我们如何拿到自己满意的薪资呢？这些套路还是需要掌握的</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/120896294" target="_blank" rel="noopener">我们如何拿到自己满意的薪资呢？这些套路还是需要掌握的</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      我不是教你诈，而是有些技巧需要了解。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="薪资" scheme="https://www.howardliu.cn/tags/%E8%96%AA%E8%B5%84/"/>
    
      <category term="换工作" scheme="https://www.howardliu.cn/tags/%E6%8D%A2%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="套路" scheme="https://www.howardliu.cn/tags/%E5%A5%97%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>阿里开源的这个库，让 Excel 导出不再复杂（填充模板的使用指南）</title>
    <link href="https://www.howardliu.cn/effective-java-easyexcel-action-fill/"/>
    <id>https://www.howardliu.cn/effective-java-easyexcel-action-fill/</id>
    <published>2021-10-10T07:38:15.000Z</published>
    <updated>2021-10-10T07:38:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/20211010155846.jpeg" alt="阿里开源的这个库，让 Excel 导出不再复杂（填充模板的使用指南）"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/宅-ken-21259066/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6674689" target="_blank" rel="noopener">宅-KEN</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6674689" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p><a href="https://www.howardliu.cn/effective-java-easyexcel-action-write/">前文</a> 说了写操作，可以实现简单的列表导出，还能 <a href="https://www.howardliu.cn/effective-java-easyexcel-action-write-pretty/">定义样式</a>。有时候，我们还需要导出的一个大表单，或者是表单+列表的形式，这个时候，我们就需要填充功能。</p><a id="more"></a><p>内容比较多，文内只会列出关键代码，想要完整源码，可以关注公号「看山的小屋」回复“easyexcel”获取。</p><p>在 EasyExcel 中，写操作可以完成大部分工作，填充的优势在于，可以实现自定义样式的，只要在模板中设置好样式，填充的数据就能够带着样式。</p><h2 id="先写个表单"><a href="#先写个表单" class="headerlink" title="先写个表单"></a>先写个表单</h2><p>既然是使用模板，写来定义一个模板。</p><p><img src="https://static.howardliu.cn/20211010154155.png" alt="先写个表单"></p><p>在 EasyExcel 的模板填充定义中，使用<code>{}</code>来表示你要用的变量，如果本来就有”{“,”}”特殊字符，需要对其进行转义，用”{“,”}“代替。</p><h3 id="写对象"><a href="#写对象" class="headerlink" title="写对象"></a>写对象</h3><p>既然是写对象，先定义一下对象结构。</p><pre><code class="java">@Datapublic class Item {    private String name;    private double number;}</code></pre><p>然后开始填充：</p><pre><code class="java">private static void fillUseObject() {    String fileName = defaultFileName(&quot;fillUseObject&quot;);    String templateFile = getPath() + File.separator + &quot;template_fill_sample.xlsx&quot;;    Item item = new Item();    item.setName(&quot;法外狂徒张三&quot;);    item.setNumber(89757);    EasyExcelFactory.write(fileName)            .withTemplate(templateFile)            .sheet()            .doFill(item);}</code></pre><p>在写操作中我们也使用过模板写列表，这里填充模板，使用的是同样的方法：<code>com.alibaba.excel.write.builder.ExcelWriterBuilder#withTemplate(java.lang.String)</code>指定模板文件路径，这里再重复一遍。withTemplate 方法有几个重载实现：</p><ol><li>指定模板文件路径<code>ExcelWriterBuilder#withTemplate(java.lang.String)</code></li><li>指定模板文件对象<code>ExcelWriterBuilder#withTemplate(java.io.File)</code></li><li>指定模板文件输入流<code>ExcelWriterBuilder#withTemplate(java.io.InputStream)</code></li></ol><p>指定模板文件和模板文件对象都是操作文件的，需要有文件信息。</p><p>指定模板文件输入流是只要文件流，这个可操作性空间就比较大了。比如，模板文件是可变的，我们可以基于一个带变量的模板文件，使用填充写入的方式初始化模板文件，然后再用模板写入的方式，写入列表。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211010154224.png" alt="写对象"></p><h3 id="写-Map"><a href="#写-Map" class="headerlink" title="写 Map"></a>写 Map</h3><p>我们也可以不用非得创建类，用 Map 也能实现相同的功能。</p><pre><code class="java">private static void fillUseMap() {    String fileName = defaultFileName(&quot;fillUseMap&quot;);    String templateFile = getPath() + File.separator + &quot;template_fill_sample.xlsx&quot;;    Map&lt;String, Object&gt; data = new HashMap&lt;&gt;();    data.put(&quot;name&quot;, &quot;法外狂徒张三&quot;);    data.put(&quot;number&quot;, 89757);    EasyExcelFactory.write(fileName)            .withTemplate(templateFile)            .sheet()            .doFill(data);}</code></pre><p>虽然 Map 能够功能相同，不过还是建议定义具体的类。因为类是可校验的，Map 是弱检测机制，纯靠约定或者测试，不是很安全。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211010154251.png" alt="写 Map"></p><p>从效果上看，结果是相同的。</p><h2 id="再写个列表"><a href="#再写个列表" class="headerlink" title="再写个列表"></a>再写个列表</h2><p>先定义模板：</p><p><img src="https://static.howardliu.cn/20211010154354.png" alt="再写个列表"></p><p>可以看到，填充列表的参数定义，与填充对象的有些差别，模板中<code>{.}</code>多了个点。</p><p>对于表格的场景，从大体上会分为少量数据和大量数据。对于少量数据，直接在内存中操作即可。对于大量数据，可以使用分批写入，借助文件缓存的方式节省内存。</p><h3 id="少量写"><a href="#少量写" class="headerlink" title="少量写"></a>少量写</h3><p>上代码：</p><pre><code class="java">private static void fillListInMemory() {    String fileName = defaultFileName(&quot;fillListInMemory&quot;);    String templateFile = getPath() + File.separator + &quot;template_fill_list.xlsx&quot;;    EasyExcelFactory.write(fileName)            .withTemplate(templateFile)            .sheet()            .doFill(sampleItems());}</code></pre><p>可以看到，填充列表与前文说到的写文件操作在代码实现上没有太大差异，这也是 EasyExcel 架构设计上的强悍。通过建造器模式的 fluent 写法，屏蔽啰嗦的写入，同时也屏蔽不同业务实现参数的差异，只在<code>doFill</code>的时候，根据不同参数实现不同逻辑。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211010154428.png" alt="少量写"></p><h3 id="大量写"><a href="#大量写" class="headerlink" title="大量写"></a>大量写</h3><p>接下来就是大量数据填充了。与上面的差异在于需要手动创建<code>ExcelWriter</code>和<code>WriteSheet</code>对象，然后使用<code>com.alibaba.excel.ExcelWriter.fill</code>方法多次写入数据。</p><p><code>fill</code>方法支持直接写入列表和使用 lambda 函数方式，注意是<code>fill</code>，不是<code>doFill</code>。<code>doFill</code>会调用<code>finish</code>方法自动关闭流，<code>fill</code>方法只做数据填充，需要手动关闭流。</p><p>代码为：</p><pre><code class="java">private static void fillListSegment() {    String fileName = defaultFileName(&quot;fillListSegment&quot;);    String templateFile = getPath() + File.separator + &quot;template_fill_list.xlsx&quot;;    final ExcelWriter excelWriter = EasyExcelFactory.write(fileName).withTemplate(templateFile).build();    try {        final WriteSheet writeSheet = EasyExcelFactory.writerSheet().build();        excelWriter.fill(BaseFill::sampleItems, writeSheet);        excelWriter.fill(sampleItems(), writeSheet);    } finally {        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211010154502.png" alt="大量写"></p><h2 id="最后写个表单-列表"><a href="#最后写个表单-列表" class="headerlink" title="最后写个表单+列表"></a>最后写个表单+列表</h2><p>最后来个表单与列表的形式。比如销售统计，表头需要填写参数信息，比如店铺信息、时间等，然后是销售记录，最后需要增加类似合计之类的信息。</p><p>这种的话，可以实现的方式也挺多，这里介绍固定列表的实现，在技巧篇中会再介绍一种动态列表的实现。</p><h3 id="填充对象-列表"><a href="#填充对象-列表" class="headerlink" title="填充对象+列表"></a>填充对象+列表</h3><p>先定义模板：</p><p><img src="https://static.howardliu.cn/20211010154533.png" alt="填充对象+列表"></p><p>从模板中可以看到，开头是时间信息，结尾有统计信息，中间是一个列表。</p><p>上代码：</p><pre><code class="java">/** * 填充对象+列表，因为列表之后还有一个字段，所以需要将{@link FillConfigBuilder#forceNewRow(Boolean)}设置为 TRUE 才行。 * &lt;p&gt; * 这样会有一个副作用：所有数据会在内存中，即数据量大的时候特别耗内存。 * &lt;p&gt; * 想要解决有两种方式： * * &lt;ul&gt; *     &lt;li&gt;list 之后没有数据了，{@link FillConfigBuilder#forceNewRow(Boolean)}设置为 FALSE&lt;/li&gt; *     &lt;li&gt;list 写完之后，手动写后面的数据&lt;/li&gt; * &lt;/ul&gt; */private static void fillObjectAndListInMemory() {    String fileName = defaultFileName(&quot;fillObjectAndListInMemory&quot;);    String templateFile = getPath() + File.separator + &quot;template_fill_object_and_list.xlsx&quot;;    final ExcelWriter excelWriter = EasyExcelFactory.write(fileName).withTemplate(templateFile).build();    try {        final WriteSheet writeSheet = EasyExcelFactory.writerSheet().build();        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;date&quot;, DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(LocalDateTime.now()));        map.put(&quot;total&quot;, System.currentTimeMillis());        excelWriter.fill(map, writeSheet);        FillConfig fillConfig = FillConfig.builder().forceNewRow(Boolean.TRUE).build();        excelWriter.fill(BaseFill::sampleItems, fillConfig, writeSheet);        excelWriter.fill(sampleItems(), fillConfig, writeSheet);    } finally {        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>这里有一个新增的配置类：<code>FillConfig fillConfig = FillConfig.builder().forceNewRow(Boolean.TRUE).build()</code>，这个是用来定义写入时的配置信息。配置为 true，代表在写入列表的时候，不管下面有没有空行，都会创建一行，然后下面的数据往后移动。如果不定义或者设置为 false，最后那行的统计信息会被覆盖。</p><p>但是只要设置为 true 了，整个填充操作将都在内存中操作，比较耗费内存。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211010154632.png" alt="填充对象+列表"></p><h3 id="填充对象-列表（大数据量）"><a href="#填充对象-列表（大数据量）" class="headerlink" title="填充对象+列表（大数据量）"></a>填充对象+列表（大数据量）</h3><p>如果列表数据比较大，还在内存中操作就比较容易内存溢出了。所以需要特殊的操作：</p><ol><li>列表之后没有表单填充了，这种最容易实现，一句话实现不了，改需求。</li><li>只能在列表之后手动写数据</li></ol><p>代码如下：</p><pre><code class="java">private static void fillObjectAndListManual() {    String fileName = defaultFileName(&quot;fillObjectAndListManual&quot;);    String templateFile = getPath() + File.separator + &quot;template_fill_object_and_list_manual.xlsx&quot;;    final ExcelWriter excelWriter = EasyExcelFactory.write(fileName).withTemplate(templateFile).build();    try {        final WriteSheet writeSheet = EasyExcelFactory.writerSheet().build();        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;date&quot;, DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(LocalDateTime.now()));        excelWriter.fill(map, writeSheet);        FillConfig fillConfig = FillConfig.builder().forceNewRow(Boolean.TRUE).build();        excelWriter.fill(BaseFill::sampleItems, fillConfig, writeSheet);        excelWriter.fill(sampleItems(), fillConfig, writeSheet);        // 下面是纯手工写数据        List&lt;List&lt;String&gt;&gt; totalListList = new ArrayList&lt;&gt;();        List&lt;String&gt; totalList = new ArrayList&lt;&gt;();        totalListList.add(totalList);        totalList.add(null);        totalList.add(&quot;统计：1000&quot;);        excelWriter.write(totalListList, writeSheet);    } finally {        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211010154712.png" alt="填充对象+列表（大数据量）"></p><h3 id="横向填充数据"><a href="#横向填充数据" class="headerlink" title="横向填充数据"></a>横向填充数据</h3><p>先定义模板：</p><p><img src="https://static.howardliu.cn/20211010154752.png" alt="横向填充数据"></p><pre><code class="java">private static void fillObjectAndListHorizontal() {    String fileName = defaultFileName(&quot;fillObjectAndListHorizontal&quot;);    String templateFile = getPath() + File.separator + &quot;template_fill_list_horizontal.xlsx&quot;;    final ExcelWriter excelWriter = EasyExcelFactory.write(fileName).withTemplate(templateFile).build();    try {        final WriteSheet writeSheet = EasyExcelFactory.writerSheet().build();        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;date&quot;, DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(LocalDateTime.now()));        excelWriter.fill(map, writeSheet);        FillConfig fillConfig = FillConfig.builder().direction(WriteDirectionEnum.HORIZONTAL).build();        excelWriter.fill(BaseFill::sampleItems, fillConfig, writeSheet);        excelWriter.fill(sampleItems(), fillConfig, writeSheet);    } finally {        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>这里配置<code>FillConfig fillConfig = FillConfig.builder().direction(WriteDirectionEnum.HORIZONTAL).build()</code>，用于定义写入方向。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211010154823.png" alt="横向填充数据"></p><h3 id="填充多个表格"><a href="#填充多个表格" class="headerlink" title="填充多个表格"></a>填充多个表格</h3><p>与写操作相同，填充操作也可以实现多表格的写入。</p><p><img src="https://static.howardliu.cn/20211010154844.png" alt="填充多个表格"></p><p>对于多表格写入，定义模板时，必须有<code>{前缀。}</code>。</p><pre><code class="java">private static void fillMultiList() {    String fileName = defaultFileName(&quot;fillMultiList&quot;);    String templateFile = getPath() + File.separator + &quot;template_fill_multi_list.xlsx&quot;;    final ExcelWriter excelWriter = EasyExcelFactory.write(fileName).withTemplate(templateFile).build();    try {        final WriteSheet writeSheet = EasyExcelFactory.writerSheet().build();        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;date&quot;, DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(LocalDateTime.now()));        excelWriter.fill(map, writeSheet);        FillConfig fillConfig = FillConfig.builder().direction(WriteDirectionEnum.HORIZONTAL).build();        excelWriter.fill(new FillWrapper(&quot;data1&quot;, sampleItems()), fillConfig, writeSheet);        // data2 分批写入        excelWriter.fill(new FillWrapper(&quot;data2&quot;, sampleItems()), writeSheet);        excelWriter.fill(new FillWrapper(&quot;data3&quot;, sampleItems()), writeSheet);    } finally {        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>这里用到了<code>FillWrapper</code>，用来包装前缀。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211010154911.png" alt="填充多个表格"></p><p>至此，写操作和填充操作全部介绍完成。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文从实战角度说了一下 EasyExcel 如果实现填充模板导出表格，有了模板填充逻辑，再加上写逻辑，我们会有更多的玩法，接下来就会说一下这些好玩的骚操作。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/effective-java-easyexcel-action-write/">阿里开源的这个库，让 Excel 导出不再复杂（简简单单的写）</a></li><li><a href="https://www.howardliu.cn/effective-java-easyexcel-action-write-pretty/">阿里开源的这个库，让 Excel 导出不再复杂（既要能写，还要写的好看）</a></li><li><a href="https://www.howardliu.cn/effective-java-easyexcel-action-fill/">阿里开源的这个库，让 Excel 导出不再复杂（填充模板的使用指南）</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/effective-java-easyexcel-action-fill/">阿里开源的这个库，让 Excel 导出不再复杂（填充模板的使用指南）</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/120687567" target="_blank" rel="noopener">阿里开源的这个库，让 Excel 导出不再复杂（填充模板的使用指南）</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      在 EasyExcel 中，写操作可以完成大部分工作，填充的优势在于，可以实现自定义样式的，只要在模板中设置好样式，填充的数据就能够带着样式。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Effective Java" scheme="https://www.howardliu.cn/tags/Effective-Java/"/>
    
      <category term="EasyExcel" scheme="https://www.howardliu.cn/tags/EasyExcel/"/>
    
  </entry>
  
  <entry>
    <title>阿里开源的这个库，让 Excel 导出不再复杂（既要能写，还要写的好看）</title>
    <link href="https://www.howardliu.cn/effective-java-easyexcel-action-write-pretty/"/>
    <id>https://www.howardliu.cn/effective-java-easyexcel-action-write-pretty/</id>
    <published>2021-10-07T07:50:47.000Z</published>
    <updated>2021-10-07T07:50:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/20211007160914.jpeg" alt="阿里开源的这个库，让 Excel 导出不再复杂（既要能写，还要写的好看）"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/birgl-6508325/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5760752" target="_blank" rel="noopener">birgl</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5760752" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p><a href="https://www.howardliu.cn/effective-java-easyexcel-action-write/">前文</a> 聊了 EasyExcel 的内容导出，本文主要说一下导出文件的格式化，格式化包括工作表/单元格样式和内容格式化。毕竟，有时候还是要看脸。</p><a id="more"></a><p>内容比较多，文内只会列出关键代码，想要完整源码，可以关注公号「看山的小屋」回复“easyexcel”获取。</p><h2 id="注解格式"><a href="#注解格式" class="headerlink" title="注解格式"></a>注解格式</h2><p>通过注解定义格式是 EasyExcel 封装的高级功能，可以让我们很方便的定义格式。</p><h3 id="格式化内容"><a href="#格式化内容" class="headerlink" title="格式化内容"></a>格式化内容</h3><p>先定义一个使用注解格式化内容的实体类：</p><pre><code class="java">@Datapublic class FormatContentItem {    @ExcelProperty(value = &quot;字符串标题&quot;, converter = TitleFormatConverter.class)    private String string;    @DateTimeFormat(&quot;yyyy 年 MM 月 dd 日 HH 时 mm 分 ss 秒&quot;)    @ExcelProperty(value = &quot;日期标题&quot;)    private Date date;    @NumberFormat(&quot;0.000%&quot;)    @ExcelProperty(&quot;数字标题&quot;)    private Double doubleData;}</code></pre><p>其中<code>DateTimeFormat</code>和<code>NumberFormat</code>两个注解都是自带的注解，用于格式化时间和数字。</p><p><code>DateTimeFormat</code>注解有两个属性，一个属性是<code>value</code>，用来定义时间格式，可以参考<code>java.text.SimpleDateFormat</code>；另一个属性是<code>use1904windowing</code>，表示使用时间使用 1904 时间系统还是 1900 时间系统，默认是否。</p><p><code>NumberFormat</code>注解有两个属性，一个属性是<code>value</code>，用来定义数字格式，可以参考<code>java.text.DecimalFormat</code>；另一个属性是<code>roundingMode</code>，用来定义保留小数的方式，使用的是<code>java.math.RoundingMode</code>枚举。</p><p>想要格式化字符串，可以借助<code>ExcelProperty</code>的 converter 属性，这个属性传入实现<code>Converter</code>的类。比如示例中的<code>TitleFormatConverter</code>，代码如下：</p><pre><code class="java">public class TitleFormatConverter implements Converter&lt;String&gt; {    @Override    public Class&lt;?&gt; supportJavaTypeKey() {        return String.class;    }    @Override    public CellDataTypeEnum supportExcelTypeKey() {        return CellDataTypeEnum.STRING;    }    @Override    public WriteCellData&lt;?&gt; convertToExcelData(String value, ExcelContentProperty contentProperty,            GlobalConfiguration globalConfiguration) {        return new WriteCellData&lt;&gt;(String.format(&quot;标题：%s（自定义）&quot;, value));    }}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211007155354.png" alt="格式化内容"></p><h3 id="定义行高、列宽"><a href="#定义行高、列宽" class="headerlink" title="定义行高、列宽"></a>定义行高、列宽</h3><p>使用注解定义行高的话，可以使用<code>HeadRowHeight</code>定义表头高度，使用<code>ContentRowHeight</code>定义表体高度，这个注解定义之后，所有表体高度都是相同的。列宽可以使用<code>ColumnWidth</code>注解定义，这个注解可以定义在类上，表示整个表格的列都一样宽，也可以定义的属性上，表示指定列的宽度。</p><pre><code class="java">@Data@HeadRowHeight(20)@ContentRowHeight(10)@ColumnWidth(25)public class FormatCellItem {    @ExcelProperty(&quot;字符串标题&quot;)    private String string;    @ExcelProperty(&quot;日期标题&quot;)    private Date date;    @ColumnWidth(50)    @ExcelProperty(&quot;数字标题&quot;)    private Double doubleData;}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211007155431.png" alt="定义行高、列宽"></p><h3 id="单元格定义样式"><a href="#单元格定义样式" class="headerlink" title="单元格定义样式"></a>单元格定义样式</h3><p>控制单元格样式有四个注解：<code>HeadStyle</code>、<code>HeadFontStyle</code>、<code>ContentStyle</code>、<code>ContentFontStyle</code>，这四个注解可以定义在类上作为全局表格的样式，也可以定义在字段上，作为当前列的样式。下面分别说一下这几个注解中比较常用的配置。</p><ul><li>*Style：分为<code>HeadStyle</code>和<code>ContentStyle</code>，分别定义表头和表体样式<ul><li>dataFormat：表头格式化，short 格式，是<code>org.apache.poi.ss.usermodel.BuiltinFormats</code>类中已定义格式的小标</li><li>border*：分别是 borderLeft、borderRight、borderTop、borderBottom 四个属性，类型是<code>com.alibaba.excel.enums.poi.BorderStyleEnum</code>枚举，用来定义表头单元格边框样式。边框的颜色也可以定义，使用、*BorderColor 定义即可。</li><li>fillPatternType：填充类型，类型是<code>com.alibaba.excel.enums.poi.FillPatternTypeEnum</code>枚举，如果想要填充背景色，这个属性需要设置为<code>SOLID_FOREGROUND</code>。</li><li>fillForegroundColor：前景色，类型是 short，值却是使用的<code>org.apache.poi.ss.usermodel.IndexedColors</code>枚举的 idx 值，只不过，两个类型不一致，一个是 short，一个是 int，没有办法直接引用。可见 java 中的依赖之间，还是有很多坑的。</li><li>fillBackgroundColor：背景色，同<code>fillForegroundColor</code>。</li><li>rotation：内容旋转角度</li></ul></li><li>*FontStyle：有<code>HeadFontStyle</code>和<code>ContentFontStyle</code>，分别定义表头和表体的字体样式。<ul><li>fontName：定义字体名称，类型字符串</li><li>fontHeightInPoints：字号大小，类型是 short</li><li>italic：是否斜体，类型是<code>com.alibaba.excel.enums.BooleanEnum</code></li><li>bold：是否加粗，类型是<code>com.alibaba.excel.enums.BooleanEnum</code></li><li>strikeout：是否使用删除线（这个词本意是三振出局的意思，应该是与棒球有关）</li><li>color：文本颜色，值使用的是<code>org.apache.poi.ss.usermodel.IndexedColors</code>，依然有类型不一致的情况</li><li>underline：下划线，类型是 byte，可以直接使用<code>Font.U_NONE</code>、<code>Font.U_SINGLE</code>、<code>Font.U_DOUBLE</code>、<code>Font.U_SINGLE_ACCOUNTING</code>、<code>Font.U_DOUBLE_ACCOUNTING</code>。</li></ul></li></ul><p>我们可以这么定义：</p><pre><code class="java">@Data// 头背景设置成红色 IndexedColors.RED.getIndex()@HeadStyle(fillPatternType = FillPatternTypeEnum.SOLID_FOREGROUND, fillForegroundColor = 10)// 头字体设置成 20@HeadFontStyle(fontHeightInPoints = 20)// 内容的背景设置成绿色 IndexedColors.GREEN.getIndex()@ContentStyle(fillPatternType = FillPatternTypeEnum.SOLID_FOREGROUND, fillForegroundColor = 17)// 内容字体设置成 20@ContentFontStyle(fontHeightInPoints = 20)public class FormatStyleCellItem {    // 字符串的头背景设置成粉红 IndexedColors.PINK.getIndex()    @HeadStyle(fillPatternType = FillPatternTypeEnum.SOLID_FOREGROUND, fillForegroundColor = 14)    // 字符串的头字体设置成 20    @HeadFontStyle(fontHeightInPoints = 30)    // 字符串的内容的背景设置成天蓝 IndexedColors.SKY_BLUE.getIndex()    @ContentStyle(fillPatternType = FillPatternTypeEnum.SOLID_FOREGROUND, fillForegroundColor = 40)    // 字符串的内容字体设置成 20    @ContentFontStyle(fontHeightInPoints = 30)    @ExcelProperty(&quot;字符串标题&quot;)    private String string;    @ExcelProperty(&quot;日期标题&quot;)    private Date date;    @ExcelProperty(&quot;数字标题&quot;)    private Double doubleData;}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211007155504.png" alt="单元格定义样式"></p><h2 id="类对象定义格式"><a href="#类对象定义格式" class="headerlink" title="类对象定义格式"></a>类对象定义格式</h2><p>这种方式可以说是纯手工组装数据了，使用的是<code>com.alibaba.excel.metadata.data.WriteCellData</code>类，这个类相当于是单元格的定义，通过设置<code>com.alibaba.excel.enums.CellDataTypeEnum</code>枚举类型的 type 属性，可以指明当前单元格格式。</p><p>守恒定律一直存在。这种方式灵活度很高，可以精细到具体的单元格格式，但是繁琐程度也增加了。</p><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>超链接使用的是<code>com.alibaba.excel.metadata.data.HyperlinkData</code>类，需要设置地址、超链类型（<code>com.alibaba.excel.metadata.data.HyperlinkData.HyperlinkType</code>枚举），然后将值写入到<code>WriteCellData</code>对象的<code>hyperlinkData</code>属性即可。</p><pre><code class="java">// 设置超链接HyperlinkData hyperlinkData = new HyperlinkData();hyperlinkData.setAddress(&quot;https://www.howardliu.cn&quot;);hyperlinkData.setHyperlinkType(HyperlinkType.URL);WriteCellData&lt;String&gt; hyperlink = new WriteCellData&lt;&gt;(&quot;网站&quot;);hyperlink.setHyperlinkData(hyperlinkData);</code></pre><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>备注使用的是<code>com.alibaba.excel.metadata.data.CommentData</code>类，需要设置作者、备注内容（<code>com.alibaba.excel.metadata.data.RichTextStringData</code>类型），因为备注的默认大小是单元格大小，如果感觉太小，还可以设置相对高度和宽度。</p><pre><code class="java">// 设置备注CommentData commentData = new CommentData();commentData.setAuthor(&quot;Howard Liu&quot;);commentData.setRichTextStringData(new RichTextStringData(&quot;这是一个备注&quot;));// 备注的默认大小是按照单元格的大小 这里想调整到 4 个单元格那么大 所以向后 向下 各额外占用了一个单元格commentData.setRelativeLastColumnIndex(1);commentData.setRelativeLastRowIndex(1);WriteCellData&lt;String&gt; comment = new WriteCellData&lt;&gt;(&quot;备注的单元格信息&quot;);comment.setCommentData(commentData);</code></pre><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>公式使用的是<code>com.alibaba.excel.metadata.data.FormulaData</code>类，可以直接设置<code>formulaValue</code>公式，不过官方不太推荐使用公式。</p><pre><code class="java">// 设置公式FormulaData formulaData = new FormulaData();// 将 123456789 中的第一个数字替换成 2// 这里只是例子 如果真的涉及到公式 能内存算好尽量内存算好 公式能不用尽量不用formulaData.setFormulaValue(&quot;REPLACE(123456789,1,1,2)&quot;);WriteCellData&lt;String&gt; formula = new WriteCellData&lt;&gt;();formula.setFormulaData(formulaData);</code></pre><h3 id="单元格格式"><a href="#单元格格式" class="headerlink" title="单元格格式"></a>单元格格式</h3><p>通过类定义单元格格式，与通过注解定义本质是一样的。所以与注解<code>HeadStyle</code>、<code>HeadFontStyle</code>、<code>ContentStyle</code>、<code>ContentFontStyle</code>对应，设置单元格格式的类是<code>WriteCellStyle</code>，设置字体的类是<code>WriteFont</code>。其中这些类的属性与注解的也是类似，不再赘述太多，直接上例子。（其实我觉得使用类定义格式的场景不多，真的碰到了，看看类定义就明白了）</p><pre><code class="java">// 设置单个单元格的样式 当然样式 很多的话 也可以用注解等方式。WriteCellStyle writeCellStyleData = new WriteCellStyle();// 这里需要指定 FillPatternType 为 FillPatternType.SOLID_FOREGROUND 不然无法显示背景颜色。writeCellStyleData.setFillPatternType(FillPatternType.SOLID_FOREGROUND);// 背景绿色writeCellStyleData.setFillForegroundColor(IndexedColors.GREEN.getIndex());WriteCellData&lt;String&gt; writeCellStyle = new WriteCellData&lt;&gt;(&quot;单元格样式&quot;);writeCellStyle.setWriteCellStyle(writeCellStyleData);writeCellStyle.setType(CellDataTypeEnum.STRING);// 设置单个单元格多种样式RichTextStringData richTextStringData = new RichTextStringData();richTextStringData.setTextString(&quot;红色绿色默认&quot;);// 前 2 个字红色WriteFont writeFont = new WriteFont();writeFont.setColor(IndexedColors.RED.getIndex());richTextStringData.applyFont(0, 2, writeFont);// 接下来 2 个字绿色writeFont = new WriteFont();writeFont.setColor(IndexedColors.GREEN.getIndex());richTextStringData.applyFont(2, 4, writeFont);WriteCellData&lt;String&gt; richTest = new WriteCellData&lt;&gt;();richTest.setType(CellDataTypeEnum.RICH_TEXT_STRING);richTest.setRichTextStringDataValue(richTextStringData);</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211007155542.png" alt="单元格格式"></p><h2 id="拦截器定义格式"><a href="#拦截器定义格式" class="headerlink" title="拦截器定义格式"></a>拦截器定义格式</h2><p>除了直接使用类定义格式，我们还可以借助拦截器实现。（这里在名称上会有一些歧义，所用的类对象命名都是 xxxStrategy，翻译过来就是 xxx 策略，但是官方对其命名为拦截器）</p><h3 id="已有拦截器"><a href="#已有拦截器" class="headerlink" title="已有拦截器"></a>已有拦截器</h3><p>前面示例中使用<code>WriteCellStyle</code>、<code>WriteFont</code>可以实现单元格的样式，如果想要实现整行数据都是相同的格式，可以借助<code>com.alibaba.excel.write.style.HorizontalCellStyleStrategy</code>拦截器。</p><pre><code class="java">/** * 使用已有策略实现自定义样式 * * &lt;ul&gt; *     &lt;li&gt;HorizontalCellStyleStrategy 每一行的样式都一样 或者隔行一样&lt;/li&gt; *     &lt;li&gt;AbstractVerticalCellStyleStrategy 每一列的样式都一样 需要自己回调每一页&lt;/li&gt; * &lt;/ul&gt; */private static void writeByCellStyleStrategy() {    String fileName = defaultFileName(&quot;writeByCellStyleStrategy&quot;);    // 表头策略    WriteCellStyle headWriteCellStyle = new WriteCellStyle();    // 背景设置为红色    headWriteCellStyle.setFillForegroundColor(IndexedColors.RED.getIndex());    WriteFont headWriteFont = new WriteFont();    headWriteFont.setFontHeightInPoints((short) 40);    headWriteCellStyle.setWriteFont(headWriteFont);    // 表体策略    WriteCellStyle contentWriteCellStyle = new WriteCellStyle();    // 这里需要指定 FillPatternType 为 FillPatternType.SOLID_FOREGROUND 不然无法显示背景颜色。表头默认了 FillPatternType 所以可以不指定    contentWriteCellStyle.setFillPatternType(FillPatternType.SOLID_FOREGROUND);    // 背景绿色    contentWriteCellStyle.setFillForegroundColor(IndexedColors.GREEN.getIndex());    WriteFont contentWriteFont = new WriteFont();    // 字体大小    contentWriteFont.setFontHeightInPoints((short) 20);    contentWriteCellStyle.setWriteFont(contentWriteFont);    // 这个策略是 头是头的样式 内容是内容的样式 其他的策略可以自己实现    HorizontalCellStyleStrategy horizontalCellStyleStrategy =            new HorizontalCellStyleStrategy(headWriteCellStyle, contentWriteCellStyle);    // 这里 需要指定写用哪个 class 去写，然后写到第一个 sheet，名字为模板 然后文件流会自动关闭    EasyExcelFactory.write(fileName)            .head(Item.class)            .registerWriteHandler(horizontalCellStyleStrategy)            .sheet()            .doWrite(sampleItems());}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211007155615.png" alt="已有拦截器"></p><p>正如上面的结果，如果我们某个单元格数据比较长，可能会有遮挡，这个时候我们可以使用<code>com.alibaba.excel.write.style.column.LongestMatchColumnWidthStyleStrategy</code>实现自动列宽调整。不过这个不太精确，但聊胜于无。</p><pre><code class="java">private static void writeUseLongestMatchColumnWidthStyleStrategy() {    String fileName = defaultFileName(&quot;writeUseLongestMatchColumnWidthStyleStrategy&quot;);    EasyExcelFactory.write(fileName)            .head(Item.class)            .registerWriteHandler(new LongestMatchColumnWidthStyleStrategy())            .sheet()            .doWrite(sampleItems());}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211007155646.png" alt="已有拦截器"></p><p>可以看到，确实不够精确。</p><h3 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h3><p>上面展示的拦截器，都是实现了<code>com.alibaba.excel.write.handler.WriteHandler</code>接口，然后使用<code>com.alibaba.excel.write.builder.AbstractExcelWriterParameterBuilder.registerWriteHandler</code>方法注册到写函数中。所以，我们也可能根据需要，自己定义需要的拦截器。</p><blockquote><p>这种自定义拦截器属于低级功能，需要了解很多底层设计和 API，鉴于篇幅，本文没有办法覆盖，这里只给出例子。如果有需要，可以留言沟通。</p></blockquote><p>比如，我们需要某些单元格设置数据验证，展现形式就是下拉菜单，我们可以这样写：</p><pre><code class="java">public class ColumnValidationWriteHandler implements SheetWriteHandler {    @Override    public void afterSheetCreate(SheetWriteHandlerContext context) {        // 区间设置 第一列第一行和第二行的数据。由于第一行是头，所以第一、二行的数据实际上是第二三行        CellRangeAddressList cellRangeAddressList = new CellRangeAddressList(1, 2, 0, 0);        DataValidationHelper helper = context.getWriteSheetHolder().getSheet().getDataValidationHelper();        DataValidationConstraint constraint = helper.createExplicitListConstraint(new String[] {&quot;测试 1&quot;, &quot;测试 2&quot;});        DataValidation dataValidation = helper.createValidation(constraint, cellRangeAddressList);        context.getWriteSheetHolder().getSheet().addValidationData(dataValidation);    }}</code></pre><p>如果我们需要将某个单元格的格式设置为超链，也可以使用拦截器：</p><pre><code class="java">public class CellStyleWriteHandler implements CellWriteHandler {    @Override    public void afterCellDispose(CellWriteHandlerContext context) {        Cell cell = context.getCell();        // 这里可以对 cell 进行任何操作        if (BooleanUtils.isTrue(context.getHead()) &amp;&amp; cell.getColumnIndex() == 0) {            CreationHelper createHelper = context.getWriteSheetHolder().getSheet().getWorkbook().getCreationHelper();            Hyperlink hyperlink = createHelper.createHyperlink(HyperlinkType.URL);            hyperlink.setAddress(&quot;https://www.howardliu.cn&quot;);            cell.setHyperlink(hyperlink);        }    }}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211007155715.png" alt="自定义拦截器"></p><h2 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h2><p>EasyExcel 提供的合并单元格功能比较简单，有两种方式：基于注解的合并、基于拦截器的合并。</p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>基于注解的合并单元格提供了两个注解：</p><ul><li><code>OnceAbsoluteMerge</code>注解实现指定位置的合并</li><li><code>ContentLoopMerge</code>这个是内容的循环合并，指定某一列每几行合并。</li></ul><pre><code class="java">// 将第 6-7 行的 2-3 列合并成一个单元格@OnceAbsoluteMerge(firstRowIndex = 5, lastRowIndex = 6, firstColumnIndex = 1, lastColumnIndex = 2)@Datapublic class MergeCellItem {    @ContentLoopMerge(eachRow = 2)    @ExcelProperty(&quot;字符串标题&quot;)    private String string;    @ExcelProperty(&quot;日期标题&quot;)    private Date date;    @ExcelProperty(&quot;数字标题&quot;)    private Double doubleData;}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211007155745.png" alt="合并单元格注解"></p><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>拦截器合并也是有两种，对应着注解：</p><ul><li><code>OnceAbsoluteMergeStrategy</code>，相对位置合并</li><li><code>LoopMergeStrategy</code>循环合并</li></ul><pre><code class="java">private static void writeMergeCellCustom() {    String fileName = defaultFileName(&quot;writeMergeCellCustom&quot;);    // 每隔 2 行会合并    // 把 eachColumn 设置成 3 也就是我们数据的长度，所以就第一列会合并。当然其他合并策略也可以自己写    LoopMergeStrategy loopMergeStrategy = new LoopMergeStrategy(2, 0);    EasyExcelFactory.write(fileName)            .head(Item.class)            .registerWriteHandler(loopMergeStrategy)            .sheet()            .doWrite(sampleItems());}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211007155820.png" alt="合并单元格拦截器"></p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文从实战角度说了一下 EasyExcel 如果实现写出好看的表格，EasyExcel中提供了很多用于格式化的注解、拦截器，可以实现通用的格式化输出，如果还有更加个性化的格式要求，也可以自定义拦截器实现。接下来聊一下如何填充模板。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/effective-java-easyexcel-action-write/">阿里开源的这个库，让 Excel 导出不再复杂（简简单单的写）</a></li><li><a href="https://www.howardliu.cn/effective-java-easyexcel-action-write-pretty/">阿里开源的这个库，让 Excel 导出不再复杂（既要能写，还要写的好看）</a></li><li><a href="https://www.howardliu.cn/effective-java-easyexcel-action-fill/">阿里开源的这个库，让Excel导出不再复杂（填充模板的使用指南）</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/effective-java-easyexcel-action-write-pretty/">阿里开源的这个库，让 Excel 导出不再复杂（既要能写，还要写的好看）</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/120637460" target="_blank" rel="noopener">阿里开源的这个库，让 Excel 导出不再复杂（既要能写，还要写的好看）</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      既要能写，还要写的好看。毕竟，有时候还是要看脸。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Effective Java" scheme="https://www.howardliu.cn/tags/Effective-Java/"/>
    
      <category term="EasyExcel" scheme="https://www.howardliu.cn/tags/EasyExcel/"/>
    
  </entry>
  
  <entry>
    <title>阿里开源的这个库，让 Excel 导出不再复杂（简简单单的写）</title>
    <link href="https://www.howardliu.cn/effective-java-easyexcel-action-write/"/>
    <id>https://www.howardliu.cn/effective-java-easyexcel-action-write/</id>
    <published>2021-10-03T22:40:34.000Z</published>
    <updated>2021-10-03T22:40:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/20211004065308.jpeg" alt="阿里开源的这个库，让 Excel 导出不再复杂（简简单单的写）"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/kimdaejeung-7703165/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6549208" target="_blank" rel="noopener">dae jeung kim</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6549208" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>导出是中后台常见的功能，Excel文件是常见的导出格式。</p><a id="more"></a><p>在Java栈中，常用的是<a href="https://sourceforge.net/projects/jexcelapi/" target="_blank" rel="noopener">JXL（目前改名为JExcel）</a>和<a href="http://poi.apache.org/" target="_blank" rel="noopener">Apache POI</a>。其中jxl最后的更新时间是2012，除了老系统中能看到影子，几乎见不到踪迹了。目前基本上是POI一统天下。</p><p>今天要说的EasyExcel阿里巴巴开源的Excel导出类库，是对POI的封装，实现了很多高级功能，并且留出扩展口，支持扩展定制化功能。打个比喻，POI相当于乐高积木，一个个的小积木可以自由组装，只能动手能力强，就可以随心所欲的组装。EasyExcel更像是把这些小积木提前组装好，想要搭建房子，就直接找组装好的屋顶、围墙就行。如果仅仅如此，那EasyExcel仅仅就是简单的工具包，其更加吸引人的地方是对于内存的控制，它通过压缩文件、分批读取、抛弃不重要数据、文件缓存等多种方式，降低内存消耗。</p><p>内容比较多，文内只会列出关键代码，想要完整源码，可以关注公号「看山的小屋」回复“easyexcel”获取。</p><h2 id="最简单的写表格"><a href="#最简单的写表格" class="headerlink" title="最简单的写表格"></a>最简单的写表格</h2><p>开始之前，先定义一下基础类，这个类将贯穿全文，所有的功能都是在这个类的简单变形。</p><pre><code class="java">@Datapublic class Item {    @ExcelProperty(&quot;字符串标题&quot;)    private String string;    @ExcelProperty(&quot;日期标题&quot;)    private Date date;    @ExcelProperty(&quot;数字标题&quot;)    private Double doubleData;    @ExcelIgnore    private String ignore;}</code></pre><h3 id="根据头对象和列表向一个工作表中写一个表格"><a href="#根据头对象和列表向一个工作表中写一个表格" class="headerlink" title="根据头对象和列表向一个工作表中写一个表格"></a>根据头对象和列表向一个工作表中写一个表格</h3><p>这是最简单的一种实现，只需要定义一个对象类，然后读取数据列表即可。</p><pre><code class="java">/** * 借助{@link com.alibaba.excel.write.builder.ExcelWriterSheetBuilder}自动创建{@link com.alibaba.excel.ExcelWriter}写入数据。 * &lt;p&gt; * 提供列表和函数作为数据源 */public static void writeAutoWriter() {    final String fileName = defaultFileName(&quot;writeAutoWriter&quot;);    EasyExcelFactory.write(fileName)            .head(Item.class)            .sheet(&quot;模板&quot;)            .doWrite(WriteSample::sampleItems);}</code></pre><p>EasyExcel提供了<code>EasyExcelFactory</code>类，API方法也是fluent方式，可以如丝般顺滑的实现生成Excel文件。如果感觉<code>EasyExcelFactory</code>太长，还可以直接写作<code>EasyExcel</code>，这是<code>EasyExcelFactory</code>的子类，类似于别名。</p><blockquote><p>不过，这种别名定义方式，在有些规范中属于<code>smell code</code>，所以，根据自己或者公司规范选择吧。</p></blockquote><p><code>com.alibaba.excel.EasyExcelFactory#write(java.lang.String)</code>方法的参数传的是导出文件的文件名，如果并不需要生成文件，只需要创建文件流，也可以传入一个输出流<code>OutputStream</code>，这样就可以更加灵活的实现生成逻辑了。</p><p><code>com.alibaba.excel.metadata.AbstractParameterBuilder#head()</code>方法是定义表头，只要传入一个类，就会读取这个类的所有字段作为表头。如果字段上<code>com.alibaba.excel.annotation.ExcelProperty</code>注解，定义了<code>value</code>，就会取<code>value</code>的值作为表头。此处还有很多操作，比如，<code>value</code>是数组，可以定义多个，如果是相邻字段定义了相同的表头，会合并单元格，表体内容会选择第一个单元格的内容。这个注解还可以定义<code>index</code>、<code>order</code>、<code>converter</code>等，后面会一一给出例子。</p><p><code>com.alibaba.excel.write.builder.ExcelWriterBuilder#sheet()</code>方法定义工作表，有多个重载方法，可以定义<code>sheetNo</code>指明是第几个工作表，可以传入<code>sheetName</code>指明工作表名称。</p><p><code>com.alibaba.excel.write.builder.ExcelWriterSheetBuilder#doWrite()</code>方法就是写Excel文件了，传入全部的列表数据，或者使用Java8+的<code>Supplier</code>函数。还可以实现分页写入，后面会给出例子。这个方法会自动关闭文件流，真是很贴心。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004065644.png" alt="根据头对象和列表向一个工作表中写一个表格"></p><h3 id="根据头对象和列表向多个工作表中写数据"><a href="#根据头对象和列表向多个工作表中写数据" class="headerlink" title="根据头对象和列表向多个工作表中写数据"></a>根据头对象和列表向多个工作表中写数据</h3><p>上面是向一个工作表写数据，接下来我们向多个工作表写数据。</p><blockquote><p>这个例子会涉及更多的内部对象，比如：ExcelWriter、WriteSheet。</p></blockquote><pre><code class="java">/** * 手动创建{@link com.alibaba.excel.ExcelWriter}，指定sheet写入数据。 * &lt;p&gt; * 提供列表和函数作为数据源 */public static void writeManualWither() {    String fileName = defaultFileName(&quot;writeManualWriter&quot;);    ExcelWriter excelWriter = null;    try {        excelWriter = EasyExcelFactory.write(fileName)                .head(Item.class)                .build();        final WriteSheet writeSheet1 = EasyExcelFactory.writerSheet(&quot;模板1&quot;).build();        excelWriter.write(WriteSample::sampleItems, writeSheet1);        final WriteSheet writeSheet2 = EasyExcelFactory.writerSheet(&quot;模板2&quot;).build();        excelWriter.write(sampleItems(), writeSheet2);    } finally {        // 千万别忘记finish 会帮忙关闭流        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>因为是想多个工作表中写数据，我们就不能直接使用<code>doWrite</code>方法了。</p><p><code>com.alibaba.excel.ExcelWriter</code>类是Excel写对象，用来创建Excel工作簿的。<code>com.alibaba.excel.write.metadata.WriteSheet</code>类是Sheet写对象，用来创建Sheet工作表的。通过<code>com.alibaba.excel.ExcelWriter#write()</code>方法，指定写入数据和写入的目标工作表，就可以实现向多个工作表中写数据的功能。</p><p>此处需要注意，我们在创建<code>ExcelWriter</code>对象时，调用了<code>head()</code>方法定义了表头，这是整个Excel的定义，sheet会继承这个定义。这样，整个Excel文件中的所有工作表，表头都是相同的。不要停，后面会给出不同工作表定义不同表头的示例。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004065724.png" alt="根据头对象和列表向多个工作表中写数据"></p><h2 id="按照定义指定导出列"><a href="#按照定义指定导出列" class="headerlink" title="按照定义指定导出列"></a>按照定义指定导出列</h2><p>在后台系统中，会有行列权限的控制。行权限，通过数据行实现，只导出有权限的行数据即可。列权限，可以通过只导出有权限的列，排除没有权限的列（通常是分等级的敏感数据）。</p><p>有时候需要定制化导出，导出所有列表格比较大，用户根据需要指定需要导出的列。</p><h3 id="排除指定列"><a href="#排除指定列" class="headerlink" title="排除指定列"></a>排除指定列</h3><pre><code class="java">private static void writeExcludeColumn() {    String fileName = defaultFileName(&quot;writeExcludeColumn&quot;);    Set&lt;String&gt; excludeColumnFiledNames = new HashSet&lt;&gt;();    excludeColumnFiledNames.add(&quot;date&quot;);    EasyExcelFactory.write(fileName)            .head(Item.class)            .excludeColumnFiledNames(excludeColumnFiledNames)            .sheet(&quot;模板&quot;)            .doWrite(WriteSample::sampleItems);}</code></pre><p>这个需求，需要借助<code>com.alibaba.excel.write.builder.AbstractExcelWriterParameterBuilder#excludeColumnFiledNames</code>方法。这个方法是在<code>ExcelWriterBuilder</code>、<code>ExcelWriterSheetBuilder</code>、<code>ExcelWriterTableBuilder</code>的父类中定义，也就是说，可以是整个Excel工作簿都排除指定字段，也可以是某个sheet工作表排除指定字段，还可以是table表格排除指定字段。</p><p>除了<code>excludeColumnFiledNames</code>通过字段名排除字段，还可以使用<code>excludeColumnIndexes</code>指定字段下标排除列，如果需要控制下标，需要在字段上定义<code>ExcelProperty</code>指明index属性，这样也能够更好的固定字段下标。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004065753.png" alt="排除指定列"></p><h3 id="只导出指定列"><a href="#只导出指定列" class="headerlink" title="只导出指定列"></a>只导出指定列</h3><pre><code class="java">private static void writeIncludeColumn() {    String fileName = defaultFileName(&quot;writeIncludeColumn&quot;);    Set&lt;String&gt; includeColumnFiledNames = new HashSet&lt;&gt;();    includeColumnFiledNames.add(&quot;date&quot;);    EasyExcelFactory.write(fileName)            .head(Item.class)            .includeColumnFiledNames(includeColumnFiledNames)            .sheet(&quot;模板&quot;)            .doWrite(WriteSample::sampleItems);}</code></pre><p>这个需求，需要借助<code>com.alibaba.excel.write.builder.AbstractExcelWriterParameterBuilder#includeColumnFiledNames</code>方法。与<code>excludeColumnFiledNames</code>是相似，都是可以分级定义，用起来也是一样的，只不过功能相反而已。</p><p>同样的，也可以使用<code>includeColumnIndexes</code>方法，通过指定字段下标指定列。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004065816.png" alt="只导出指定列"></p><h2 id="表头"><a href="#表头" class="headerlink" title="表头"></a>表头</h2><p>表头的定义是比较关键的，会直接影响Excel文件的质量。所以，EasyExcel提供了比较丰富的表头定义方法。</p><h3 id="原始表头"><a href="#原始表头" class="headerlink" title="原始表头"></a>原始表头</h3><p>这里定义了一个新的基础类：<code>EmptyItem</code>，与<code>Item</code>的区别是移除了<code>ExcelProperty</code>的定义。</p><pre><code class="java">@Datapublic class EmptyItem {    private String string;    private Date date;    private Double doubleData;}</code></pre><p>在这种情况下，会直接使用<code>EmptyItem</code>对象的字段作为表头名称。</p><pre><code class="java">private static void writeNoAnnotation() {    final String fileName = defaultFileName(&quot;writeNoAnnotation&quot;);    EasyExcelFactory.write(fileName)            .head(EmptyItem.class)            .sheet(&quot;模板&quot;)            .doWrite(WriteSample::sampleItems);}</code></pre><blockquote><p>这里可以看到，EasyExcel对于表头对象、表体列表对象，没有强制要求必须是相同的对象，只要字段一致，就能够正常组装数据。</p></blockquote><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004065847.png" alt="原始表头"></p><h3 id="自定义表头"><a href="#自定义表头" class="headerlink" title="自定义表头"></a>自定义表头</h3><p>使用字段作为表头显然不是我们想要的，EasyExcel提供了<code>ExcelProperty</code>注解，可以定义表头的名称。这个注解还提供了<code>index</code>、<code>order</code>两个属性，可以定义列的位置和顺序。</p><pre><code class="java">@Datapublic class IndexItem {    @ExcelProperty(value = &quot;字符串标题&quot;, index = 1)    private String string;    @ExcelProperty(value = &quot;日期标题&quot;, index = 3)    private Date date;    @ExcelProperty(value = &quot;数字标题&quot;, index = 5)    private Double doubleData;}</code></pre><p>使用起来也很简单：</p><pre><code class="java">private static void writeWithIndex() {    final String fileName = defaultFileName(&quot;writeWithIndex&quot;);    EasyExcelFactory.write(fileName)            .head(IndexItem.class)            .sheet(&quot;模板&quot;)            .doWrite(WriteSample::sampleItems);}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004065911.png" alt="自定义表头"></p><p>这里需要注意一下，在使用<code>ExcelProperty</code>注解时，index表示字段放置第几列，order表示顺序。</p><p>根据index和order的不同语义，对两者的控制不同。如果index相同，直接会抛出异常，因为程序无法判断这个列放那个字段。如果index值中间有空的数字，就会出现空列。如果order和index同时使用，index优先占据位置，order做排序。index=-1的话，使用java默认排序，order值越小，列越靠前。</p><p><code>ExcelProperty</code>的value属性是字符串数组，相当于一个字段可以定义多个头，这样就可以实现多级表头。同时，如果位置相邻的列定义列明相同，还会合并列。比如：</p><pre><code class="java">@Datapublic class ComplexHeadItem {    @ExcelProperty({&quot;大标题&quot;, &quot;字符串标题&quot;})    private String string;    @ExcelProperty(&quot;日期标题&quot;)    private Date date;    @ExcelProperty({&quot;大标题&quot;, &quot;数字标题0&quot;})    private Double doubleData;    @ExcelProperty({&quot;数字标题&quot;})    private Double doubleData1;    @ExcelProperty({&quot;数字标题&quot;})    private Double doubleData2 = 0.0;}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004065935.png" alt="自定义表头-合并"></p><h3 id="动态表头、表体"><a href="#动态表头、表体" class="headerlink" title="动态表头、表体"></a>动态表头、表体</h3><p>前面的例子中，表头定义都是传入一个对象，通过解析对象的属性字段，抽取表头定义。有的时候，我们没有办法提前定义表头对象，或者说，表头是根据条件、权限等因素动态变化的，这个时候，就可以使用EasyExcel提供的动态表头功能了。</p><pre><code class="java">/** * 动态表头，传入的是{@code List&lt;List&lt;String&gt;&gt;}格式数据。 * &lt;p&gt; * 可以实现多层表头。 */private static void writeDynamicHead() {    String fileName = defaultFileName(&quot;writeDynamicHead&quot;);    EasyExcelFactory.write(fileName)            .head(dynamicHead())            .sheet()            .doWrite(sampleItems());}private static List&lt;List&lt;String&gt;&gt; dynamicHead() {    List&lt;List&lt;String&gt;&gt; heads = new ArrayList&lt;&gt;();    final List&lt;String&gt; head0 = new ArrayList&lt;&gt;(Arrays.asList(&quot;头0&quot;, &quot;字符串标题【动态】&quot;));    heads.add(head0);    final List&lt;String&gt; head1 = new ArrayList&lt;&gt;(Arrays.asList(&quot;头0&quot;, &quot;日期标题【动态】&quot;));    heads.add(head1);    final List&lt;String&gt; head2 = new ArrayList&lt;&gt;(Collections.singletonList(&quot;数字标题【动态】&quot;));    heads.add(head2);    return heads;}</code></pre><p>使用<code>com.alibaba.excel.metadata.AbstractParameterBuilder#head(java.util.List&lt;java.util.List&lt;java.lang.String&gt;&gt;)</code>方法，传入<code>List&lt;List&lt;String&gt;&gt;</code>类型的数据即可。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004070011.png" alt="动态表头、表体"></p><p>当然，这样做还不是彻底的动态。我们可以使用<code>com.alibaba.excel.write.builder.ExcelWriterSheetBuilder#doWrite(java.util.Collection&lt;?&gt;)</code>实现动态表体。代码如下：</p><pre><code class="java">private static void writeDynamicData() {    String fileName = defaultFileName(&quot;writeDynamicData&quot;);    EasyExcelFactory.write(fileName)            .head(dynamicHead())            .sheet()            .doWrite(dynamicData());}private static List&lt;List&lt;Object&gt;&gt; dynamicData() {    List&lt;List&lt;Object&gt;&gt; list = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; 10; i++) {        List&lt;Object&gt; data = new ArrayList&lt;&gt;();        data.add(&quot;字符串&quot; + i);        data.add(new Date());        data.add((i + 1) * 0.1);        list.add(data);    }    return list;}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004070036.png" alt="动态表头、表体"></p><h3 id="表头国际化"><a href="#表头国际化" class="headerlink" title="表头国际化"></a>表头国际化</h3><p>互联网无国界，很多时候，我们需要实现国际化。这个时候，我们可以使用动态表头功能，传入不同的表头定义，生成不同的Excel文件。有时候，我们还需要提前定义表体的格式，使用动态表体可以实现。有没有更加简单方法呢？必须有。</p><p>先定义格式化表头对象：</p><pre><code class="java">@Datapublic class FormatContentItem {    @ExcelProperty(value = &quot;字符串标题&quot;, converter = TitleFormatConverter.class)    private String string;    @DateTimeFormat(&quot;yyyy年MM月dd日HH时mm分ss秒&quot;)    @ExcelProperty(value = &quot;日期标题&quot;)    private Date date;    @NumberFormat(&quot;0.000%&quot;)    @ExcelProperty(&quot;数字标题&quot;)    private Double doubleData;}</code></pre><p>再实现国际化：</p><pre><code class="java">/** * 可以同时设置head参数： * {@link AbstractParameterBuilder#head(java.util.List)} * {@link AbstractParameterBuilder#head(java.lang.Class)} * &lt;p&gt; * 对于表头设置，最终起作用的是{@link AbstractParameterBuilder#head(java.util.List)}，这样的话，我们可以实现国际化的配置。 */private static void writeDynamicMultiHead() {    String fileName = defaultFileName(&quot;writeDynamicMultiHead&quot;);    EasyExcelFactory.write(fileName)            .head(dynamicHead())            .head(FormatContentItem.class)            .sheet()            .doWrite(sampleItems());}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004070102.png" alt="表头国际化"></p><h2 id="多次写入"><a href="#多次写入" class="headerlink" title="多次写入"></a>多次写入</h2><p>一般来说，中后台的数据量都不小，有时候需要一次导出几十万行数据，甚至更多，而这种操作并不是常态，如果内存配置比较大，那大多数时间内存都是闲置状态。此时，就可以借助EasyExcel的文件缓存能力，分批写入数据。</p><h3 id="向同一个excel同一个sheet中多次写入"><a href="#向同一个excel同一个sheet中多次写入" class="headerlink" title="向同一个excel同一个sheet中多次写入"></a>向同一个excel同一个sheet中多次写入</h3><p>首先是比较常见的场景，向一个sheet工作表中分批写入数据。</p><pre><code class="java">private static void writeOneSheet() {    String fileName = defaultFileName(&quot;writeOneSheet&quot;);    ExcelWriter excelWriter = null;    try {        excelWriter = EasyExcelFactory.write(fileName)                .head(Item.class)                .build();        final WriteSheet writeSheet = EasyExcelFactory.writerSheet(&quot;模板&quot;).build();        for (int i = 0; i &lt; 5; i++) {            excelWriter.write(sampleItems(), writeSheet);        }    } finally {        // 千万别忘记finish 会帮忙关闭流        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>首先定义<code>ExcelWriter</code>可以操作整个Excel工作簿，然后定义<code>ExcelWriter</code>sheet工作表，接下来就是循环调用<code>com.alibaba.excel.ExcelWriter.write(java.util.Collection&lt;?&gt;, com.alibaba.excel.write.metadata.WriteSheet)</code>方法，将数据写入到指定的sheet工作表中。这里需要注意的是，最后一定要调用<code>com.alibaba.excel.ExcelWriter.finish</code>方法，表示停止写入并关闭流。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004070128.png" alt="向同一个excel同一个sheet中多次写入"></p><h3 id="向同一个excel不同sheet中多次写入（表头相同）"><a href="#向同一个excel不同sheet中多次写入（表头相同）" class="headerlink" title="向同一个excel不同sheet中多次写入（表头相同）"></a>向同一个excel不同sheet中多次写入（表头相同）</h3><p>还有一种场景是按月导出全年的订单数据，每个月一个sheet工作表，这种导出的方式，表头都是相同的。根据上面的经验，我们需要定义多个<code>WriteSheet</code>工作表对象，然后向该对象中写数据。</p><p>这里还可能有一种情况，就是我们需要在多个<code>WriteSheet</code>工作表对象之间切换写入，为了不会找错对象，可以指定<code>sheetNo</code>。</p><p>代码如下：</p><pre><code class="java">private static void writeDiffSheetWithSameHead() {    String fileName = defaultFileName(&quot;writeDiffSheetWithSameHead&quot;);    ExcelWriter excelWriter = null;    try {        excelWriter = EasyExcelFactory.write(fileName)                .head(Item.class)                .build();        for (int i = 0; i &lt; 5; i++) {            final WriteSheet writeSheet = EasyExcelFactory.writerSheet(i, &quot;模板&quot; + i)                    .build();            excelWriter.write(sampleItems(), writeSheet);        }    } finally {        // 千万别忘记finish 会帮忙关闭流        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004070152.png" alt="向同一个excel不同sheet中多次写入（表头相同）"></p><p><img src="https://static.howardliu.cn/20211004070212.png" alt="向同一个excel不同sheet中多次写入（表头相同）"></p><h3 id="向同一个excel不同sheet中多次写入（表头不同）"><a href="#向同一个excel不同sheet中多次写入（表头不同）" class="headerlink" title="向同一个excel不同sheet中多次写入（表头不同）"></a>向同一个excel不同sheet中多次写入（表头不同）</h3><p>还有一种场景，导出指定时间范围的订单信息，一个sheet工作表放具体的商品信息，另一个sheet工作表放订单收货地址信息。这种场景就需要不同的表头，根据前面的讲解，我们知道，只需要在定义<code>WriteSheet</code>对象时指定不同的表头对象即可。</p><p>代码如下：</p><pre><code class="java">private static void writeDiffSheetWithDiffHead() {    String fileName = defaultFileName(&quot;writeDiffSheetWithDiffHead&quot;);    ExcelWriter excelWriter = null;    try {        excelWriter = EasyExcelFactory.write(fileName)                .build();        final WriteSheet writeSheet0 = EasyExcelFactory.writerSheet(0, &quot;模板1&quot;)                .head(Item.class)                .build();        excelWriter.write(sampleItems(), writeSheet0);        final WriteSheet writeSheet1 = EasyExcelFactory.writerSheet(1, &quot;模板2&quot;)                .head(ComplexHeadItem.class)                .build();        excelWriter.write(sampleItems(), writeSheet1);    } finally {        // 千万别忘记finish 会帮忙关闭流        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004070229.png" alt="向同一个excel不同sheet中多次写入（表头不同）"></p><p><img src="https://static.howardliu.cn/20211004070246.png" alt="向同一个excel不同sheet中多次写入（表头不同）"></p><h2 id="实现多表"><a href="#实现多表" class="headerlink" title="实现多表"></a>实现多表</h2><p>EasyExcel对于Excel文件定义分成了三层，</p><ol><li>工作簿，也就是Excel文件</li><li>工作表，对应是Excel文件中的Sheet</li><li>表格，对应是Sheet中的有表头、表体的组合</li></ol><p>这里所说的功能就是在一个Sheet中创建多个表格。</p><h3 id="同一表单中创建表格"><a href="#同一表单中创建表格" class="headerlink" title="同一表单中创建表格"></a>同一表单中创建表格</h3><p>这个是开胃菜，演示一下怎么单独指定表格。</p><pre><code class="java">private static void writeTable() {    String fileName = defaultFileName(&quot;writeTable&quot;);    final ExcelWriter excelWriter = EasyExcelFactory.write(fileName)            .head(Item.class)            .build();    try {        // 把sheet设置为不需要头 不然会输出sheet的头 这样看起来第一个table 就有2个头了        WriteSheet writeSheet = EasyExcelFactory.writerSheet()                .needHead(Boolean.FALSE)                .build();        // 这里必须指定需要头，table 会继承sheet的配置，sheet配置了不需要，table 默认也是不需要        WriteTable writeTable0 = EasyExcelFactory.writerTable(0)                .needHead(Boolean.TRUE)                .build();        excelWriter.write(sampleItems(), writeSheet, writeTable0);    } finally {        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>可以看到，除了前面提过的<code>ExcelWriter</code>和<code>WriteSheet</code>，这里还用到了<code>WriteTable</code>，这个就是表格的写对象。有了这个对象，我们只要多创建几个，就能够实现在一个Sheet工作表中，创建多个表格的功能。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004070309.png" alt="同一表单中创建表格"></p><p>与前面的例子完全没有差别，条条大路通罗马。</p><h3 id="同一表单中创建不同表格（相同表头）"><a href="#同一表单中创建不同表格（相同表头）" class="headerlink" title="同一表单中创建不同表格（相同表头）"></a>同一表单中创建不同表格（相同表头）</h3><p>有了上面的铺垫，我们直接上代码：</p><pre><code class="java">private static void writeTables() {    String fileName = defaultFileName(&quot;writeTables&quot;);    final ExcelWriter excelWriter = EasyExcelFactory.write(fileName)            .build();    try {        // 把sheet设置为不需要头 不然会输出sheet的头 这样看起来第一个table 就有2个头了        WriteSheet writeSheet = EasyExcelFactory.writerSheet()                .head(Item.class)                .needHead(Boolean.FALSE)                .build();        // 这里必须指定需要头，table 会继承sheet的配置，sheet配置了不需要，table 默认也是不需要        WriteTable writeTable0 = EasyExcelFactory.writerTable(0)                .needHead(Boolean.TRUE)                .build();        WriteTable writeTable1 = EasyExcelFactory.writerTable(1)                .needHead(Boolean.TRUE)                .build();        // 第一次写入会创建头        excelWriter.write(sampleItems(), writeSheet, writeTable0);        // 第二次写如也会创建头，然后在第一次的后面写入数据        excelWriter.write(sampleItems(), writeSheet, writeTable1);    } finally {        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>因为使用的是相同的表头，我们可以直接在<code>WriteSheet</code>中定义表头对象，通过继承的方式，实现两个表格的表头是相同的。这里需要注意一下，<code>WriteSheet</code>构建时，设置<code>needHead(Boolean.FALSE)</code>，如果不设置或者设置为true，那第一个表格就会有两个表头。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004070331.png" alt="同一表单中创建不同表格（相同表头）"></p><h3 id="同一表单中创建不同表格（不同表头）"><a href="#同一表单中创建不同表格（不同表头）" class="headerlink" title="同一表单中创建不同表格（不同表头）"></a>同一表单中创建不同表格（不同表头）</h3><p>举一反三，对于不同表头，我们只需要为<code>WriteTable</code>对象设置不同表头即可：</p><pre><code class="java">private static void writeTablesWithDiffHead() {    String fileName = defaultFileName(&quot;writeTablesWithDiffHead&quot;);    final ExcelWriter excelWriter = EasyExcelFactory.write(fileName)            .build();    try {        WriteSheet writeSheet = EasyExcelFactory.writerSheet()                .build();        WriteTable writeTable0 = EasyExcelFactory.writerTable(0)                .head(Item.class)                .build();        excelWriter.write(sampleItems(), writeSheet, writeTable0);        WriteTable writeTable1 = EasyExcelFactory.writerTable(1)                .head(ComplexHeadItem.class)                .build();        excelWriter.write(sampleItems(), writeSheet, writeTable1);    } finally {        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004070353.png" alt="同一表单中创建不同表格（不同表头）"></p><h2 id="写入模板文件（非填充）"><a href="#写入模板文件（非填充）" class="headerlink" title="写入模板文件（非填充）"></a>写入模板文件（非填充）</h2><p>有时候，我们需要按照某种模板导出数据，这类模板文件属于固定样式，没有动态数据。比如前面几行是标题、权限声明、责任声明之类的，紧跟着就是列表数据。如果全靠手工拼写数据比较繁琐，EasyExcel提供了写入模板文件的方式。先看代码：</p><pre><code class="java">private static void writeByTemplate() {    String fileName = defaultFileName(&quot;writeByTemplate&quot;);    String templateFile = getPath() + File.separator + &quot;template_write_after_fill.xlsx&quot;;    EasyExcelFactory.write(fileName)            .withTemplate(templateFile)            .head(Item.class)            .sheet()            .doWrite(sampleItems());}</code></pre><p>需要使用<code>com.alibaba.excel.write.builder.ExcelWriterBuilder#withTemplate(java.lang.String)</code>指定模板文件路径。withTemplate方法有几个重载实现：</p><ol><li>指定模板文件路径<code>ExcelWriterBuilder#withTemplate(java.lang.String)</code></li><li>指定模板文件对象<code>ExcelWriterBuilder#withTemplate(java.io.File)</code></li><li>指定模板文件输入流<code>ExcelWriterBuilder#withTemplate(java.io.InputStream)</code></li></ol><p>指定模板文件和模板文件对象都是操作文件的，需要有文件信息。</p><p>指定模板文件输入流是只要文件流，这个可操作性空间就比较大了。比如，模板文件是可变的，我们可以基于一个带变量的模板文件，使用填充写入的方式初始化模板文件，然后再用模板写入的方式，写入列表。（这个会在技巧篇中详细说明）</p><p>代码中的模板文件内容：</p><p><img src="https://static.howardliu.cn/20211004070420.png" alt="写入模板文件（非填充）"></p><p>导出文件的内容：</p><p><img src="https://static.howardliu.cn/20211004070440.png" alt="写入模板文件（非填充）"></p><p>可以看出，这种方式写入的列表是以追加的方式写入，原有的模板内容不会修改，会从第一行空白行开始写列表信息。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文从实战角度说了一下 EasyExcel 如果实现写表格，接下来会讲解一下如何更好看的写。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/effective-java-easyexcel-action-write/">阿里开源的这个库，让 Excel 导出不再复杂（简简单单的写）</a></li><li><a href="https://www.howardliu.cn/effective-java-easyexcel-action-write-pretty/">阿里开源的这个库，让 Excel 导出不再复杂（既要能写，还要写的好看）</a></li><li><a href="https://www.howardliu.cn/effective-java-easyexcel-action-fill/">阿里开源的这个库，让Excel导出不再复杂（填充模板的使用指南）</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/effective-java-easyexcel-action-write/">阿里开源的这个库，让 Excel 导出不再复杂（简简单单的写）</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/120600688" target="_blank" rel="noopener">阿里开源的这个库，让 Excel 导出不再复杂（简简单单的写）</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      今天要说的EasyExcel阿里巴巴开源的Excel导出类库，是对POI的封装，实现了很多高级功能，并且留出扩展口，支持扩展定制化功能。打个比喻，POI相当于乐高积木，一个个的小积木可以自由组装，只能动手能力强，就可以随心所欲的组装。EasyExcel更像是把这些小积木提前组装好，想要搭建房子，就直接找组装好的屋顶、围墙就行。如果仅仅如此，那EasyExcel仅仅就是简单的工具包，其更加吸引人的地方是对于内存的控制，它通过压缩文件、分批读取、抛弃不重要数据、文件缓存等多种方式，降低内存消耗。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Effective Java" scheme="https://www.howardliu.cn/tags/Effective-Java/"/>
    
      <category term="EasyExcel" scheme="https://www.howardliu.cn/tags/EasyExcel/"/>
    
  </entry>
  
  <entry>
    <title>关于微服务系统中数据一致性的总结</title>
    <link href="https://www.howardliu.cn/data-consistency-in-microservices/"/>
    <id>https://www.howardliu.cn/data-consistency-in-microservices/</id>
    <published>2021-09-17T14:29:58.000Z</published>
    <updated>2021-09-17T14:29:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/20200714212210.png" alt="关于微服务系统中数据一致性的总结"></p><p>你好，我是看山。</p><p>从单体架构到分布式架构，从巨石架构到微服务架构。系统之间的交互越来越复杂，系统间的数据交互量级也是指数级增长。作为一个系统，我们要保证逻辑的自洽和数据的自洽。</p><a id="more"></a><p>数据自洽有两方面要求：</p><ol><li>抛开代码，数据能够自己验证自己的准确性，也就是数据彼此之间不矛盾</li><li>所有数据准确且符合期望</li></ol><p>为了实现这两点，需要实现数据的一致性，为了实现一致性，就需要用到事务。</p><p>需要注意一下，本文所设计的数据一致性，不是多数据副本之间保持数据一致性，而是系统之间的业务数据保持一致性。</p><h2 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h2><p>在早期的系统中，我们可以通过关系型数据库的事务保证数据的一致性。这种事务有四个基本要素：ACID。</p><ul><li>A（Atomicity，原子性）：整个事务中的所有操作，要么全部完成，要么全部失败，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li>C（Consistency，一致性）：一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。</li><li>I（Isolation，隔离性）：隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。</li><li>D（Durability，持久性）：在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</li></ul><p>这四个要素是关系型数据库的根本。无论系统多么复杂，只要使用同一个关系型数据库，我们就可以借助事务保证数据一致性。基于对关系型数据库的信任，我们可以认为本地事务是可靠的，开发过程中不需要额外的工作。从架构的角度，关系型数据库也是一个单独的系统，那关系型数据库与应用之间也是形成了分布式。所以我们先研究一下这种简单的分布式系统如何实现 ACID。</p><p>首先，A（原子性）和 D（持久性）是彼此之间密不可分的两个属性：原子性保证了事务的所有操作，要么全部完成，要么全部失败，不可能停滞在中间某个环节；持久性保证了一旦事务完成，该事务对数据库所作的更改便持久的保存在数据库之中，不会因为任何原因而导致其修改的内容被撤销或丢失。</p><p>众所周知，数据必须写入到磁盘后才能保证持久化，仅仅保存在内存中，一旦出现系统崩溃、主机断电等情况，数据就会丢失。所以，关键是“写入磁盘”要实现原子性和持久性，然而这个动作存在中间态：正在写入。所以，现代的关系型数据库通常采用追加日志记录的方式。将修改数据所需的全部信息（包括修改什么数据、数据物理上位于哪个内存页和磁盘块中、从什么值改成什么值，等等），以顺序追加的形式记录到磁盘中。只有在日志记录全部落盘，数据库在日志中看到代表事务成功提交的“提交记录”后，才会根据日志上的信息对真正的数据进行修改。修改完成后，再在日志中加入一条“结束记录”表示事务已完成持久化，这种事务实现方法被称为“提交日志”。</p><p><img src="https://static.howardliu.cn/20210917175145.png" alt="本地事务"></p><p>我们能够通过日志保证一个事务的原子性和持久性，那如果出现多个事务访问同一个资源呢？作为程序猿都知道，多个线程/进程访问同一个资源，这个资源就称为临界资源，想要解决临界资源占用冲突的方式很简单，就是加锁。关系型数据库为我们准备了三种锁：</p><ul><li>写锁（Write Lock）：同一个时刻，只有有一个事务对数据加写锁，所以写锁也被称为排它锁（exclusive Lock）。数据被加了写锁后，其他事务不能写入数据，也不能对其添加读锁（注意，是不能加读锁，但是可以读取数据）。</li><li>读锁（Read Lock）：同一时刻，多个事务可以对数据添加读锁，所以读锁也被称为共享锁（Shared Lock）。数据库被添加读锁后，数据不能被添加写锁。</li><li>范围锁（Range Lock）：对一个范围的数据添加写锁，这个范围的数据不能被写入。也可以算作写锁的批量行为。</li></ul><p>根据这三种锁的不同组合，我们可以实现四种不同的事务隔离级别：</p><ul><li>可串行化（Serializable）：写入的时候加写锁，读取的时候加读锁，范围读写的时候加范围锁。</li><li>可重复度（Repeatable Read）：写入的时候加写锁，读取的时候加读锁，范围读写的时候不加锁，这样会出现读取相同范围数据的时候，返回结果不同，即幻读（Phantom Read）。</li><li>读已提交（Read Committed）：写入的时候加写锁，读取的时候加读锁，读取完成后立马释放读锁。这样会出现同一个事务多次读取相同数据，返回结果不同，即不可重复读（Non-Repeatable Read）。</li><li>读未提交（Read Uncommitted）：写入的时候加写锁，读取的时候不加锁。这样就会读取到另一个还未提交的事务写入的数据，即脏读（Dirty Read）。</li></ul><h2 id="全局事务"><a href="#全局事务" class="headerlink" title="全局事务"></a>全局事务</h2><p>随着系统规模不断扩大，业务量不断增加。单体应用不再满足需求，我们会拆分系统，然后拆分数据库。此时，同一个请求中，就会出现同时访问多个数据库的情况。为了解决这种情况的数据一致性问题，X/Open 组织在 1991 年（那个时候我还小）提出了一套 X/Open XA 的处理事务的架构。XA 的核心内容是定义了全局的事务管理器（Transaction Manager，用于协调全局事务）和局部的资源管理器（Resource Manager，用于驱动本地事务）之间的通信接口，在一个事务管理器和多个资源管理器（Resource Manager）之间形成通信桥梁，通过协调多个数据源的一致动作，实现全局事务的统一提交或者统一回滚。与 XA 架构配套的是两阶段提交协议（2PC，Two Phase Commitment Protocol）。在这个协议中，最关键的点就是，多个数据库的活动，均由一个事务协调器的组件来控制。具体的分为 5 个步骤：</p><ol><li>应用程序调用事务管理器中的提交方法</li><li>事务管理器将联络事务中涉及的每个数据库，并通知它们准备提交事务（这是第一阶段的开始）</li><li>接收到准备提交事务通知后，数据库必须确保能在被要求提交事务时提交事务，或在被要求回滚事务时回滚事务。如果数据库无法准备事务，它会以一个否定响应来回应事务管理器。</li><li>事务管理器收集来自各数据库的所有响应。</li><li>在第二阶段，事务管理器将事务的结果通知给每个数据库。如果任一数据库做出否定响应，则事务管理器会将一个回滚命令发送给事务中涉及的所有数据库。如果数据库都做出肯定响应，则事务管理器会指示所有的资源管理器提交事务。一旦通知数据库提交，此后的事务就不能失败了。通过以肯定的方式响应第一阶段，每个资源管理器均已确保，如果以后通知它提交事务，则事务不会失败。</li></ol><p><img src="https://static.howardliu.cn/20210917181732.png" alt="2PC"></p><p>两阶段提交协议实现简单，但存在几个明显缺陷：</p><ul><li>单点问题：事务管理器在两段提交中具有举足轻重的作用，事务管理器等待资源管理器回复时可以有超时机制，允许资源管理器宕机，但资源管理器等待事务管理器指令时无法做超时处理。一旦宕机的不是其中某个资源管理器，而是事务管理器的话，所有资源管理器都会受到影响。如果事务管理器一直没有恢复，没有正常发送 Commit 或者 Rollback 的指令，那所有资源管理器都必须一直等待。</li><li>性能问题：两段提交过程中，所有资源管理器相当于被绑定成为一个统一调度的整体，期间要经过两次远程服务调用，三次数据持久化（准备阶段写重做日志，事务管理器做状态持久化，提交阶段在日志写入 Commit Record），整个过程将持续到资源管理器集群中最慢的那一个处理操作结束为止，这决定了两段式提交的性能通常都较差。</li><li>一致性风险：尽管提交阶段时间很短，但这仍是一段明确存在的危险期。如果事务管理器在发出准备指令后，根据收到各个资源管理器发回的信息确定事务状态是可以提交的，事务管理器会先持久化事务状态，并提交自己的事务，如果这时候网络断开，无法再通过网络向所有资源管理器发出 Commit 指令的话，就会导致部分数据（事务管理器的）已提交，但部分数据（资源管理器的）既未提交，也没有办法回滚，产生了数据不一致的问题。</li></ul><p>能够发现问题，就能够想到办法解决。我们高中老师说了，只要意识不滑坡，办法总比困难多。所以又发展出了三阶段提交协议（3PC，Three Phase Commitment Protocol），能够缓解单点问题和准备阶段的性能问题。这个协议把 2PC 中的准备阶段拆分为 CanCommit 和 PreCommit，把提交阶段改名为 DoCommit。CanCommit 是询问阶段，让每个资源管理器根据自身情况判断该事务是否有可能完成。</p><p>3PC 本质是通过一次问询，如果大家都说自己可以，那成事的可能性很大，减少了准备阶段直接锁定资源的重操作。由于事务失败回滚概率变小的原因，在三段式提交中，如果在 PreCommit 阶段之后发生了事务管理器宕机，即资源管理器没有能等到 DoCommit 的消息的话，默认的操作策略将是提交事务而不是回滚事务或者持续等待，这就相当于避免了事务管理器单点问题的风险。</p><p><img src="https://static.howardliu.cn/20210917181759.png" alt="3PC"></p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>说到分布式事务，不得不提 CAP 理论：任何分布式系统只可同时满足一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）中的两点，没法三者兼顾。</p><p><img src="https://static.howardliu.cn/20210917184402.png" alt="CAP 理论"></p><ul><li>一致性（Consistency）：数据在任何时刻、任何分布式节点中所看到的都是符合预期的。</li><li>可用性（Availability）：系统不间断地提供服务的能力，可用性是由可靠性（Reliability）和可维护性（Serviceability）计算得出的比例值。可靠性通过平均无故障时间（Mean Time Between Failure，MTBF）来度量；可维护性通过平均可修复时间（Mean Time To Repair，MTTR）来度量。可用性衡量系统可以正常使用的时间与总时间之比，公式为：A=MTBF/(MTBF+MTTR)。</li><li>分区容错性（Partition Tolerance）：分布式环境中部分节点因网络原因而彼此失联后，系统仍能正确地提供服务的能力。</li></ul><blockquote><p>CAP 理论定义是经过几次修改的，修改后的定义本质没有区别，只是在逻辑上更加严谨。本文为了好理解，使用了最容易让大众接收并理解的定义。</p></blockquote><p>既然 CAP 不能兼顾，那我们来看看缺少其中一环会出现什么情况：</p><ul><li>选择 CA 放弃 P：即我们认为网络可靠不会出现分区情况，这种可靠是各个节点之间不会出现网络延迟、中断等情况，显然是不成立的。</li><li>选择 CP 放弃 A：这样做就是抛弃了可用性，为了保证数据一致性，一旦出现网络异常，节点之间的信息同步时间可以无限制地延长。使用 CP 组合的一般用于对数据质量要求很高的场合，也就是为了保证数据完全一致，暂时不提供服务，直到网络完全恢复，这可能持续一个不确定的时间，尤其是在系统已经表现出高延迟时或者网络故障导致失去连接时。</li><li>选择 AP 放弃 C：意味着一旦发生网络分区，优先提供服务可用，放弃数据一致性。这是目前分布式系统的主流选择，因为网络本身就是链接不同区域的服务器的，网络又是不可靠的，所以 P 不能被舍弃。同时，我们实现分布式系统就是为了提高可用性，这是我们的目的，不能舍弃。</li></ul><p>这里需要再说明一下，我们选择 AP 放弃 C 不是放弃数据一致，而是暂时放弃强一致性（Strong Consistency），而是选择弱一致性，即最终一致性（Eventual Consistency）：系统中的所有数据副本经过一段时间后，最终能够达到一致的状态。这里所说的一段时间，也要是用户可接受范围内的一段时间。</p><p>最终一致性也有一个理论支撑：BASE 理论（不得不说，理论界的缩写真牛啊，ACID 是酸，CAP 是帽子，BASE 是碱），内容主要包括：</p><ul><li>基本可用（<strong>B</strong>asically <strong>A</strong>vailable）：当系统在出现不可预知故障的时候，允许损失部分可用性。比如，允许响应时间增长，允许部分非关键接口降级或熔断等。</li><li>软状态（<strong>S</strong>oft <strong>S</strong>tate）：软状态也称为弱状态，和硬状态相对。是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</li><li>最终一致性（<strong>E</strong>ventually Consistent）：最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</li></ul><p>在工程实践中，最终一致性分为 5 种，这 5 种方式会结合使用，共同实现最终一致性：</p><ul><li>因果一致性（Causal consistency）：如果节点 A 在更新完某个数据后通知了节点 B，那么节点 B 之后对该数据的访问和修改都是基于 A 更新后的值。于此同时，和节点 A 无因果关系的节点 C 的数据访问则没有这样的限制。</li><li>读己之所写（Read your writes）：节点 A 更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。</li><li>会话一致性（Session consistency）：会话一致性将对系统数据的访问过程框定在了一个会话当中，系统能保证在同一个有效的会话中实现“读己之所写”的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。</li><li>单调读一致性（Monotonic read consistency）：如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。</li><li>单调写一致性（Monotonic write consistency）：一个系统要能够保证来自同一个节点的写操作被顺序的执行。</li></ul><p><img src="https://static.howardliu.cn/20210917182909.png" alt="一致性关系模型"></p><p>有了理论之后，我们来说一下实现最终一致性的几种模式。</p><h3 id="可靠事件模式"><a href="#可靠事件模式" class="headerlink" title="可靠事件模式"></a>可靠事件模式</h3><p>可靠事件模式属于事件驱动架构：当某个事件发生时，例如更新一个业务实体，服务会向消息代理发布一个事件。消息代理会向订阅事件的服务推送事件，当订阅这些事件的服务接收此事件时，就可以完成自己的业务，也可能会引发更多的事件发布。</p><p>我们通过一个例子来解释一下这种模式，用户下单成功后，订单系统需要通知库存系统减库存。</p><p><img src="https://static.howardliu.cn/20210917181828.png" alt="可靠事件模式"></p><ol><li>订单系统根据用户操作完成下单操作。此时会使用同一个本地事务保存订单信息和写入事件。</li><li>另外一个消息服务会轮询事件表，将状态是“进行中”的事件以消息形式发送到消息服务中。如果发送失败，因为是轮询任务，会在下一次轮询的时候再次发送。（此处有一些优化点，本例为了简化模型，不展开）</li><li>消息服务向订阅下单消息的库存服务发送下单成功消息，库存服务开始处理。此时会有这么集中情况：<ol><li>库存服务扣减库存成功，消息服务接收到处理成功响应。消息服务将响应结果返回给订单服务，订单服务中事件接收器将事件修改为“已完成”。</li><li>库存服务扣减库存失败，消息服务接收到处理失败响应。此时消息服务会再次向库存服务发送消息，直到得到成功响应。如果失败次数达到阈值，可以告警通知人工介入。</li><li>消息服务给订单服务返回结果时，发生失败，订单服务没有接收到成功响应。这个时候，事件轮询逻辑会再次将事件发送给消息服务。这样，库存服务会重复收到扣减库存的消息，所以要求库存服务做好幂等。库存服务发现消息已经处理过，直接返回成功。</li></ol></li></ol><p>这种靠着持续重试来保证可靠性的解决方案，叫做“最大努力交付”（Best-Effort Delivery），也是“可靠”两个字的来源。</p><p>可靠事件模式还有一种更普通的形式，被称为“最大努力一次提交”（Best-Effort 1PC），指的就是将最有可能出错或最核心的业务以本地事务的方式完成后，采用不断重试的方式（不限于消息服务）来促使同一个分布式事务中的其他关联业务全部完成。找到最可能出错的方式是提前做好出错概率的先验评估，才能够知道哪块最容易出错。找到最核心的业务的方式是找到那种只要成功，其他业务必须成功的那块业务。</p><p>这里我们再补充两个概念：</p><ul><li>业务异常：业务逻辑产生错误的情况，比如账户余额不足、商品库存不足等。</li><li>技术异常：非业务逻辑产生的异常，如网络连接异常、网络超时等。</li></ul><h3 id="TCC-模式"><a href="#TCC-模式" class="headerlink" title="TCC 模式"></a>TCC 模式</h3><p>TCC（Try-Confirm-Cancel）是一种<strong>业务侵入式</strong>较强的事务方案，要求业务处理过程必须拆分为“预留业务资源”和“确认/释放消费资源”两个子过程，由统一的服务协调调度不同业务系统的子过程。分为以下三个阶段：</p><ul><li>Try：尝试执行阶段，完成所有业务可执行性的检查（保障一致性），并且预留好全部需要用到的业务资源（保障隔离性）。</li><li>Confirm：确认执行阶段，不进行任何业务检查，直接使用 Try 阶段准备的资源来完成业务处理。Confirm 阶段可能会重复执行，需要满足幂等性。</li><li>Cancel：取消执行阶段，释放 Try 阶段预留的业务资源。Cancel 阶段可能会重复执行，需要满足幂等性。</li></ul><p><img src="https://static.howardliu.cn/20210917181847.png" alt="TCC 模式"></p><ol><li>订单系统创建事务，生成事务 ID（用于作为识别请求幂等的标识），通过活动管理器记录活动日志。</li><li>进入 Try 阶段<ol><li>调用账户系统，检查账户余额是否充足，如果充足，冻结需要的金额，此时账户余额是临界资源，需要通过排它锁或乐观锁保证冻结操作的安全性。</li><li>调用库存系统，检查商品库存是否充足，如果充足，锁定需要的库存，锁库操作也需要加锁保证安全</li></ol></li><li>如果所有业务返回成功，记录活动日志为 Confirm，进入 Confirm 阶段：<ol><li>调用账户系统，扣减冻结的金额</li><li>调用库存系统，扣减锁定的库存</li></ol></li><li>第 3 步操作中如果全部完成，事务宣告结束。如果第 3 步中任何一方出现异常，都会根据活动日志中的记录，重复执行 Confirm 操作，即进行最大努力交付。所以各业务系统的 Confirm 操作需要实现幂等性。</li><li>如果第 2 步有任何一方失败（包括业务异常和技术异常），将活动日志记录为 Cancel，进入 Cancel 阶段：<ol><li>调用账户系统，释放冻结的金额</li><li>调用库存系统，释放锁定的库存</li></ol></li><li>第 5 步操作中如果全部完成，事务宣告失败。如果第 5 步中任何一方出现异常（包括业务异常和技术异常），都会根据活动日志中的记录，重复执行 Cacel 操作，即最大努力交付。所以各业务系统的 Cancel 操作也需要实现幂等性。</li></ol><p>是不是感觉 TCC 与 2PC 的很像，两者的区别在于，TCC 位于业务代码层面，属于白盒，2PC 位于基础设施层面，属于黑盒。所以 TCC 有更高的灵活性，可以根据需要，调整资源锁定的粒度。</p><p>TCC 在业务执行过程中可以预留资源，解决了可靠事件模式的资源隔离问题。但是，TCC 还有两个明显缺点：</p><ol><li>TCC 将基础设施层的逻辑上移到业务代码，对业务有很高的侵入性，需要更高的开发成本，开发成本提升，相对应的维护成本、开发人员的素质等，都会有更高的要求。</li><li>TCC 要求资源可以锁定、占用或释放，但是有的资源属于外部系统，没有办法实现锁定。</li></ol><p>鉴于上面的两个缺点，我们看看 SAGA 是否可以弥补。</p><h3 id="SAGA-模式"><a href="#SAGA-模式" class="headerlink" title="SAGA 模式"></a>SAGA 模式</h3><p>SAGA 在英文中是“长篇故事、长篇记叙、一长串事件”的意思。SAGA 模式的提出远早于分布式事务概念的提出（再次对前辈大佬佩服的五体投地），它源于 1987 年普林斯顿大学的 Hector Garcia-Molina 和 Kenneth Salem 在 ACM 发表的一篇论文《SAGAS》。文中提出了一种提升“长时间事务”（Long Lived Transaction）运作效率的方法，大致思路是把一个大事务分解为可以交错运行的一系列子事务集合，后来发展成将一个分布式环境中的大事务分解为一系列本地事务的设计模式。在有的文章中，将这种模式称为业务补偿模式，SAGA 是对事务形式的描述，业务补偿是对事务行为的描述，其本质是一样的。</p><p>SAGA 模式有两种实现：</p><ul><li>正向恢复（Forward Recovery）：顺序执行各个子事务，如果遇到某个子事务执行失败，将一直重试该操作，知道成功，然后继续执行下一个子事务。比如用户下单支付成功了，就一定要扣减库存。</li><li>反向恢复（Backward Recovery）：顺序执行各个子事务，如果遇到某个子事务执行失败，将执行该子事务的补偿操作（避免因为技术异常造成的失败，补偿操作需要幂等），然后倒序执行已经成功的子事务的补偿操作。这种一般是可取消的批量操作，比如出行订票，需要购买飞机票、订酒店、买门票，如果买门票失败了，飞机票和酒店就可以取消了。</li></ul><p><img src="https://static.howardliu.cn/20210917181908.png" alt="SAGA 模式"></p><p>根据这两种实现，SAGA 可以分为两部分：</p><ul><li>子事务（Normal Transactions）：大事务拆分若干个小事务，将整个事务 T 分解为 n 个子事务，命名为 T<sub>1</sub>、T<sub>2</sub>、…、T<sub>n</sub>。每个子事务都应该是或者能被视为是原子行为。如果分布式事务能够正常提交，其对数据的影响（最终一致性）应与连续按顺序成功提交 Ti 等价。</li><li>补偿事务（Compensating Transactions）：每个子事务对应的补偿动作，命名为 C<sub>1</sub>、C<sub>2</sub>、…、C<sub>n</sub>。</li></ul><p>子事务与补偿动作需要满足一些条件：</p><ol><li>T<sub>i</sub>与 C<sub>i</sub>必须对应</li><li>补偿动作 C<sub>i</sub>一定会执行成功，即需要实现最大努力交付。</li><li>T<sub>i</sub>与 C<sub>i</sub>需要具备幂等性</li></ol><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文主要总结了本地事务、全局事务、最终一致性等方式实现数据自洽。重点介绍了实现最终一致性的集中模式：可靠事件模式、TCC 模式、SAGA 模式等。数据的一致性一直是个难题，随着微服务化之后，数据一致性更加困难，有困难不怕，只要不放弃，总会解决的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://icyfenix.cn/architect-perspective/general-architecture/transaction/" target="_blank" rel="noopener">事务处理</a></li><li><a href="https://kanshan.blog.csdn.net/article/details/51867631" target="_blank" rel="noopener">微服务架构下的数据一致性：概念及相关模式</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/data-consistency-in-microservices/">关于微服务系统中数据一致性的总结</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/120358607" target="_blank" rel="noopener">关于微服务系统中数据一致性的总结</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      从单体架构到分布式架构，从巨石架构到微服务架构。系统之间的交互越来越复杂，系统间的数据交互量级也是指数级增长。作为一个系统，我们要保证逻辑的自洽和数据的自洽。数据自洽有两方面要求：抛开代码，数据能够自己验证自己的准确性，也就是数据彼此之间不矛盾；所有数据准确且符合期望。
    
    </summary>
    
    
      <category term="microservice" scheme="https://www.howardliu.cn/categories/microservice/"/>
    
    
      <category term="微服务" scheme="https://www.howardliu.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="数据一致性" scheme="https://www.howardliu.cn/tags/%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="事务" scheme="https://www.howardliu.cn/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</title>
    <link href="https://www.howardliu.cn/springboot-action-junit5-mockmvc-mockito/"/>
    <id>https://www.howardliu.cn/springboot-action-junit5-mockmvc-mockito/</id>
    <published>2021-09-11T14:30:27.000Z</published>
    <updated>2021-09-11T14:30:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/coffee-beans-6603499_1920.jpg" alt="SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/nickype-10327513/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6603499" target="_blank" rel="noopener">NickyPe</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6603499" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>今天聊聊如何在 SpringBoot 中集成 Junit5、MockMvc、Mocktio。Junit5 是在 Java 栈中应用最广的测试框架，Junit4 一度霸榜。</p><a id="more"></a><p>升级到 Junit5 之后，除了增加 Java8 的很多特性，做了很多功能增强，在结构上做了优化调整，拆分了很多不同的模块，可以按需引入，比如：</p><ul><li>JUnit Platform - 在 JVM 上启动测试框架</li><li>JUnit Jupiter - 在 JUnit5 中编写测试和扩展</li><li>JUnit Vintage - 提供运行基于 JUnit3 和 JUnit4 的测试引擎</li></ul><p>从 SpringBoot 2.2.0 之后，Junit5 已经成为了默认的 Junit 版本。有了 JUnit Vintage，从 Junit4 迁移到 Junit5 的成本极低。所以本文就直接针对 Junit5 开始了。</p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>先说版本，是为了避免因为版本差异出现各种奇怪的问题：</p><ul><li>JDK：jdk8（小版本可以忽略）</li><li>SpringBoot：2.5.2<ul><li>继承<code>spring-boot-starter-parent</code></li><li>依赖<code>spring-boot-starter-web</code></li><li>依赖<code>spring-boot-starter-test</code></li></ul></li><li>JUnit：5.7.2</li><li>Mockito：3.9.0</li><li>hamcrest：2.2</li></ul><p>SpringBoot 的好处在于，只要继承<code>spring-boot-starter-parent</code>或引入<code>spring-boot-pom-dependencies</code>，然后添加<code>spring-boot-starter-test</code>依赖即可。定义的 POM 内容如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.5.2&lt;/version&gt;    &lt;/parent&gt;    &lt;groupId&gt;cn.howardliu.effective.spring&lt;/groupId&gt;    &lt;artifactId&gt;springboot-junit5-mockito&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;springboot-junit5-mockio&lt;/name&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>因为继承了<code>spring-boot-starter-parent</code>，所以我们依赖的<code>spring-boot-starter-test</code>不需要写具体的版本，可以直接集成父级的版本定义。其中，<code>spring-boot-starter-web</code>是用于提供 REST API 的 web 容器，<code>spring-boot-starter-test</code>可以提供各种测试框架的，<code>spring-boot-maven-plugin</code>是将 SpringBoot 应用打包为可执行 jar 的插件。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>因为是 DEMO 示例，我们实现一个 Echo 接口，能够接收请求参数，并返回加工后的字符串。按照惯例，我们使用万能的<code>Hello, World!</code>。</p><p>我们的项目结构如下：</p><pre><code class="txt">├── pom.xml└── src    ├── main    │   ├── java    │   │   └── cn    │   │       └── howardliu    │   │           └── effective    │   │               └── spring    │   │                   └── springbootjunit5mockio    │   │                       ├── SpringbootJunit5MockioApplication.java    │   │                       ├── controller    │   │                       │   └── EchoController.java    │   │                       └── service    │   │                           ├── EchoService.java    │   │                           └── impl    │   │                               └── EchoServiceImpl.java    │   └── resources    │       └── application.yaml    └── test        └── java            └── cn                └── howardliu                    └── effective                        └── spring                            └── springbootjunit5mockio                                └── controller                                    ├── EchoControllerMockTest.java                                    └── EchoControllerNoMockitoTest.java</code></pre><ul><li>SpringbootJunit5MockioApplication：SpringBoot 应用启动入口</li><li>EchoController：接口定义</li><li>EchoService：实现业务逻辑接口</li><li>EchoServiceImpl：接口实现</li><li>EchoControllerMockTest：使用 Mock 代理 EchoService 实现</li><li>EchoControllerNoMockitoTest：直接测试接口实现</li></ul><h3 id="EchoServiceImpl"><a href="#EchoServiceImpl" class="headerlink" title="EchoServiceImpl"></a>EchoServiceImpl</h3><p>我们看下<code>EchoService</code>的实现，这将是我们 DEMO 的核心实现：</p><pre><code class="java">@Servicepublic class EchoServiceImpl implements EchoService {    @Override    public String echo(String foo) {        return &quot;Hello, &quot; + foo;    }}</code></pre><h3 id="EchoControllerNoMockitoTest"><a href="#EchoControllerNoMockitoTest" class="headerlink" title="EchoControllerNoMockitoTest"></a>EchoControllerNoMockitoTest</h3><p>我们先使用 Junit5+MockMvc 实现 Controller 接口的普通调用，代码如下：</p><pre><code class="java">@SpringBootTest(classes = SpringbootJunit5MockioApplication.class)@AutoConfigureMockMvcclass EchoControllerNoMockitoTest {    @Autowired    private MockMvc mockMvc;    @Test    void echo() throws Exception {        final String result = mockMvc.perform(                MockMvcRequestBuilders.get(&quot;/echo/&quot;)                        .param(&quot;name&quot;, &quot;看山&quot;)        )                .andExpect(MockMvcResultMatchers.status().isOk())                .andDo(MockMvcResultHandlers.print())                .andReturn()                .getResponse()                .getContentAsString(StandardCharsets.UTF_8);        Assertions.assertEquals(&quot;Hello, 看山&quot;, result);    }}</code></pre><p>我们通过<code>SpringBootTest</code>注解定义这是一个 SpringBoot 应用的测试用例，然后通过<code>AutoConfigureMockMvc</code>启动测试容器。这样，就可以直接注入<code>MockMvc</code>实例测试 Controller 接口。</p><p>这里需要注意一点，网上很多教程会让写<code>@ExtendWith({SpringExtension.class})</code>这样一个注解，其实完全没有必要。通过源码我们可以知道，<code>SpringBootTest</code>注解已经添加了<code>ExtendWith</code>。</p><h3 id="EchoControllerMockTest"><a href="#EchoControllerMockTest" class="headerlink" title="EchoControllerMockTest"></a>EchoControllerMockTest</h3><p>这个测试用例中，我们通过 Mockito 组件代理<code>EchoService</code>的<code>echo</code>方法，代码如下：</p><pre><code class="java">@SpringBootTest(classes = SpringbootJunit5MockioApplication.class)@ExtendWith(MockitoExtension.class)@AutoConfigureMockMvcclass EchoControllerMockTest {    @Autowired    private MockMvc mockMvc;    @MockBean    private EchoService echoService;    @BeforeEach    void setUp() {        Mockito.when(echoService.echo(Mockito.any()))                .thenReturn(&quot;看山说：&quot; + System.currentTimeMillis());    }    @Test    void echo() throws Exception {        final String result = mockMvc.perform(                MockMvcRequestBuilders.get(&quot;/echo/&quot;)                        .param(&quot;name&quot;, &quot;看山的小屋&quot;)        )                .andExpect(MockMvcResultMatchers.status().isOk())                .andDo(MockMvcResultHandlers.print())                .andReturn()                .getResponse()                .getContentAsString(StandardCharsets.UTF_8);        Assertions.assertTrue(result.startsWith(&quot;看山&quot;));    }}</code></pre><p>在这个示例中，我们需要注意<code>@ExtendWith(MockitoExtension.class)</code>注解，这个注解是用于引入<code>MockBean</code>的，我们通过对<code>echo</code>方法的拦截，使其返回我们定义好的响应结果。这种方式是为了在多系统或者多功能测试时，不需要真正调用接口。</p><p>比如，我们需要获取用户手机号，通常在接口中会校验用户有没有登录，我们就可以使用 Mockito 的能力代理登录验证，使结果永远是 true。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>至此，我们完成了 SpringBoot 集成 Junit5、MockMvc、Mockito 的示例。想要获取源码，只需要关注公众号「看山的小屋」，回复<code>spring</code>即可。</p><p>很多同学感觉单元测试没有编写的必要，直接使用 Swagger 或者 Postman 之类的工具就能很好的测试接口。确实如此，对于简单的 CRUD 接口，写单元测试的必要性不太高。但是，如果是复杂接口呢？接口参数有很多的组合，响应结果也需要各种验证，如果使用一次性的工具，每次测试组合参数就已经让人崩溃了，而且组合参数不能存留甚至不能在多人间传承，就会浪费很多的人力。</p><p>此时，单元测试的效果就会显现。我们只需要编写一次参数组合，放在 csv 之类的文件中，通过单元测试的参数化测试方式，即可多次运行，验证接口的正确性。</p><p>或者，当我们感觉系统已经臭味弥漫，对其重构之后，为了验证接口功能不变，也可以直接使用原来的测试用例加以验证。</p><p>综上，虽然测试用例编写麻烦，但是妙用无穷。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response/">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response-exception/">SpringBoot 实战：如何优雅的处理异常</a></li><li><a href="https://www.howardliu.cn/spring-beanpostprocessor/">SpringBoot 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://www.howardliu.cn/spring-request-recorder/">SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li><li><a href="https://www.howardliu.cn/spring-enum-params/">SpringBoot 实战：优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-enum-params-principle/">SpringBoot 实战：优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody-principle/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-junit5-mockmvc-mockito/">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a></li><li><a href="https://www.howardliu.cn/spring-classpath-file-access/">SpringBoot 实战：加载和读取资源文件内容</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/springboot-action-junit5-mockmvc-mockito/">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/120244720" target="_blank" rel="noopener">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a></p><center><b>👇🏻欢迎关注个人公众号，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      今天聊聊如何在 SpringBoot 中集成 Junit5、MockMvc、Mocktio。Junit5 是在 Java 栈中应用最广的测试框架，Junit4 一度霸榜。
    
    </summary>
    
    
      <category term="springboot" scheme="https://www.howardliu.cn/categories/springboot/"/>
    
    
      <category term="SpringBoot" scheme="https://www.howardliu.cn/tags/SpringBoot/"/>
    
      <category term="实战" scheme="https://www.howardliu.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</title>
    <link href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody-principle/"/>
    <id>https://www.howardliu.cn/springboot-action-enum-params-in-requestbody-principle/</id>
    <published>2021-08-28T08:39:56.000Z</published>
    <updated>2021-08-28T08:39:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/lesser-sand-plover-6535531_1920.jpg" alt="SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/johnnys_pic-21062476/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6535531" target="_blank" rel="noopener">Johnnys_pic</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6535531" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>在<a href="https://www.howardliu.cn/springboot-enum-params-principle/">优雅的使用枚举参数（原理篇）</a>中我们聊过，Spring对于不同的参数形式，会采用不同的处理类处理参数，这种形式，有些类似于策略模式。将针对不同参数形式的处理逻辑，拆分到不同处理类中，减少耦合和各种if-else逻辑。本文就来扒一扒，RequestBody参数中使用枚举参数的原理。</p><a id="more"></a><h2 id="找入口"><a href="#找入口" class="headerlink" title="找入口"></a>找入口</h2><p>对 Spring 有一定基础的同学一定知道，请求入口是<code>DispatcherServlet</code>，所有的请求最终都会落到<code>doDispatch</code>方法中的<code>ha.handle(processedRequest, response, mappedHandler.getHandler())</code>逻辑。我们从这里出发，一层一层向里扒。</p><p>跟着代码深入，我们会找到<code>org.springframework.web.method.support.InvocableHandlerMethod#invokeForRequest</code>的逻辑：</p><pre><code class="java">public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,        Object... providedArgs) throws Exception {    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);    if (logger.isTraceEnabled()) {        logger.trace(&quot;Arguments: &quot; + Arrays.toString(args));    }    return doInvoke(args);}</code></pre><p>可以看出，这里面通过<code>getMethodArgumentValues</code>方法处理参数，然后调用<code>doInvoke</code>方法获取返回值。<code>getMethodArgumentValues</code>方法内部又是通过<code>HandlerMethodArgumentResolverComposite</code>实例处理参数。这个类内部是一个<code>HandlerMethodArgumentResolver</code>实例列表，列表中是Spring处理参数逻辑的集合，跟随代码Debug，可以看到有27个元素。这些类也是可以定制扩展，实现自己的参数解析逻辑，这部分内容后续再做介绍。</p><h2 id="选择Resolver"><a href="#选择Resolver" class="headerlink" title="选择Resolver"></a>选择Resolver</h2><p>这个Resolver列表中，包含我们常用的几个处理类。Get请求的普通参数是通过<code>RequestParamMethodArgumentResolver</code>处理参数，包装类通过<code>ModelAttributeMethodProcessor</code>处理参数，RequestBody形式的参数，则是通过<code>RequestResponseBodyMethodProcessor</code>处理参数。这段就是Spring中策略模式的使用，通过实现<code>org.springframework.web.method.support.HandlerMethodArgumentResolver#supportsParameter</code>方法，判断输入参数是否可以解析。下面贴上<code>RequestResponseBodyMethodProcessor</code>的实现：</p><pre><code class="java">public boolean supportsParameter(MethodParameter parameter) {    return parameter.hasParameterAnnotation(RequestBody.class);}</code></pre><p>可以看到，<code>RequestResponseBodyMethodProcessor</code>是通过判断参数是否带有<code>RequestBody</code>注解来判断，当前参数是否可以解析。</p><h2 id="解析参数"><a href="#解析参数" class="headerlink" title="解析参数"></a>解析参数</h2><p><code>RequestResponseBodyMethodProcessor</code>继承自<code>AbstractMessageConverterMethodArgumentResolver</code>，真正解析<code>RequestBody</code>参数的逻辑在<code>org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#readWithMessageConverters</code>方法中。我们看下源码（因为源码比较长，文中仅留下核心逻辑。）：</p><pre><code class="java">protected &lt;T&gt; Object readWithMessageConverters(HttpInputMessage inputMessage, MethodParameter parameter,        Type targetType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException {    MediaType contentType = inputMessage.getHeaders().getContentType();// 1    Class&lt;?&gt; contextClass = parameter.getContainingClass();// 2    Class&lt;T&gt; targetClass = (targetType instanceof Class ? (Class&lt;T&gt;) targetType : null);// 3    Object body = NO_VALUE;    EmptyBodyCheckingHttpInputMessage message = new EmptyBodyCheckingHttpInputMessage(inputMessage);// 4    for (HttpMessageConverter&lt;?&gt; converter : this.messageConverters) {// 5        Class&lt;HttpMessageConverter&lt;?&gt;&gt; converterType = (Class&lt;HttpMessageConverter&lt;?&gt;&gt;) converter.getClass();        GenericHttpMessageConverter&lt;?&gt; genericConverter =                (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter&lt;?&gt;) converter : null);        if (genericConverter != null ? genericConverter.canRead(targetType, contextClass, contentType) :                (targetClass != null &amp;&amp; converter.canRead(targetClass, contentType))) {            if (message.hasBody()) {                HttpInputMessage msgToUse =                        getAdvice().beforeBodyRead(message, parameter, targetType, converterType);                body = (genericConverter != null ? genericConverter.read(targetType, contextClass, msgToUse) :                        ((HttpMessageConverter&lt;T&gt;) converter).read(targetClass, msgToUse));// 6                body = getAdvice().afterBodyRead(body, msgToUse, parameter, targetType, converterType);            }            else {                body = getAdvice().handleEmptyBody(null, message, parameter, targetType, converterType);            }            break;        }    }    return body;}</code></pre><p>跟着代码说明一下各部分用途：</p><ol><li>获取请求content-type</li><li>获取参数容器类</li><li>获取目标参数类型</li><li>将请求参数转换为<code>EmptyBodyCheckingHttpInputMessage</code>类型</li><li>循环各种RequestBody参数解析器，这些解析器都是<code>HttpMessageConverter</code>接口的实现类。Spring对各种情况做了全量覆盖，总有一款适合的。文末给出<code>HttpMessageConverter</code>各个扩展类的类图。</li><li>for循环体中就是选择一款适合的，进行解析<ol><li>首先调用<code>canRead</code>方法判断是否可用</li><li>判断请求请求参数是否为空，为空则通过AOP的<code>advice</code>处理一下空请求体，然后返回</li><li>不为空，先通过AOP的<code>advice</code>做前置处理，然后调用<code>read</code>方法转换对象，在通过<code>advice</code>做后置处理</li></ol></li></ol><blockquote><p>Spring的AOP不在本文范围内，所以一笔带过。后续有专题说明。</p></blockquote><p>本例中，<code>HttpMessageConverter</code>使用的是<code>MappingJackson2HttpMessageConverter</code>，该类继承自<code>AbstractJackson2HttpMessageConverter</code>。看名称就知道，这个类是使用Jackson处理请求参数。其中<code>read</code>方法之后，会调用内部私有方法<code>readJavaType</code>，下面给出该方法的核心逻辑：</p><pre><code class="java">private Object readJavaType(JavaType javaType, HttpInputMessage inputMessage) throws IOException {    MediaType contentType = inputMessage.getHeaders().getContentType();// 1    Charset charset = getCharset(contentType);    ObjectMapper objectMapper = selectObjectMapper(javaType.getRawClass(), contentType);// 2    Assert.state(objectMapper != null, &quot;No ObjectMapper for &quot; + javaType);    boolean isUnicode = ENCODINGS.containsKey(charset.name()) ||            &quot;UTF-16&quot;.equals(charset.name()) ||            &quot;UTF-32&quot;.equals(charset.name());// 3    try {        if (isUnicode) {            return objectMapper.readValue(inputMessage.getBody(), javaType);// 4        } else {            Reader reader = new InputStreamReader(inputMessage.getBody(), charset);            return objectMapper.readValue(reader, javaType);        }    }    catch (InvalidDefinitionException ex) {        throw new HttpMessageConversionException(&quot;Type definition error: &quot; + ex.getType(), ex);    }    catch (JsonProcessingException ex) {        throw new HttpMessageNotReadableException(&quot;JSON parse error: &quot; + ex.getOriginalMessage(), ex, inputMessage);    }}</code></pre><p>跟着代码说明一下各部分用途：</p><ol><li>获取请求的<code>content-type</code>，这个是Spring实现的扩展逻辑，根据不同的<code>content-type</code>可以选择不同的<code>ObjectMapper</code>实例。也就是第2步的逻辑</li><li>根据<code>content-type</code>和目标类型，选择<code>ObjectMapper</code>实例。本例中直接返回的是默认的，也就是通过<code>Jackson2ObjectMapperBuilder.cbor().build()</code>方法创建的。</li><li>检查请求是否是unicode字符，目前来说，大家用的都是<code>UTF-8</code>的</li><li>通过<code>ObjectMapper</code>将请求json转换为对象。其实这部分还有一段判断<code>inputMessage</code>是否是<code>MappingJacksonInputMessage</code>实例的，考虑到大家使用的版本，这部分就不说了。</li></ol><p>至此，Spring的逻辑全部结束，似乎还是没有找到我们使用的<code>JsonCreator</code>注解或者<code>JsonDeserialize</code>的逻辑。不过也能想到，这两个都是Jackson的类，那必然应该是Jackson的逻辑。接下来，就扒一扒Jackson的转换逻辑了。</p><h2 id="深入Jackson的ObjectMapper逻辑"><a href="#深入Jackson的ObjectMapper逻辑" class="headerlink" title="深入Jackson的ObjectMapper逻辑"></a>深入Jackson的ObjectMapper逻辑</h2><p>牵扯Jackson的逻辑主要分布在<code>AbstractMessageConverterMethodArgumentResolver#readWithMessageConverters</code>和<code>ObjectMapper#readValue</code>这两个方法中。先说一下<code>ObjectMapper#readValue</code>方法的逻辑，这里面会调用<code>GenderIdCodeEnum#create</code>方法，完成类型转换。</p><p><code>ObjectMapper#readValue</code>方法直接调用了当前类中的<code>_readMapAndClose</code>方法，这个方法里面比较关键的是<code>ctxt.readRootValue(p, valueType, _findRootDeserializer(ctxt, valueType), null)</code>，这个方法就是将输入json转换为对象。咱们再继续深入，可以找到Jackson内部是通过<code>BeanDeserializer</code>这个类转换对象的，比较重要的是<code>deserializeFromObject</code>方法，源码如下（删除一下不太重要的代码）：</p><pre><code class="java">public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException{    // 这里根据上下文中目标类型，创建实例对象，其中 _valueInstantiator 是 StdValueInstantiator 实例。    final Object bean = _valueInstantiator.createUsingDefault(ctxt);    // [databind#631]: Assign current value, to be accessible by custom deserializers    p.setCurrentValue(bean);    if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {        String propName = p.currentName();        do {            p.nextToken();            // 根据字段名找到 属性对象，对于gender字段，类型是 MethodProperty。            SettableBeanProperty prop = _beanProperties.find(propName);            if (prop != null) { // normal case                try {                    // 开始进行解码操作，并将解码结果写入到对象中                    prop.deserializeAndSet(p, ctxt, bean);                } catch (Exception e) {                    wrapAndThrow(e, bean, propName, ctxt);                }                continue;            }            handleUnknownVanilla(p, ctxt, bean, propName);        } while ((propName = p.nextFieldName()) != null);    }    return bean;}</code></pre><p>咱们看一下<code>MethodProperty#deserializeAndSet</code>的逻辑（只保留关键代码）：</p><pre><code class="java">public void deserializeAndSet(JsonParser p, DeserializationContext ctxt,        Object instance) throws IOException{    Object value;    // 调用 FactoryBasedEnumDeserializer 实例的解码方法    value = _valueDeserializer.deserialize(p, ctxt);    // 通过反射将值写入对象中    _setter.invoke(instance, value);}</code></pre><p>其中<code>_valueDeserializer</code>是<code>FactoryBasedEnumDeserializer</code>实例，快要接近目标了，看下这段逻辑：</p><pre><code class="java">public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException{    // 获取json中的值    Object value = _deser.deserialize(p, ctxt);    // 调用 GenderIdCodeEnum#create 方法    return _factory.callOnWith(_valueClass, value);}</code></pre><p><code>_factory</code>是<code>AnnotatedMethod</code>实例，主要是对<code>JsonCreator</code>注解定义的方法的包装，然后<code>callOnWith</code>中调用<code>java.lang.reflect.Method#invoke</code>反射方法，执行<code>GenderIdCodeEnum#create</code>。</p><p>至此，我们终于串起来所有逻辑。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文通过一个示例串起来<code>@JsonCreator</code>注解起作用的逻辑，<code>JsonDeserializer</code>接口的逻辑与之类型，可以耐心debug一番。下面给出主要类的类图：</p><p><img src="https://static.howardliu.cn/RequestResponseBodyMethodProcessor.png" alt="SpringBoot参数解析类图"></p><p><img src="https://static.howardliu.cn/HttpMessageConverter.png" alt="HttpMessageConverter"></p><p><img src="https://static.howardliu.cn/ObjectMapper.png" alt="ObjectMapper"></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response/">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response-exception/">SpringBoot 实战：如何优雅的处理异常</a></li><li><a href="https://www.howardliu.cn/spring-beanpostprocessor/">SpringBoot 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://www.howardliu.cn/spring-request-recorder/">SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li><li><a href="https://www.howardliu.cn/spring-enum-params/">SpringBoot 实战：优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-enum-params-principle/">SpringBoot 实战：优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody-principle/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-junit5-mockmvc-mockito/">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a></li><li><a href="https://www.howardliu.cn/spring-classpath-file-access/">SpringBoot 实战：加载和读取资源文件内容</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody-principle/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/120052842" target="_blank" rel="noopener">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</a></p><center><b>👇🏻欢迎关注个人公众号，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Spring对于不同的参数形式，会采用不同的处理类处理参数，这种形式，有些类似于策略模式。将针对不同参数形式的处理逻辑，拆分到不同处理类中，减少耦合和各种if-else逻辑。本文就来扒一扒，RequestBody参数中使用枚举参数的原理。
    
    </summary>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/categories/spring/"/>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/tags/spring/"/>
    
      <category term="enum" scheme="https://www.howardliu.cn/tags/enum/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</title>
    <link href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody/"/>
    <id>https://www.howardliu.cn/springboot-action-enum-params-in-requestbody/</id>
    <published>2021-08-22T07:45:44.000Z</published>
    <updated>2021-08-22T07:45:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/macroperspective-6558526_1920.jpg" alt="SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/christian_crowd-22911196/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6558526" target="_blank" rel="noopener">Christian_Crowd</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6558526" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>前文说到 <a href="https://www.howardliu.cn/spring-enum-params/">优雅的使用枚举参数</a> 和 <a href="https://www.howardliu.cn/springboot-enum-params-principle/">实现原理</a>，本文继续说一下如何在 RequestBody 中优雅使用枚举。</p><p>本文先上实战，说一下如何实现。在 <a href="https://www.howardliu.cn/spring-enum-params/">优雅的使用枚举参数</a> 代码的基础上，我们继续实现。如果想要获取源码，可以关注公号「看山的小屋」，回复 spring 即可。</p><a id="more"></a><h2 id="确认需求"><a href="#确认需求" class="headerlink" title="确认需求"></a>确认需求</h2><p>需求与前文类似，只不过这里需要是在 RequestBody 中使用。与前文不同的是，这种请求是通过 Http Body 的方式传输到后端，通常是 json 或 xml 格式，Spring 默认借助 Jackson 反序列化为对象。</p><p>同样的，我们需要在枚举中定义 int 类型的 id、String 类型的 code，id 取值不限于序号（即从 0 开始的 orinal 数据），code 不限于 name。客户端请求过程中，可以传 id，可以传 code，也可以传 name。服务端只需要在对象中定义一个枚举参数，不需要额外的转换，即可得到枚举值。</p><p>好了，接下来我们定义一下枚举对象。</p><h2 id="定义枚举和对象"><a href="#定义枚举和对象" class="headerlink" title="定义枚举和对象"></a>定义枚举和对象</h2><p>先定义我们的枚举类<code>GenderIdCodeEnum</code>，包含 id 和 code 两个属性：</p><pre><code class="java">public enum GenderIdCodeEnum implements IdCodeBaseEnum {    MALE(1, &quot;male&quot;),    FEMALE(2, &quot;female&quot;);    private final Integer id;    private final String code;    GenderIdCodeEnum(Integer id, String code) {        this.id = id;        this.code = code;    }    @Override    public String getCode() {        return code;    }    @Override    public Integer getId() {        return id;    }}</code></pre><p>这个枚举类的要求与前文一致，不清楚的可以再去看一下。</p><p>在定义一个包装类<code>GenderIdCodeRequestBody</code>，用于接收 json 数据的请求体：</p><pre><code class="java">@Datapublic class GenderIdCodeRequestBody {    private String name;    private GenderIdCodeEnum gender;    private long timestamp;}</code></pre><p>除了<code>GenderIdCodeEnum</code>参数外，其他都是示例，所以随便定义一下。</p><h2 id="实现转换逻辑"><a href="#实现转换逻辑" class="headerlink" title="实现转换逻辑"></a>实现转换逻辑</h2><p>前奏铺垫好，接下来入正题了。Jackson 提供了两种方案：</p><ul><li>方案一：精准攻击，指定需要转换的字段，不影响其他类对象中的字段</li><li>方案二：全范围攻击，所有借助 Jackson 反序列化的枚举字段，全部具备自动转换功能</li></ul><h3 id="方案一：精准攻击"><a href="#方案一：精准攻击" class="headerlink" title="方案一：精准攻击"></a>方案一：精准攻击</h3><p>这种方案中，我们首先需要实现<code>JsonDeserialize</code>抽象类：</p><pre><code class="java">public class IdCodeToEnumDeserializer extends JsonDeserializer&lt;BaseEnum&gt; {    @Override    public BaseEnum deserialize(JsonParser jsonParser, DeserializationContext deserializationContext)            throws IOException {        final String param = jsonParser.getText();// 1        final JsonStreamContext parsingContext = jsonParser.getParsingContext();// 2        final String currentName = parsingContext.getCurrentName();// 3        final Object currentValue = parsingContext.getCurrentValue();// 4        try {            final Field declaredField = currentValue.getClass().getDeclaredField(currentName);// 5            final Class&lt;?&gt; targetType = declaredField.getType();// 6            final Method createMethod = targetType.getDeclaredMethod(&quot;create&quot;, Object.class);// 7            return (BaseEnum) createMethod.invoke(null, param);// 8        } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException | NoSuchFieldException e) {            throw new CodeBaseException(ErrorResponseEnum.PARAMS_ENUM_NOT_MATCH, new Object[] {param}, &quot;&quot;, e);        }    }}</code></pre><p>然后在指定枚举字段上定义<code>@JsonDeserialize</code>注解，比如：</p><pre><code class="java">@JsonDeserialize(using = IdCodeToEnumDeserializer.class)private GenderIdCodeEnum gender;</code></pre><p>具体说一下每行的作用：</p><ol><li>获取参数值。根据需要，此处可能是 id、code 或 name，也就是源值，需要将其转换为枚举；</li><li>获取转换上线文，这个是为 3、4 步做准备的；</li><li>获取标记<code>@JsonDeserialize</code>注解的字段，此时<code>currentName</code>的值是<code>gender</code>；</li><li>获取包装对象，也就是<code>GenderIdCodeRequestBody</code>对象；</li><li>根据包装对象的<code>Class</code>对象，以及字段名<code>gender</code>获取<code>Field</code>对象，为第 5 步做准备；</li><li>获取<code>gender</code>字段对应的枚举类型，也即是<code>GenderIdCodeEnum</code>。之所以这样做，是要实现一个通用的反序列化类；</li><li>这里是写死的一种实现，就是在枚举类中，需要定义一个静态方法，方法名是<code>create</code>，请求参数是<code>Object</code>；</li><li>通过反射调用<code>create</code>方法，将第一步获取的请求参数传入。</li></ol><p>我们来看一下枚举类中定义的<code>create</code>方法：</p><pre><code class="java">public static GenderIdCodeEnum create(Object code) {    final String stringCode = code.toString();    final Integer intCode = BaseEnum.adapter(stringCode);    for (GenderIdCodeEnum item : values()) {        if (Objects.equals(stringCode, item.name())) {            return item;        }        if (Objects.equals(item.getCode(), stringCode)) {            return item;        }        if (Objects.equals(item.getId(), intCode)) {            return item;        }    }    return null;}</code></pre><p>为了性能考虑，我们可以提前定义三组 map，分别以 id、code、name 为 key，以枚举值为 value，这样就可以通过 O(1) 的时间复杂度返回了。可以参考前文的<code>Converter</code>类的实现逻辑。</p><p>这样，我们就可以实现精准转换了。</p><h3 id="方案二：全范围攻击"><a href="#方案二：全范围攻击" class="headerlink" title="方案二：全范围攻击"></a>方案二：全范围攻击</h3><p>这种方案是全范围攻击了，只要是 Jackson 参与的反序列化，只要其中有目标枚举参数，就会受到这种进入这种方案的逻辑中。这种方案是在枚举类中定义一个静态转换方法，通过<code>@JsonCreator</code>注解注释，Jackson 就会自动转换了。</p><p>这个方法的定义与方案一中的<code>create</code>方法完全一致，所以只需要在<code>create</code>方法上加上注解即可：</p><pre><code class="java">@JsonCreator(mode = Mode.DELEGATING)public static GenderIdCodeEnum create(Object code) {    final String stringCode = code.toString();    final Integer intCode = BaseEnum.adapter(stringCode);    for (GenderIdCodeEnum item : values()) {        if (Objects.equals(stringCode, item.name())) {            return item;        }        if (Objects.equals(item.getCode(), stringCode)) {            return item;        }        if (Objects.equals(item.getId(), intCode)) {            return item;        }    }    return null;}</code></pre><p>其中<code>Mode</code>类有四个值：<code>DEFAULT</code>、<code>DELEGATING</code>、<code>PROPERTIES</code>、<code>DISABLED</code>，这四种的差别会在原理篇中说明。还是那句话，对于应用类技术，我们可以先知其然，再知其所以然，也一定要知其所以然。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>先定义一个 controller 方法：</p><pre><code class="java">@PostMapping(&quot;gender-id-code-request-body&quot;)public GenderIdCodeRequestBody bodyGenderIdCode(@RequestBody GenderIdCodeRequestBody genderRequest) {    genderRequest.setTimestamp(System.currentTimeMillis());    return genderRequest;}</code></pre><p>然后定义测试用例，还是借助 JUnit5：</p><pre><code class="java">@ParameterizedTest@ValueSource(strings = {&quot;\&quot;MALE\&quot;&quot;, &quot;\&quot;male\&quot;&quot;, &quot;\&quot;1\&quot;&quot;, &quot;1&quot;})void postGenderIdCode(String gender) throws Exception {    final String result = mockMvc.perform(            MockMvcRequestBuilders.post(&quot;/echo/gender-id-code-request-body&quot;)                    .contentType(MediaType.APPLICATION_JSON_UTF8)                    .accept(MediaType.APPLICATION_JSON_UTF8)                    .content(&quot;{\&quot;gender\&quot;: &quot; + gender + &quot;, \&quot;name\&quot;: \&quot;看山\&quot;}&quot;)    )            .andExpect(MockMvcResultMatchers.status().isOk())            .andDo(MockMvcResultHandlers.print())            .andReturn()            .getResponse()            .getContentAsString();    ObjectMapper objectMapper = new ObjectMapper();    final GenderIdCodeRequestBody genderRequest = objectMapper.readValue(result, GenderIdCodeRequestBody.class);    Assertions.assertEquals(GenderIdCodeEnum.MALE, genderRequest.getGender());    Assertions.assertEquals(&quot;看山&quot;, genderRequest.getName());    Assertions.assertTrue(genderRequest.getTimestamp() &gt; 0);}</code></pre><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文主要说明了如何在 RequestBody 中优雅的使用枚举参数，借助了 Jackson 的反序列化扩展，可以定制类型转换逻辑。碍于文章篇幅，没有罗列大段代码。关注公号「看山的小屋」回复 spring 可以获取源码。关注我，下一篇我们进入原理篇。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response/">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response-exception/">SpringBoot 实战：如何优雅的处理异常</a></li><li><a href="https://www.howardliu.cn/spring-beanpostprocessor/">SpringBoot 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://www.howardliu.cn/spring-request-recorder/">SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li><li><a href="https://www.howardliu.cn/spring-enum-params/">SpringBoot 实战：优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-enum-params-principle/">SpringBoot 实战：优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody-principle/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-junit5-mockmvc-mockito/">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a></li><li><a href="https://www.howardliu.cn/spring-classpath-file-access/">SpringBoot 实战：加载和读取资源文件内容</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</a></p><center><b>👇🏻欢迎关注个人公众号，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文继续说一下如何在 RequestBody 中优雅使用枚举。
    
    </summary>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/categories/spring/"/>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/tags/spring/"/>
    
      <category term="enum" scheme="https://www.howardliu.cn/tags/enum/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实战：优雅的使用枚举参数（原理篇）</title>
    <link href="https://www.howardliu.cn/springboot-enum-params-principle/"/>
    <id>https://www.howardliu.cn/springboot-enum-params-principle/</id>
    <published>2021-08-13T13:30:21.000Z</published>
    <updated>2021-08-13T13:30:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/wheat-6536039_1920.jpg" alt="SpringBoot 实战：优雅的使用枚举参数（原理篇）"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/minka2507-3728206/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6536039" target="_blank" rel="noopener">minka2507</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6536039" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p><a href="https://howardliu.cn/spring-enum-params/" target="_blank" rel="noopener">SpringBoot 实战：优雅的使用枚举参数</a> 中聊了怎么优雅的使用枚举参数，本文就来扒一扒 Spring 是如何找到对应转换器 Converter 的。</p><a id="more"></a><h2 id="找入口"><a href="#找入口" class="headerlink" title="找入口"></a>找入口</h2><p>对 Spring 有一定基础的同学一定知道，请求入口是<code>DispatcherServlet</code>，所有的请求最终都会落到<code>doDispatch</code>方法中的<code>ha.handle(processedRequest, response, mappedHandler.getHandler())</code>逻辑。我们从这里出发，一层一层向里扒。</p><p>跟着代码深入，我们会找到<code>org.springframework.web.method.support.InvocableHandlerMethod#invokeForRequest</code>的逻辑：</p><pre><code class="java">public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,        Object... providedArgs) throws Exception {    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);    if (logger.isTraceEnabled()) {        logger.trace(&quot;Arguments: &quot; + Arrays.toString(args));    }    return doInvoke(args);}</code></pre><p>可以看出，这里面通过<code>getMethodArgumentValues</code>方法处理参数，然后调用<code>doInvoke</code>方法获取返回值。</p><p>继续深入，能够找到<code>org.springframework.web.method.annotation.RequestParamMethodArgumentResolver#resolveArgument</code>方法，这个方法就是解析参数的逻辑。</p><p>试想一下，如果是我们自己实现这段逻辑，会怎么做呢？</p><ol><li>获取输入参数</li><li>找到目标参数</li><li>检查是否需要特殊转换逻辑</li><li>如果需要，进行转换</li><li>如果不需要，直接返回</li></ol><p><img src="http://static.howardliu.cn/spring/spring-resolveArgument.jpg" alt="解析参数"></p><p>获取输入参数的逻辑在<code>org.springframework.web.method.annotation.RequestParamMethodArgumentResolver#resolveName</code>，单参数返回的是 String 类型，多参数返回 String 数组。核心代码如下：</p><pre><code class="java">String[] paramValues = request.getParameterValues(name);if (paramValues != null) {    arg = (paramValues.length == 1 ? paramValues[0] : paramValues);}</code></pre><p>所以说，无论我们的目标参数是什么，输入参数都是 String 类型或 String 数组，然后 Spring 把它们转换为我们期望的类型。</p><p>找到目标参数的逻辑在<code>DispatcherServlet</code>中，根据 uri 找到对应的 Controller 处理方法，找到方法就找到了目标参数类型。</p><p>接下来就是检查是否需要转换逻辑，也就是<code>org.springframework.validation.DataBinder#convertIfNecessary</code>，顾名思义，如果需要就转换，将字符串类型转换为目标类型。在我们的例子中，就是将 String 转换为枚举值。</p><h2 id="查找转换器"><a href="#查找转换器" class="headerlink" title="查找转换器"></a>查找转换器</h2><p>继续深扒，会在<code>org.springframework.beans.TypeConverterDelegate#convertIfNecessary</code>方法中找到这么一段逻辑：</p><pre><code class="java">if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {    try {        return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);    }    catch (ConversionFailedException ex) {        // fallback to default conversion logic below        conversionAttemptEx = ex;    }}</code></pre><p>这段逻辑中，调用了<code>org.springframework.core.convert.support.GenericConversionService#canConvert</code>方法，检查是否可转换，如果可以转换，将会执行类型转换逻辑。</p><p>检查是否可转换的本质就是检查是否能够找到对应的转换器。如果能找到，就用找到的转换器开始转换逻辑，如果找不到，那就是不能转换，走其他逻辑。</p><p>我们可以看看查找转换器的代码<code>org.springframework.core.convert.support.GenericConversionService#getConverter</code>，可以对我们自己写代码有一些启发：</p><pre><code class="java">private final Map&lt;ConverterCacheKey, GenericConverter&gt; converterCache = new ConcurrentReferenceHashMap&lt;&gt;(64);protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {    ConverterCacheKey key = new ConverterCacheKey(sourceType, targetType);    GenericConverter converter = this.converterCache.get(key);    if (converter != null) {        return (converter != NO_MATCH ? converter : null);    }    converter = this.converters.find(sourceType, targetType);    if (converter == null) {        converter = getDefaultConverter(sourceType, targetType);    }    if (converter != null) {        this.converterCache.put(key, converter);        return converter;    }    this.converterCache.put(key, NO_MATCH);    return null;}</code></pre><p>转换为伪代码就是：</p><ol><li>根据参数类型和目标类型，构造缓存 key</li><li>根据缓存 key，从缓存中查询转换器</li><li>如果能找到且不是 NO_MATCH，返回转换器；如果是 NO_MATCH，返回 null；如果未找到，继续</li><li>通过<code>org.springframework.core.convert.support.GenericConversionService.Converters#find</code>查询转换器</li><li>如果未找到，检查源类型和目标类型是否可以强转，也就是类型一致。如果是，返回 NoOpConverter，如果否，返回 null。</li><li>检查找到的转换器是否为 null，如果不是，将转换器加入到缓存中，返回该转换器</li><li>如果否，在缓存中添加 NO_MATCH 标识，返回 null</li></ol><p><img src="http://static.howardliu.cn/spring/spring-find-converter.jpg" alt="查找转换器"></p><p>Spring 内部使用<code>Map</code>作为缓存，用来存储通用转换器接口<code>GenericConverter</code>，这个接口会是我们自定义转换器的包装类。我们还可以看到，转换器缓存用的是<code>ConcurrentReferenceHashMap</code>，这个类是线程安全的，可以保证并发情况下，不会出现异常存储。但是<code>getConverter</code>方法没有使用同步逻辑。换句话说，并发请求时，可能存在性能损耗。不过，对于 web 请求场景，并发损耗好过阻塞等待。</p><p>我们在看下 Spring 是如何查找转换器的，在<code>org.springframework.core.convert.support.GenericConversionService.Converters#find</code>中就是找到对应转换器的核心逻辑：</p><pre><code class="java">private final Map&lt;ConvertiblePair, ConvertersForPair&gt; converters = new ConcurrentHashMap&lt;&gt;(256);@Nullablepublic GenericConverter find(TypeDescriptor sourceType, TypeDescriptor targetType) {    // Search the full type hierarchy    List&lt;Class&lt;?&gt;&gt; sourceCandidates = getClassHierarchy(sourceType.getType());    List&lt;Class&lt;?&gt;&gt; targetCandidates = getClassHierarchy(targetType.getType());    for (Class&lt;?&gt; sourceCandidate : sourceCandidates) {        for (Class&lt;?&gt; targetCandidate : targetCandidates) {            ConvertiblePair convertiblePair = new ConvertiblePair(sourceCandidate, targetCandidate);            GenericConverter converter = getRegisteredConverter(sourceType, targetType, convertiblePair);            if (converter != null) {                return converter;            }        }    }    return null;}@Nullableprivate GenericConverter getRegisteredConverter(TypeDescriptor sourceType,        TypeDescriptor targetType, ConvertiblePair convertiblePair) {    // Check specifically registered converters    ConvertersForPair convertersForPair = this.converters.get(convertiblePair);    if (convertersForPair != null) {        GenericConverter converter = convertersForPair.getConverter(sourceType, targetType);        if (converter != null) {            return converter;        }    }    // Check ConditionalConverters for a dynamic match    for (GenericConverter globalConverter : this.globalConverters) {        if (((ConditionalConverter) globalConverter).matches(sourceType, targetType)) {            return globalConverter;        }    }    return null;}</code></pre><p>我们可以看到，Spring 是通过源类型和目标类型组合起来，查找对应的转换器。而且，Spring 还通过<code>getClassHierarchy</code>方法，将源类型和目标类型的家族族谱全部列出来，用双层 for 循环遍历查找。</p><p>上面的代码中，还有一个<code>matches</code>方法，在这个方法里面，调用了<code>ConverterFactory#getConverter</code>方法，也就是用这个工厂方法，创建了指定类型的转换器。</p><pre><code class="java">private final ConverterFactory&lt;Object, Object&gt; converterFactory;public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {    boolean matches = true;    if (this.converterFactory instanceof ConditionalConverter) {        matches = ((ConditionalConverter) this.converterFactory).matches(sourceType, targetType);    }    if (matches) {        Converter&lt;?, ?&gt; converter = this.converterFactory.getConverter(targetType.getType());        if (converter instanceof ConditionalConverter) {            matches = ((ConditionalConverter) converter).matches(sourceType, targetType);        }    }    return matches;}</code></pre><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>经过上面的逻辑，已经找到判断可以进行转换。其核心逻辑就是已经找到对应的转换器了，下面就是转换逻辑，在<code>org.springframework.core.convert.support.GenericConversionService#convert</code>中：</p><pre><code class="java">public Object convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {    Assert.notNull(targetType, &quot;Target type to convert to cannot be null&quot;);    if (sourceType == null) {        Assert.isTrue(source == null, &quot;Source must be [null] if source type == [null]&quot;);        return handleResult(null, targetType, convertNullSource(null, targetType));    }    if (source != null &amp;&amp; !sourceType.getObjectType().isInstance(source)) {        throw new IllegalArgumentException(&quot;Source to convert from must be an instance of [&quot; +                sourceType + &quot;]; instead it was a [&quot; + source.getClass().getName() + &quot;]&quot;);    }    GenericConverter converter = getConverter(sourceType, targetType);    if (converter != null) {        Object result = ConversionUtils.invokeConverter(converter, source, sourceType, targetType);        return handleResult(sourceType, targetType, result);    }    return handleConverterNotFound(source, sourceType, targetType);}</code></pre><p>其中的<code>GenericConverter converter = getConverter(sourceType, targetType)</code>就是前文中<code>getConverter</code>方法。此处还是可以给我们编码上的一些借鉴的：<code>getConverter</code>方法在<code>canConvert</code>中调用了一次，然后在后续真正转换的时候又调用一次，这是参数转换逻辑，我们该怎么优化这种同一请求内多次调用相同逻辑或者请求相同参数呢？那就是使用缓存。为了保持一次请求中前后两次数据的一致性和请求的高效，推荐使用内存缓存。</p><p>执行到这里，直接调用<code>ConversionUtils.invokeConverter(converter, source, sourceType, targetType)</code>转换，其内部是使用<code>org.springframework.core.convert.support.GenericConversionService.ConverterFactoryAdapter#convert</code>方法，代码如下：</p><pre><code class="java">public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {    if (source == null) {        return convertNullSource(sourceType, targetType);    }    return this.converterFactory.getConverter(targetType.getObjectType()).convert(source);}</code></pre><p>这里就是调用<code>ConverterFactory</code>工厂类构建转换器（即<code>IdCodeToEnumConverterFactory</code>类的<code>getConverter</code>方法），然后调用转换器的<code>conver</code>方法（即<code>IdCodeToEnumConverter</code>类的<code>convert</code>方法），将输入参数转换为目标类型。具体实现可以看一下实战篇中的代码，这里不做赘述。</p><p>至此，我们把整个路程通了下来。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>在本文中，我们跟随源码找到自定义转换器工厂类和转换器类的实现逻辑。这里需要强调一下的是，由于实战篇中我们用到的例子是简单参数的方式，也就是<code>Controller</code>的方法参数都是直接参数，没有包装成对象。这样的话，Spring 是通过<code>RequestParamMethodArgumentResolver</code>处理参数。如果是包装成对象，会使用<code>ModelAttributeMethodProcessor</code>处理参数。这两个处理类中查找类型转换器逻辑都是相同的。</p><p>无论是<code>GET</code>请求，还是传参式的<code>POST</code>请求（即<code>Form</code>模式），都可以使用上面这种方式，实现枚举参数的类型转换。但是是 HTTP Body 方式却不行，为什么呢？</p><p>Spring 对于 body 参数是通过<code>RequestResponseBodyMethodProcessor</code>处理的，其内部使用了<code>MappingJackson2HttpMessageConverter</code>转换器，逻辑完全不同。所以，想要实现 body 的类型转换，还需要走另外一种方式。将在下一篇中给出。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response/">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response-exception/">SpringBoot 实战：如何优雅的处理异常</a></li><li><a href="https://www.howardliu.cn/spring-beanpostprocessor/">SpringBoot 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://www.howardliu.cn/spring-request-recorder/">SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li><li><a href="https://www.howardliu.cn/spring-enum-params/">SpringBoot 实战：优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-enum-params-principle/">SpringBoot 实战：优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody-principle/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-junit5-mockmvc-mockito/">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a></li><li><a href="https://www.howardliu.cn/spring-classpath-file-access/">SpringBoot 实战：加载和读取资源文件内容</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/springboot-enum-params-principle/">SpringBoot 实战：优雅的使用枚举参数（原理篇）</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/119725983" target="_blank" rel="noopener">SpringBoot 实战：优雅的使用枚举参数（原理篇）</a></p><center><b>👇🏻欢迎关注个人公众号，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      SpringBoot 实战：优雅的使用枚举参数中聊了怎么优雅的使用枚举参数，本文就来扒一扒 Spring 是如何找到对应转换器 Converter 的。
    
    </summary>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/categories/spring/"/>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/tags/spring/"/>
    
      <category term="enum" scheme="https://www.howardliu.cn/tags/enum/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实战：优雅的使用枚举参数</title>
    <link href="https://www.howardliu.cn/spring-enum-params/"/>
    <id>https://www.howardliu.cn/spring-enum-params/</id>
    <published>2021-08-10T14:40:04.000Z</published>
    <updated>2021-08-10T14:40:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/scarlet-lily-beetle-6389888_1920.jpg" alt="SpringBoot 实战：优雅的使用枚举参数"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/sinousxl-7554155/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6389888" target="_blank" rel="noopener">Sinousxl</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6389888" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>接口开发过程中不免有表示类型的参数，比如 0 表示未知，1 表示男，2 表示女。通常有两种做法，一种是用数字表示，另一种是使用枚举实现。</p><a id="more"></a><p>使用数字表示就是通过契约形式，约定每个数字表示的含义，接口接收到参数，就按照约定对类型进行判断，接口维护成本比较大。</p><p>在 Spring 体系中，使用枚举表示，是借助 Spring 的 Converter 机制，可以将数字或字符串对应到枚举的序号或者 name，然后将前端的输入转换为枚举类型。</p><p>在场景不复杂的场景中，枚举可以轻松胜任。</p><p>于是，迅速实现逻辑，准备提测。这个时候需求变了，不允许选择未知性别，只能选男或女，就没有 0 值。这样，因为取值是从 1 开始，而枚举的序号是从 0 开始，就会产生冲突。</p><p>还有一些不太多的场景，就是前端不期望类型都是用数字，可能期望用一些有意义的字符串表示。但是按照前端规范，需要用小写或者驼峰命名。但是后端的规范中，枚举必须是大写，又是冲突。</p><p>需求合不合理暂且不论，我们要保存对技术的探索精神。</p><h2 id="确认需求"><a href="#确认需求" class="headerlink" title="确认需求"></a>确认需求</h2><p>首先确认需求。我们期望定义一个枚举类作为参数，接口访问的时候，可以是 int 类型的 id，id 取值不限于枚举的序号；也可以是 String 类型的 code，code 取值不限于枚举的 name。换句话说，这个枚举有个 id 和 code，随意定义，只要接口传过来匹配上，就能够自动转成枚举类型。</p><p>既然这样，我们就规范下 id 和 code 取值。为了扩展，定义三个接口：IdBaseEnum、CodeBaseEnum 以及 IdCodeBaseEnum。</p><pre><code class="java">public interface IdBaseEnum {    Integer getId();}public interface CodeBaseEnum {    String getCode();}public interface IdCodeBaseEnum extends IdBaseEnum, CodeBaseEnum {}</code></pre><p>接下来就该定义我们的主角了。</p><h2 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h2><p>前面定义了三个接口，分别是单独 id、单独 code，和有 id 和 code 的。这样，我们就可以定义三种枚举，分别对应三个接口。三种方式类似，所以就不在文中重复列举了。感兴趣的可以关注公众号「看山的小屋」回复 spring 获取源码。</p><p>我们定义一个性别枚举，枚举包含 id 和 code 两个属性。</p><pre><code class="java">public enum GenderIdCodeEnum implements IdCodeBaseEnum {    MALE(1, &quot;male&quot;),    FEMALE(2, &quot;female&quot;);    private final Integer id;    private final String code;    GenderIdCodeEnum(Integer id, String code) {        this.id = id;        this.code = code;    }    @Override    public String getCode() {        return code;    }    @Override    public Integer getId() {        return id;    }}</code></pre><p>这里需要注意一点，id 和 code 不能重复。</p><ol><li>id 与 id、code 与 code 不能重复，比如 MAIL 定义 id 是 1，FAMLE 就不能定义 id 是 1 了。</li><li>id 与 code 之间也不能重复，比如，MALE 定义 id 是 1001，FEMALE 定义 code 是 1001。</li></ol><p>这是由于 Spring 在转换参数的时候，将输入参数全部视为 String 类型。虽然我们定义 id 和 code 类型不同，但是在匹配的时候，都是按照字符串匹配的。如果存在相同值，就会产生歧义。</p><h2 id="Converter-和-ConverterFactory"><a href="#Converter-和-ConverterFactory" class="headerlink" title="Converter 和 ConverterFactory"></a>Converter 和 ConverterFactory</h2><p>根据规范，接下来定义一下 Converter 和 ConverterFactory。这些是 Spring 留给我们的扩展口，按照规范定义即可。</p><p>Converter 类：</p><pre><code class="java">public class IdCodeToEnumConverter&lt;T extends IdCodeBaseEnum&gt; implements Converter&lt;String, T&gt; {    private final Map&lt;String, T&gt; idEnumMap = Maps.newHashMap();    private final Map&lt;String, T&gt; codeEnumMap = Maps.newHashMap();    public IdCodeToEnumConverter(Class&lt;T&gt; enumType) {        Arrays.stream(enumType.getEnumConstants())                .forEach(x -&gt; {                    idEnumMap.put(x.getId().toString(), x);                    codeEnumMap.put(x.getCode(), x);                });    }    @Override    public T convert(String source) {        return Optional.of(source)                .map(codeEnumMap::get)                .orElseGet(() -&gt; Optional.of(source)                        .map(idEnumMap::get)                        .orElseThrow(() -&gt; new CodeBaseException(ErrorResponseEnum.PARAMS_ENUM_NOT_MATCH)));    }}</code></pre><p>ConverterFactory 类：</p><pre><code class="java">public class IdCodeToEnumConverterFactory implements ConverterFactory&lt;String, IdCodeBaseEnum&gt; {    @SuppressWarnings(&quot;rawtypes&quot;)    private static final Map&lt;Class, Converter&gt; CONVERTERS = Maps.newHashMap();    @Override    public &lt;T extends IdCodeBaseEnum&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) {        //noinspection unchecked        Converter&lt;String, T&gt; converter = CONVERTERS.get(targetType);        if (converter == null) {            converter = new IdCodeToEnumConverter&lt;&gt;(targetType);            CONVERTERS.put(targetType, converter);        }        return converter;    }}</code></pre><p>这两个就是转换的核心了，我们只要将他们装配到 Spring 的类型转换器中，就能够实现枚举类型的自动转化了。</p><h2 id="加载配置"><a href="#加载配置" class="headerlink" title="加载配置"></a>加载配置</h2><p>将我们定义的 Converter 和 ConverterFactory 注册到 Spring 的类型转换器中。</p><pre><code class="java">@Configurationpublic class WebConfig implements WebMvcConfigurer {    @Override    public void addFormatters(FormatterRegistry registry) {        registry.addConverterFactory(new IdCodeToEnumConverterFactory());        registry.addConverterFactory(new CodeToEnumConverterFactory());        registry.addConverterFactory(new IdToEnumConverterFactory());    }}</code></pre><p>至此，核心定义全部结束。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>写一个 Controller 作为测试入口：</p><pre><code class="java">@RestController@RequestMapping(&quot;echo&quot;)public class EchoController {    @GetMapping(&quot;gender-id-code&quot;)    public String genderIdCode(@RequestParam(&quot;gender&quot;) GenderIdCodeEnum gender) {        return gender.name();    }}</code></pre><p>准备测试用例测试：</p><pre><code class="java">@SpringBootTest(classes = SpringEnumParamApplication.class)@AutoConfigureMockMvcclass EchoControllerTest {    @Autowired    private MockMvc mockMvc;    @ParameterizedTest    @ValueSource(strings = {&quot;MALE&quot;, &quot;male&quot;, &quot;1&quot;})    void genderIdCode(String gender) throws Exception {        final String result = mockMvc.perform(                MockMvcRequestBuilders.get(&quot;/echo/gender-id-code&quot;)                        .param(&quot;gender&quot;, gender)        )                .andExpect(MockMvcResultMatchers.status().isOk())                .andDo(MockMvcResultHandlers.print())                .andReturn()                .getResponse()                .getContentAsString();        Assertions.assertEquals(&quot;MALE&quot;, result);    }}</code></pre><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>实现枚举参数并不难，只要按照 Spring 的扩展规范实现即可。需要注意的是，注意枚举类中唯一的 id 和 code。</p><p>本文是应用，下篇说一下原理。以及 http body 形式请求的枚举转换逻辑。</p><p>关注公众号「看山的小屋」回复 spring 获取源码。源码中完整定义了三种枚举形式。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response/">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response-exception/">SpringBoot 实战：如何优雅的处理异常</a></li><li><a href="https://www.howardliu.cn/spring-beanpostprocessor/">SpringBoot 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://www.howardliu.cn/spring-request-recorder/">SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li><li><a href="https://www.howardliu.cn/spring-enum-params/">SpringBoot 实战：优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-enum-params-principle/">SpringBoot 实战：优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody-principle/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-junit5-mockmvc-mockito/">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a></li><li><a href="https://www.howardliu.cn/spring-classpath-file-access/">SpringBoot 实战：加载和读取资源文件内容</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/spring-enum-params/">SpringBoot 实战：优雅的使用枚举参数</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/119581202" target="_blank" rel="noopener">SpringBoot 实战：优雅的使用枚举参数</a></p><center><b>👇🏻欢迎关注个人公众号，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      接口开发过程中不免有表示类型的参数，比如 0 表示未知，1 表示男，2 表示女。通常有两种做法，一种是用数字表示，另一种是使用枚举实现。
    
    </summary>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/categories/spring/"/>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/tags/spring/"/>
    
      <category term="enum" scheme="https://www.howardliu.cn/tags/enum/"/>
    
  </entry>
  
  <entry>
    <title>看山聊 Java：检查日期字符串是否合法</title>
    <link href="https://www.howardliu.cn/java-date-string-valid-date/"/>
    <id>https://www.howardliu.cn/java-date-string-valid-date/</id>
    <published>2021-08-06T13:47:46.000Z</published>
    <updated>2021-08-06T13:47:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/berries-6514669_1920.jpg" alt="看山聊 Java：检查日期字符串是否合法"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/nastasyaday-11197808/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6514669" target="_blank" rel="noopener">Анастасия Белоусова</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6514669" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><a id="more"></a><p>这次说一下，怎样检查给出的字符串，是否是合法日期字符串。本文将从 Java 原生和第三方组件两种方式来说明。</p><h2 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h2><p>后端接口在接收数据的时候，都需要进行检查。检查全部通过后，才能够执行业务逻辑。对于时间格式，我们一般需要检查这么几方面：</p><ol><li>字符串格式是否正确，比如格式是不是<code>yyyy-MM-dd</code></li><li>时间在合法范围内，比如我们需要限定在一个月内的时间</li><li>字符串可以解析为正常的时间，比如 2 月 30 号就不是正常时间</li></ol><p>对于时间格式的判断，我们可以通过正则表达式来检查。不过考虑到正则表达式的性能、输入数据的复杂性，一般能用别的方式，就不选正则表达式。我们还是选择一种更加通用、更加高效的检查方式。</p><p>首先，定义时间校验器的接口：</p><pre><code class="java">public interface DateValidator {    boolean isValid(String dateStr);}</code></pre><p>接口方法接收一个字符串，返回布尔类型，表示字符串是否是合法的时间格式。</p><h2 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h2><p>接下来就是通过不同方式实现<code>DateValidator</code>。</p><h3 id="使用-DateFormat-检查"><a href="#使用-DateFormat-检查" class="headerlink" title="使用 DateFormat 检查"></a>使用 DateFormat 检查</h3><p>Java 提供了格式化和解析时间的工具：<code>DateFormat</code>抽象类和<code>SimpleDataFormat</code>实现类。我们借此实现时间校验器：</p><pre><code class="java">public class DateValidatorUsingDateFormat implements DateValidator {    private final String dateFormat;    public DateValidatorUsingDateFormat(String dateFormat) {        this.dateFormat = dateFormat;    }    @Override    public boolean isValid(String dateStr) {        final DateFormat sdf = new SimpleDateFormat(this.dateFormat);        sdf.setLenient(false);        try {            sdf.parse(dateStr);        } catch (ParseException e) {            return false;        }        return true;    }}</code></pre><p>这里需要注意一下，<code>DateFormat</code>和<code>SimpleDataFormat</code>是非线程安全的，所以每次方法调用时，都需要新建实例。</p><p>我们通过单元测试验证下：</p><pre><code class="java">class DateValidatorUsingDateFormatTest {    @Test    void isValid() {        final DateValidator validator = new DateValidatorUsingDateFormat(&quot;yyyy-MM-dd&quot;);        Assertions.assertTrue(validator.isValid(&quot;2021-02-28&quot;));        Assertions.assertFalse(validator.isValid(&quot;2021-02-30&quot;));    }}</code></pre><p>在 Java8 之前，一般都是用这种方式来验证。Java8 之后，我们有了更多的选择。</p><h3 id="使用-LocalDate-检查"><a href="#使用-LocalDate-检查" class="headerlink" title="使用 LocalDate 检查"></a>使用 LocalDate 检查</h3><p>Java8 引入了更加好用日期和时间 API（想要了解更多内容，请移步参看 <a href="https://www.howardliu.cn/java-date-and-time-intro/">Java8 中的时间类及常用 API</a>）。其中包括<code>LocalDate</code>类，是一个不可变且线程安全的时间类。</p><p><code>LocalDate</code>提供了两个静态方法，用来解析时间。这两个方法内部都是使用<code>java.time.format.DateTimeFormatter</code>来处理数据：</p><pre><code class="java">// 使用 DateTimeFormatter.ISO_LOCAL_DATE 处理数据public static LocalDate parse(CharSequence text) {    return parse(text, DateTimeFormatter.ISO_LOCAL_DATE);}// 使用提供的 DateTimeFormatter 处理数据public static LocalDate parse(CharSequence text, DateTimeFormatter formatter) {        Objects.requireNonNull(formatter, &quot;formatter&quot;);    return formatter.parse(text, LocalDate::from);}</code></pre><p>通过<code>LocalDate</code>的<code>parse</code>方法实现我们的校验器：</p><pre><code class="java">public class DateValidatorUsingLocalDate implements DateValidator {    private final DateTimeFormatter dateFormatter;    public DateValidatorUsingLocalDate(DateTimeFormatter dateFormatter) {        this.dateFormatter = dateFormatter;    }    @Override    public boolean isValid(String dateStr) {        try {            LocalDate.parse(dateStr, this.dateFormatter);        } catch (DateTimeParseException e) {            return false;        }        return true;    }}</code></pre><p><code>java.time.format.DateTimeFormatter</code>类是不可变的，也就是天然的线程安全，我们可以在不同线程使用同一个校验器实例。</p><p>我们通过单元测试验证下：</p><pre><code class="java">class DateValidatorUsingLocalDateTest {    @Test    void isValid() {        final DateTimeFormatter dateFormatter = DateTimeFormatter.ISO_LOCAL_DATE;        final DateValidator validator = new DateValidatorUsingLocalDate(dateFormatter);        Assertions.assertTrue(validator.isValid(&quot;2021-02-28&quot;));        Assertions.assertFalse(validator.isValid(&quot;2021-02-30&quot;));    }}</code></pre><p>既然<code>LocalDate#parse</code>是通过<code>DateTimeFormatter</code>实现的，那我们也可以直接使用<code>DateTimeFormatter</code>。</p><h3 id="使用-DateTimeFormatter-检查"><a href="#使用-DateTimeFormatter-检查" class="headerlink" title="使用 DateTimeFormatter 检查"></a>使用 DateTimeFormatter 检查</h3><p><code>DateTimeFormatter</code>解析文本总共分两步。第一步，根据配置将文本解析为日期和时间字段；第二步，用解析后的字段创建日期和时间对象。</p><p>实现验证器：</p><pre><code class="java">public class DateValidatorUsingDateTimeFormatter implements DateValidator {    private final DateTimeFormatter dateFormatter;    public DateValidatorUsingDateTimeFormatter(DateTimeFormatter dateFormatter) {        this.dateFormatter = dateFormatter;    }    @Override    public boolean isValid(String dateStr) {        try {            this.dateFormatter.parse(dateStr);        } catch (DateTimeParseException e) {            return false;        }        return true;    }}</code></pre><p>通过单元测试验证：</p><pre><code class="java">class DateValidatorUsingDateTimeFormatterTest {    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(&quot;uuuu-MM-dd&quot;, Locale.CHINA);    @Test    void isValid() {        final DateTimeFormatter dateFormatter = DATE_FORMATTER.withResolverStyle(ResolverStyle.STRICT);        final DateValidator validator = new DateValidatorUsingDateTimeFormatter(dateFormatter);        Assertions.assertTrue(validator.isValid(&quot;2021-02-28&quot;));        Assertions.assertFalse(validator.isValid(&quot;2021-02-30&quot;));    }}</code></pre><p>可以看到，我们指定了转换模式是<code>ResolverStyle.STRICT</code>，这个类型是说明解析模式。共有三种：</p><ul><li>STRICT：严格模式，日期、时间必须完全正确。</li><li>SMART：智能模式，针对日可以自动调整。月的范围在 1 到 12，日的范围在 1 到 31。比如输入是 2 月 30 号，当年 2 月只有 28 天，返回的日期就是 2 月 28 日。</li><li>LENIENT：宽松模式，主要针对月和日，会自动后延。结果类似于<code>LocalData#plusDays</code>或者<code>LocalDate#plusMonths</code>。</li></ul><p>我们通过例子看下区别：</p><pre><code class="java">class DateValidatorUsingDateTimeFormatterTest {    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(&quot;uuuu-MM-dd&quot;, Locale.CHINA);    @Test    void testResolverStyle() {        Assertions.assertEquals(LocalDate.of(2021, 2,28), parseDate(&quot;2021-02-28&quot;, ResolverStyle.STRICT));        Assertions.assertNull(parseDate(&quot;2021-02-29&quot;, ResolverStyle.STRICT));        Assertions.assertEquals(LocalDate.of(2021, 2,28), parseDate(&quot;2021-02-28&quot;, ResolverStyle.STRICT));        Assertions.assertNull(parseDate(&quot;2021-13-28&quot;, ResolverStyle.STRICT));        Assertions.assertEquals(LocalDate.of(2021, 2,28), parseDate(&quot;2021-02-28&quot;, ResolverStyle.SMART));        Assertions.assertEquals(LocalDate.of(2021, 2,28), parseDate(&quot;2021-02-29&quot;, ResolverStyle.SMART));        Assertions.assertNull(parseDate(&quot;2021-13-28&quot;, ResolverStyle.SMART));        Assertions.assertNull(parseDate(&quot;2021-13-29&quot;, ResolverStyle.SMART));        Assertions.assertEquals(LocalDate.of(2021, 2,28), parseDate(&quot;2021-02-28&quot;, ResolverStyle.LENIENT));        Assertions.assertEquals(LocalDate.of(2021, 3,1), parseDate(&quot;2021-02-29&quot;, ResolverStyle.LENIENT));        Assertions.assertEquals(LocalDate.of(2022, 1,28), parseDate(&quot;2021-13-28&quot;, ResolverStyle.LENIENT));        Assertions.assertEquals(LocalDate.of(2022, 2,2), parseDate(&quot;2021-13-33&quot;, ResolverStyle.LENIENT));    }    private static LocalDate parseDate(String dateString, ResolverStyle resolverStyle) {        try {            return LocalDate.parse(dateString, DATE_FORMATTER.withResolverStyle(resolverStyle));        } catch (DateTimeParseException e) {            return null;        }    }}</code></pre><p>从例子可以看出，<code>ResolverStyle.STRICT</code>是严格控制，用来做时间校验比较合适；<code>ResolverStyle.LENIENT</code>可以最大程度将字符串转化为时间对象，在合理范围内可以随便玩；<code>ResolverStyle.SMART</code>名为智能，但智力有限，两不沾边，优势不够明显。JDK 提供的<code>DateTimeFormatter</code>实现，都是<code>ResolverStyle.STRICT</code>模式。</p><p>说了 JDK 自带的实现，接下来说说第三方组件的实现方式。</p><h3 id="使用-Apache-出品的-commons-validator-检查"><a href="#使用-Apache-出品的-commons-validator-检查" class="headerlink" title="使用 Apache 出品的 commons-validator 检查"></a>使用 Apache 出品的 commons-validator 检查</h3><p>Apache Commons 项目提供了一个校验器框架，包含多种校验规则，包括日期、时间、数字、货币、IP 地址、邮箱、URL 地址等。本文主要说检查时间，所以重点看看<code>GenericValidator</code>类提供的<code>isDate</code>方法：</p><pre><code class="java">public class GenericValidator implements Serializable {    // 其他方法    public static boolean isDate(String value, Locale locale) {        return DateValidator.getInstance().isValid(value, locale);    }    public static boolean isDate(String value, String datePattern, boolean strict) {        return org.apache.commons.validator.DateValidator.getInstance().isValid(value, datePattern, strict);    }}</code></pre><p>先引入依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;commons-validator&lt;/groupId&gt;    &lt;artifactId&gt;commons-validator&lt;/artifactId&gt;    &lt;version&gt;1.7&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>实现验证器：</p><pre><code class="java">public class DateValidatorUsingCommonsValidator implements DateValidator {    private final String dateFormat;    public DateValidatorUsingCommonsValidator(String dateFormat) {        this.dateFormat = dateFormat;    }    @Override    public boolean isValid(String dateStr) {        return GenericValidator.isDate(dateStr, dateFormat, true);    }}</code></pre><p>通过单元测试验证：</p><pre><code class="java">class DateValidatorUsingCommonsValidatorTest {    @Test    void isValid() {        final DateValidator dateValidator = new DateValidatorUsingCommonsValidator(&quot;yyyy-MM-dd&quot;);        Assertions.assertTrue(dateValidator.isValid(&quot;2021-02-28&quot;));        Assertions.assertFalse(dateValidator.isValid(&quot;2021-02-30&quot;));    }}</code></pre><p>看<code>org.apache.commons.validator.DateValidator#isValid</code>源码可以发现，内部是通过<code>DateFormat</code>和<code>SimpleDateFormat</code>实现的。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>在本文中，我们通过四种方式实现了时间字符串校验逻辑。为了节省篇幅，文中代码只提供了核心内容。想要了解具体实现，可以关注公号「看山的小屋」，回复“date”获取源码。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol><li><a href="https://www.howardliu.cn/java-date-and-time-intro/">Java8 中的时间类及常用 API</a></li><li><a href="https://www.howardliu.cn/java-date-to-localdate-and-localdatetime/">Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://www.howardliu.cn/java-date-time-migrating-to-jsr310/">使用 Java8 中的时间类</a></li><li><a href="https://www.howardliu.cn/java-date-string-valid-date/">检查日期字符串是否合法</a></li></ol><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-date-string-valid-date/">看山聊 Java：检查日期字符串是否合法</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/119464230" target="_blank" rel="noopener">看山聊 Java：检查日期字符串是否合法</a></p><center><b>👇🏻欢迎关注个人公众号，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      这次说一下，怎样检查给出的字符串，是否是合法日期字符串。本文将从 Java 原生和第三方组件两种方式来说明。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="Date" scheme="https://www.howardliu.cn/tags/Date/"/>
    
      <category term="Time" scheme="https://www.howardliu.cn/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>《Go 开发指南》-管理 Go 环境</title>
    <link href="https://www.howardliu.cn/manage-install/"/>
    <id>https://www.howardliu.cn/manage-install/</id>
    <published>2021-07-24T09:38:39.000Z</published>
    <updated>2021-07-24T09:38:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/kitten-6479019_1920.jpg" alt="《Go 开发指南》-管理 Go 环境"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/krystianwin-8237000/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6479019" target="_blank" rel="noopener">krystianwin</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6479019" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><blockquote><p>本文源自并发编程网的翻译邀请，文章来自 Go 官方网站。</p></blockquote><a id="more"></a><p>本文主要讲述了如何在同一台机器上安装多个版本 Go 环境，再描述一下如何卸载 Go 环境。</p><p>如果想要查看如何快速安装 Go 环境，可以访问：<a href="https://www.howardliu.cn/install-go/">快速安装 Go 环境</a>。</p><p>如果想要通过源码安装，可以访问：<a href="https://golang.google.cn/doc/install/source" target="_blank" rel="noopener">从源码安装 Go 环境</a>。</p><h2 id="如何安装多版本"><a href="#如何安装多版本" class="headerlink" title="如何安装多版本"></a>如何安装多版本</h2><p>有时候，我们希望用不同版本测试我们的代码，这就需要我们在一台机器上安装多个版本。有关版本列表，可以访问<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a>。</p><blockquote><p>注意：通过这种方式，需要提前装好<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a>。</p></blockquote><p>要安装其他版本，需要运行<code>go get</code>命令，指定下载位置。下面给出下载安装<code>1.10.7</code>版本的命令：</p><pre><code class="shell">go get golang.org/dl/go1.10.7go1.10.7 download</code></pre><p>使用最新下载的版本运行 go 命令，需要在 go 命令后附上版本号，比如：</p><pre><code class="shell">go1.10.7 version</code></pre><p>如果安装了多个版本，想要查看每个版本安装位置，可以查看指定版本的<code>GOROOT</code>值。比如：</p><pre><code class="shell">go1.10.7 env GOROOT</code></pre><p>如果想要卸载已下载版本，只需要移除<code>GOROOT</code>环境变量指定的目录和<code>goX.Y.Z</code>文件夹就行。</p><h2 id="如何卸载"><a href="#如何卸载" class="headerlink" title="如何卸载"></a>如何卸载</h2><p>本节说一下如何从你的系统中卸载 Go 环境。</p><h3 id="Linux-macOS-FreeBSD"><a href="#Linux-macOS-FreeBSD" class="headerlink" title="Linux / macOS / FreeBSD"></a>Linux / macOS / FreeBSD</h3><ol><li>删除 Go 目录，通常是<code>/usr/local/go</code>。</li><li>从<code>PATH</code>环境变量中移除 Go 的<code>bin</code>目录。在 Linux 和 FreeBSD 系统中，可以编辑<code>/etc/profile</code>或者<code>$HOME/.profile</code>修改<code>PATH</code>变量。如果是在 Mac 系统中，通过安装包安装的 Go 环境，需要删除<code>/etc/paths.d/go</code>文件。</li></ol><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在 Windows 系统中，最简单的方式是通过控制面板的“添加/删除程序”：</p><ol><li>在控制面板中，打开“添加/删除程序”</li><li>选择 Go 环境的卸载按钮，跟随步骤执行就行。</li></ol><p>要删除 Go 环境，还可以通过命令行的方式：</p><pre><code class="cmd">msiexec /x go{{version}}.windows-{{cpu-arch}}.msi /q</code></pre><blockquote><p>注：使用卸载程序卸载 Go，会自动删除创建时添加的环境变量。</p></blockquote><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/install-go/">《Go 开发指南》-快速安装 Go 环境</a></li><li><a href="https://www.howardliu.cn/manage-install/">《Go 开发指南》-管理 Go 环境</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>原文链接：<a href="https://golang.google.cn/doc/manage-install" target="_blank" rel="noopener">Managing Go installations</a><br>翻译：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>译文链接：<a href="https://www.howardliu.cn/manage-install/">《Go 开发指南》-管理 Go 环境</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/119061750" target="_blank" rel="noopener">《Go 开发指南》-管理 Go 环境</a></p><center><b>👇🏻欢迎关注个人公众号，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      如何在同一台机器上安装多个版本 Go 环境，再描述一下如何卸载 Go 环境。
    
    </summary>
    
    
      <category term="go" scheme="https://www.howardliu.cn/categories/go/"/>
    
    
      <category term="go" scheme="https://www.howardliu.cn/tags/go/"/>
    
      <category term="开发指南" scheme="https://www.howardliu.cn/tags/%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>《Go 开发指南》-快速安装 Go 环境</title>
    <link href="https://www.howardliu.cn/install-go/"/>
    <id>https://www.howardliu.cn/install-go/</id>
    <published>2021-07-24T09:21:23.000Z</published>
    <updated>2021-07-24T09:21:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/travel-6470467_1920.jpg" alt="《Go 开发指南》-快速安装 Go 环境"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/jpdvg-11163235/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6470467" target="_blank" rel="noopener">JPierre Desvigne</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6470467" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><blockquote><p>本文源自并发编程网的翻译邀请，文章来自 Go 官方网站。</p></blockquote><a id="more"></a><p>按照下面的步骤，你可以实现快速安装。</p><p>如果想要通过源码安装，可以访问：<a href="https://golang.google.cn/doc/install/source" target="_blank" rel="noopener">从源码安装 Go 环境</a>。</p><p>如果想要安装多个版本的 Go 或者卸载，可以访问：<a href="https://www.howardliu.cn/manage-install/">管理 Go 环境</a>。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>下面提供了 Linux、Mac、Windows 三种系统 Go 语言安装包的下载路径：</p><ul><li>Linux：<a href="https://golang.org/dl/go1.16.5.linux-amd64.tar.gz" target="_blank" rel="noopener">https://golang.org/dl/go1.16.5.linux-amd64.tar.gz</a></li><li>Mac：<a href="https://golang.org/dl/go1.16.5.darwin-amd64.pkg" target="_blank" rel="noopener">https://golang.org/dl/go1.16.5.darwin-amd64.pkg</a></li><li>Windows：<a href="https://golang.org/dl/go1.16.5.windows-amd64.msi" target="_blank" rel="noopener">https://golang.org/dl/go1.16.5.windows-amd64.msi</a></li></ul><p>如果想要获取其他操作系统或者其他版本的，可以访问<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a>。</p><p>默认情况下，go 命令默认下载和验证模块时，使用的是 Google 提供的模块镜像服务和 checksum 验证。我们可以从<a href="https://golang.org/cmd/go/" target="_blank" rel="noopener">https://golang.org/cmd/go/</a>获取全面的 go 命令和配置。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ol><li><p>将下载的压缩包解压到<code>/usr/local</code>目录中，可以执行下面这条命令（需要切换到 root 用户或者使用 sudo）：</p><pre><code class="bash"> rm -rf /usr/local/go tar -C /usr/local -xzf go1.16.5.linux-amd64.tar.gz</code></pre><blockquote><p>注意：提供的这条命令会删除之前安装的 go 环境，在执行之前最好做下备份。</p></blockquote></li><li><p>将<code>/usr/local/go/bin</code>添加到<code>PATH</code>环境变量中，可以在<code>$HOME/.profile</code>或者<code>/etc/profile</code>中添加下面这条命令：</p><pre><code class="bash"> export PATH=$PATH:/usr/local/go/bin</code></pre><blockquote><p>注意：对配置文件的修改，需要等到下次登录计算机的时候才会生效。如果想要立即生效，可以直接运行 shell 命令，或者使用命令<code>source $HOME/.profile</code>重新执行一下配置内容。</p></blockquote></li><li><p>打开终端，输入下面的命令，验证下是否按照成功：</p><pre><code class="bash"> go version</code></pre></li><li><p>确认一下打印的版本号，与下载的版本号是否一致。如果一致，说明按照成功，如果说命令找不到或者版本不一致，那就是安装有问题。【译者注：如果条件允许，最好重启系统，然后在验证一次，避免环境变量配置错误。】</p></li></ol><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><ol><li><p>双击打开下载的安装包，按照提示安装。<br>这个安装包会直接将 Go 安装在<code>/usr/local/go</code>目录中，并将<code>/usr/local/go/bin</code>添加到<code>PATH</code>环境变量中。可能需要重启终端才能使环境变量生效。</p></li><li><p>打开终端，输入下面的命令，验证下是否按照成功：</p><pre><code class="bash"> go version</code></pre></li><li><p>确认一下打印的版本号</p></li></ol><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ol><li><p>双击打开下载的安装包，按照提示安装。<br>默认情况下，会安装在<code>Program Files</code>或者<code>Program Files (x86)</code>目录中，也可以根据自己的习惯修改。安装完成后，需要重启终端使环境变量生效。</p></li><li><p>验证安装是否成功</p><ol><li><p>在 Windows 系统中，打开菜单</p></li><li><p>搜索框中键入<code>cmd</code>然后回车，打开终端</p></li><li><p>在终端中，输入下面命令</p><pre><code class="bash"> go version</code></pre></li><li><p>确认一下打印的版本号</p></li></ol></li></ol><h2 id="开始-coding"><a href="#开始-coding" class="headerlink" title="开始 coding"></a>开始 coding</h2><p>经过上面步骤，你已经成功安装了 Go 环境，访问 <a href="https://golang.google.cn/doc/tutorial/getting-started.html" target="_blank" rel="noopener">Getting Started tutorial</a> 开始 Coding 之旅吧。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/install-go/">《Go 开发指南》-快速安装 Go 环境</a></li><li><a href="https://www.howardliu.cn/manage-install/">《Go 开发指南》-管理 Go 环境</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>原文链接：<a href="https://golang.google.cn/doc/install" target="_blank" rel="noopener">Download and install</a><br>翻译：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>译文链接：<a href="https://www.howardliu.cn/install-go/">《Go 开发指南》-快速安装 Go 环境</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/119061721" target="_blank" rel="noopener">《Go 开发指南》-快速安装 Go 环境</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      快速安装 Go 环境
    
    </summary>
    
    
      <category term="go" scheme="https://www.howardliu.cn/categories/go/"/>
    
    
      <category term="go" scheme="https://www.howardliu.cn/tags/go/"/>
    
      <category term="开发指南" scheme="https://www.howardliu.cn/tags/%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>好书不是通过价格可以衡量的，比如这本</title>
    <link href="https://www.howardliu.cn/about-the-fenix-project/"/>
    <id>https://www.howardliu.cn/about-the-fenix-project/</id>
    <published>2021-07-12T16:10:51.000Z</published>
    <updated>2021-07-12T16:10:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/bee-6354562_1920.jpg" alt="好书不是通过价格可以衡量的，比如这本"></p><p>你好，我是看山。</p><p>笔者主修Java，所以在<a href="https://www.howardliu.cn/lists-book-recommendations-2021/">《程序员进阶书单2021版》</a>主要推荐了一些Java工程师进阶必读书单。推荐原则是豆瓣的评分，结果，遗漏了一本开源书籍，甚是遗憾，今天补上。</p><a id="more"></a><p>推荐的书籍名为《凤凰架构》，开源地址是<a href="https://icyfenix.cn/" target="_blank" rel="noopener">https://icyfenix.cn/</a>。</p><p>看到凤凰，我们会想到凤凰涅槃、涅槃重生之类的词语。在作者看来，我们的系统不是一成不变的，只要在软件生命周期内，总会因为某些原因出现问题，或者是设计上的，或者是工程师代码问题，甚至最简单的网络问题。就像是凤凰浴火，经历考验，然后重生一般。</p><p>本书探讨的主题就是，如何构建一个可靠的分布式系统。这套方法论，可以让多人协作开发的系统，让一个大型的、分布式的系统，可靠的运行。这不是依赖团队成员个人能力，或者是研发质量管理就能够实现的，这是一个系统性的、架构层面的问题。想要实现这个目标，最终要依赖技术和架构。</p><p>全书主要分为5部分：</p><ul><li>演进中的架构：从历史演进过程，以全局视角，梳理微服务发展过程中出现的大量技术名词、概念。可以让我们了解技术的时代背景和探索过程。这里不得不推荐另外一本书《大型网站技术架构》，大家有时间可以看看。</li><li>架构师的视角：这一部分不是局限在某种架构的通用技巧，而是系统性地讲解做架构设计的时候，架构师都应该思考哪些问题、可以选择哪些主流的解决方案和行业标准做法，以及这些主流方案都有什么优缺点、会给架构设计带来什么影响，等等。这样一来，我们才可以把“架构设计”这样比较抽象的工作具体化、具象化。</li><li>分布式的基石：这一部分聚焦在分布式架构，探讨分布式带来的问题与应对策略。剖析分布式架构中出现的一系列问题，比如服务的注册发现、跟踪治理、负载均衡、故障隔离、认证授权、伸缩扩展、传输通讯、事务处理等，有哪些解决思路、方法和常见工具。</li><li>不可变基础设施：这一部分按照云原生时代“基础设施即代码”的新思路，深入理解基础设施不变性的目的、原理与实现途径，体会用代码和用基础设施，来解决分布式问题的差异，让我们更轻松的理解不可变基础设施的内涵，便于在实际工作中做运维、程序升级和部署等工作。</li><li>技术方法论：这一部分属于归纳总结的部分，前面都是从实践出发，让我们更加清楚如何是设计一个不断升级的系统。这一章讲述一些方法论，在我们有一定实践的基础上，构建可靠的理论体系，理论与实现相结合，相互螺旋上升。</li></ul><p>前面说了这么多，该介绍一下作者了，就是大名鼎鼎的周志明，<a href="https://book.douban.com/subject/34907497/" target="_blank" rel="noopener">《深入理解Java虚拟机》</a>作者。相信Java栈的开发者，即使没有读过这本书，也听过其名。就是这本书让笔者有爱有恨，爱的是提升了笔者对JVM的认识，恨的是提升了大家对JVM的认识。</p><p>再次附上开源地址<a href="https://icyfenix.cn/" target="_blank" rel="noopener">https://icyfenix.cn/</a>。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/lists-book-recommendations-2021/">程序员进阶书单2021版</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/about-the-fenix-project/">好书不是通过价格可以衡量的，比如这本</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/103794938" target="_blank" rel="noopener">好书不是通过价格可以衡量的，比如这本</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://static.howardliu.cn/cover/bee-6354562_1920.jpg&quot; alt=&quot;好书不是通过价格可以衡量的，比如这本&quot;&gt;&lt;/p&gt;
&lt;p&gt;你好，我是看山。&lt;/p&gt;
&lt;p&gt;笔者主修Java，所以在&lt;a href=&quot;https://www.howardliu.cn/lists-book-recommendations-2021/&quot;&gt;《程序员进阶书单2021版》&lt;/a&gt;主要推荐了一些Java工程师进阶必读书单。推荐原则是豆瓣的评分，结果，遗漏了一本开源书籍，甚是遗憾，今天补上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="书单" scheme="https://www.howardliu.cn/tags/%E4%B9%A6%E5%8D%95/"/>
    
      <category term="技术成长" scheme="https://www.howardliu.cn/tags/%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>想躺平不是错</title>
    <link href="https://www.howardliu.cn/relax-and-run/"/>
    <id>https://www.howardliu.cn/relax-and-run/</id>
    <published>2021-07-09T00:16:44.000Z</published>
    <updated>2021-07-09T00:16:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/caterpillar-6387049_1920.jpg" alt="想躺平不是错"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/jggrz-7998824/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6387049" target="_blank" rel="noopener">jggrz</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6387049" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>今天聊聊这段时间比较火的一个网络词：躺平。据说这个词还被某些网站屏蔽了，不知道这篇文章会不会也被屏蔽掉。</p><a id="more"></a><p>维基百科为<code>躺平</code>下了一个比较完善的定义：</p><blockquote><p>躺平或躺平主义是 2021 年开始在中华人民共和国流行的网络词语。指这一时期的年轻人在国内经济下滑、社会问题激化的大背景下，出于对现实环境的失望而做出的“与其跟随社会期望坚持奋斗，不如选择‘躺平’，无欲无求”的处事态度。被视为是对抗社会“内卷化”的一种方式。其具体内涵包括“不买房、不买车、不结婚、不生娃、不消费”及“维持最低生存标准，拒绝成为他人赚钱的机器和被剥削的奴隶”，是“低欲望青年”对于阶级固化的低移动性社会、中产阶级萎缩、在职贫穷、苛刻待遇、劳资关系失谐、以及不合理的社会经济结构等现况的回应。</p></blockquote><p>后面就是个人愚见了。</p><p>不禁有人会问，为什么现在年轻人要躺平呢？以前怎么没有？</p><p>怎么会没有？躺平这个词是新词，但这种想法却不是新的，新瓶装旧酒而已。</p><p>在更早的时候有一个词：三和大神。</p><p>维基百科依然可以找到解释：</p><blockquote><p>三和大神是指栖身在中国广东省深圳市龙华区景乐新村海新信人力资源市场附近的一群打工者，“三和”一词源自该区域最大的人力资源公司名称。他们居无定所，以日结薪资的临时工为生，号称“做一天可以玩三天”。这些打工者有的甚至没有身份证，身负债务，与家人鲜有来往。失去身份证无法购票，甚至无法离开三和地区。三和大神的定义同时有精神方面的因素，往往有着过一天算一天的豁达精神，不畏死，不惧穷、苦、脏。</p></blockquote><p>还有个词是“葛优躺”，2016 年的网络词，比喻自己的“颓废”的现状。</p><p><img src="http://static.howardliu.cn/raving/1f178a82b9014a90168ef327b977ad1ab21bee85.jpeg" alt="葛优躺"></p><p>再往前有个词是“佛系”，2014 年的网络词了，指无欲无求、不悲不喜、云淡风轻而追求内心平和的生活态度。</p><p>再往前，看看唐伯虎，躺的很潇洒。</p><blockquote><p>酒醒只在花前坐，酒醉还须花下眠。<br>花前花后日复日，酒醉酒醒年复年。<br>但愿老死花酒间，不愿鞠躬车马前。</p></blockquote><p>最后追上一句“世人笑我太疯癫，我笑世人看不穿。”简直是我躺平辈的真实心态。</p><p>再往前还有陶渊明，隐居山野间，“种豆南山下，草盛豆苗稀”，任由庄稼被杂草吞噬。</p><p>历史上的名人尚且如此，那些没有被历史记住的躺平青年，何其之多。躺平一词，只是给这种处事方式定了一个新说法而已。</p><p>从某度搜索这个词，结果有 1000 万条，可见热度如何。我天朝上国日益繁荣，怎么今年突然出来这么个词？</p><p>现在社会上工作的大部分人，是 80、90、00 这 30 年之间的人，正在接受生活工作的鞭挞。</p><p>改革开放 40 多年，经济迅速发展，几乎赶上欧美 200 多年的发展历程，甚至在某些领域已遥遥领先。</p><p>社会的发展不可能一蹴而就，必然是问题叠问题，不断解决问题。正在工作中努力拼搏的这批人，赶上了计划生育、90 年代的国企下岗、99 年的大学扩招、08 年的房价上涨、15 年二胎政策，以及今年的三胎政策、中考分流等。（中考分流和这批人没有直接关系，不过会跟这批人的子女有关系。）</p><p>能量守恒是自然规律。想要获得一些东西，必然需要通过等价的事物作为交换。社会发展也要遵循这个规律。</p><p>建国初期，百废待兴，需要发展。农业需要农民、工业需要工人、科研需要科学家、社会需要学者，各行各业都缺人，人多力量大。（不是说人多就有用，但是人多出现有用的人概率更大。）因此，人口数量稳步提升，但是国土面积就那么大，任由发展，就可能演变成“老鼠乌托邦”实验，所以必须刹车制动，于是有了计划生育。</p><p>后来，市场经济调控下，大锅饭不再能够保障大部分人的生活，国企经营能力赶不上社会发展，下岗成为了市场经济下的必然。但是下岗工人需要再就业、再创业。但是人口高速增长的那批正在读高中的学子马上也要毕业，怎么办？大学扩招，让这批即将毕业踏入社会的高中生，可以进入大学再学几年，大学成为分担就业压力的一个池子。</p><p>于是，本来大部分人上不了大学，变成了半数人有机会上大学。这样又造成了课外教培事业的繁荣，原本只有那些 90 分以上的孩子才能上大学。扩招之后，70 分以上都可以，那 60 分的就想往上提一下，70 分的怕被挤下来，也参加课外教培。学习上的内卷开始。也就是说，这批有躺平想法的年轻人，在学校读书的时候就被内卷过了。（这又是另外一个话题了，这里不做展开。）</p><p>等到这批扩招的大学生毕业，普通的流水线工厂肯定是不会去了，必然是要到大城市，进写字楼当白领。于是，当白领的人越来越多，但是资源就那么多，彼此竞争。白领人多了，蓝领就少了，也造成了各种用工荒。</p><p>大城市因其资源、人才、企业相互影响，产生人口聚集。人口多了，竞争压力大，教育资源紧缺，房价上涨，种种这些，压得这批年轻人喘不开气来。这些压力转变到生育上，就造成大家不愿生不敢生。人口增长缓慢，老龄化加剧，于是有了后来的鼓励生育，开放二胎三胎。</p><p>说了这么多，似乎和躺平没什么直接关系。仔细思考下，能够发现其中的必然联系。</p><p>目前 80、90、00 这群人，都是经历过社会高速发展的。到目前，我国经济水平已经赶上国际水平，跻身大国行列。后期就要更加良性的发展，不能以牺牲其他方面为代价的发展。所以，经济发展放缓必然是常态化。加上新冠疫情的出现，让这种常态化更快的到来。</p><p>总结下来，钱更难挣了。想要挣到相同的钱，需要我们的能力更强，付出更多的努力。对于这批人，车贷房贷教育费，赡养老人，抚育子女，各种事情都需要花钱。钱变得难挣，但是花钱并没有减少。</p><p>所以，想要躺会儿放松放松，把可能造成压力的事物都摒弃，让自己压力小一些。放松下来，什么也不管，无欲无求，简单度日即可。</p><p>但是，人毕竟是群居生物，有其社群关联。有父母、有妻儿，我朝亲情至上。所以上要孝敬父母，下要抚育子女，中间要与伴侣互相扶持。一时的放松可以，但是不能一直松下去。一时的放松是劳逸结合，一世的放松就是烂泥扶不上墙了。</p><p>推荐看看周董《稻香》的 MV，可以学学男主人公，当工作累了，可以回乡下老家，体验一下慢生活，给自己充充电。释放了压力，才能轻装前行。</p><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/relax-and-run/">想躺平不是错</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/118686355" target="_blank" rel="noopener">想躺平不是错</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      今天聊聊这段时间比较火的一个网络词：躺平。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="躺平" scheme="https://www.howardliu.cn/tags/%E8%BA%BA%E5%B9%B3/"/>
    
  </entry>
  
  <entry>
    <title>看山聊 Java：使用 Java8 中的时间类</title>
    <link href="https://www.howardliu.cn/java-date-time-migrating-to-jsr310/"/>
    <id>https://www.howardliu.cn/java-date-time-migrating-to-jsr310/</id>
    <published>2021-06-30T15:02:17.000Z</published>
    <updated>2021-06-30T15:02:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/chestnut-heath-6370080_1920.jpg" alt="看山聊 Java：使用 Java8 中的时间类"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/erik_karits-15012370/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6370080" target="_blank" rel="noopener">Erik Karits</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6370080" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>前面聊了聊 Java8 新版时间 API 的类，然后又说了说怎么与旧版时间 API 的转换，今天来聊聊怎样通过新 API 实现老 API 的功能，这样我们就可以逐步替换掉旧版 API，与时俱进。</p><a id="more"></a><p>Java8 之前，我们常用的时间类有<code>java.util.date</code>、<code>java.util.Calendar</code>和<code>java.util.Timezone</code>。还会有一些不那么常用的，<code>java.sql.Date</code>、<code>java.sql.TimeStamp</code>。</p><p>这些类可以实现一些简单的功能，但是要实现复杂的功能，我们只能自己实现很多工具类，或者借助第三方类库，其中比较著名的第三方库是 joda-time，后来 Java8 吸收其设计，直接让 joda-time 转正了。</p><blockquote><p>因为这个系列说的都是时间库，后文没有特殊说明，使用“新版 API”指代<code>JSR 310</code>提供的时间 API，使用“旧版 API”指代 Java 8 之前提供的官方时间 API。</p></blockquote><h2 id="新版-API-的优势"><a href="#新版-API-的优势" class="headerlink" title="新版 API 的优势"></a>新版 API 的优势</h2><p>新版 API 的优势，对应的就是旧版 API 的劣势。</p><h3 id="语义明确"><a href="#语义明确" class="headerlink" title="语义明确"></a>语义明确</h3><p>这点非常重要。</p><p>我们在定义一个实体的时候，能够做到语义明确没有歧义非常重要。</p><p>比如，我们需要定义出生日期，只需要年月日，在以前只能用<code>java.util.Date</code>，但是这个类包含时分秒。</p><p>或者，我们需要定义生日，正常只需要月日就行，连年都不需要，<code>java.util.Date</code>更加做不到。</p><p>在这些场景中，我们只能通过注释或者属性名做一些松散约束，很容易出错。</p><p>经验告诉我们，人是不可靠的，约定是不可靠的，只要有犯错的可能，就一定会犯错。</p><p>新版 API 完美解决这个问题，提供具有不同语义且语义明确的类。如果想表示日期可以用<code>LocalDate</code>，如果想表示生日，可以用<code>MonthDay</code>。这样，我们就能够借助编译器增强约束力。</p><h3 id="符合自然规律"><a href="#符合自然规律" class="headerlink" title="符合自然规律"></a>符合自然规律</h3><p>我们来通过一段代码感受下（测试日期是 2021 年 6 月 28 日），执行结果放在每行结尾处：</p><pre><code class="java">Date date = new Date();System.out.println(date);// Mon Jun 28 21:41:25 CST 2021System.out.println(date.getYear());// 121System.out.println(date.getMonth());// 5System.out.println(date.getDay());// 1Calendar calendar = Calendar.getInstance();calendar.setTime(date);System.out.println(calendar.get(Calendar.YEAR));// 2021System.out.println(calendar.get(Calendar.MONTH));// 5System.out.println(calendar.get(Calendar.DAY_OF_MONTH));// 28LocalDate localDate = LocalDate.now();System.out.println(localDate.getYear());// 2021System.out.println(localDate.getMonth());// JUNESystem.out.println(localDate.getDayOfMonth());// 28</code></pre><p>仅仅一个年月日的获取，旧版 API 已经是存在各种含义。</p><p><code>java.util.Date#getYear</code>表示的是当前年份减去 1900；<code>java.util.Date#getDay</code>返回的是当前是一周中的第几天，下标从 0 开始。当然，这几个 API 在 JDK1.1 的时候已经标记废弃了，但是知道现在也没有删除。相信很多初次使用旧版 API 的同学，都可能踩过坑。</p><p>更甚的是，<code>java.util.Date</code>和<code>java.util.Calendar</code>的返回的月份，都是从 0 开始计数的。但是年和日是从 1 开始计数，实在没有搞懂当时开发人员的脑回路是怎样的。</p><p>再看新版 API，完全符合我们的认知：年是自然年，月使用<code>Month</code>枚举（枚举的 value 值是自然月），日是自然日，一切都是根据我们对自然规律的理解。</p><p>而且，新版 API 很贴心的考虑了夏令时，在使用<code>ZonedDateTime</code>进行不同区域时间转换时，会自动计算。可以说，关于时间的逻辑，新版 API 已经都包含了。</p><h3 id="功能完善"><a href="#功能完善" class="headerlink" title="功能完善"></a>功能完善</h3><p>旧版 API 提供的时间类，只能实现一些简单的逻辑，想要做一些复杂的操作，就需要自己实现。新版 API 提供了灵活的时间功能 API。</p><ul><li><code>Instant</code>：表示时间戳，也就是一个时间点。</li><li><code>LocalDate</code>：表示日期，年、月、日</li><li><code>LocalTime</code>：表示时间，时、分、秒、纳秒</li><li><code>LocalDateTime</code>：表示日期+时间，内部也是通过<code>LocalDate</code>和<code>LocalTime</code>存储数据的</li><li><code>OffsetDateTime</code>：带有时间偏移的<code>LocalDateTime</code></li><li><code>OffsetTime</code>：带有时间偏移的<code>LocalTime</code></li><li><code>ZonedDateTime</code>：比<code>OffsetDateTime</code>多了时区，也就是带有时区、带有时间偏移的<code>LocalDateTime</code></li><li><code>MonthDay</code>：表示月、日，不包含年和时间</li><li><code>YearMonth</code>：表示年、月，不包含日和时间</li><li><code>Duration</code>：表示纳秒、秒的时间量，可以度量天、小时、分、秒、毫秒、纳秒。</li><li><code>Period</code>：表示年、月、日的时间量，可以度量年、月、日、周。</li></ul><p>有了上面这些类，我们可以在操作时间时横着走了。</p><h3 id="不可变（线程安全）"><a href="#不可变（线程安全）" class="headerlink" title="不可变（线程安全）"></a>不可变（线程安全）</h3><p>上面提到的这些类中，都是不可修改的，这些类的成员变量都使用<code>final</code>修饰，所有需要修改数据的方法，都是返回一个新实例。新版 API 通过这种方式实现了时间类的不可变性。</p><p>我们都知道，一个对象是不可变的，那它就是线程安全的。</p><p>旧版 API 的则不是这样，数据可变且对并发敏感。当然，这只能算是设计初衷不同。</p><p>新版 API 表示时间的类是线程安全的，可以对时间格式化的<code>DateTimeFormatter</code>也是时间安全的。</p><p>旧版的<code>SimpleDateFormat</code>也是类似的功能，但却不是线程安全的。这点就不是设计初衷不同了，而是缺少设计。相信很多没有被这个类毒打过的小白，会定义一些工具类，里面是<code>static</code>定义的<code>SimpleDateFormat</code>，然后对时间进行格式化，测试的时候没有一点问题，放在线上就出现各种诡异错误。</p><h2 id="开启征程"><a href="#开启征程" class="headerlink" title="开启征程"></a>开启征程</h2><p>我们通过一些常用场景，展示新旧版本 API 的实现方式。</p><h3 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h3><p>旧版 API：</p><pre><code class="java">Date now = new Date();</code></pre><p>新版 API：</p><pre><code class="java">// 没有偏移、没有时区概念的当前时间LocalDateTime now = LocalDateTime.now();// 有偏移和时区的当前时间ZonedDateTime now2 = ZonedDateTime.now();</code></pre><h3 id="指定日期"><a href="#指定日期" class="headerlink" title="指定日期"></a>指定日期</h3><p>旧版 API：</p><pre><code class="java">Date birthday = new GregorianCalendar(1988, Calendar.AUGUST, 20).getTime();</code></pre><p>新版 API：</p><pre><code class="java">LocalDate birthday = LocalDate.of(1988, Month.AUGUST, 20);LocalDate birthday2 = LocalDate.of(1988, 8, 20);</code></pre><h3 id="获取指定量"><a href="#获取指定量" class="headerlink" title="获取指定量"></a>获取指定量</h3><p>旧版 API：</p><pre><code class="java">int month = new GregorianCalendar().get(Calendar.MONTH);</code></pre><p>新版 API：</p><pre><code class="java">Month month = LocalDateTime.now().getMonth();</code></pre><h3 id="调整时间"><a href="#调整时间" class="headerlink" title="调整时间"></a>调整时间</h3><p>比如，获取当前之间 5 小时前的时间。</p><p>旧版 API：</p><pre><code class="java">GregorianCalendar calendar = new GregorianCalendar();calendar.add(Calendar.HOUR_OF_DAY, -5);Date fiveHoursBefore = calendar.getTime();</code></pre><p>新版 API：</p><pre><code class="java">LocalDateTime fiveHoursBefore = LocalDateTime.now().minusHours(5);</code></pre><h3 id="调整指定时间量"><a href="#调整指定时间量" class="headerlink" title="调整指定时间量"></a>调整指定时间量</h3><p>比如，将时间调整到 6 月。</p><p>旧版 API：</p><pre><code class="java">GregorianCalendar calendar = new GregorianCalendar();calendar.set(Calendar.MONTH, Calendar.JUNE);Date inJune = calendar.getTime();</code></pre><p>新版 API：</p><pre><code class="java">LocalDateTime inJune = LocalDateTime.now().withMonth(Month.JUNE.getValue());</code></pre><h3 id="截断时间量"><a href="#截断时间量" class="headerlink" title="截断时间量"></a>截断时间量</h3><p>我们有时候会将时间对象某个单位后面的所有时间量设置为 0，这个操作形象的称为截断。比如，将分、秒、毫秒设置为零。</p><p>旧版 API：</p><pre><code class="java">Calendar now = Calendar.getInstance();now.set(Calendar.MINUTE, 0);now.set(Calendar.SECOND, 0);now.set(Calendar.MILLISECOND, 0);Date truncated = now.getTime();</code></pre><p>新版 API：</p><pre><code class="java">LocalTime truncated = LocalTime.now().truncatedTo(ChronoUnit.HOURS);</code></pre><h3 id="时区转换"><a href="#时区转换" class="headerlink" title="时区转换"></a>时区转换</h3><p>旧版 API：</p><pre><code class="java">GregorianCalendar calendar = new GregorianCalendar();calendar.setTimeZone(TimeZone.getTimeZone(&quot;CET&quot;));Date centralEastern = calendar.getTime();</code></pre><p>新版 API：</p><pre><code class="java">ZonedDateTime centralEastern = LocalDateTime.now().atZone(ZoneId.of(&quot;CET&quot;));</code></pre><h3 id="计算时间跨度"><a href="#计算时间跨度" class="headerlink" title="计算时间跨度"></a>计算时间跨度</h3><p>旧版 API：</p><pre><code class="java">GregorianCalendar calendar = new GregorianCalendar();Date now = new Date();calendar.add(Calendar.HOUR, 1);Date hourLater = calendar.getTime();long elapsed = hourLater.getTime() - now.getTime();</code></pre><p>新版 API：</p><pre><code class="java">LocalDateTime now = LocalDateTime.now();LocalDateTime hourLater = LocalDateTime.now().plusHours(1);Duration span = Duration.between(now, hourLater);</code></pre><p><code>Duration</code>是跨度较小，可以度量天、小时、分、秒、毫秒、纳秒。如果跨度较大，可以使用<code>Period</code>，可以度量年、月、日、周。</p><h3 id="时间格式化和解析"><a href="#时间格式化和解析" class="headerlink" title="时间格式化和解析"></a>时间格式化和解析</h3><p>新版 API 使用<code>DateTimeFormatter</code>，这个类是线程安全的。而且相较于<code>SimpleDateFormat</code>提供了很多额外的功能。</p><p>旧版 API：</p><pre><code class="java">SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);Date now = new Date();String formattedDate = dateFormat.format(now);Date parsedDate = dateFormat.parse(formattedDate);</code></pre><p>新版 API：</p><pre><code class="java">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);LocalDate now = LocalDate.now();String formattedDate = now.format(formatter);LocalDate parsedDate = LocalDate.parse(formattedDate, formatter);</code></pre><h3 id="其他一些小功能"><a href="#其他一些小功能" class="headerlink" title="其他一些小功能"></a>其他一些小功能</h3><p>比如，计算一个月有几天：</p><p>旧版 API：</p><pre><code class="java">Calendar calendar = new GregorianCalendar(1990, Calendar.FEBRUARY, 20);int daysInMonth = calendar.getActualMaximum(Calendar.DAY_OF_MONTH);</code></pre><p>新版 API：</p><pre><code class="java">int daysInMonth = YearMonth.of(1990, 2).lengthOfMonth();</code></pre><h2 id="新旧版-API-的转换"><a href="#新旧版-API-的转换" class="headerlink" title="新旧版 API 的转换"></a>新旧版 API 的转换</h2><p>新版 API 虽然好用，但是罗马不是一天建成的。旧版 API 不会一夜消失，可能需要共用。Java 8 提供了很多方法，用来在新旧版本 API 之间进行转换。比如：</p><pre><code class="java">// 从 Calendar 转换 InstantInstant instantFromCalendar = GregorianCalendar.getInstance().toInstant();// 从 Calendar 转换 ZonedDateTimeZonedDateTime zonedDateTimeFromCalendar = new GregorianCalendar().toZonedDateTime();// 从 Instant 转换 DateDate dateFromInstant = Date.from(Instant.now());// 从 ZonedDateTime 转换 CalendarGregorianCalendar calendarFromZonedDateTime = GregorianCalendar.from(ZonedDateTime.now());// 从 Date 转换 InstantInstant instantFromDate = new Date().toInstant();// 从 TimeZone 转换 ZoneIdZoneId zoneIdFromTimeZone = TimeZone.getTimeZone(&quot;PST&quot;).toZoneId();</code></pre><p>更多的内容可以看看该系列的另一篇：<a href="https://www.howardliu.cn/java-date-to-localdate-and-localdatetime/">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a>。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>在本文中，我们讲解了旧版 API 的缺点、新版 API 的优点。新版 API 提供了很多友好的方法，而且不同类之间操作几乎一致，所以很多例子虽然只是说了一个类的使用，但是其他类也可以采用相似方式实现。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol><li><a href="https://www.howardliu.cn/java-date-and-time-intro/">Java8 中的时间类及常用 API</a></li><li><a href="https://www.howardliu.cn/java-date-to-localdate-and-localdatetime/">Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://www.howardliu.cn/java-date-time-migrating-to-jsr310/">使用 Java8 中的时间类</a></li><li><a href="https://www.howardliu.cn/java-date-string-valid-date/">检查日期字符串是否合法</a></li></ol><hr><p>你好，我是看山，10 年老猿，开源贡献者。游于码界，戏享人生。关注公众号：<a href="http://static.howardliu.cn/about/kanshanshuo.png" target="_blank" rel="noopener">看山的小屋</a>，领取学习资料。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-date-time-migrating-to-jsr310/">看山聊 Java：使用 Java8 中的时间类</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/103794938" target="_blank" rel="noopener">看山聊 Java：使用 Java8 中的时间类</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      前面聊了聊 Java8 新版时间 API 的类，然后又说了说怎么与旧版时间 API 的转换，今天来聊聊怎样通过新 API 实现老 API 的功能，这样我们就可以逐步替换掉旧版 API，与时俱进。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="Date" scheme="https://www.howardliu.cn/tags/Date/"/>
    
      <category term="Time" scheme="https://www.howardliu.cn/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>如果非要在多线程中使用 ArrayList 会发生什么？（第二篇）</title>
    <link href="https://www.howardliu.cn/arraylist-is-not-thread-safe-2/"/>
    <id>https://www.howardliu.cn/arraylist-is-not-thread-safe-2/</id>
    <published>2021-06-29T15:18:18.000Z</published>
    <updated>2021-06-29T15:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/home-studios-5249651_1920.jpg" alt="如果非要在多线程中使用 ArrayList 会发生什么？（第二篇）"></p><p>你好，我是看山。</p><p>前面写过一篇文章 <a href="https://howardliu.cn/arraylist-is-not-thread-safe/" target="_blank" rel="noopener">《如果非要在多线程中使用 ArrayList 会发生什么？》</a>，有读者反馈，Java 11 代码已经修复，还会出现 null 元素。</p><p>为了便于理解，当时只是通过代码执行顺序说明了异常原因。其实多线程中还会涉及 Java 内存模型，本文就从这方面说明一下。</p><a id="more"></a><h2 id="对比源码"><a href="#对比源码" class="headerlink" title="对比源码"></a>对比源码</h2><p>我们先来看看 Java 11 中，<code>add</code>方法做了什么调整。</p><p>Java 8 中<code>add</code>方法的实现：</p><pre><code class="java">public boolean add(E e) {    ensureCapacityInternal(size + 1);    elementData[size++] = e;    return true;}</code></pre><p>Java 11 中<code>add</code>方法的实现：</p><pre><code class="java">public boolean add(E e) {    modCount++;    add(e, elementData, size);    return true;}private void add(E e, Object[] elementData, int s) {    if (s == elementData.length)        elementData = grow();    elementData[s] = e;    size = s + 1;}</code></pre><p>两段逻辑的差异在于数组下标是否确定：</p><ul><li><code>elementData[size++] = e;</code>，Java 8 中直接使用<code>size</code>定位并赋值，然后通过<code>size++</code>自增</li><li><code>elementData[s] = e; size = s + 1;</code>，Java 11 借助临时变量<code>s</code>定位并赋值，然后通过<code>size = s + 1</code>给<code>size</code>赋新值</li></ul><p>Java 11 的优点在于，为数组指定元素赋值的时候，下标值是确定的。也就是说，只要进入<code>add(E e, Object[] elementData, int s)</code>方法中，就只会处理指定位置的数组元素。并且，<code>size</code>的值也是根据<code>s</code>增加。按照执行顺序推断，最终的结果可能会丢数，但是不会出现 null。（多个线程向同一个下标赋值，即<code>s</code>相等，那最终<code>size</code>也相等。）</p><h2 id="验证一下"><a href="#验证一下" class="headerlink" title="验证一下"></a>验证一下</h2><p>让我们来验证下。</p><pre><code class="java">package com.kuaishou.is.datamart;import java.util.ArrayList;import java.util.List;import java.util.concurrent.CountDownLatch;public class Main {    public static void main(String[] args) throws InterruptedException {        List&lt;String&gt; list = new ArrayList&lt;&gt;();        CountDownLatch latch = new CountDownLatch(1);        CountDownLatch waiting = new CountDownLatch(3);        Thread t1 = new Thread(() -&gt; {            try {                latch.await();                for (int i = 0; i &lt; 1000; i++) {                    list.add(&quot;1&quot;);                }            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                waiting.countDown();            }        });        Thread t2 = new Thread(() -&gt; {            try {                latch.await();                for (int i = 0; i &lt; 1000; i++) {                    list.add(&quot;2&quot;);                }            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                waiting.countDown();            }        });        Thread t2 = new Thread(() -&gt; {            try {                latch.await();                for (int i = 0; i &lt; 1000; i++) {                    list.add(&quot;2&quot;);                }            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                waiting.countDown();            }        });        t1.start();        t2.start();        latch.countDown();        waiting.await();        System.out.println(list);    }}</code></pre><p>在 Java 8 和 Java 11 中分别执行，果然，出现了<code>ArrayIndexOutOfBoundsException</code>和<code>null</code>的情况。如果没有出现，那就是姿势不对，需要多试几次或者多几个线程。</p><h2 id="换个角度想问题"><a href="#换个角度想问题" class="headerlink" title="换个角度想问题"></a>换个角度想问题</h2><p>上一篇通过代码执行顺序解释了出现问题的原因，这次再看看 JMM 的原因。</p><p><img src="http://static.howardliu.cn/java/jmm.png" alt="jmm"></p><p>从上图我们可以看到，Java 为每个线程创建了一个本地内存区域，也就是说，代码运行过程中使用的数据，是线程本地缓存的数据。这份缓存的数据，会与主内存的数据做交换（更新主内存数据或更新本次缓存中的数据）。</p><p>我们通过一个时序图看下为什么会出现 null（数组越界异常同理）：</p><p><img src="http://static.howardliu.cn/java/arraylist-add.png" alt="多线程场景下 ArrayList#add 方法的时序图"></p><p>从时序图我们可以看出现，在执行过程中，两个线程取的<code>size</code>值和<code>elementData</code>数组地址，大部分是操作自己本地缓存中的，执行一段时间后，会将本地缓存中的数据写回主内存数据，然后还会从主内存中读取最新数据更新本地缓存数据。异常就在这个交换过程中发生了。</p><p>这个时候，可能有读者会想，是不是把<code>size</code>和<code>elementData</code>两个变量加上<code>volatile</code>就可以解决了。如果这样想，那你就想简单。线程安全是整个类设计实现时已经确定了，除了属性需要考虑多线程的影响，方法（主要是会修改属性元素的方法）也需要考虑。</p><p><code>ArrayList</code>的定位是非线程安全的，其中的所有方法都没有考虑多线程下为共享资源加锁。即使<code>size</code>和<code>elementData</code>两个变量都是实时读写主内存，但是<code>add</code>和<code>grow</code>方法还是可能会覆盖另一个线程的数据。</p><p>我们从<code>ArrayList</code>的<code>add</code>方法注释可以得知，方法拆分不是为了实现线程安全，而是为了执行效率和内存占用：</p><blockquote><p>This helper method split out from add(E) to keep method bytecode size under 35 (the -XX:MaxInlineSize default value), which helps when add(E) is called in a C1-compiled loop.</p></blockquote><p>所以说，在多线程场景下使用<code>ArrayList</code>，该出现的异常，一个也不会少。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol><li><a href="https://www.howardliu.cn/arraylist-is-not-thread-safe/">如果非要在多线程中使用 ArrayList 会发生什么？</a></li><li><a href="https://www.howardliu.cn/arraylist-is-not-thread-safe-2/">如果非要在多线程中使用 ArrayList 会发生什么？（第二篇）</a></li></ol><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/arraylist-is-not-thread-safe-2/">如果非要在多线程中使用 ArrayList 会发生什么？（第二篇）</a><br>CSDN 主页：<a href="http://kanshan.csdn.net/" target="_blank" rel="noopener">http://kanshan.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.csdn.net/article/details/118346355" target="_blank" rel="noopener">如果非要在多线程中使用 ArrayList 会发生什么？（第二篇）</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      如果非要在多线程中使用 ArrayList 会发生什么？（第二篇）
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="ArrayList" scheme="https://www.howardliu.cn/tags/ArrayList/"/>
    
      <category term="线程安全" scheme="https://www.howardliu.cn/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>看山聊 Java：Date 与 LocalDate 或 LocalDateTime 互相转换</title>
    <link href="https://www.howardliu.cn/java-date-to-localdate-and-localdatetime/"/>
    <id>https://www.howardliu.cn/java-date-to-localdate-and-localdatetime/</id>
    <published>2021-06-22T14:50:46.000Z</published>
    <updated>2021-06-22T14:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/rome-6207755_1920.jpg" alt="看山聊 Java：Date 与 LocalDate 或 LocalDateTime 互相转换"></p><p>你好，我是看山。</p><p>从 Java1 到 Java8 将近 20 年，再加上 Java8 的普及时间、各种历史 API 兼容过渡时间。我们很多时候需要在旧时间 API 与新时间 API 之间切换，并行使用。今天就来说说，<code>java.util.Date</code>与<code>java.time.LocalDate/LocalDateTime</code>如何互相转换。</p><a id="more"></a><h2 id="java-util-Date转为java-time-LocalDate"><a href="#java-util-Date转为java-time-LocalDate" class="headerlink" title="java.util.Date转为java.time.LocalDate"></a><code>java.util.Date</code>转为<code>java.time.LocalDate</code></h2><p>Java8 发行的时候，也考虑到了新旧 API 之间的转换，所以在<code>java.util.Date</code>中增加了<code>toInstance()</code>方法，可以得到一个<code>Instance</code>实例。<code>Instance</code>没有时区概念，所以我们需要通过<code>atZone()</code>指定时区，得到<code>ZonedDateTime</code>实例，然后转换为<code>java.time.LocalDate</code>。如下：</p><pre><code class="java">public LocalDate convertToLocalDateViaInstant(Date dateToConvert) {    return dateToConvert.toInstant()            .atZone(ZoneId.systemDefault())            .toLocalDate();}</code></pre><p>同样的，我们也可以借助<code>Instance</code>的<code>ofEpochMilli()</code>方法创建实例。如下：</p><pre><code class="java">public LocalDate convertToLocalDateViaMilisecond(Date dateToConvert) {    return Instant.ofEpochMilli(dateToConvert.getTime())            .atZone(ZoneId.systemDefault())            .toLocalDate();}</code></pre><p>Java 中，除了<code>java.util.Date</code>，还有一个 Date 对象是<code>java.sql.Date</code>，java8 给这个类增加了一个直接转换为<code>LocalDate</code>的方法<code>toLocalDate()</code>。所以，我们也可以将<code>java.util.Date</code>转换为<code>java.sql.Date</code>，然后借助<code>toLocalDate()</code>方法。如下：</p><pre><code class="java">public LocalDate convertToLocalDateViaSqlDate(Date dateToConvert) {    return new java.sql.Date(dateToConvert.getTime()).toLocalDate();}</code></pre><h2 id="java-util-Date转为java-time-LocalDateTime"><a href="#java-util-Date转为java-time-LocalDateTime" class="headerlink" title="java.util.Date转为java.time.LocalDateTime"></a><code>java.util.Date</code>转为<code>java.time.LocalDateTime</code></h2><p><code>java.util.Date</code>是包含年月日时分秒的，转为<code>java.time.LocalDate</code>是把时分秒去掉，转为<code>java.time.LocalDateTime</code>是精度保留，转换方式完全一样，只不过要用到的是<code>toLocalDateTime()</code>方法。如下：</p><pre><code class="java">public LocalDateTime convertToLocalDateTimeViaInstant(Date dateToConvert) {    return dateToConvert.toInstant()            .atZone(ZoneId.systemDefault())            .toLocalDateTime();}public LocalDateTime convertToLocalDateTimeViaMilisecond(Date dateToConvert) {    return Instant.ofEpochMilli(dateToConvert.getTime())            .atZone(ZoneId.systemDefault())            .toLocalDateTime();}</code></pre><p><code>java.sql.Date</code>精度只有年月日，<code>java.sql.Timestamp</code>精度包含时分秒，所以还可以借助这个类的<code>toLocalDateTime()</code>方法实现转换：</p><pre><code class="java">LocalDateTime convertToLocalDateTimeViaSqlTimestamp(Date dateToConvert) {    return new java.sql.Timestamp(dateToConvert.getTime()).toLocalDateTime();}</code></pre><p>接下来，我们看看怎么从新时间 API 转旧时间 API。</p><h2 id="java-time-LocalDate转为java-util-Date"><a href="#java-time-LocalDate转为java-util-Date" class="headerlink" title="java.time.LocalDate转为java.util.Date"></a><code>java.time.LocalDate</code>转为<code>java.util.Date</code></h2><p>先来一个简单的方法，借助<code>java.sql.Date</code>的<code>valueOf()</code>方法，如下：</p><pre><code class="java">public java.util.Date convertToDateViaSqlDate(LocalDate dateToConvert) {    return java.sql.Date.valueOf(dateToConvert);}</code></pre><p><code>java.sql.Date.valueOf()</code>方法的实现也比较简单，我们也可以自己实现：</p><pre><code class="java">public static Date valueOf(LocalDate date) {    return new Date(date.getYear() - 1900,            date.getMonthValue() - 1,            date.getDayOfMonth());}</code></pre><blockquote><p>题外话：不知为何 Java8 这么偏爱<code>java.sql.Date</code>，提供了各种好用的转换方法。但是按照我的习惯，大部分时间用的都是<code>java.util.Date</code>类，是不是这个习惯得改改了。</p></blockquote><p>还有一种方式，是借助<code>java.util.Date</code>的<code>from(Instant instant)</code>方法，如下：</p><pre><code class="java">public java.util.Date convertToDateViaInstant(LocalDate dateToConvert) {    return java.util.Date.from(dateToConvert.atStartOfDay().atZone(ZoneId.systemDefault())            .toInstant());}</code></pre><h2 id="java-time-LocalDateTime转为java-util-Date"><a href="#java-time-LocalDateTime转为java-util-Date" class="headerlink" title="java.time.LocalDateTime转为java.util.Date"></a><code>java.time.LocalDateTime</code>转为<code>java.util.Date</code></h2><p>介绍两种方式。</p><p>一种是借助<code>java.sql.Timestamp</code>的<code>valueOf()</code>方法，如下：</p><pre><code class="java">public java.util.Date convertToDateViaSqlTimestamp(LocalDateTime dateToConvert) {    return java.sql.Timestamp.valueOf(dateToConvert);}</code></pre><p>另一种方式是：</p><pre><code class="java">public java.util.Date convertToDateViaInstant(LocalDateTime dateToConvert) {    return java.util.Date.from(dateToConvert.atZone(ZoneId.systemDefault())            .toInstant());}</code></pre><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>虽然 Java8 已经是行业底线，但是为了向下兼容，很多类库或者遗留代码依然保留了旧 API，不可能一夜之间替换完毕，所以我们还是会有新旧 API 的转换。本文提供几种转换方式，可供大家使用。当然，条条大路通罗马，这些方法都不是唯一的方式。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol><li><a href="https://www.howardliu.cn/java-date-and-time-intro/">Java8 中的时间类及常用 API</a></li><li><a href="https://www.howardliu.cn/java-date-to-localdate-and-localdatetime/">Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://www.howardliu.cn/java-date-time-migrating-to-jsr310/">使用 Java8 中的时间类</a></li><li><a href="https://www.howardliu.cn/java-date-string-valid-date/">检查日期字符串是否合法</a></li></ol><hr><p>你好，我是看山，10 年老猿，开源贡献者。游于码界，戏享人生。关注公众号：<a href="http://static.howardliu.cn/about/kanshanshuo.png" target="_blank" rel="noopener">看山的小屋</a>，领取学习资料。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-date-to-localdate-and-localdatetime/">看山聊 Java：Date 与 LocalDate 或 LocalDateTime 互相转换</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/118121634" target="_blank" rel="noopener">看山聊 Java：Date 与 LocalDate 或 LocalDateTime 互相转换</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      从 Java1 到 Java8 将近 20 年，再加上 Java8 的普及时间、各种历史 API 兼容过渡时间。我们很多时候需要在旧时间 API 与新时间 API 之间切换，并行使用。今天就来说说，java.util.Date 与 java.time.LocalDate/LocalDateTime 如何互相转换。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="Date" scheme="https://www.howardliu.cn/tags/Date/"/>
    
      <category term="Time" scheme="https://www.howardliu.cn/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>看山聊 Java：Java8 中的时间类及常用 API</title>
    <link href="https://www.howardliu.cn/java-date-and-time-intro/"/>
    <id>https://www.howardliu.cn/java-date-and-time-intro/</id>
    <published>2021-06-15T15:03:23.000Z</published>
    <updated>2021-06-15T15:03:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/strawberries-6165597_1920.jpg" alt="看山聊 Java：Java8 中的时间类及常用 API"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/onderortel-8618939/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6165597" target="_blank" rel="noopener">Önder Örtel</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6165597" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>年龄大的 Java 程序员都有体会，Java8 之前，Java 提供了一组时间类：<code>java.util.Date</code>、<code>java.util.Calendar</code>及其子类和工具类等。功能比较全面，最大的缺点是难用。所以很多团队直接放弃原生时间类，使用第三方的时间类库。后来，Java8 吸收了 joda-time 的优秀设计，提供了一组新的时间处理 API<code>java.time.</code>。</p><p>本文作为这个系列的第一篇，扒一扒<code>Date</code>和<code>Calendar</code>存在的问题，说说 Java8 提供的时间库是怎么解决这些问题的。后续再说一下 Java8 中<code>java.time.</code>包中的一些核心类，例如<code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>、<code>ZonedDateTime</code>、<code>Period</code>、<code>Duration</code>。</p><a id="more"></a><h2 id="老时间-API-存在的问题"><a href="#老时间-API-存在的问题" class="headerlink" title="老时间 API 存在的问题"></a>老时间 API 存在的问题</h2><ol><li>线程安全性：老的时间 API 是非线程安全的，而我们的代码都是运行在并发环境下，这样就不得不处理难以调试的并发问题，而且还需要额外的代码处理线程安全。一不小心，就会碰到一些比较诡异的错误，本地还不容易复现，比如定义了一个公用的<code>SimpleDateFormt</code>去操作时间，偶尔并发时会出错，只能通过迂回的办法实现（比如借助<code>ThreadLocal</code>）。在 Java8 中引入的新时间 API 是不可变对象，天然保证了线程安全。</li><li>API 设计和可理解性：老的时间 API 在这设计上没有一致的模型，而且日常操作功能不全。而且有一些比较让人诟病的设计，比如<code>Date</code>类的构造方法<code>public Date(int year, int month, int date)</code>，其中<code>month</code>字段取值是<code>0-11</code>，也就是按照计算机的 0 作为第一个数，但是<code>day</code>没有这种情况，取值是<code>1-31</code>，很容易搞错。新 API 以 ISO 为中心，遵循日期、时间、持续时间、时间间隔等一致的域模型，而且为时间 API 增加很多实用的工具方法。</li><li>时区处理：老的时间 API 在处理时区逻辑时比较繁琐，但是在新的 API 中，只需要通过<code>Local*</code>或<code>Zoned*</code>等类处理时区即可。</li></ol><p>下面就开始实际上手 Java8 的时间 API 了。</p><h2 id="LocalDate、LocalTime、LocalDateTime"><a href="#LocalDate、LocalTime、LocalDateTime" class="headerlink" title="LocalDate、LocalTime、LocalDateTime"></a>LocalDate、LocalTime、LocalDateTime</h2><p>这三个是最常用的几个时间类了，根据名字可以知道，这三个类是默认使用当前机器上的时区作为参考系的时间对象。也就是说，在不需要显示指定时区时，我们就可以使用这几个类。</p><h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><p><code>LocalDate</code>是 ISO 格式（yyyy-MM-dd）的日期，没有时分秒的时间数据。我们可以用它表示生日、放假等只关心日期的数据。通过<code>now</code>方法创建当前日期实例：</p><pre><code class="java">LocalDate localDate = LocalDate.now();</code></pre><p>这里是使用机器时间创建的。</p><p>我们还可以使用<code>of</code>方法或<code>parse</code>方法获取指定日期的<code>LocalDate</code>实例，比如，我们想要时间为 2021 年 6 月 11 号：</p><pre><code class="java">LocalDate.of(2021, 6, 11);LocalDate.parse(&quot;2021-06-11&quot;);</code></pre><p><code>LocalDate</code>还提供了各种实用方法来获取时间信息，接下来快速浏览一下这些 API 方法。</p><ol><li>获取明天的日期，即当前日期加一天：</li></ol><pre><code class="java">LocalDate tomorrow = LocalDate.now().plusDays(1);</code></pre><ol start="2"><li>获取上个月的今天，即当前日期并减去一个月（我们可以使用枚举单位操作数据）：</li></ol><pre><code class="java">LocalDate previousMonthSameDay = LocalDate.now().minus(1, ChronoUnit.MONTHS);`</code></pre><ol start="3"><li>解析日期“2021-06-11”，并获取周几（结果<code>DayOfWeek</code>是一个枚举类，设计很周到）：</li></ol><pre><code class="java">DayOfWeek friday = LocalDate.parse(&quot;2021-06-11&quot;).getDayOfWeek();</code></pre><ol start="4"><li>解析日期“2021-06-11”，并获取几号：</li></ol><pre><code class="java">int eleven = LocalDate.parse(&quot;2021-06-11&quot;).getDayOfMonth();</code></pre><ol start="5"><li>检查一个日期的年份是否是闰年：</li></ol><pre><code class="java">boolean leapYear = LocalDate.now().isLeapYear();</code></pre><ol start="6"><li>判断一个日期是否在另外一个日期之前：</li></ol><pre><code class="java">boolean isBefore = LocalDate.parse(&quot;2021-06-11&quot;).isBefore(LocalDate.parse(&quot;2021-06-12&quot;));</code></pre><ol start="7"><li>判断一个日期是否在另外一个日期之后：</li></ol><pre><code class="java">boolean isAfter = LocalDate.parse(&quot;2021-06-12&quot;).isAfter(LocalDate.parse(&quot;2021-06-11&quot;));</code></pre><ol start="8"><li>获取给定日期的当天开始时间，比如给定“2021-06-11”，想要获取“2021-06-11T00:00”（也就是当天的 0 点时间）：</li></ol><pre><code class="java">LocalDateTime beginningOfDay = LocalDate.parse(&quot;2021-06-11&quot;).atStartOfDay();</code></pre><ol start="9"><li>获取给定日期所在月份的的第一天，比如给定“2021-06-11”，想要获取“2021-06-01”：</li></ol><pre><code class="java">LocalDate firstDayOfMonth = LocalDate.parse(&quot;2021-06-11&quot;).with(TemporalAdjusters.firstDayOfMonth());</code></pre><h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p><code>LocalDate</code>是 ISO 格式（yyyy-MM-dd）的日期，没有时分秒的时间数据。我们可以用它表示生日、放假等只关心日期的数据。通过<code>now</code>方法创建当前日期实例：</p><p><code>LocalTime</code>提供的是没有日期数据的时间，只有时分秒数据。这个类很多方法与<code>LocalDate</code>类似，所以我们快速过一下这些 API 方法。</p><ol><li>创建当前时间</li></ol><pre><code class="java">LocalTime now = LocalTime.now();</code></pre><ol start="2"><li>解析给定的字符串时间，可以使用<code>of</code>和<code>parse</code>方法，比如下午 4:30：</li></ol><pre><code class="java">LocalTime sixty30 = LocalTime.parse(&quot;16:30&quot;);LocalTime sixty31 = LocalTime.of(16, 31);</code></pre><ol start="3"><li>解析给定字符串时间，并获取一小时后的时间实例：</li></ol><pre><code class="java">LocalTime seventy30 = LocalTime.parse(&quot;16:30&quot;).plus(1, ChronoUnit.HOURS);</code></pre><ol start="4"><li>获取给定字符串时间的小时数：</li></ol><pre><code class="java">int sixty = LocalTime.parse(&quot;16:30&quot;).getHour();</code></pre><ol start="5"><li>判断一个时间是否在另外一个时间之前：</li></ol><pre><code class="java">boolean isBeforeTime = LocalTime.parse(&quot;16:30&quot;).isBefore(LocalTime.parse(&quot;17:30&quot;));</code></pre><ol start="6"><li>判断一个时间是否在另外一个时间之后：</li></ol><pre><code class="java">boolean isAfterTime = LocalTime.parse(&quot;17:30&quot;).isAfter(LocalTime.parse(&quot;16:30&quot;));</code></pre><ol start="7"><li>常用的时间常量：</li></ol><pre><code class="java">LocalTime.MIN;// 00:00LocalTime.NOON;// 12:00LocalTime.MAX;// 23:59:59.999999999LocalTime.MIDNIGHT;// 00:00</code></pre><h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>顾名思义，<code>LocalDateTime</code>表示日期和时间的组合。有了前两个类做铺垫，这个类也是很类似的操作。</p><ol><li>创建当前时间</li></ol><pre><code class="java">LocalDateTime.now();</code></pre><ol start="2"><li>解析给定的字符串时间，可以使用<code>of</code>和<code>parse</code>方法，比如 2021 年 6 月 11 日 16 点 30 分：</li></ol><pre><code class="java">LocalDateTime.of(2021, Month.JUNE, 11, 16, 30);LocalDateTime.parse(&quot;2021-06-11T16:30:00&quot;);// 注意这个时间格式，这种写法属于 UTC 时间格式，后续再开文说一下时间格式的话题。</code></pre><p>其他与<code>LocalDate</code>和<code>LocalTime</code>类似的 API，比如<code>plusDays</code>、<code>MinsHours</code>、<code>getMonth</code>等。我们可以把<code>LocalDateTime</code>理解为<code>LocalDate</code>和<code>LocalTime</code>的合体。</p><p><code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>处理的都是当前系统所在时区的日期时间数据，有时候我们还需要处理特定时区的日期和时间，Java8 提供了<code>ZonedDateTime</code>，接下来我们说说这个类。</p><h2 id="ZonedDateTime"><a href="#ZonedDateTime" class="headerlink" title="ZonedDateTime"></a>ZonedDateTime</h2><p><code>ZonedDateTime</code>的使用需要配合<code>ZoneId</code>，<code>ZoneId</code>表示不同区域的标识符，在<code>${JAVA_HOME}/lib/tzdb.dat</code>文件中存放了默认的区域标识符，如果没有特别定义，需要是文件中指定的数据才能获取到<code>ZoneId</code>实例。</p><p>我们来创建我天朝的区域：<code>ZoneId zoneId = ZoneId.of(&quot;Asia/Shanghai&quot;);</code>。</p><p>如果不知道有哪些区域，可以通过<code>Set&lt;String&gt; allZoneIds = ZoneId.getAvailableZoneIds();</code>获取，我当前 jdk 版本是 jdk1.8.0_202，一共有 599 个区域标识。</p><p>我们对比我朝与漂亮国的时间，获取当前时间：</p><pre><code class="java">ZonedDateTime.now();// 2021-06-11T17:49:53.400+08:00[Asia/Shanghai]ZonedDateTime.now(ZoneId.systemDefault());// 2021-06-11T17:49:53.400+08:00[Asia/Shanghai]ZonedDateTime.now(ZoneId.of(&quot;America/New_York&quot;));// 2021-06-11T05:49:53.400-04:00[America/New_York]</code></pre><p>可以看到，<code>now</code>方法不传参数与使用当前时区参数结果一致，使用漂亮国时区时，在小时上有区别，但是两个时间，都是指当前时间。我们可以通过指定<code>ZoneId</code>获取不同时区的结果：</p><pre><code class="java">final ZonedDateTime newyorkZonedDateTime = ZonedDateTime.now(ZoneId.of(&quot;America/New_York&quot;));// 2021-06-11T05:57:00.655-04:00[America/New_York]final ZonedDateTime shanghaiZonedDateTime = newyorkZonedDateTime.withZoneSameInstant(ZoneId.of(&quot;Asia/Shanghai&quot;));// 2021-06-11T17:57:00.655+08:00[Asia/Shanghai]final ZonedDateTime shanghaiZonedDateTime2 = ZonedDateTime.now(ZoneId.of(&quot;Asia/Shanghai&quot;));// 2021-06-11T17:58:34.221+08:00[Asia/Shanghai]</code></pre><p>可以看到，我们直接获取北京时间与通过漂亮国时间转换为北京时间，结果是一样的。</p><p>这里有一点需要提醒，这点是我朝程序员容易忽略的。那就是夏令时，我国没有夏令时，但是国外有些国家使用夏令时。所以在处理时间的时候，我们最好不要通过手动加减时区差来计算时间，这样很容易忽略夏令时。</p><h2 id="Period、Duration"><a href="#Period、Duration" class="headerlink" title="Period、Duration"></a>Period、Duration</h2><p>这两个类都是表示时间量，也就是时间段。不过，<code>Period</code>类以年、月、日这种比较大的单位表示时间量，<code>Duration</code>类以秒、纳秒这种相对较小的单位表示时间量。</p><h3 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h3><p><code>Period</code>表示的单位是年或月或日这种相对大一些的单位。我们可以用它来增减时间，或者计算两个时间间的时间差。</p><p>比如，我们以 2021 年 6 月 15 日为基准，计算 5 天后的日期：</p><pre><code class="java">LocalDate initialDate = LocalDate.parse(&quot;2021-06-15&quot;);LocalDate finalDate = initialDate.plus(Period.ofDays(5));// 2021-06-20</code></pre><p><code>Period</code>提供了<code>ofYears</code>、<code>ofMonths</code>、<code>ofWeeks</code>、<code>ofDays</code>、<code>of</code>等方法，可以随情况处理时间。</p><p>除了锚定的特定时间，<code>Period</code>还可以计算两个日期之间的时间差。比如：</p><pre><code class="java">LocalDate initialDate = LocalDate.parse(&quot;2021-06-15&quot;);final LocalDate newDate = initialDate.plus(Period.of(1, 2, 3));final Period period = Period.between(initialDate, newDate);int years = period.getYears();// 1int months = period.getMonths();// 2int days = period.getDays();// 3</code></pre><p>这里需要注意一下，这三个方法是两个单位同单位的差，不会进行换算。我们可以借助<code>ChronoUnit</code>实现单位换算状态下的结果：</p><pre><code class="java">long allYears = ChronoUnit.YEARS.between(initialDate, newDate);// 1long allMonths = ChronoUnit.MONTHS.between(initialDate, newDate);// 14long allDays = ChronoUnit.DAYS.between(initialDate, newDate);// 429</code></pre><p><code>ChronoUnit</code>是借助<code>Duration</code>实现的，所以最细粒度可以到纳秒。</p><h3 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h3><p><code>Duration</code>可以表示的单位是天、小时、分、秒、毫秒、纳秒，其内部结果是通过秒、纳秒进行存储的，其他可表示的单位，都是通过这两个单位组合实现的。比如，一分钟等于 3600 秒，那内部存储就是 3600 秒 0 纳秒；1 毫秒等于 1000000 纳秒，内部存储就是 0 秒 1000000 纳秒。</p><p><code>Duration</code>用法与<code>Period</code>类似。比如，我们给 21 点 03 分 15 秒加 30 秒：</p><pre><code class="java">LocalTime initialTime = LocalTime.parse(&quot;21:02:15&quot;);LocalTime finalTime = initialTime.plus(Duration.ofSeconds(30));// 21:02:45</code></pre><p><code>Duration</code>也可以计算两个时间之间的时间差，只是单位较小一些，比如：</p><pre><code class="java">LocalTime initialTime = LocalTime.parse(&quot;21:02:15&quot;);LocalTime newTime = LocalTime.of(21, 02, 20);Duration duration = Duration.between(initialTime, newTime);long seconds = duration.getSeconds();// 5int nano = duration.getNano();// 0</code></pre><p>同样的，我们可以借助<code>ChronoUnit</code>实现更多单位的时间差，这里不做赘述。</p><h2 id="从老时间-API-创建"><a href="#从老时间-API-创建" class="headerlink" title="从老时间 API 创建"></a>从老时间 API 创建</h2><p>Java8 提供了<code>toInstant()</code>方法，可以将老时间 API 的<code>Date</code>和<code>Calendar</code>转换为新的对象：</p><pre><code class="java">Date date = new Date();LocalDateTime localDateTime = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());Calendar calendar = GregorianCalendar.getInstance();LocalDateTime localDateTime1 = LocalDateTime.ofInstant(calendar.toInstant(), ZoneId.systemDefault());</code></pre><h2 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h2><p>Java8 提供了易于使用的时间格式化 API，这里简单说下。比如：</p><pre><code class="java">LocalDateTime localDateTime = LocalDateTime.of(2021, Month.JUNE, 15, 21, 23);String localDateString = localDateTime.format(DateTimeFormatter.ISO_DATE);// 2021-06-15</code></pre><p>与老时间 API 一样，我们可以指定格式：</p><pre><code class="java">localDateTime.format(DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd&quot;));</code></pre><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>从 Java7 到 Java8，提供了很多特性，除了 Lambda 表达式，时间 API 绝对也是良心功能了。而且从发布到现在已经过去这么多年，我们还是要与时俱进，逐渐使用优秀的 API 替换老 API 了。如果还在用 Java7 或者 Java6，然后还想使用 Java8 这种时间 API，这里推荐两个第三方库：<code>threetenbp</code>和<code>joda-time</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/eugenp/tutorials/tree/master/core-java-modules/core-java-8-datetime" target="_blank" rel="noopener">core-java-8-datetime</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1303904694304801" target="_blank" rel="noopener">ZonedDateTime</a></li></ul><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol><li><a href="https://www.howardliu.cn/java-date-and-time-intro/">Java8 中的时间类及常用 API</a></li><li><a href="https://www.howardliu.cn/java-date-to-localdate-and-localdatetime/">Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://www.howardliu.cn/java-date-time-migrating-to-jsr310/">使用 Java8 中的时间类</a></li><li><a href="https://www.howardliu.cn/java-date-string-valid-date/">检查日期字符串是否合法</a></li></ol><hr><p>你好，我是看山，10 年老猿，开源贡献者。游于码界，戏享人生。关注公众号：<a href="http://static.howardliu.cn/about/kanshanshuo.png" target="_blank" rel="noopener">看山的小屋</a>，领取学习资料。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-date-and-time-intro/">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/117945803" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文作为这个系列的第一篇，扒一扒 Date 和 Calendar 存在的问题，说说 Java8 提供的时间库是怎么解决这些问题的。后续再说一下 Java8 中 java.time 包中的一些核心类，例如 LocalDate、LocalTime、LocalDateTime、ZonedDateTime、Period、Duration。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Date" scheme="https://www.howardliu.cn/tags/Date/"/>
    
      <category term="Time" scheme="https://www.howardliu.cn/tags/Time/"/>
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
  </entry>
  
</feed>
