<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沉潜飞动</title>
  
  <subtitle>君子藏器于身，待时而动。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.howardliu.cn/"/>
  <updated>2022-01-15T05:10:35.000Z</updated>
  <id>https://www.howardliu.cn/</id>
  
  <author>
    <name>Howard Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java12 的新特性</title>
    <link href="https://www.howardliu.cn/java-12-features/"/>
    <id>https://www.howardliu.cn/java-12-features/</id>
    <published>2022-01-15T05:10:35.000Z</published>
    <updated>2022-01-15T05:10:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/lily-gf02d5baa4_1920.jpg" alt="Java12 的新特性"></p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>你好，我是看山。</p><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文讲解一下 Java12 的特性，作为第一个长期支持版 Java11 之后的第一个版本，增加的功能也不少，除了一些小幅度的 API 增强，增加了另一个试验阶段的垃圾收集器 Shenandoah、对 G1 做了优化、增加微基准套件等。</p><h2 id="语法特性"><a href="#语法特性" class="headerlink" title="语法特性"></a>语法特性</h2><p>Java12 提供了很多的语法特性，既有小而美的增强 API，又有特别方便的工具扩展。本节我们跟着代码看看比较好玩的功能。</p><h3 id="String-的增强方法：indent-和-transform"><a href="#String-的增强方法：indent-和-transform" class="headerlink" title="String 的增强方法：indent 和 transform"></a>String 的增强方法：indent 和 transform</h3><p>在 Java12 中，String 又增强了两个方法。之所以说又，是因为在 Java11 中已经增加过小而美的方法，想要详细了解的可以查看 <a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 新特性</a>。</p><p>这次增加的方法是<code>indent</code>（缩进）和<code>transform</code>（转换）。</p><p>顾名思义，<code>indent</code>方法是对字符串每行（使用<code>\r</code>或<code>\n</code>分隔）数据缩进指定空白字符，参数是 int 类型。</p><p>如果参数大于 0，就缩进指定数量的空格；如果参数小于 0，就将左侧的空字符删除指定数量，即右移。</p><p>我们看下源码：</p><pre><code class="java">public String indent(int n) {    if (isEmpty()) {        return &quot;&quot;;    }    Stream&lt;String&gt; stream = lines();    if (n &gt; 0) {        final String spaces = &quot; &quot;.repeat(n);        stream = stream.map(s -&gt; spaces + s);    } else if (n == Integer.MIN_VALUE) {        stream = stream.map(s -&gt; s.stripLeading());    } else if (n &lt; 0) {        stream = stream.map(s -&gt; s.substring(Math.min(-n, s.indexOfNonWhitespace())));    }    return stream.collect(Collectors.joining(&quot;\n&quot;, &quot;&quot;, &quot;\n&quot;));}</code></pre><p>这里会使用到 Java11 增加的<code>lines</code>、<code>repeat</code>、<code>stripLeading</code>等方法。<code>indent</code>最后会将多行数据通过<code>Collectors.joining(&quot;\n&quot;, &quot;&quot;, &quot;\n&quot;)</code>方法拼接，结果会有两点需要注意：</p><ul><li><code>\r</code>会被替换成<code>\n</code>；</li><li>如果原字符串是多行数据，最后一行的结尾没有<code>\n</code>，最后会补上一个<code>\n</code>，即多了一个空行。</li></ul><p>我们看下测试代码：</p><pre><code class="java">@Testvoid testIndent() {    final String text = &quot;\t\t\t 你好，我是看山。\n \u0020\u2005Java12 的 新特性。\r 欢迎三连+关注哟&quot;;    assertEquals(&quot;    \t\t\t 你好，我是看山。\n     \u0020\u2005Java12 的 新特性。\n    欢迎三连+关注哟、n&quot;, text.indent(4));    assertEquals(&quot;\t 你好，我是看山。\n\u2005Java12 的 新特性。\n 欢迎三连+关注哟、n&quot;, text.indent(-2));    final String text2 = &quot;山水有相逢&quot;;    assertEquals(&quot;山水有相逢&quot;, text2);}</code></pre><p>我们再来看看<code>transform</code>方法，源码一目了然：</p><pre><code class="java">public &lt;R&gt; R transform(Function&lt;? super String, ? extends R&gt; f) {    return f.apply(this);}</code></pre><p>通过传入的<code>Function</code>对当前字符串进行转换，转换结果由<code>Function</code>决定。比如，我们要对字符串反转：</p><pre><code class="java">@Testvoid testTransform() {    final String text = &quot;看山是山&quot;;    final String reverseText = text.transform(s -&gt; new StringBuilder(s).reverse().toString());    assertEquals(&quot;山是山看&quot;, reverseText);}</code></pre><p>其实这个方法在 Java8 中提供的<code>Optional</code>实现类似的功能（完整的 Optional 功能可以查看 <a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">Optional 的 6 种操作</a>）：</p><pre><code class="java">@Testvoid testTransform() {    final String text = &quot;看山是山&quot;;    final String reverseText2 = Optional.of(text)            .map(s -&gt; new StringBuilder(s).reverse().toString())            .orElse(&quot;&quot;);    assertEquals(&quot;山是山看&quot;, reverseText2);}</code></pre><h3 id="Files-的增强方法：mismatch"><a href="#Files-的增强方法：mismatch" class="headerlink" title="Files 的增强方法：mismatch"></a>Files 的增强方法：mismatch</h3><p>在 Java12 中，<code>Files</code>增加了<code>mismatch</code>方法，用于对比两个文件中的不相同字符的位置，如果内容相同，返回<code>-1L</code>，是<code>long</code>类型的。</p><p>我们来简单看下怎么用：</p><pre><code class="java">@Testvoid testMismatch() throws IOException {    final Path pathA = Files.createFile(Paths.get(&quot;a.txt&quot;));    final Path pathB = Files.createFile(Paths.get(&quot;b.txt&quot;));    // 写入相同内容    Files.write(pathA, &quot;看山&quot;.getBytes(), StandardOpenOption.WRITE);    Files.write(pathB, &quot;看山&quot;.getBytes(), StandardOpenOption.WRITE);    final long mismatch1 = Files.mismatch(pathA, pathB);    Assertions.assertEquals(-1L, mismatch1);    // 追加不同内容    Files.write(pathA, &quot;是山&quot;.getBytes(), StandardOpenOption.APPEND);    Files.write(pathB, &quot;不是山&quot;.getBytes(), StandardOpenOption.APPEND);    final long mismatch2 = Files.mismatch(pathA, pathB);    Assertions.assertEquals(6L, mismatch2);    Files.deleteIfExists(pathA);    Files.deleteIfExists(pathB);}</code></pre><p>我们可以看到，当第一次在两个文件中写入相同内容，执行<code>mismatch</code>方法返回的是<code>-1L</code>。当第二次追加进去不同的内容后，返回的是<code>6L</code>。之所以是 6，是因为测试代码中使用的字符集是<code>UTF-8</code>，大部分汉子是占用 3 个字符，前两个字相同，从第三个字开始不同，下标从 0 开始，所以开始位置是 6。</p><h3 id="Collectors-的增强方法：teeing"><a href="#Collectors-的增强方法：teeing" class="headerlink" title="Collectors 的增强方法：teeing"></a>Collectors 的增强方法：teeing</h3><p>我们看下<code>teeing</code>的定义：</p><pre><code class="java">public static &lt;T, R1, R2, R&gt; Collector&lt;T, ?, R&gt; teeing(    Collector&lt;? super T, ?, R1&gt; downstream1,    Collector&lt;? super T, ?, R2&gt; downstream2,    BiFunction&lt;? super R1, ? super R2, R&gt; merger)</code></pre><p>这个方法有三个参数，前两个是<code>Collector</code>对象，用于对输入数据进行预处理，第三个参数是<code>BiFunction</code>，用于将前两个处理后的结果作为参数传入<code>BiFunction</code>中，运算得到结果。</p><p>我们来看下例子：</p><pre><code class="java">@Testvoid testTeeing() {    var result = Stream.of(&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;)            .collect(Collectors.teeing(                    Collectors.filtering(n -&gt; n.contains(&quot;u&quot;), Collectors.toList()),                    Collectors.filtering(n -&gt; n.contains(&quot;n&quot;), Collectors.toList()),                    (list1, list2) -&gt; List.of(list1, list2)            ));    assertEquals(2, result.size());    assertTrue(isEqualCollection(List.of(&quot;Sunday&quot;, &quot;Tuesday&quot;), result.get(0)));    assertTrue(isEqualCollection(List.of(&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Wednesday&quot;), result.get(1)));}</code></pre><p>我们对输入的几个字符串进行过滤，然后将过滤结果组成一个新的队列。</p><h3 id="新工具：CompactNumberFormat"><a href="#新工具：CompactNumberFormat" class="headerlink" title="新工具：CompactNumberFormat"></a>新工具：CompactNumberFormat</h3><p>这个工具比较好玩，可以对数字进行按需格式化。提供了<code>public static NumberFormat getCompactNumberInstance(Locale locale, NumberFormat.Style formatStyle)</code>方法用于初始化：</p><ul><li>第一个参数是指定区域，不同区域展示的结果不同，比如中国展示汉字、美国展示英文；</li><li>第二个参数是指定展示结果的模式，分为<code>SHORT</code>和<code>LONG</code>，不过对于中文展示，似乎没啥区别。</li></ul><p>我们一起看下例子：</p><pre><code class="java">@Testvoid testFormat() {    final NumberFormat zhShort = NumberFormat.getCompactNumberInstance(Locale.CHINA, Style.SHORT);    assertEquals(&quot;1 万&quot;, zhShort.format(10_000));    assertEquals(&quot;1 兆&quot;, zhShort.format(1L &lt;&lt; 40));    final NumberFormat zhLong = NumberFormat.getCompactNumberInstance(Locale.CHINA, Style.LONG);    assertEquals(&quot;1 万&quot;, zhLong.format(10_000));    assertEquals(&quot;1 兆&quot;, zhLong.format(1L &lt;&lt; 40));    final NumberFormat usShort = NumberFormat.getCompactNumberInstance(Locale.US, Style.SHORT);    usShort.setMaximumFractionDigits(2);    assertEquals(&quot;10K&quot;, usShort.format(10_000));    assertEquals(&quot;1.1T&quot;, usShort.format(1L &lt;&lt; 40));    final NumberFormat usLong = NumberFormat.getCompactNumberInstance(Locale.US, Style.LONG);    usLong.setMaximumFractionDigits(2);    assertEquals(&quot;10 thousand&quot;, usLong.format(10_000));    assertEquals(&quot;1.1 trillion&quot;, usLong.format(1L &lt;&lt; 40));}</code></pre><p>我们也可以继续使用<code>NumberFormat</code>中的方法定义，比如示例中保留小数点后 2 位。</p><h2 id="Shenandoah：一个低停顿垃圾收集器"><a href="#Shenandoah：一个低停顿垃圾收集器" class="headerlink" title="Shenandoah：一个低停顿垃圾收集器"></a>Shenandoah：一个低停顿垃圾收集器</h2><p>Java12 引入了一个实验阶段的垃圾收集器：Shenandoah，作为一个低停顿的垃圾收集器。</p><p>Shenandoah 垃圾收集器是 RedHat 在 2014 年宣布进行的垃圾收集器研究项目，其工作原理是通过与 Java 应用执行线程同时运行来降低停顿时间。简单的说就是，Shenandoah 工作时与应用程序线程并发，通过交换 CPU 并发周期和空间以改善停顿时间，使得垃圾回收器执行线程能够在 Java 线程运行时进行堆压缩，并且标记和整理能够同时进行，因此避免了在大多数 JVM 垃圾收集器中所遇到的问题。</p><p><img src="https://static.howardliu.cn/java/shenandoah-gc-cycle.png" alt="Shenandoah GC"></p><p>Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200MB 还是 200GB，都将拥有一致的系统暂停时间，不过实际使用性能将取决于实际工作堆的大小和工作负载。</p><p>Java12 中 Shenandoah 处于实验阶段，想要使用需要编译时添加<code>--with-jvm-features=shenandoahgc</code>，然后启动时使用<code>-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC</code>以开启。</p><p>后续会补充 Java 中各种垃圾收集器的文章，其中会有介绍 Shenandoah 的，敬请关注公众号「看山的小屋」。如果想要提前了解，欢迎访问<a href="https://wiki.openjdk.java.net/display/shenandoah" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/shenandoah</a>。</p><h2 id="增加一套基准测试套件"><a href="#增加一套基准测试套件" class="headerlink" title="增加一套基准测试套件"></a>增加一套基准测试套件</h2><p>Java12 中添加一套基准测试套件，该基准测试套件基于 JMH（Java Microbenchmark Harness），使开发人员可以轻松运行现有的基准测试并创建新的基准测试，其目标是提供一个稳定且优化的基准。</p><p>在这套基准测试套件中包括将近 100 个基准测试的初始集合，并且能够轻松添加新基准、更新基准测试和提高查找已有基准测试的便利性。</p><p>微基准套件与 JDK 源代码位于同一个目录中，并且在构建后将生成单个 Jar 文件。它是一个单独的项目，在支持构建期间不会执行，以方便开发人员和其他对构建微基准套件不感兴趣的人在构建时花费比较少的构建时间。</p><h2 id="Switch-表达式扩展（预览版）"><a href="#Switch-表达式扩展（预览版）" class="headerlink" title="Switch 表达式扩展（预览版）"></a>Switch 表达式扩展（预览版）</h2><p>Switch 语句出现的姿势是条件判断、流程控制组件，与现在很流行的新语言对比，其写法显得非常笨拙，所以 Java 推出了 Switch 表达式语法，可以让我们写出更加简化的代码。这个扩展在 Java12 中作为预览版首次引入，需要在编译时增加<code>-enable-preview</code>开启，在 Java14 中正式提供，功能编号是 <a href="https://openjdk.java.net/jeps/361" target="_blank" rel="noopener">JEP 361</a>。</p><p>比如，我们通过 switch 语法简单计算工作日、休息日，在 Java12 之前需要这样写：</p><pre><code class="java">@Testvoid testSwitch() {    final DayOfWeek day = DayOfWeek.from(LocalDate.now());    String typeOfDay = &quot;&quot;;    switch (day) {        case MONDAY:        case TUESDAY:        case WEDNESDAY:        case THURSDAY:        case FRIDAY:            typeOfDay = &quot;Working Day&quot;;            break;        case SATURDAY:        case SUNDAY:            typeOfDay = &quot;Rest Day&quot;;            break;    }    Assertions.assertFalse(typeOfDay.isEmpty());}</code></pre><p>在 Java12 中的 Switch 表达式中，我们可以直接简化：</p><pre><code class="java">@Testvoid testSwitchExpression() {    final DayOfWeek day = DayOfWeek.SATURDAY;    final String typeOfDay = switch (day) {        case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; &quot;Working Day&quot;;        case SATURDAY, SUNDAY -&gt; &quot;Day Off&quot;;    };    Assertions.assertEquals(&quot;Day Off&quot;, typeOfDay);}</code></pre><p>是不是很清爽。文末提供的源码中，<code>pom.xml</code>定义的<code>maven.compiler</code>版本写的是<code>14</code>，这是因为 Switch 表达式是 Java14 正式提供，我没有重新编译 Java，所以只能指定 Java14 来实现这个功能代码的演示。</p><h2 id="引入-JVM-常量-API"><a href="#引入-JVM-常量-API" class="headerlink" title="引入 JVM 常量 API"></a>引入 JVM 常量 API</h2><p>Java12 中引入 JVM 常量 API，用来更容易地对关键类文件和运行时构件的描述信息进行建模，特别是对那些从常量池加载的常量，这是一项非常技术性的变化，能够以更简单、标准的方式处理可加载常量。</p><p>具体来说就是<code>java.base</code>模块新增了<code>java.lang.constant</code>包，引入了<code>ConstantDesc</code>接口以及<code>Constable</code>接口。<code>ConstantDesc</code>的子接口包括：</p><ul><li><code>ClassDesc</code>：Class 的可加载常量标称描述符；</li><li><code>MethodTypeDesc</code>：方法类型常量标称描述符；</li><li><code>MethodHandleDesc</code>：方法句柄常量标称描述符；</li><li><code>DynamicConstantDesc</code>：动态常量标称描述符。</li></ul><p>继续挖坑，这部分内容会在进阶篇再详细介绍，敬请关注公众号「看山的小屋」。</p><h2 id="改进-AArch64-实现"><a href="#改进-AArch64-实现" class="headerlink" title="改进 AArch64 实现"></a>改进 AArch64 实现</h2><p>Java12 中将只保留一套 AArch64 实现，之前版本中，有两个关于 aarch64 的实现，分别是<code>ope/src/hotspot/cpu/arm</code>以及<code>open/src/hotspot/cpu/aarch64</code>，它们的实现重复了。为了集中精力更好地实现 aarch64，删除了<code>open/src/hotspot/cpu/arm</code>中与 arm64（64-bit Arm platform）实现相关的代码，只保留 32 位 ARM 端口和 64 位 aarch64 的端口。</p><p>这样做，可以让开发人员将目标集中在剩下的这个 64 位 ARM 实现上，消除维护两套端口所需的重复工作。</p><p>目标聚焦，力量集中。</p><h2 id="默认使用类数据共享（CDS）存档"><a href="#默认使用类数据共享（CDS）存档" class="headerlink" title="默认使用类数据共享（CDS）存档"></a>默认使用类数据共享（CDS）存档</h2><p>在 <a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a> 中我们介绍过类数据共享（CDS，Class Data Sharing），其作用是通过构建时生成默认类列表，在运行时使用内存映射，减少 Java 的启动时间和减少动态内存占用量，也能在多个 Java 虚拟机之间共享相同的归档文件，减少运行时的资源占用。</p><p>在 Java12 之前，想要使用需要三步走手动开启，到了 Java12，将默认开启 CDS 功能，想要关闭，需要使用参数<code>-Xshare:off</code>。</p><h2 id="改善-G1-垃圾收集器"><a href="#改善-G1-垃圾收集器" class="headerlink" title="改善 G1 垃圾收集器"></a>改善 G1 垃圾收集器</h2><h3 id="能够中止收集"><a href="#能够中止收集" class="headerlink" title="能够中止收集"></a>能够中止收集</h3><p>G1 垃圾收集器可以在大内存多处理器的工作场景中提升回收效率，能够满足用户预期降低 STW 停顿时间。</p><p>其内部是采用一个高级分析引擎来选择在收集期间要处理的工作量，此选择过程的结果是一组称为 GC 回收集（collection set，CSet）的区域。一旦收集器确定了 GC 回收集 并且 GC 回收、整理工作已经开始，则 G1 收集器必须完成收集集合集的所有区域中的所有活动对象之后才能停止；但是如果收集器选择过大的 GC 回收集，可能会导致 G1 回收器停顿时间超过预期时间。</p><p>在 Java12 中，GC 回收集拆分为必需和可选两部分，使 G1 垃圾回收器能中止垃圾回收过程。其中必需处理的部分包括 G1 垃圾收集器不能递增处理的 GC 回收集的部分，同时也可以包含老年代以提高处理效率。在 G1 垃圾回收器完成收集需要必需回收的部分之后，G1 垃圾回收器可以根据剩余时间决定是否停止收集。</p><h3 id="向操作系统自动返回未用堆内存"><a href="#向操作系统自动返回未用堆内存" class="headerlink" title="向操作系统自动返回未用堆内存"></a>向操作系统自动返回未用堆内存</h3><p>在 Java11 中，G1 仅在进行 Full GC 或并发处理周期时才能向操作系统返还堆内存，但是这两种场景都是 G1 极力避免的，所以如果我们使用 G1 收集器，基本上很难返还 Java 堆内存，这样对于那种周期性执行大量占用内存的应用，会造成比较多的内存浪费。</p><p>Java12 中，G1 垃圾收集器将在应用程序不活动期间定期生成或持续循环检查整体 Java 堆使用情况，以便 G1 垃圾收集器能够更及时的将 Java 堆中不使用内存部分返还给操作系统。对于长时间处于空闲状态的应用程序，此项改进将使 JVM 的内存利用率更加高效。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java12 新增的特性，完整的特性清单可以从<a href="https://openjdk.java.net/projects/jdk/12/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/12/</a>查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-12-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java12 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122530460" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java12 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文讲解一下 Java12 的特性，作为第一个长期支持版 Java11 之后的第一个版本，增加的功能也不少，除了一些小幅度的 API 增强，增加了另一个试验阶段的垃圾收集器 Shenandoah、对 G1 做了优化、增加微基准套件等。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java12" scheme="https://www.howardliu.cn/tags/Java12/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java11 的新特性</title>
    <link href="https://www.howardliu.cn/java-11-features/"/>
    <id>https://www.howardliu.cn/java-11-features/</id>
    <published>2022-01-09T14:09:15.000Z</published>
    <updated>2022-01-09T14:09:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/animal-gb69e2a049_1920.jpg" alt="Java11 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java11 是 2018 年 9 月发布的，是自 Java8 之后第一个长期支持版（long-term support，LTS）。相比于其他版本 6 个月维护期，长期支持版的维护期是 3 年。</p><p>长期支持版的更新会比较多，而且都是相对稳定的更新。今天我们就一起看看 Java11 都有哪些喜人的变化：增强的 API、全新的 HTTP 客户端、<a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">基于嵌套关系的访问控制优化</a>、低开销的堆性能采用工具、ZGC、Epsilon 垃圾收集器、飞行记录器等。</p><h2 id="增强-String"><a href="#增强-String" class="headerlink" title="增强 String"></a>增强 String</h2><p>首先说下<code>String</code>中新增的方法：<code>repeat</code>、<code>strip</code>、<code>stripLeading</code>、<code>stripTrailing</code>、<code>isBlank</code>、<code>lines</code>。这些方法还是挺有用的，以前我们可能需要借助第三方类库（比如 Apache 出品的 commons-lang）中的工具类，现在可以直接使用嫡亲方法了。</p><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><p><code>repeat</code>是实例方法，顾名思义，这个方法是返回给定字符串的重复值的，参数是<code>int</code>类型，传参的时候需要注意：</p><ul><li>如果重复次数小于 0 会抛出<code>IllegalArgumentException</code>异常；</li><li>如果重复次数为 0 或者字符串本身是空字符串，将返回空字符串；</li><li>如果重复次数为 1 直接返回本身；</li><li>如果字符串重复指定次数后，长度超过<code>Integer.MAX_VALUE</code>，会抛出<code>OutOfMemoryError</code>错误。</li></ul><p>用法很简单：</p><pre><code class="java">@Testvoid testRepeat() {    String output = &quot;foo &quot;.repeat(2) + &quot;bar&quot;;    assertEquals(&quot;foo foo bar&quot;, output);}</code></pre><p>小而美的一个工具方法。</p><h3 id="strip、stripLeading、stripTrailing"><a href="#strip、stripLeading、stripTrailing" class="headerlink" title="strip、stripLeading、stripTrailing"></a>strip、stripLeading、stripTrailing</h3><p><code>strip</code>方法算是<code>trim</code>方法的增强版，<code>trim</code>方法可以删除字符串两侧的空白字符（空格、tab 键、换行符），但是对于<code>Unicode</code>的空白字符无能为力，<code>strip</code>补足这一短板。</p><p>用起来是这样的：</p><pre><code class="java">@Testvoid testTrip() {    final String output = &quot;\n\t  hello   \u2005&quot;.strip();    assertEquals(&quot;hello&quot;, output);    final String trimOutput = &quot;\n\t  hello   \u2005&quot;.trim();    assertEquals(&quot;hello   \u2005&quot;, trimOutput);}</code></pre><p>对比一下可以看到，<code>trim</code>方法的清理功能稍弱。</p><p><code>stripLeading</code>和<code>stripTrailing</code>与<code>strip</code>类似，区别是一个清理头，一个清理尾。用法如下：</p><pre><code class="java">@Testvoid testTripLeading() {    final String output = &quot;\n\t  hello   \u2005&quot;.stripLeading();    assertEquals(&quot;hello   \u2005&quot;, output);}@Testvoid testTripTrailing() {    final String output = &quot;\n\t  hello   \u2005&quot;.stripTrailing();    assertEquals(&quot;\n\t  hello&quot;, output);}</code></pre><h3 id="isBlank"><a href="#isBlank" class="headerlink" title="isBlank"></a>isBlank</h3><p>这个方法是用于判断字符串是否都是空白字符，除了空格、tab 键、换行符，也包括<code>Unicode</code>的空白字符。</p><p>用法很简单：</p><pre><code class="java">@Testvoid testIsBlank() {    assertTrue(&quot;\n\t\u2005&quot;.isBlank());}</code></pre><h3 id="lines"><a href="#lines" class="headerlink" title="lines"></a>lines</h3><p>最后这个方法是将字符串转化为字符串<code>Stream</code>类型，字符串分隔依据是换行符：<code>\n</code>、<code>\r</code>、<code>\r\n</code>，用法如下：</p><pre><code class="java">@Testvoid testLines() {    final String multiline = &quot;This is\n \na multiline\nstring.&quot;;    final String output = multiline.lines()            .filter(Predicate.not(String::isBlank))            .collect(Collectors.joining(&quot; &quot;));    assertEquals(&quot;This is a multiline string.&quot;, output);}</code></pre><h2 id="增强文件读写"><a href="#增强文件读写" class="headerlink" title="增强文件读写"></a>增强文件读写</h2><p>本次更新在<code>Files</code>中增加了两个方法：<code>readString</code>和<code>writeString</code>。<code>writeString</code>作用是将指定字符串写入文件，<code>readString</code>作用是从文件中读出内容到字符串。是一个对<code>Files</code>工具类的增强，封装了对输出流、字节等内容的操作。</p><p>用法比较简单：</p><pre><code class="java">@Testvoid testReadWriteString() throws IOException {    final Path tmpPath = Path.of(&quot;./&quot;);    final Path tempFile = Files.createTempFile(tmpPath, &quot;demo&quot;, &quot;.txt&quot;);    final Path filePath = Files.writeString(tempFile, &quot;看山 howardliu.cn\n 公众号：看山的小屋&quot;);    assertEquals(tempFile, filePath);    final String fileContent = Files.readString(filePath);    assertEquals(&quot;看山 howardliu.cn\n 公众号：看山的小屋&quot;, fileContent);    Files.deleteIfExists(filePath);}</code></pre><p><code>readString</code>和<code>writeString</code>还可以指定字符集，不指定默认使用<code>StandardCharsets.UTF_8</code>字符集，可以应对大部分场景了。</p><h2 id="增强集合的数组操作"><a href="#增强集合的数组操作" class="headerlink" title="增强集合的数组操作"></a>增强集合的数组操作</h2><p><code>java.util.Collection</code>提供了集合转数组的方法有两个：</p><ul><li><code>Object[] toArray()</code>：可以直接转数组，但是转换后是<code>Object</code>类型，后续使用的时候，需要强转，太不优雅了；</li><li><code>&lt;T&gt; T[] toArray(T[] a)</code>：传入一个指定类型的数组，一般会有另种实现：<ul><li>一是，如果传入数组长度小于列表长度，会借助<code>Arrays.copyOf</code>创建列表长度的数组，这个数组与传入数组参数没有关系</li><li>二是，如果传入数组长度大于等于列表长度，会借助<code>System.arraycopy</code>将列表写入数组，超过长度的数组元素置为<code>null</code>。</li></ul></li></ul><p>我们一般这样用：</p><pre><code class="java">@Testvoid testArray() {    final List&lt;String&gt; vars = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);    final Object[] objArray = vars.toArray();    final String[] strArray = vars.toArray(new String[0]);    Assertions.assertTrue(Arrays.asList(strArray).contains(&quot;1&quot;));    Assertions.assertTrue(Arrays.asList(strArray).contains(&quot;2&quot;));    Assertions.assertTrue(Arrays.asList(strArray).contains(&quot;3&quot;));}</code></pre><p>在 Java11 中，又新增了一种实现，相当于对<code>&lt;T&gt; T[] toArray(T[] a)</code>做了增强，其源码是：</p><pre><code class="java">default &lt;T&gt; T[] toArray(IntFunction&lt;T[]&gt; generator) {    return toArray(generator.apply(0));}</code></pre><p>可以看到，是通过传入一个<code>IntFunction</code>类型的函数，然后调用<code>&lt;T&gt; T[] toArray(T[] a)</code>创建数组，其实是采用了我们常用的给<code>toArray</code>传入空数组的方式，用法如下：</p><pre><code class="java">@Testvoid testArray() {    final List&lt;String&gt; vars = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);    final String[] strArray2 = vars.toArray(String[]::new);    Assertions.assertTrue(Arrays.asList(strArray2).contains(&quot;1&quot;));    Assertions.assertTrue(Arrays.asList(strArray2).contains(&quot;2&quot;));    Assertions.assertTrue(Arrays.asList(strArray2).contains(&quot;3&quot;));}</code></pre><p>从使用上，似乎没有太多的提升，但是写法上，使用了函数式编程，是不是很优雅。</p><p><img src="https://static.howardliu.cn/Illustration/smile_1.jpg" alt="优雅的假笑"></p><h2 id="增强函数-Predicate"><a href="#增强函数-Predicate" class="headerlink" title="增强函数 Predicate"></a>增强函数 Predicate</h2><p>这个也是方法增强，在以前，我们在<code>Stream</code>中的<code>filter</code>方法判断否的时候，一般需要<code>!</code>运算，比如我们想要找到字符串列表中的数字，可以这样写：</p><pre><code class="java">final List&lt;String&gt; list = Arrays.asList(&quot;1&quot;, &quot;a&quot;);final List&lt;String&gt; nums = list.stream()        .filter(NumberUtils::isDigits)        .collect(Collectors.toList());Assertions.assertEquals(1, nums.size());Assertions.assertTrue(nums.contains(&quot;1&quot;));</code></pre><p>想要找到非数字的，<code>filter</code>方法写的就会用到<code>!</code>非操作：</p><pre><code class="java">final List&lt;String&gt; notNums = list.stream()        .filter(x -&gt; !NumberUtils.isDigits(x))        .collect(Collectors.toList());Assertions.assertEquals(1, notNums.size());Assertions.assertTrue(notNums.contains(&quot;a&quot;));</code></pre><p>Java11 中为<code>Predicate</code>增加<code>not</code>方法，可以更加简单的实现非操作：</p><pre><code class="java">final List&lt;String&gt; notNums2 = list.stream()        .filter(Predicate.not(NumberUtils::isDigits))        .collect(Collectors.toList());Assertions.assertEquals(1, notNums2.size());Assertions.assertTrue(notNums2.contains(&quot;a&quot;));</code></pre><p>有些教程还会推崇静态引入，比如在头部使用<code>import static java.util.function.Predicate.not</code>，这样在函数式编程时，可以写更少的代码，语义更强，比如：</p><pre><code class="java">final List&lt;String&gt; notNums2 = list.stream()        .filter(not(NumberUtils::isDigits))        .collect(toList());</code></pre><p>喜好随人，没有优劣。</p><h2 id="Lambda-中的局部变量"><a href="#Lambda-中的局部变量" class="headerlink" title="Lambda 中的局部变量"></a>Lambda 中的局部变量</h2><p>局部变量是 Java10 中增加的特性，具体可以查看 <a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a> 中的介绍，但是不支持在 Lambda 中使用局部变量。</p><p>在 Lambda 中，我们可以这样操作：</p><pre><code class="java">(String s1, String s2) -&gt; s1 + s2</code></pre><p>也可以这样：</p><pre><code class="java">(s1, s2) -&gt; s1 + s2</code></pre><p>到 Java11 之后，我们还能这样：</p><pre><code class="java">(var s1, var s2) -&gt; s1 + s2</code></pre><p>单纯从语法上，似乎没啥特点，但是如果再加上一些别的用法，比如：</p><pre><code class="java">(@Nonnull var s1, @Nullable var s2) -&gt; s1 + s2</code></pre><p>是不是就能看出差别了，我们可以有如下的操作：</p><pre><code class="java">@Testvoid testLocalVariable() {    final List&lt;String&gt; sampleList = Arrays.asList(&quot;Hello&quot;, &quot;World&quot;);    final String resultString = sampleList.stream()            .map((@NotNull var x) -&gt; x.toUpperCase())            .collect(Collectors.joining(&quot;, &quot;));    Assertions.assertEquals(&quot;HELLO, WORLD&quot;, resultString);}</code></pre><p>不过，这里还是有一些限制，比如：</p><p>如果是多个参数，不能有的使用<code>var</code>修饰，有的不指定类型：</p><pre><code class="java">// 错误写法(var s1, s2) -&gt; s1 + s2</code></pre><p>或者，不能混合使用，一个使用<code>var</code>修饰，一个使用明确的类型：</p><pre><code class="java">// 错误写法(var s1, String s2) -&gt; s1 + s2</code></pre><p>如果是单个参数，如果是单行操作，我们可以不写<code>{}</code>，但是使用<code>var</code>修饰的时候，就不能省略<code>{}</code>了：</p><pre><code class="java">// 错误写法var s1 -&gt; s1.toUpperCase()</code></pre><p>还是有一些限制的，我们在便利的同时，需要符合一定的约束。自由和规范不冲突。</p><h2 id="转正的-HTTP-客户端"><a href="#转正的-HTTP-客户端" class="headerlink" title="转正的 HTTP 客户端"></a>转正的 HTTP 客户端</h2><p>在 <a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a> 中说过，Java 中有一个全新的 HTTP 客户端，当时还在孵化模块中，到 Java11 可以正式使用了。</p><p>新客户端用法简单、性能可靠，而且支持功能也多。我们先简单看下使用：</p><pre><code class="java">@Testvoid testHttpClient() throws IOException, InterruptedException {    final HttpClient httpClient = HttpClient.newBuilder()            .version(HttpClient.Version.HTTP_2)            .connectTimeout(Duration.ofSeconds(20))            .build();    final HttpRequest httpRequest = HttpRequest.newBuilder()            .GET()            .uri(URI.create(&quot;https://www.howardliu.cn/robots.txt&quot;))            .build();    final HttpResponse&lt;String&gt; httpResponse = httpClient.send(httpRequest, BodyHandlers.ofString());    final String responseBody = httpResponse.body();    assertTrue(responseBody.contains(&quot;Allow&quot;));}</code></pre><h2 id="基于嵌套关系的访问控制优化"><a href="#基于嵌套关系的访问控制优化" class="headerlink" title="基于嵌套关系的访问控制优化"></a>基于嵌套关系的访问控制优化</h2><p>这部分是遗留的技术债务，从 Java1.1 开始，到 Java11 修复，属于 Valhalla 项目的一部分，我们在 <a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a> 一文中有详细解释，这里就不再赘述了。</p><h2 id="增强-java-命令"><a href="#增强-java-命令" class="headerlink" title="增强 java 命令"></a>增强 java 命令</h2><p>在 Java11 之前，想要运行源文件，需要先通过<code>javac</code>命令编译，然后使用<code>java</code>命令运行，先可以直接使用<code>java</code>运行了：</p><pre><code class="java">$ java HelloWorld.javaHello Java 11!</code></pre><h2 id="动态类文件常量"><a href="#动态类文件常量" class="headerlink" title="动态类文件常量"></a>动态类文件常量</h2><p>为了使 JVM 对动态语言更具吸引力，Java 指令集引入了 invokedynamic。</p><p>不过 Java 开发人员通常不会注意到此功能，因为它隐藏在 Java 字节代码中。通过使用 invokedynamic，可以延迟方法调用的绑定。例如，Java 语言使用该技术来实现 Lambda 表达式，这些表达式仅在首次使用时才显示出来。这样做，invokedynamic 已经演变成一种必不可少的语言功能。</p><p>Java 11 引入了类似的机制，扩展了 Java 文件格式，以支持新的常量池：CONSTANT_Dynamic，它在初始化的时候，像 invokedynamic 指令生成代理方法一样，委托给 bootstrap 方法进行初始化创建，对上层软件没有很大的影响，降低开发新形式的可实现类文件约束带来的成本和干扰。</p><p>此功能可提高性能，并面向语言设计人员和编译器实现人员。</p><h2 id="低开销的堆性能采用工具"><a href="#低开销的堆性能采用工具" class="headerlink" title="低开销的堆性能采用工具"></a>低开销的堆性能采用工具</h2><p>Java 11 中提供一种低开销的 Java 堆分配采样方法，能够得到堆分配的 Java 对象信息，并且能够通过 JVMTI 访问堆信息。</p><p>引入这个低开销内存分析工具是为了达到如下目的：</p><ul><li>足够低的开销，可以默认且一直开启；</li><li>能通过定义好的程序接口访问；</li><li>能够对所有堆分配区域进行采样；</li><li>能给出正在和未被使用的 Java 对象信息。</li></ul><p>对用户来说，了解堆中内存分布是非常重要的，特别是遇到生产环境中出现的高 CPU、高内存占用率的情况。目前有一些已经开源的工具，允许用户分析应用程序中的堆使用情况，比如：Java Flight Recorder、jmap、YourKit 以及 VisualVM tools.。但是这些工具都有一个明显的不足之处：无法得到对象的分配位置，headp dump 以及 heap histogram 中都没有包含对象分配的具体信息，但是这些信息对于调试内存问题至关重要，因为它能够告诉开发人员他们的代码中发生的高内存分配的确切位置，并根据实际源码来分析具体问题，这也是 Java 11 中引入这种低开销堆分配采样方法的原因。</p><h2 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h2><p>ZGC 是一个可伸缩、低延迟的垃圾收集器，性能由于 G1 收集器，从 Java11 开始可以在 Linux/x64 平台体验，全平台支持是从 Java17 开始。详细介绍可以从<a href="https://wiki.openjdk.java.net/display/zgc/Main" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/zgc/Main</a>查看。</p><p>在 Java11 中尚处于试验阶段，没有包含在 JDK 构建中，想要启用，需要在 JDK 编译时添加参数<code>--with-jvm-features=zgc</code>。显式启用了 ZGC 之后，我们可以使用构建好的 JDK 启动，需要添加参数<code>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code>。</p><p>ZGC 有下面几个目标：</p><ul><li>GC 停顿时间不超过 10ms</li><li>可以处理从几百 MB 的小堆，到几个 TB 的大堆</li><li>与 G1 回收算法相比，应用吞吐能力不会下降超过 15%</li><li>为未来的 GC 特性和优化有色指针和负载屏障奠定基础</li></ul><p>从<a href="https://openjdk.java.net/jeps/333" target="_blank" rel="noopener">https://openjdk.java.net/jeps/333</a>给出的数据可以看出来，在 128G 堆大小的测试中，ZGC 优势明显，找了一张网上的图片：</p><p><img src="https://static.howardliu.cn/java/java-11-1.png" alt="SPECjbb 2015 的基准测试"></p><p>这里预告一下，Java12 中也增加了一个实现阶段的垃圾收集器 Shenandoah，到时候咱们看一下。</p><h2 id="改进-Aarch64-指令集"><a href="#改进-Aarch64-指令集" class="headerlink" title="改进 Aarch64 指令集"></a>改进 Aarch64 指令集</h2><p>Java 11 优化了 ARM64 或 Arch64 处理器上现有的字符串和数组内部函数。还为<code>java.lang.Math</code>的<code>sin</code>、<code>cos</code>和<code>log</code>方法实现了新的内部函数。</p><p>我们像其他函数一样使用内在函数，但是，编译器会以特殊的方式处理内部函数，将使用 CPU 体系结构特定的汇编代码来提高性能。可以关注一下<code>HotSpotIntrinsicCandidate</code>这个注解。</p><h2 id="Epsilon-垃圾收集器"><a href="#Epsilon-垃圾收集器" class="headerlink" title="Epsilon 垃圾收集器"></a>Epsilon 垃圾收集器</h2><p>Java11 引入了一个新的实验性垃圾收集器：Epsilon。Epsilon 垃圾收集器提供一个完全消极的 GC 实现，分配有限的内存资源，最大限度的降低内存占用和内存吞吐延迟时间，适用于模拟内存不足错误的场景。</p><p>Epsilon 垃圾收集器有几个使用场景：</p><ul><li>性能测试：无操作的垃圾收集器可以过滤因为收集器自身原因造成的性能损失；</li><li>内存压力测试：可以用于验证分配内存的阈值；</li><li>VM 接口测试：以 VM 开发视角，有一个简单的 GC 实现，有助于理解 VM-GC 的最小接口实现。它也用于证明 VM-GC 接口的健全性；</li><li>存活极短的任务：这种生命周期极短的任务，需要实现快速启动、快速释放资源的特性。开发者知道这种任务的内存阈值是多少，很大概率上，任务存活周期内，不会触发垃圾回收，就需要一个什么也不干的收集器站着位置就行。</li></ul><p>可以通过<code>-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC</code>参数开启。</p><h2 id="飞行记录器（Flight-Recorder）"><a href="#飞行记录器（Flight-Recorder）" class="headerlink" title="飞行记录器（Flight Recorder）"></a>飞行记录器（Flight Recorder）</h2><p>飞行记录器（Flight Recorder）可是个好东西，之前是 Oracle JDK 中的一个商用产品，现已在 Open JDK 中开源。这是一种低开销的事件信息收集框架，主要用于对应用程序和 JVM 进行故障检查、分析。</p><p>飞行记录器记录的主要数据源于应用程序、JVM 和操作系统，这些事件信息保存在单独的事件记录文件中，故障发生后，能够从事件记录文件中提取出有用信息对故障进行分析。有些类似于飞机上的黑匣子。</p><p><img src="https://static.howardliu.cn/Illustration/800.jpeg" alt="飞机上的黑匣子"></p><p>比如，我们可以使用以下参数开启一个时长为 120 秒的记录：</p><pre><code class="shell">-XX:StartFlightRecording=duration=120s,settings=profile,filename=recording.jfr</code></pre><p>生成的文件可以使用 JMC 工具可视化查看，也可以自己写代码通过<code>RecordedEvent</code>解析。不过嘛，有可视化的，干嘛还要自己敲代码呢？</p><p>我们也可以在运行时通过<code>jcmd</code>命令启动记录：</p><pre><code class="shell">$ jcmd &lt;pid&gt; JFR.start$ jcmd &lt;pid&gt; JFR.dump filename=recording.jfr$ jcmd &lt;pid&gt; JFR.stop</code></pre><p>收到监控，想推广一下之前写的开源监控组件 Cynomys，源码在<a href="https://github.com/howardliu-cn/cynomys" target="_blank" rel="noopener">https://github.com/howardliu-cn/cynomys</a>，里面包含通过 Netty 实现的 RPC 框架、javaagent 实现的探针、使用 javassist 操作字节码、JMX 实现 JVM 内部监控等，可以对操作系统、网络、JVM、请求、SQL 等内容进行监控。</p><h2 id="移除或过期组件"><a href="#移除或过期组件" class="headerlink" title="移除或过期组件"></a>移除或过期组件</h2><p>社会在发展，技术在进步。又有一些功能或组件不合时宜，要么移除、要么标记过期。标记过期的最好不要再用了，不知道哪天就会被移除，想要升级依赖反而麻烦。</p><ul><li>JavaEE 和 CORBA：单独的 JavaEE 版本可以从第三方站点获取，所以在 JavaSEO 中不再包含。从 Java9 开始，JavaEE 和 CORBA 模块已经标记为过期，到 Java11 就完全移除。</li><li>JMC 从 JDK 中移除，可以单独下载。</li><li>JavaFX 也是这样，从 JDK 模块从中移除，需要单独引入。</li><li>Nashorn JavaScript 引擎标记为废弃</li><li>Jar 包的 Pack200 压缩方案标记为废弃</li></ul><h2 id="其他小改动"><a href="#其他小改动" class="headerlink" title="其他小改动"></a>其他小改动</h2><ul><li>实现了新的 ChaCha20 和 ChaCha20-Poly1305 加密算法，取代不安全的 RC4。</li><li>使用 Curve25519 和 Curve448 支持加密密钥协议，以取代现有的 ECDH 方案</li><li>升级 TLS 版本到 1.3，提升了安全性和性能</li><li>支持 Unicode 10， 带来了更多的字符、符号和表情符号</li></ul><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java11 新增的特性，完整的特性清单可以从<a href="https://openjdk.java.net/projects/jdk/11/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/11/</a>查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-11-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java11 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122401213" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java11 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      今天我们就一起看看 Java11 都有哪些喜人的变化：增强的 API、全新的 HTTP 客户端、[基于嵌套关系的访问控制优化](https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA)、低开销的堆性能采用工具、ZGC、Epsilon 垃圾收集器、飞行记录器等。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java11" scheme="https://www.howardliu.cn/tags/Java11/"/>
    
  </entry>
  
  <entry>
    <title>Java11 中基于嵌套关系的访问控制优化</title>
    <link href="https://www.howardliu.cn/java-11-jep181-nestmate/"/>
    <id>https://www.howardliu.cn/java-11-jep181-nestmate/</id>
    <published>2022-01-05T14:57:16.000Z</published>
    <updated>2022-01-05T14:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/rowan-2098486_1920.jpg" alt="Java11 中基于嵌套的权限控制"></p><p>你好，我是看山。</p><p>Java 语言很强大，但是，有人的地方就有江湖，有猿的地方就有 bug，Java 的核心代码并非十全十美。比如在 <a href="https://mp.weixin.qq.com/s/4jVPnaOr-rve3GQdukDFmA" target="_blank" rel="noopener">JDK 中居然也有反模式接口常量</a> 中介绍的反模式实现，以及本文说到的这个技术债务：嵌套关系（NestMate）调用方式。</p><a id="more"></a><p>在 Java 语言中，类和接口可以相互嵌套，这种组合之间可以不受限制的彼此访问，包括访问彼此的构造函数、字段、方法等。即使是<code>private</code>私有的，也可以彼此访问。比如下面这样定义：</p><pre><code class="java">public class Outer {    private int i;    public void print1() {        print11();        print12();    }    private void print11() {        System.out.println(i);    }    private void print12() {        System.out.println(i);    }    public void callInnerMethod() {        final Inner inner = new Inner();        inner.print4();        inner.print5();        System.out.println(inner.j);    }    public class Inner {        private int j;        public void print3() {            System.out.println(i);            print1();        }        public void print4() {            System.out.println(i);            print11();            print12();        }        private void print5() {            System.out.println(i);            print11();            print12();        }    }}</code></pre><p>上例中，<code>Outer</code>类中的字段<code>i</code>、方法<code>print11</code>和<code>print12</code>都是私有的，但是可以在<code>Inner</code>类中直接访问，<code>Inner</code>类的字段<code>j</code>、方法<code>print5</code>是私有的，也可以在<code>Outer</code>类中使用。这种设计是为了更好的封装，在用户看来，这几个彼此嵌套的类/接口是一体的，分开定义是为了更好的封装自己，隔离不同特性，但是有因为彼此是一体，所以私有元素也应该是共有的。</p><h2 id="Java11-之前的实现方式"><a href="#Java11-之前的实现方式" class="headerlink" title="Java11 之前的实现方式"></a>Java11 之前的实现方式</h2><p>我们使用 Java8 编译，然后借助<code>javap -c</code>命令分别查看<code>Outer</code>和<code>Inner</code>的结果。</p><pre><code class="shell">$ javap -c Outer.class      Compiled from &quot;Outer.java&quot;public class cn.howardliu.tutorials.java8.nest.Outer {  public cn.howardliu.tutorials.java8.nest.Outer();    Code:       0: aload_0       1: invokespecial #4                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V       4: return  public void print1();    Code:       0: aload_0       1: invokespecial #2                  // Method print11:()V       4: aload_0       5: invokespecial #1                  // Method print12:()V       8: return  public void callInnerMethod();    Code:       0: new           #7                  // class cn/howardliu/tutorials/java8/nest/Outer$Inner       3: dup       4: aload_0       5: invokespecial #8                  // Method cn/howardliu/tutorials/java8/nest/Outer$Inner.&quot;&lt;init&gt;&quot;:(Lcn/howardliu/tutorials/java8/nest/Outer;)V       8: astore_1       9: aload_1      10: invokevirtual #9                  // Method cn/howardliu/tutorials/java8/nest/Outer$Inner.print4:()V      13: aload_1      14: invokestatic  #10                 // Method cn/howardliu/tutorials/java8/nest/Outer$Inner.access$000:(Lcn/howardliu/tutorials/java8/nest/Outer$Inner;)V      17: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;      20: aload_1      21: invokestatic  #11                 // Method cn/howardliu/tutorials/java8/nest/Outer$Inner.access$100:(Lcn/howardliu/tutorials/java8/nest/Outer$Inner;)I      24: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V      27: return  static int access$200(cn.howardliu.tutorials.java8.nest.Outer);    Code:       0: aload_0       1: getfield      #3                  // Field i:I       4: ireturn  static void access$300(cn.howardliu.tutorials.java8.nest.Outer);    Code:       0: aload_0       1: invokespecial #2                  // Method print11:()V       4: return  static void access$400(cn.howardliu.tutorials.java8.nest.Outer);    Code:       0: aload_0       1: invokespecial #1                  // Method print12:()V       4: return}</code></pre><p>再来看看<code>Inner</code>的编译结果，这里需要注意的是，内部类会使用特殊的命名方式定义<code>Inner</code>类，最终会将编译结果存储在两个文件中：</p><pre><code class="shell">$ javap -c Outer\$Inner.classCompiled from &quot;Outer.java&quot;public class cn.howardliu.tutorials.java8.nest.Outer$Inner {  final cn.howardliu.tutorials.java8.nest.Outer this$0;  public cn.howardliu.tutorials.java8.nest.Outer$Inner(cn.howardliu.tutorials.java8.nest.Outer);    Code:       0: aload_0       1: aload_1       2: putfield      #3                  // Field this$0:Lcn/howardliu/tutorials/java8/nest/Outer;       5: aload_0       6: invokespecial #4                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V       9: return  public void print3();    Code:       0: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;       3: aload_0       4: getfield      #3                  // Field this$0:Lcn/howardliu/tutorials/java8/nest/Outer;       7: invokestatic  #6                  // Method cn/howardliu/tutorials/java8/nest/Outer.access$200:(Lcn/howardliu/tutorials/java8/nest/Outer;)I      10: invokevirtual #7                  // Method java/io/PrintStream.println:(I)V      13: aload_0      14: getfield      #3                  // Field this$0:Lcn/howardliu/tutorials/java8/nest/Outer;      17: invokevirtual #8                  // Method cn/howardliu/tutorials/java8/nest/Outer.print1:()V      20: return  public void print4();    Code:       0: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;       3: aload_0       4: getfield      #3                  // Field this$0:Lcn/howardliu/tutorials/java8/nest/Outer;       7: invokestatic  #6                  // Method cn/howardliu/tutorials/java8/nest/Outer.access$200:(Lcn/howardliu/tutorials/java8/nest/Outer;)I      10: invokevirtual #7                  // Method java/io/PrintStream.println:(I)V      13: aload_0      14: getfield      #3                  // Field this$0:Lcn/howardliu/tutorials/java8/nest/Outer;      17: invokestatic  #9                  // Method cn/howardliu/tutorials/java8/nest/Outer.access$300:(Lcn/howardliu/tutorials/java8/nest/Outer;)V      20: aload_0      21: getfield      #3                  // Field this$0:Lcn/howardliu/tutorials/java8/nest/Outer;      24: invokestatic  #10                 // Method cn/howardliu/tutorials/java8/nest/Outer.access$400:(Lcn/howardliu/tutorials/java8/nest/Outer;)V      27: return  static void access$000(cn.howardliu.tutorials.java8.nest.Outer$Inner);    Code:       0: aload_0       1: invokespecial #2                  // Method print5:()V       4: return  static int access$100(cn.howardliu.tutorials.java8.nest.Outer$Inner);    Code:       0: aload_0       1: getfield      #1                  // Field j:I       4: ireturn}</code></pre><p>我们可以看到，<code>Outer</code>和<code>Inner</code>中多出了几个方法，方法名格式是<code>access$*00</code>。</p><p><code>Outer</code>中的<code>access$200</code>方法返回了属性<code>i</code>，<code>access$300</code>和<code>access$400</code>分别调用了<code>print11</code>和<code>print12</code>方法。这些新增的方法都是静态方法，作用域是默认作用域，即包内可用。这些方法最终被<code>Inner</code>类中的<code>print3</code>和<code>print4</code>调用，相当于间接调用<code>Outer</code>中的私有属性或方法。</p><p>我们称这些生成的方法为“桥”方法（Bridge Method），是一种实现嵌套关系内部互相访问的方式。</p><p>在编译的时候，Java 为了保持类的单一特性，会将嵌套类编译到多个 class 文件中，同时为了保证嵌套类能够彼此访问，自动创建了调用私有方法的“桥”方法，这样，在保持原有定义不变的情况下，又实现了嵌套语法。</p><h2 id="技术债务"><a href="#技术债务" class="headerlink" title="技术债务"></a>技术债务</h2><p>“桥”方法的实现是比较巧妙的，但是这会造成源码与编译结果访问控制权限不一致，比如，我们可以在<code>Inner</code>中调用<code>Outer</code>中的私有方法，按照道理来说，我们可以在<code>Inner</code>中通过反射调用<code>Outer</code>的方法，但实际上不行，会抛出<code>IllegalAccessException</code>异常。我们验证一下：</p><pre><code class="java">public class Outer {    // 省略其他方法    public void callInnerReflectionMethod()            throws InvocationTargetException, NoSuchMethodException, IllegalAccessException {        final Inner inner = new Inner();        inner.callOuterPrivateMethod(this);    }    public class Inner {        // 省略其他方法        public void callOuterPrivateMethod(Outer outer)                throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {            final Method method = outer.getClass().getDeclaredMethod(&quot;print12&quot;);            method.invoke(outer);        }    }}</code></pre><p>定义测试用例：</p><pre><code class="java">@Testvoid gotAnExceptionInJava8() {    final Outer outer = new Outer();    final Exception e = assertThrows(IllegalAccessException.class, outer::callInnerReflectionMethod);    e.printStackTrace();    assertDoesNotThrow(outer::callInnerMethod);}</code></pre><p>打印的异常信息是：</p><pre><code class="log">java.lang.IllegalAccessException: class cn.howardliu.tutorials.java8.nest.Outer$Inner cannot access a member of class cn.howardliu.tutorials.java8.nest.Outer with modifiers &quot;private&quot;    at java.base/jdk.internal.reflect.Reflection.newIllegalAccessException(Reflection.java:361)    at java.base/java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:591)    at java.base/java.lang.reflect.Method.invoke(Method.java:558)    at cn.howardliu.tutorials.java8.nest.Outer$Inner.callOuterPrivateMethod(Outer.java:62)    at cn.howardliu.tutorials.java8.nest.Outer.callInnerReflectionMethod(Outer.java:36)</code></pre><p>通过反射直接调用私有方法会失败，但是可以直接的或者通过反射访问这些“桥”方法，这样就比较奇怪了。所以提出 <a href="http://openjdk.java.net/jeps/181" target="_blank" rel="noopener">JEP181 改进</a>，修复这个技术债务的同时，为后续的改进铺路。</p><h2 id="Java11-中的实现"><a href="#Java11-中的实现" class="headerlink" title="Java11 中的实现"></a>Java11 中的实现</h2><p>我们再来看看 Java11 编译之后的结果：</p><pre><code class="shell">$ javap -c Outer.class      Compiled from &quot;Outer.java&quot;public class cn.howardliu.tutorials.java11.nest.Outer {  public cn.howardliu.tutorials.java11.nest.Outer();    Code:       0: aload_0       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V       4: return  public void print1();    Code:       0: aload_0       1: invokevirtual #2                  // Method print11:()V       4: aload_0       5: invokevirtual #3                  // Method print12:()V       8: return  public void callInnerMethod();    Code:       0: new           #7                  // class cn/howardliu/tutorials/java11/nest/Outer$Inner       3: dup       4: aload_0       5: invokespecial #8                  // Method cn/howardliu/tutorials/java11/nest/Outer$Inner.&quot;&lt;init&gt;&quot;:(Lcn/howardliu/tutorials/java11/nest/Outer;)V       8: astore_1       9: aload_1      10: invokevirtual #9                  // Method cn/howardliu/tutorials/java11/nest/Outer$Inner.print4:()V      13: aload_1      14: invokevirtual #10                 // Method cn/howardliu/tutorials/java11/nest/Outer$Inner.print5:()V      17: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;      20: aload_1      21: getfield      #11                 // Field cn/howardliu/tutorials/java11/nest/Outer$Inner.j:I      24: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V      27: return}</code></pre><p>是不是很干净，与<code>Outer</code>类的源码结构是一致的。我们再看看<code>Inner</code>有没有什么变化：</p><pre><code class="shell">$ javap -c Outer\$Inner.classCompiled from &quot;Outer.java&quot;public class cn.howardliu.tutorials.java11.nest.Outer$Inner {  final cn.howardliu.tutorials.java11.nest.Outer this$0;  public cn.howardliu.tutorials.java11.nest.Outer$Inner(cn.howardliu.tutorials.java11.nest.Outer);    Code:       0: aload_0       1: aload_1       2: putfield      #1                  // Field this$0:Lcn/howardliu/tutorials/java11/nest/Outer;       5: aload_0       6: invokespecial #2                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V       9: return  public void print3();    Code:       0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;       3: aload_0       4: getfield      #1                  // Field this$0:Lcn/howardliu/tutorials/java11/nest/Outer;       7: getfield      #4                  // Field cn/howardliu/tutorials/java11/nest/Outer.i:I      10: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V      13: aload_0      14: getfield      #1                  // Field this$0:Lcn/howardliu/tutorials/java11/nest/Outer;      17: invokevirtual #6                  // Method cn/howardliu/tutorials/java11/nest/Outer.print1:()V      20: return  public void print4();    Code:       0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;       3: aload_0       4: getfield      #1                  // Field this$0:Lcn/howardliu/tutorials/java11/nest/Outer;       7: getfield      #4                  // Field cn/howardliu/tutorials/java11/nest/Outer.i:I      10: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V      13: aload_0      14: getfield      #1                  // Field this$0:Lcn/howardliu/tutorials/java11/nest/Outer;      17: invokevirtual #7                  // Method cn/howardliu/tutorials/java11/nest/Outer.print11:()V      20: aload_0      21: getfield      #1                  // Field this$0:Lcn/howardliu/tutorials/java11/nest/Outer;      24: invokevirtual #8                  // Method cn/howardliu/tutorials/java11/nest/Outer.print12:()V      27: return}</code></pre><p>同样干净。</p><p>我们在通过测试用例验证一下反射调用：</p><pre><code class="java">@Testvoid doesNotGotAnExceptionInJava11() {    final Outer outer = new Outer();    assertDoesNotThrow(outer::callInnerReflectionMethod);    assertDoesNotThrow(outer::callInnerMethod);}</code></pre><p>结果是正常运行。</p><p>这就是 JEP181 期望的结果，源码和编译结果一致，访问控制一致。</p><h2 id="Nestmate-新增的-API"><a href="#Nestmate-新增的-API" class="headerlink" title="Nestmate 新增的 API"></a>Nestmate 新增的 API</h2><p>在 Java11 中还新增了几个 API，用于嵌套关系的验证：</p><h3 id="getNestHost"><a href="#getNestHost" class="headerlink" title="getNestHost"></a>getNestHost</h3><p>这个方法是返回嵌套主机（NestHost），转成普通话就是找到嵌套类的外层类。对于非嵌套类，直接返回自身（其实也算是返回外层类）。</p><p>我们看下用法：</p><pre><code class="java">@Testvoid checkNestHostName() {    final String outerNestHostName = Outer.class.getNestHost().getName();    assertEquals(&quot;cn.howardliu.tutorials.java11.nest.Outer&quot;, outerNestHostName);    final String innerNestHostName = Inner.class.getNestHost().getName();    assertEquals(&quot;cn.howardliu.tutorials.java11.nest.Outer&quot;, innerNestHostName);    assertEquals(outerNestHostName, innerNestHostName);    final String notNestClass = NotNestClass.class.getNestHost().getName();    assertEquals(&quot;cn.howardliu.tutorials.java11.nest.NotNestClass&quot;, notNestClass);}</code></pre><p>对于<code>Outer</code>和<code>Inner</code>都是返回了<code>cn.howardliu.tutorials.java11.nest.Outer</code>。</p><h3 id="getNestMembers"><a href="#getNestMembers" class="headerlink" title="getNestMembers"></a>getNestMembers</h3><p>这个方法是返回嵌套类的嵌套成员数组，下标是 0 的元素确定是 NestHost 对应的类，其他元素顺序没有给出排序规则。我们看下使用：</p><pre><code class="java">@Testvoid getNestMembers() {    final List&lt;String&gt; outerNestMembers = Arrays.stream(Outer.class.getNestMembers())            .map(Class::getName)            .collect(Collectors.toList());    assertEquals(2, outerNestMembers.size());    assertTrue(outerNestMembers.contains(&quot;cn.howardliu.tutorials.java11.nest.Outer&quot;));    assertTrue(outerNestMembers.contains(&quot;cn.howardliu.tutorials.java11.nest.Outer$Inner&quot;));    final List&lt;String&gt; innerNestMembers = Arrays.stream(Inner.class.getNestMembers())            .map(Class::getName)            .collect(Collectors.toList());    assertEquals(2, innerNestMembers.size());    assertTrue(innerNestMembers.contains(&quot;cn.howardliu.tutorials.java11.nest.Outer&quot;));    assertTrue(innerNestMembers.contains(&quot;cn.howardliu.tutorials.java11.nest.Outer$Inner&quot;));}</code></pre><h3 id="isNestmateOf"><a href="#isNestmateOf" class="headerlink" title="isNestmateOf"></a>isNestmateOf</h3><p>这个方法是用于判断两个类是否是彼此的 NestMate，彼此形成嵌套关系。判断依据还是嵌套主机，只要相同，两个就是 NestMate。我们看下使用：</p><pre><code class="java">@Testvoid checkIsNestmateOf() {    assertTrue(Inner.class.isNestmateOf(Outer.class));    assertTrue(Outer.class.isNestmateOf(Inner.class));}</code></pre><h2 id="后续的改进"><a href="#后续的改进" class="headerlink" title="后续的改进"></a>后续的改进</h2><p>嵌套关系是作为 Valhalla 项目的一部分，这个项目的主要目标之一是改进 JAVA 中的值类型和泛型。后续会有更多的改进：</p><ul><li>在泛型特化（generic specialization）中，每个特化类型（specialized type）可被创建为泛型的一个 Nestmate。</li><li>支持对<code>Unsafe.defineAnonymousClass()</code> API 的安全替换，实现将新类创建为已有类的 Nestmate。</li><li>可能会影响“密封类”（sealed classes），仅允许 Nestmate 的子类作为密封类。</li><li>可能会影响私有嵌套类型。私有嵌套类型当前定义为包内可访问（package-access）。</li></ul><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文阐述了基于嵌套关系的访问控制优化，其中涉及<code>NestMate</code>、<code>NestHost</code>、<code>NestMember</code>等概念。这次优化是 Valhalla 项目中一部分，主要改进 Java 中的值类型和泛型等。文中涉及源码都上传在 GitHub 上，关注公号「看山的小屋」回复“java”获取源码。</p><p>青山不改，绿水长流，咱们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-11-jep181-nestmate/">Java11 中基于嵌套关系的访问控制优化</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122334212" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Java 语言很强大，但是，有人的地方就有江湖，有猿的地方就有 bug，Java 的核心代码并非十全十美。比如在JDK 中居然也有反模式接口常量中介绍的反模式实现，以及本文说到的这个技术债务：嵌套关系（NestMate）调用方式。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java11" scheme="https://www.howardliu.cn/tags/Java11/"/>
    
  </entry>
  
  <entry>
    <title>这一年很幸运，平平淡淡的|2021 年度总结</title>
    <link href="https://www.howardliu.cn/2021-summary/"/>
    <id>https://www.howardliu.cn/2021-summary/</id>
    <published>2022-01-03T09:10:33.000Z</published>
    <updated>2022-01-03T09:10:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/wine-6688901_1920.jpg" alt="这一年很幸运，平平淡淡的|2021 年度总结"></p><p>你好，我是看山。</p><p>一晃又是一年，果然岁数越大，时间越快。有些内容在 <a href="https://mp.weixin.qq.com/s/_I8NtBk7NvGQt18jlxkW6Q" target="_blank" rel="noopener">原来还能这么干</a> 一文中聊了一些，今天再聊点别的。让我们一起总结过去，把握现在，展望未来。</p><p>总结下来，2021 年还算幸运，平平淡淡过一年。工作上按部就班，生活上一如既往。</p><a id="more"></a><p>如果说有什么可以出牛的，就是开始好好写文了。幸运的是在 2021 年最后一天，得到了 InfoQ 官方认可，成为签约作者。</p><h2 id="按部就班的工作"><a href="#按部就班的工作" class="headerlink" title="按部就班的工作"></a>按部就班的工作</h2><p>2021 年换了一份工作，感谢前司领导同事的帮助，知道了什么是好好工作，怎样做可以做好工作：</p><ol><li>一切用数字说话：if you cannot measure it, you cannot manage it;</li><li>做之前多想想怎么形成闭环：如果在想法上都没有闭环，那结果就经不起推敲；</li><li>方法论很重要：在没有绝对的有效处理事情的能力前，就学习一些方法论，指导工作；</li><li>坦诚待人：做到绝对坦诚不容易，可以先在工作上做到这点；</li><li>结果导向：一个人、一个团队、一个公司，都是为了一个目标在做事，如果没有结果，谈其他的都没有意义。</li></ol><p>到了现司之后，也有了一些感悟：孤胆英雄是没有办法生存的，团队才是能够好好工作的最小单位。</p><p>上面这些，每一条都可以描述很多，既然是年终总结，就先一笔带过，看官可以先自行体会一下。如果有必要，再开文详细聊聊。</p><h2 id="一如既往的生活"><a href="#一如既往的生活" class="headerlink" title="一如既往的生活"></a>一如既往的生活</h2><p>2021 年要好好感谢我媳妇，如果有哪位朋友恰好看到这篇文章，记得给小猪转发一下，我猜她一定忽略了我的这份心意。</p><p><img src="https://static.howardliu.cn/about/zhuzhu-qiqi.jpg" alt="朱朱和七七"></p><p>生活方面没有太多要说的，只有满心的感动和感激。</p><h2 id="其他方面的小确幸"><a href="#其他方面的小确幸" class="headerlink" title="其他方面的小确幸"></a>其他方面的小确幸</h2><p>在 <a href="https://mp.weixin.qq.com/s/IlgvUH79DEuCmUmTmqsqKg" target="_blank" rel="noopener">Geek 青年说北京沙龙分享</a> 中聊过，我是 2013 年开始写博客，2018 年停更一年，从 2021 年开始坚持周更。这个过程中，认识了很多志同道合的朋友，见到了很多优秀的博主。</p><p>一个人可以走的很快，一群人可以走的很远。</p><p>写博客是为了实现自己定的目标，不必太在意结果。不过，正如前面所说，一切用数字说话。下面就晒一下 2021 年的一些成绩（这些成绩和大佬没法比，只能小小的自嗨一下）：</p><p>C 站粉丝达到 17000，访问量有 870000：</p><p><img src="https://static.howardliu.cn/about/csdn-20220103.png" alt="2022 年 1 月 3 日，看山 CSDN 的详细资料"></p><p>C 站 1024 活动时，收货博客专家勋章：</p><p><img src="https://static.howardliu.cn/about/csdn-2021-october-24th.jpg" alt="CSDN1024 活动-博客专家勋章"></p><p>参加知乎海盐计划，直接升级到 4 级；</p><p>参加掘金 11 月更文活动，两次后端模块的周榜前 10；</p><p>参加 InfoQ 写作平台签约作者第二季，成功入选。评选结果是在 12 月 31 号公布的，算是给 2021 年的写作之旅画上一个不错的句号。</p><p><img src="https://static.howardliu.cn/about/InfoQ-xie-kanshan-1.jpg" alt="InfoQ 签约作者第二季"></p><p>除了写博客，今年也开始健身了。一开始是维嘉带着练，后来维嘉回了学校是跟着斌哥练，终于看到了 75 公斤的影子。</p><h2 id="2022-年的计划"><a href="#2022-年的计划" class="headerlink" title="2022 年的计划"></a>2022 年的计划</h2><p>新的一年，为了对自己负责，对家人负责，对朋友负责，我们总要做出新一年的计划。我 2022 年的计划就是搞定 2021 年那些原定于 2020 年未完成的安排，只为兑现 2019 年时要完成 2018 年许下的诺言，曾说 2017 年之后一定不要像 2016 年那样只会跟着 2015 年去做 2014 年没给 2013 年完成的那个目标。</p><p>哈哈哈，上面的文案摘自某音的段子，比较写实。</p><p>我真实的计划就不放出来了，心理学上有个研究结果，当多次向别人描述自己的计划，就会产生一种错觉，以为自己已经完成了计划。计划不广而告之，但是一定要有。</p><p>没有计划的人生不值得过。</p><p>青山不改，绿水长流，咱们下次见。</p><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/2021-summary/">这一年很幸运，平平淡淡的|2021 年度总结</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122334052" target="_blank" rel="noopener">这一年很幸运，平平淡淡的|2021 年度总结</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      一晃又是一年，果然岁数越大，时间越快。总结下来，2021 年还算幸运，平平淡淡过一年。工作上按部就班，生活上一如既往。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="年度总结" scheme="https://www.howardliu.cn/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>原来还能这么干——罗胖2022年《时间的朋友》观后感</title>
    <link href="https://www.howardliu.cn/2022-friends-of-time/"/>
    <id>https://www.howardliu.cn/2022-friends-of-time/</id>
    <published>2022-01-01T16:48:14.000Z</published>
    <updated>2022-01-01T16:48:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/nature-6891549_1920.jpg" alt="原来还能这么干——罗胖2022年《时间的朋友》观后感"></p><p>你好，我是看山。</p><p>就这样 2022 年了，年纪越大，时间越快，又到了罗胖《时间的朋友》直播的时候，看完后想写点什么，奈何腹中墨水太少，索性不难为自己，随便写写。由于疫情原因，罗胖今年的跨年演讲现场的观众全部都是熊猫娃娃，评论区有整场直播的视频回访和文字稿，有些事情，还是要自己亲自感受一下。</p><a id="more"></a><h2 id="打破思维的墙"><a href="#打破思维的墙" class="headerlink" title="打破思维的墙"></a>打破思维的墙</h2><p>整场演讲的主题是“原来还能这么干”，用我能够理解的话，就是打破思维的墙。</p><p>每个人都有自己的思维模式，这是我们赖以生存的根本，也是我们能够更快速、更高效处理普通事务的根本。之前在 <a href="https://mp.weixin.qq.com/s/JbFoEynzykrGBhOgu4Ne4w" target="_blank" rel="noopener">别让非理性思维毁了你的人生</a> 中聊过，我们的大脑为了节省能量，会经常处于自动驾驶模式，这让我们可以更有机会省出能量做其他事情。比如，我看看到知道冒白气的水是热的，不会直接喝；我们知道冷了要穿衣服，否则会生病……但是有些时候，我们用常规的办法解决不了问题，怎么办？</p><p>想要打破思维的墙，我们需要绝对的理性分析限制我们思维的问题是什么？真正要解决的问题有哪些？就不列举罗胖演讲中的例子了，我们考虑一下网约车出来之前那种打车难的问题。</p><p>很多人可能没有经历过打车难的时期，那个时候，我们没有办法知道哪里有出租车，只能就近在路边招手，出租车师傅同样不知道哪有顾客，只能满城转悠，或者在上客概率到的地方等着，比如 CBD、高铁站、机场等。平时还好，等会就等会，如果恰好有急事、或者带着老人小孩、亦或是刮风下雨的时候，就会比较难受。怎么办？</p><p>如果我们可以提前和司机师傅约好，在约定地点上车，是不是就可以了。想法有了，接下来就是实现，于是有了一系列的网约车 APP。现在大家打车记录不需要路边拦车了，直接网上下单，指定地点上车即可，方便快捷。</p><p>这几年，很多互联网公司的崛起，改变了我们的生活方式，比如：外卖、拼团、移动支付……他们的成功，是走了以前没有人走过的路。</p><p>《功勋》中屠呦呦关于常山碱的判断中，认为已经经过反复论证走不通的路，就该果断放弃，立马淘汰，找到更可靠的方式，于是有了后面的青蒿素的发现。</p><p>碰到问题，我们要投入百分之百的努力克服困难，但是如果已经不行了，就该考虑换个方式再上。</p><p>“行就行，不行再想想办法。”</p><h2 id="一切都在变"><a href="#一切都在变" class="headerlink" title="一切都在变"></a>一切都在变</h2><p>唯一不变的就是变化。没有什么是永恒不变的，我们能够应对变化的手段，只有提前预知变化，做好准备，当变化来临时，坦然面对。</p><p>很多 2020 年风生水起的教培行业，在国家出台双减政策后，一夜之间，大厦轰然倒塌。很多教培行业的老师、研发人员，只能重新考虑未来的发展。其实国家一直有这个信号，我在 <a href="https://mp.weixin.qq.com/s/EuNjfAmgQ3G491g6G4PAew" target="_blank" rel="noopener">想躺平不是错</a> 中也谈过相关的问题。很多人抱怨国家手段强硬，但他们真正抱怨的是，国家没有提前告诉他们要行霹雳手段，改变这个畸形发展的行业。</p><p>我们很多人相信风水、星座、命运，其实只是想从中探寻一些未来的可能。罗胖给出了一个观点是，我们没有办法一直追寻改变，只要找到未来的不变，试着靠近他，当未来来临时，我们就已经赶在了潮流的前列。</p><p>那怎么找到未来一定发生的事情？个人愚见是翻翻国家政策，比如“十四五”规划，看看规划的未来目标。跟着国家政策走，绝对不会有太大偏差。找到目标了怎么实现呢？有能力上，没能力提升能力也要上，如果还是上不去，就“打破思维的墙”，再想想别的办法。</p><h2 id="35-岁怎么了？一切刚刚好"><a href="#35-岁怎么了？一切刚刚好" class="headerlink" title="35 岁怎么了？一切刚刚好"></a>35 岁怎么了？一切刚刚好</h2><p>35 岁焦虑是每个程序员都有的？各种营销号中一直鼓吹一个观点，到了 35 岁，就会一下子变成了没有任何价值的抹布。而且给出很多的理由：</p><ol><li>家庭拖累，上有老下有小，会分心；</li><li>体力精力跟不上，没有办法跟刚毕业的小年轻比较；</li><li>变成了老油条，工作中很容易偷懒；</li><li>……</li></ol><p>似乎都有道理，但是总感觉哪里不对。罗胖的观点是，年龄大了之后，除了工作能力之外，我们拼的还有软技能。</p><p>以编程开发为例，简单的 CRUD，刚毕业的小伙子和 35 岁的人开发结果差不多，但是复杂逻辑呢？但凡有些经验的开发人员，会把场景考虑更加完善，会在开发时考虑更多的设计模式，这些经验，会让程序更加健壮，能够应对更多的变化。而且，经历了社会的毒打之后，我们会比较平和的接受一些职场上的不公平，这不是怂，而是一种心态的转变，“世间事，除了生死，哪一件事不是闲事。”</p><p>心态平和了，为人处世才会简单，能够更好的处理人际关系。这就是我们的软技能，如果我们可以在开发之外再有一些亮眼的特点，比如：架构设计、逻辑分析、产品设计、汇报总结等等。</p><p>之前看过一篇文章，里面说到，被辞退的员工，不会被告知被辞退的真正原因，只会说是公司效益不好、发展不畅。其实，很多时候是软技能太弱。</p><p>既然我们没有办法和 20 多岁的年轻人拼精力，那我们以一个更有生活阅历的年轻人身份在职场中打拼。</p><h2 id="此生不悔入华夏"><a href="#此生不悔入华夏" class="headerlink" title="此生不悔入华夏"></a>此生不悔入华夏</h2><p>不知道从什么时候开始，这种情绪就渗进了我们骨子里面。</p><p>写这段内容的时候，写了改，改了删。我企图找到一些证据，证明我的这个想法是对的，我企图找到一个事件，能够代表这种情绪的起点。最后还是删了，这是潜移默化的一个结果。填饱肚子的不是最后一个包子，而是前面 9 个包子的铺垫。</p><p>我只表达这种情绪，其他的交给时间。</p><h2 id="可以常常回味的话"><a href="#可以常常回味的话" class="headerlink" title="可以常常回味的话"></a>可以常常回味的话</h2><p>『1』给重要时刻：</p><p>“行万里路，读万遍经。笨鸭早飞，笨牛勤耕。让小的敬老的，拿次的留好的。宁欺官，不欺贤，宁欺贤，不欺天。人多的地方不去，没人的地方不留。赞美成功的人，安慰失败的人。犯病的东西不吃，犯法的事情不做。不要穿金戴银，只要好好做人。墙倒众人推，我不推；枪打出头鸟，我不打。种瓜得瓜瓜儿大，种豆得豆豆儿多。”————《王鼎钧回忆录》</p><p>『2』给理性乐观派：</p><p>“我的乐观并不需要这些头头是道的逻辑支撑，它就是一种朴素的信念：相信中国会更好。这种信念不是源于学术训练，而是源于司马迁、杜甫、苏轼，源于‘一条大河波浪宽’，源于对中国人勤奋实干的钦佩。它影响了我看待问题的角度和处理信息的方式，我接受这种局限性，没有改变的打算。”————兰小欢</p><p>『3』给犹豫不决的人：</p><p>“什么是事件？事件就是某种超出了原因的结果。”————齐泽克</p><p>『4』给准备出发的人：</p><p>“设计是一个不断生成目标和备选方案的过程。”————赫伯特·西蒙</p><p>『5』给正在路上的人：</p><p>“非常理想，特别现实。”————李希贵</p><p>『6』给正在拓荒的人：</p><p>“提前一个版本遵守法律”————王永治</p><p>『7』给知易行难的人：</p><p>“要改变一个成年人的行为，认知、能力、提醒，三者同样重要”————王建硕</p><p>『8』给身处困境的人：</p><p>“地球上最后一个人独自坐在房间里，这时忽然响起了敲门声……”————弗里蒂克·布朗</p><p>『9』给 2022 年的我们：</p><p>“让我们泰然自若，与自己的时代狭路相逢”————莎士比亚</p><h2 id="我们都要好好的"><a href="#我们都要好好的" class="headerlink" title="我们都要好好的"></a>我们都要好好的</h2><p>生活很难，有时候就需要一种正能量激励我们，哪怕只是轻轻的推一把，齿轮就会转动起来，然后就沿着这种惯性继续下去。</p><p>愿大家 2022 年“各从其欲，皆得所愿”。</p><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/2022-friends-of-time/">原来还能这么干——罗胖2022年《时间的朋友》观后感</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122273004" target="_blank" rel="noopener">原来还能这么干——罗胖2022年《时间的朋友》观后感</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      就这样 2022 年了，年纪越大，时间越快，又到了罗胖《时间的朋友》直播的时候，看完后想写点什么，奈何腹中墨水太少，索性不难为自己，随便写写。由于疫情原因，罗胖今年的跨年演讲现场的观众全部都是熊猫娃娃，评论区有整场直播的视频回访和文字稿，有些事情，还是要自己亲自感受一下。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊，时间的朋友" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A%EF%BC%8C%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java10 的新特性</title>
    <link href="https://www.howardliu.cn/java-10-features/"/>
    <id>https://www.howardliu.cn/java-10-features/</id>
    <published>2021-12-29T14:01:57.000Z</published>
    <updated>2021-12-29T14:01:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/christmas-5740350.png?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="Java10 新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><a id="more"></a><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>从 Java10 开始，Java 版本正式进入每半年一个版本的更新节奏，更新频率加快，小步快跑。</p><p>接下来我们瞅瞅 Java10 都更新了哪些比较有意思的功能。</p><h2 id="局部变量类型推断"><a href="#局部变量类型推断" class="headerlink" title="局部变量类型推断"></a>局部变量类型推断</h2><p>我们都知道 Java 是强类型语言，有着严格的类型限制。想要定义一个变量，必须明确指明变量类型，用<code>Object</code>抬杠的可以离开了。但是从 Java10 开始，我们可以在定义局部变量时使用<code>var</code>限定变量类型，Java 编译器会根据变量的值推断具体的类型。</p><p>比如，我们定义一个<code>Map</code>对象：</p><pre><code class="java">Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</code></pre><p>现在我们可以写做：</p><pre><code class="java">var idToNameMap = new HashMap&lt;Integer, String&gt;();</code></pre><p>这个功能算是 Java 的一次尝鲜，给 Java 语言增加了更多的可能，让我们的代码更加简洁，更加专注于可读性。</p><p>需要注意的是，新增的<code>var</code>不会把 Java 变成动态语言，在编译时，编译器会自动推断类型，将其转换为确定的类型，不会在运行时动态变化。</p><p>目前<code>var</code>只能用于局部变量，而且等号右侧必须是确定类型的定义，包括：初始化的实例、方法的调用、匿名内部类。</p><p>我们再回到刚才的例子：</p><pre><code class="java">// 以前的写法Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();// 现在可以这么写var idToNameMap = new HashMap&lt;Integer, String&gt;();</code></pre><p>对于参数的名字，我们可以不在关注类型，可以更多的关注参数的意义，这也是编写可读代码的要求。</p><p>这也为我们提出了一些要求，如果是特别长的 Lambda 表达式，还是老老实实的使用明确的类型吧，否则写着写着就迷糊了。</p><p>再就是推断类型时没有那么智能，都是基于最明确的推断，比如：</p><pre><code class="java">var emptyList = new ArrayList&lt;&gt;();</code></pre><p>这个时候推断<code>emptyList</code>的结果是<code>ArrayList&lt;Object&gt;</code>，绝对不会按照我们常用写法推断成<code>List&lt;Object&gt;</code>。</p><p>如果是匿名内部类，比如：</p><pre><code class="java">var obj = new Object() {};</code></pre><p>这个时候<code>obj.getClass()</code>可就不是<code>Object.class</code>了，而且匿名内部类的类型了。</p><p>所以，小刀虽好，但也要好好用，胡乱用容易误伤。</p><h2 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h2><p>从 Java9 开始提供不可变集合的实现，Java10 继续扩展。集合是一个容器，作为一个参数传入方法中，我们并不知道方法是否会对容器中的元素进行修改，有了不可变集合，我们就能够在一定程度上进行控制（毕竟对容器中对象的数据进行修改，我们的控制力就没有那么强了）。</p><p>针对不可变集合，我们摘取<code>java.util.List</code>的描述（其他的描述都是类似的）：</p><blockquote><h2 id="Unmodifiable-Lists"><a href="#Unmodifiable-Lists" class="headerlink" title="Unmodifiable Lists"></a>Unmodifiable Lists</h2><p>The List.of and List.copyOf static factory methods provide a convenient way to create unmodifiable lists. The List instances created by these methods have the following characteristics:</p><ul><li>They are unmodifiable. Elements cannot be added, removed, or replaced. Calling any mutator method on the List will always cause UnsupportedOperationException to be thrown. However, if the contained elements are themselves mutable, this may cause the List’s contents to appear to change.</li><li>They disallow null elements. Attempts to create them with null elements result in NullPointerException.</li><li>They are serializable if all elements are serializable.</li><li>The order of elements in the list is the same as the order of the provided arguments, or of the elements in the provided array.</li><li>They are value-based. Callers should make no assumptions about the identity of the returned instances. Factories are free to create new instances or reuse existing ones. Therefore, identity-sensitive operations on these instances (reference equality (==), identity hash code, and synchronization) are unreliable and should be avoided.</li><li>They are serialized as specified on the Serialized Form page.</li></ul></blockquote><p>简单翻译一下：</p><ul><li>这些集合都不可变，元素不能增、减、替换，调用修改方法都会返回<code>UnsupportedOperationException</code>异常。但是，but，如果集合中的元素是可变的，那就控不住了。比如，元素是<code>AtomInteger</code>就没法控制其中的值，集合只是元素不变；如果是<code>String</code>，那集合是整体不变的。</li><li>不允许<code>null</code>，会抛出<code>NullPointerException</code></li><li>如果集合中的元素是可序列化的，那集合就能够序列化</li><li>集合中元素的顺序是加入的顺序</li><li><code>copyOf</code>和<code>of</code>这些方法中返回的结果可能使用提前定义好的对象，比如空集合、原集合等。换句话说，在不同调用位置返回了相同对象。所以不要相信<code>==</code>、<code>hashCode</code>，也不要对其加锁。</li></ul><h3 id="copyOf"><a href="#copyOf" class="headerlink" title="copyOf"></a>copyOf</h3><p>在<code>java.util.List</code>、<code>java.util.Map</code>、<code>java.util.Set</code>这几个接口中都各自添加了一个<code>copyOf</code>静态方法，用来创建不可变集合，最终都会是<code>ImmutableCollections</code>中定义的几个集合实现，与 Java9 中定义的<code>of</code>方法类似。</p><p>对于<code>java.util.Map</code>、<code>java.util.Set</code>，这里有一个优化，如果传入的本身就是不可变的集合，将直接返回传入的参数，代码如下：</p><pre><code class="java">static &lt;E&gt; Set&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) {    if (coll instanceof ImmutableCollections.AbstractImmutableSet) {        return (Set&lt;E&gt;)coll;    } else {        return (Set&lt;E&gt;)Set.of(new HashSet&lt;&gt;(coll).toArray());    }}</code></pre><h3 id="toUnmodifiableList、toUnmodifiableSet、toUnmodifiableMap"><a href="#toUnmodifiableList、toUnmodifiableSet、toUnmodifiableMap" class="headerlink" title="toUnmodifiableList、toUnmodifiableSet、toUnmodifiableMap"></a>toUnmodifiableList、toUnmodifiableSet、toUnmodifiableMap</h3><p>Java10 很贴心的提供了<code>Stream</code>中的操作，我们直接创建不可变集合了。比如：</p><pre><code class="java">Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;)    .map(x -&gt; &quot;id: &quot; + x)    .collect(Collectors.toUnmodifiableList());</code></pre><p><code>toUnmodifiableList</code>、<code>toUnmodifiableSet</code>、<code>toUnmodifiableMap</code>的用法与<code>toList</code>、<code>toSet</code>、<code>toMap</code>没有太多区别，差别在于返回的是不可变集合。</p><h2 id="Optional-族增加-orElseThrow-方法"><a href="#Optional-族增加-orElseThrow-方法" class="headerlink" title="Optional 族增加 orElseThrow 方法"></a>Optional 族增加 orElseThrow 方法</h2><p>这里说的 Optional 族包括<code>Optional</code>、<code>OptionalInt</code>、<code>OptionalLong</code>、<code>OptionalDouble</code>几个实现。以前有一个<code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code>方法，用于获取不到数据时，抛出<code>exceptionSupplier</code>中定义的异常。</p><p>我们会写成：</p><pre><code class="java">Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;)    .map(x -&gt; &quot;id: &quot; + x)    .findAny()    .orElseThrow(() -&gt; new NoSuchElementException(&quot;No value present&quot;));</code></pre><p>优点是我们可以自定义自己的异常以及异常信息。有时候，我们不关心具体的异常和异常信息，这个时候 Java10 中的新增的<code>orElseThrow</code>方法就派上用场了：</p><pre><code class="java">Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;)    .map(x -&gt; &quot;id: &quot; + x)    .findAny()    .orElseThrow();</code></pre><p>此时如果元素为空，将抛出<code>NoSuchElementException</code>异常。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>Java 当年在性能方面一直被诟病，中间隔着一层虚拟机，实现跨平台运行的功能同时，也致使其执行性能不如 C 语言。所以，Java 一直在性能方面投入大量精力。</p><p>我们看看 Java10 中都有哪些优化点。</p><h3 id="G1-实现并行-Full-GC-算法"><a href="#G1-实现并行-Full-GC-算法" class="headerlink" title="G1 实现并行 Full GC 算法"></a>G1 实现并行 Full GC 算法</h3><p>从 Java9 开始，G1 已经转正，成为默认的垃圾收集器。不过在 Full GC 时，G1 还是采用的单线程串行标记压缩算法，这样 STW 时间会比较长。到 Java10，Full GC 实现了并行标记压缩算法，明显缩短 STW 时间。</p><h3 id="应用程序类数据共享（AppCDS）"><a href="#应用程序类数据共享（AppCDS）" class="headerlink" title="应用程序类数据共享（AppCDS）"></a>应用程序类数据共享（AppCDS）</h3><p>CDS（Class-Data Sharing，类数据共享）是在 Java5 引入的一种类预处理方式，可以将一组类共享到一个归档文件中，在运行时通过内存映射加载类，这样做可以减少启动时间。同时在多个 JVM 之间实现同享同一个归档文件，减少动态内存占用。</p><p>但是 CDS 有一个限制，就是只能是 Bootstrap ClassLoader 使用，这样就将功能限制了类的范围。在 Java10 中，将这个功能扩展到了系统类加载器（System ClassLoader，或者成为应用类加载器，Application ClassLoader）、内置的平台类加载器（Platform ClassLoader），或者是自定义的类加载器。这样就将功能扩展到了应用类。</p><p>想要使用这个功能的话，总共分三步：</p><p><img src="https://static.howardliu.cn/Illustration/BE710605-5206-4D37-8D8C-86E515A6D386.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="总共分三步"></p><ol><li>打包<br>我们把<code>hello.jar</code>中的<code>HelloWorld</code>类使用的类添加到<code>hello.lst</code>中：</li></ol><pre><code class="shell">$ java -Xshare:off -XX:+UseAppCDS -XX:DumpLoadedClassList=hello.lst \    -cp hello.jar HelloWorld</code></pre><ol start="2"><li>创建 AppCDS 归档<br>接下来使用<code>hello.lst</code>中的内容创建 AppCDS 文件<code>hello.jsa</code>：</li></ol><pre><code class="shell">$ java -Xshare:dump -XX:+UseAppCDS -XX:SharedClassListFile=hello.lst \   -XX:SharedArchiveFile=hello.jsa -cp hello.jar</code></pre><ol start="3"><li>使用 AppCDS 归档<br>最后是使用<code>hello.jsa</code>启动<code>HelloWorld</code>：</li></ol><pre><code class="shell">$ java -Xshare:on -XX:+UseAppCDS -XX:SharedArchiveFile=hello.jsa \   -cp hello.jar HelloWorld</code></pre><h3 id="基于-Java-的-JIT-编译器-Graal"><a href="#基于-Java-的-JIT-编译器-Graal" class="headerlink" title="基于 Java 的 JIT 编译器 Graal"></a>基于 Java 的 JIT 编译器 Graal</h3><p><a href="https://github.com/oracle/graal/" target="_blank" rel="noopener">Graal</a> 是使用 Java 编写的与 HotSpot JVM 集成的动态编译器，专注于高性能和可扩展性。是从 JDK9 引入的实验性 AOT 编译器的基础。</p><p>在 JDK10 中，我们可以在 Linux/x64 平台将 Graal 作为 JIT 编译器使用。开启命令如下：</p><pre><code class="shell">-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler</code></pre><p>需要注意的是，这是实验特性，相当于公测阶段，可能在某些场景下，性能不如现有的 JIT 编译器。</p><h2 id="支持容器"><a href="#支持容器" class="headerlink" title="支持容器"></a>支持容器</h2><p>容器化是目前的趋势，在之前，由于 JVM 不能够感知容器，在同一个主机上部署多个虚拟机时，会造成内存占用、CPU 抢占等问题，这点也成为了很多大会上抨击 Java 语言不适合容器时代的一个点。</p><p>现在好了，JVM 可以感知容器了。只是暂时还只支持 Linux 系统（so what，其他平台也还没有用过）。这个功能默认开启，不想使用可以手动关闭：</p><pre><code class="shell">-XX:-UseContainerSupport</code></pre><p>我们还可以手动指定 CPU 核数：</p><pre><code class="shell">-XX:ActiveProcessorCount=1</code></pre><p>还有三个可以控制内存的使用量：</p><pre><code class="shell">-XX:InitialRAMPercentage-XX:MaxRAMPercentage-XX:MinRAMPercentage</code></pre><p>就目前来看，这部分还可以继续完善，相信只是时间问题。</p><h2 id="根证书认证"><a href="#根证书认证" class="headerlink" title="根证书认证"></a>根证书认证</h2><p>自 Java9 起在 keytool 中加入参数 -cacerts，可以查看当前 JDK 管理的根证书。而 Java9 中 cacerts 目录为空，这样就会给开发者带来很多不便。从 Java10 开始，将会在 JDK 中提供一套默认的 CA 根证书。</p><p>作为 JDK 一部分的 cacerts 密钥库旨在包含一组能够用于在各种安全协议的证书链中建立信任的根证书。在 Java10 之前，cacerts 密钥库是空的，默认情况下，关键安全组件（如 TLS）是不起作用的，开发人员需要手动添加一组根证书来使用这些验证。</p><p>Java10 中，Oracle 开放了根证书源码，可以让 OpenJDK 构建对开发人员更有吸引力，并减少这些构建与 Oracle JDK 构建之间的差异。</p><h2 id="启用和删除的功能"><a href="#启用和删除的功能" class="headerlink" title="启用和删除的功能"></a>启用和删除的功能</h2><p>有增有减，这样才能够保证 Java 的与时共进。</p><h3 id="命令行工具和某些参数"><a href="#命令行工具和某些参数" class="headerlink" title="命令行工具和某些参数"></a>命令行工具和某些参数</h3><ul><li>移除<code>javah</code>命令，这个命令用于创建 native 方法所需的 C 的头文件和资源文件的，使用<code>javac -h</code>替代。</li><li>移除<code>policytool</code>工具，这个工具用于创建和管理策略文件。可以直接还使用文本编辑器代替。</li><li>删除<code>java -Xprof</code>参数，这个参数本来是用于评测正在运行的程序，并将评测数据发送到标准输出。可以使用<code>jmap</code>代替。</li></ul><h3 id="某些-API"><a href="#某些-API" class="headerlink" title="某些 API"></a>某些 API</h3><p><code>java.security.acl</code>包标记为过期，标记参数<code>forRemoval</code>是<code>true</code>，将在未来版本中删除。目前，这个包内的功能已经被<code>java.security.Policy</code>取代。<code>java.security</code>包中的<code>Certificate</code>、<code>Identity</code>、<code>IdentityScope</code>、<code>Signer</code>的标记参数<code>forRemoval</code>也是<code>true</code>。这些都将在后续版本中删除。</p><h2 id="基于时间的版本发布模式"><a href="#基于时间的版本发布模式" class="headerlink" title="基于时间的版本发布模式"></a>基于时间的版本发布模式</h2><p>从 Java10 开始，Java 正式进入每半年一个版本的更新节奏，主要改动如下：</p><ol><li>每 6 个月发布一组新特性；</li><li>长期支持版（LTS）将支持 3 年，其他版本支持 6 个月；</li><li>Java11、Java17 是长期支持版；</li><li>采用<code>$FEATURE.$INTERIM.$UPDATE.$PATCH</code>命名机制：<code>$FEATURE</code>，每次版本发布加 1，不考虑具体的版本内容；<code>$INTERIM</code>，中间版本号，在大版本中间发布的，包含问题修复和增强的版本，不会引入非兼容性修改；<code>$PATCH</code>用于快速打补丁的。</li></ol><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java10 新增的特性，完整的特性清单可以从<a href="https://openjdk.java.net/projects/jdk/10/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/10/</a>查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-10-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java10 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122225794" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java10 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      从 Java10 开始，Java 版本正式进入每半年一个版本的更新节奏，更新频率加快，小步快跑。在 Java10 中增加了局部变量类型推断、不可变集合、Optional增强、G1 实现并行 Full GC 算法、支持容器、根证书认证等特性。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java10" scheme="https://www.howardliu.cn/tags/Java10/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis-Plus 版本冲突触发“Could not convert argument value of type [java.lang.String] to required type [java.lang.Class]”的 java.lang.NoClassDefFoundError 异常</title>
    <link href="https://www.howardliu.cn/mybatis-plus-conflict-noclassdeffounderror/"/>
    <id>https://www.howardliu.cn/mybatis-plus-conflict-noclassdeffounderror/</id>
    <published>2021-12-25T03:51:38.000Z</published>
    <updated>2021-12-25T03:51:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/dog-2963062_1920.jpg" alt="Mybatis-Plus 版本冲突触发“Could not convert argument value of type [java.lang.String] to required type [java.lang.Class]”的 java.lang.NoClassDefFoundError 异常"></p><p>你好，我是看山。</p><p>今天项目依赖了一个基础组件之后，启动失败，排查过程走了一些弯路，最终确认是因为依赖组件版本冲突造成了<code>java.lang.NoClassDefFoundError</code>异常。下面是排查过程，希望可以给你提供一些思路。</p><a id="more"></a><h2 id="观察异常栈"><a href="#观察异常栈" class="headerlink" title="观察异常栈"></a>观察异常栈</h2><p>下面是打印的异常栈信息，从其中提炼可能的关键信息，能够找到“Could not convert argument value of type [java.lang.String] to required type [java.lang.Class]”，还有“Unresolvable class definition for class [cn.howardliu.demo.AddressMapper]”。继续从异常栈中找一下发生的时机，可以发现是调用<code>AbstractAutowireCapableBeanFactory.createBeanInstance</code>时，这个方法是创建 Bean 实例。</p><pre><code class="log">这块是异常信息（getMessage 的内容，横向太长，手动换行了）：org.springframework.beans.factory.UnsatisfiedDependencyException:    Error creating bean with name &#39;methodValidationPostProcessor&#39; defined in class path resource [org/springframework/boot/autoconfigure/validation/ValidationAutoConfiguration.class]:    Unsatisfied dependency expressed through method &#39;methodValidationPostProcessor&#39; parameter 0;    nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException:    Error creating bean with name &#39;addressMapper&#39; defined in file [/Users/liuxinghao/Documents/work/code/cn.howardliu/effective-spring/target/classes/cn/howardliu/demo/AddressMapper.class]:    Unsatisfied dependency expressed through constructor parameter 0:    Could not convert argument value of type [java.lang.String] to required type [java.lang.Class]:    Failed to convert value of type &#39;java.lang.String&#39; to required type &#39;java.lang.Class&#39;;    nested exception is java.lang.IllegalArgumentException:     Unresolvable class definition for class [cn.howardliu.demo.AddressMapper]下面是异常栈：    at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:799) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:540) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1341) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1181) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:556) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:516) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:324) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:322) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:207) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]其他异常栈信息可以忽略了</code></pre><p>我们可以根据目前有效的信息进行排查，首先看下我们的<code>cn.howardliu.demo.AddressMapper</code>定义是否有问题，再看看依赖它的 Service 有没有问题，什么问题也没有发现。下一个检查点是配置，比如<code>@MapperScan</code>是否正确、Mapper 类上有没有加上<code>@Mapper</code>注解，发现也没有问题。</p><p>从异常信息找不到思路了，只能从代码入手了。</p><blockquote><p>这里需要说一下，打印异常信息至关重要，直接影响我们排错的思路。如果打印的信息没有办法准确定位，我们将会花费大量的时间查找真正的错误，这就需要走查代码，有时候还需要一些经验。</p></blockquote><h2 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h2><p>我们由异常栈``ConstructorResolver.createArgumentArray(ConstructorResolver.java:799) 入手，跟着断点往下追，最终会追到<code>org.springframework.util.ClassUtils#forName</code>方法，其中会抛出异常的代码是下面这块：</p><pre><code class="java">try {    return Class.forName(name, false, clToUse);}catch (ClassNotFoundException ex) {    int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);    if (lastDotIndex != -1) {        String innerClassName =                name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);        try {            return Class.forName(innerClassName, false, clToUse);        }        catch (ClassNotFoundException ex2) {            // Swallow - let original exception get through        }    }    throw ex;}</code></pre><p>出现错误的是<code>Class.forName(name, false, clToUse)</code>这句，<code>name</code>传的是”cn.howardliu.demo.AddressMapper”字符串，抛出的异常是<code>java.lang.NoClassDefFoundError</code>，由于不是<code>ClassNotFoundException</code>异常，不会进入<code>catch</code>逻辑，会直接向上抛出。</p><p>找到错误我们就好定位问题了。</p><p>一般来说，<code>java.lang.NoClassDefFoundError</code>错误是需要加载的类能够找到，但是加载时出现了异常，简单说就是，类的定义有问题。我们借助 JD-GUI 反编译一下运行 jar 包，结果如下：</p><pre><code class="java">import com.baomidou.mybatisplus.core.mapper.BaseMapper;import cn.howardliu.demo.Address;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface AddressMapper extends BaseMapper&lt;Address&gt; {}</code></pre><p>观察仔细的话，我们可以看到<code>import com.baomidou.mybatisplus.core.mapper.BaseMapper;</code>这行没有下划线，也就是说，在反编译工具中追溯不到这个接口，推断出来就是在运行环境中，找不到<code>BaseMapper</code>这个类定义。</p><p>所以，当<code>Class.forName</code>加载类的时候抛出了<code>java.lang.NoClassDefFoundError</code>异常。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>如果有一定经验，就会立刻想到，大概率出现了依赖 jar 的版本冲突。</p><p>我们可以借助 maven 命令行找到版本冲突的依赖：</p><pre><code class="shell">mvn dependency:tree -Dverbose | grep conflict</code></pre><p>打印结果为：</p><pre><code class="log">[INFO] |  +- (com.baomidou:mybatis-plus:jar:3.1.2:compile - omitted for conflict with 2.1.6)</code></pre><p>我们也可以借助 IDEA 的可视化工具，在 pom.xml 上打开依赖图：</p><p><img src="https://static.howardliu.cn/java/EF543BDC-9C35-43CF-A181_20211225114104.png" alt="依赖图"></p><p>我们可以看到 mybatis-plus 的红线指示出冲突信息：</p><p><img src="https://static.howardliu.cn/java/F0C16C09-7C27-4D34-99F9-B73B665EF0A3_20211225114132.png" alt="冲突信息"></p><p>结论就是 Mybatis-Plus 版本冲突了，项目中依赖了 mybatis-plus 的 2.1.6 和 3.1.2 两个版本，由于 2.1.6 路径更短，最终被选中。</p><p>此时只需要将低版本的依赖去掉即可。</p><h2 id="复盘问题"><a href="#复盘问题" class="headerlink" title="复盘问题"></a>复盘问题</h2><h3 id="mybatis-plus-的版本问题"><a href="#mybatis-plus-的版本问题" class="headerlink" title="mybatis-plus 的版本问题"></a>mybatis-plus 的版本问题</h3><p>为什么低版本的 mybatis-plus 会造成类加载失败呢？是因为 mybatis-plus 跨版本更新时，把<code>BaseMapper</code>的包路径改了：</p><pre><code class="java">// 3.1.2 版本import com.baomidou.mybatisplus.core.mapper.BaseMapper;// 2.1.6 版本import com.baomidou.mybatisplus.mapper.BaseMapper;</code></pre><p>而且还不止这一个，<code>IService</code>、<code>ServiceImpl</code>、<code>TableName</code>、<code>TableField</code>、<code>Model</code>、<code>TableField</code>等等，很多常用的类都改了位置。所以会造成找不到依赖的类。编译是 3.1.2 依赖还在运行环境中，就会出现编译没有问题，执行时出现加载类异常。</p><p>想要工程化的解决这个问题，我们可以创建基础的依赖 bom 配置，定义好基础依赖包，在项目中不在指定版本。这样做到统一版本，可以有效的避免这类问题。</p><p>我们还可以在 CI/CD 中加入冲突依赖检查，如果发现冲突依赖，就终止流水线。</p><h3 id="真实异常被隐藏问题"><a href="#真实异常被隐藏问题" class="headerlink" title="真实异常被隐藏问题"></a>真实异常被隐藏问题</h3><p>接下来我们看下为什么明明是<code>java.lang.NoClassDefFoundError</code>异常，结果异常栈中打印的是一堆不相干的错误。继续跟着刚才的断点 Debug：</p><p><code>org.springframework.util.ClassUtils#resolveClassName</code>会捕捉<code>LinkageError</code>错误，然后包装成<code>IllegalArgumentException</code>异常，这个时候真是异常还是继续上抛。</p><p>然后在<code>org.springframework.beans.TypeConverterSupport#convertIfNecessary</code>方法会包装成<code>TypeMismatchException</code>异常，此时，真实异常还在异常<code>cause</code>参数中，并没有丢失。</p><p>等回到<code>org.springframework.beans.factory.support.ConstructorResolver#createArgumentArray</code>方法后，捕捉异常的方法是：</p><pre><code class="java">try {    convertedValue = converter.convertIfNecessary(originalValue, paramType, methodParam);}catch (TypeMismatchException ex) {    throw new UnsatisfiedDependencyException(            mbd.getResourceDescription(), beanName, new InjectionPoint(methodParam),            &quot;Could not convert argument value of type [&quot; +                    ObjectUtils.nullSafeClassName(valueHolder.getValue()) +                    &quot;] to required type [&quot; + paramType.getName() + &quot;]: &quot; + ex.getMessage());}</code></pre><p>此时我们可以注意到，在包装成<code>UnsatisfiedDependencyException</code>异常的时候，只是把捕捉到的<code>TypeMismatchException</code>通过<code>getMessage</code>方法追加在异常描述后面，此时经过前面几轮的包装再包装，真实的异常的异常信息仅剩<code>Unresolvable class definition for class [cn.howardliu.demo.AddressMapper]</code>这段经过处理的信息，完全没有<code>java.lang.NoClassDefFoundError</code>的影子了。</p><p>至此，真实异常消失无踪。</p><p>这也给我们一个提醒，我们要保证异常的时候，一定要保留有效信息，否则，排错会非常麻烦。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文是抓虫文，从问题出发，到解决问题，给出完整的思路。<code>java.lang.NoClassDefFoundError</code>一般都是出现在版本冲突的时候，这种异常是编译打包没有问题，在运行时加载类失败。在本文中之所以排查时走了一些弯路，是因为<code>Spring</code>隐藏了真实异常，给我们排错造成了一些阻碍。所以，我们在日常开发时也要重视异常的明确信息，可以给我们排错提供准确的目标。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/mybatis-plus-conflict-noclassdeffounderror/">Mybatis-Plus 版本冲突触发“Could not convert argument value of type [java.lang.String] to required type [java.lang.Class]”的 java.lang.NoClassDefFoundError 异常</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122203746" target="_blank" rel="noopener">Mybatis-Plus 版本冲突触发“Could not convert argument value of type [java.lang.String] to required type [java.lang.Class]”的 java.lang.NoClassDefFoundError 异常</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      今天项目依赖了一个基础组件之后，启动失败，排查过程走了一些弯路，最终确认是因为依赖组件版本冲突造成了`java.lang.NoClassDefFoundError`异常。下面是排查过程，希望可以给你提供一些思路。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="NoClassDefFoundError" scheme="https://www.howardliu.cn/tags/NoClassDefFoundError/"/>
    
      <category term="Mybatis-Plus" scheme="https://www.howardliu.cn/tags/Mybatis-Plus/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java9 的新特性</title>
    <link href="https://www.howardliu.cn/java-9-features/"/>
    <id>https://www.howardliu.cn/java-9-features/</id>
    <published>2021-12-19T02:09:20.000Z</published>
    <updated>2021-12-19T02:09:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/train-g9ee00db77_1920.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java9 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>相较于 <a href="https://mp.weixin.qq.com/s/f0bgOBy1_Hz-HHRD32HSXw" target="_blank" rel="noopener">Java8</a>，Java9 没有新增语法糖，但是其增加的特性也都是非常实用的，比如 Jigsaw 模块化、JShell、发布-订阅框架、GC 等。本文将快速、高层次的介绍一些新特性，完整的特性可以参加<a href="https://openjdk.java.net/projects/jdk9/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk9/</a>。</p><blockquote><p>这里需要说明一下，由于 Java9 并不是长期支持版，当前也是从现在看过去，所以笔者偷个懒，文章的示例代码都是在 Java11 下写的，可能会与 Java9 中的定义有些出入，不过，这也没啥，毕竟我们真正使用的时候还是优先考虑长期支持版。</p></blockquote><h2 id="Jigsaw-模块化"><a href="#Jigsaw-模块化" class="headerlink" title="Jigsaw 模块化"></a>Jigsaw 模块化</h2><p>模块化是一个比较大的更新，这让以前 All-in-One 的 Java 包拆分成几个模块。这种模块化系统提供了类似 OSGi 框架系统的功能，比如多个模块可以独立开发，按需引用、按需集成，最终组装成一个完整功能。</p><p>模块具有依赖的概念，可以导出功能 API，可以隐藏实现细节。</p><p>还有一个好处是可以实现 JVM 的按需使用，能够减小 Java 运行包的体积，让 JVM 在内存更小的设备上运行。JVM 当时的初衷就是做硬件，也算是不忘初心了。</p><p>另外，JVM 中<code>com.sun.*</code>的之类的内部 API，做了更强的封闭，不在允许调用，提升了内核安全。</p><p>在使用的时候，我们需要在 java 代码的顶层目录中定义一个<code>module-info.java</code>文件，用于描述模块信息：</p><pre><code class="java">module cn.howardliu.java9.modules.car {    requires cn.howardliu.java9.modules.engines;    exports cn.howardliu.java9.modules.car.handling;}</code></pre><p>上面描述的信息是：模块<code>cn.howardliu.java9.modules.car</code>需要依赖模块<code>cn.howardliu.java9.modules.engines</code>，并导出模块<code>cn.howardliu.java9.modules.car.handling</code>。</p><p>更多的信息可以查看 OpenJDK 的指引 <a href="https://openjdk.java.net/projects/jigsaw/quick-start，后续会单独介绍" target="_blank" rel="noopener">https://openjdk.java.net/projects/jigsaw/quick-start，后续会单独介绍</a> Jigsaw 模块的使用，内容会贴到评论区。</p><h2 id="全新的-HTTP-客户端"><a href="#全新的-HTTP-客户端" class="headerlink" title="全新的 HTTP 客户端"></a>全新的 HTTP 客户端</h2><p>这是一个千呼万唤始出来的功能，终于有官方 API 可以替换老旧难用的<code>HttpURLConnection</code>。只不过，在 Java9 中，新版 HTTP 客户端是放在孵化模块中（具体信息可以查看 <a href="https://openjdk.java.net/jeps/110）。" target="_blank" rel="noopener">https://openjdk.java.net/jeps/110）。</a></p><p>老版 HTTP 客户端存在很多问题，大家开发的时候基本上都是使用第三方 HTTP 库，比如 Apache HttpClient、Netty、Jetty 等。</p><p>新版 HTTP 客户端的目标很多，毕竟这么多珠玉在前，如果还是做成一坨，指定是要被笑死的。所以新版 HTTP 客户端列出了 16 个目标，包括简单易用、打印关键信息、WebSocket、HTTP/2、HTTPS/TLS、良好的性能、非阻塞 API 等等。</p><p>我们先简单的瞅瞅：</p><pre><code class="java">final String url = &quot;https://postman-echo.com/get&quot;;final HttpRequest request = HttpRequest.newBuilder()        .uri(new URI(url))        .GET()        .build();final HttpResponse&lt;String&gt; response = HttpClient.newHttpClient()        .send(request, HttpResponse.BodyHandlers.ofString());final HttpHeaders headers = response.headers();headers.map().forEach((k, v) -&gt; System.out.println(k + &quot;:&quot; + v));System.out.println(response.statusCode());System.out.println(response.body());</code></pre><blockquote><p>新版 HTTP 客户端可以在 Java11 中正常使用了，上面的代码也是在 Java11 中写的，API 是在<code>java.net.http</code>包中。</p></blockquote><h2 id="改进的进程-API"><a href="#改进的进程-API" class="headerlink" title="改进的进程 API"></a>改进的进程 API</h2><p>在 Java9 中提供的进程 API，可以控制和管理操作系统进程。也就是说，可以在代码中管理当前进程，甚至可以销毁当前进程。</p><h3 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h3><p>这个功能是由<code>java.lang.ProcessHandle</code>提供的，我们来瞅瞅怎么用：</p><pre><code class="java">final ProcessHandle self = ProcessHandle.current();final long pid = self.pid();System.out.println(&quot;PID: &quot; + pid);final ProcessHandle.Info procInfo = self.info();procInfo.arguments().ifPresent(x -&gt; {    for (String s : x) {        System.out.println(s);    }});procInfo.commandLine().ifPresent(System.out::println);procInfo.startInstant().ifPresent(System.out::println);procInfo.totalCpuDuration().ifPresent(System.out::println);</code></pre><p><code>java.lang.ProcessHandle.Info</code>中提供了丰富的进程信息</p><h3 id="销毁进程"><a href="#销毁进程" class="headerlink" title="销毁进程"></a>销毁进程</h3><p>我们还可以使用<code>java.lang.ProcessHandle#destroy</code>方法销毁进程，我们演示一下销毁子进程：</p><pre><code class="java">ProcessHandle.current().children()        .forEach(procHandle -&gt; {            System.out.println(procHandle.pid());            System.out.println(procHandle.destroy());        });</code></pre><blockquote><p>从 Java8 之后，我们会发现 Java 提供的 API 使用了<code>Optional</code>、<code>Stream</code>等功能，*<em>Eating your own dog food *</em>也是比较值得学习的。</p></blockquote><h2 id="其他小改动"><a href="#其他小改动" class="headerlink" title="其他小改动"></a>其他小改动</h2><p>Java9 中还对做了对已有功能做了点改动，我们来瞅瞅都有哪些。</p><h3 id="改进-try-with-resources"><a href="#改进-try-with-resources" class="headerlink" title="改进 try-with-resources"></a>改进 try-with-resources</h3><p>从 Java7 开始，我们可以使用<code>try-with-resources</code>语法自动关闭资源，所有实现了<code>java.lang.AutoCloseable</code>接口，可以作为资源。但是这里会有一个限制，就是每个资源需要声明一个新变量。</p><p>也就是这样：</p><pre><code class="java">public static void tryWithResources() throws IOException {    try (FileInputStream in2 = new FileInputStream(&quot;./&quot;)) {        // do something    }}</code></pre><p>对于这种直接使用的还算方便，但如果是需要经过一些列方法定义的呢？就得写成下面这个样子：</p><pre><code class="java">final Reader inputString = new StringReader(&quot;www.howardliu.cn 看山&quot;);final BufferedReader br = new BufferedReader(inputString);// 其他一些逻辑try (BufferedReader br1 = br) {    System.out.println(br1.lines());}</code></pre><p>在 Java9 中，如果资源是<code>final</code>定义的或者等同于<code>final</code>变量，就不用声明新的变量名，可以直接在<code>try-with-resources</code>中使用：</p><pre><code class="java">final Reader inputString = new StringReader(&quot;www.howardliu.cn 看山&quot;);final BufferedReader br = new BufferedReader(inputString);// 其他一些逻辑try (br) {    System.out.println(br.lines());}</code></pre><h3 id="改进钻石操作符-Diamond-Operator"><a href="#改进钻石操作符-Diamond-Operator" class="headerlink" title="改进钻石操作符 (Diamond Operator)"></a>改进钻石操作符 (Diamond Operator)</h3><p>钻石操作符（也就是<code>&lt;&gt;</code>）是 Java7 引入的，可以简化泛型的书写，比如：</p><pre><code class="java">Map&lt;String, List&lt;String&gt;&gt; strsMap = new TreeMap&lt;String, List&lt;String&gt;&gt;();</code></pre><p>右侧的<code>TreeMap</code>类型可以根据左侧的泛型定义推断出来，借助钻石操作符可以简化为：</p><pre><code class="java">Map&lt;String, List&lt;String&gt;&gt; strsMap = new TreeMap&lt;&gt;();</code></pre><p>看山会简洁很多，<code>&lt;&gt;</code>的写法就是钻石操作符 (Diamond Operator)。</p><p>但是这种写法不适用于匿名内部类。比如有个抽象类：</p><pre><code class="java">abstract static class Consumer&lt;T&gt; {    private T content;    public Consumer(T content) {        this.content = content;    }    abstract void accept();    public T getContent() {        return content;    }}</code></pre><p>在 Java9 之前，想要实现匿名内部类，就需要写成：</p><pre><code class="java">final Consumer&lt;Integer&gt; intConsumer = new Consumer&lt;Integer&gt;(1) {    @Override    void accept() {        System.out.println(getContent());    }};intConsumer.accept();final Consumer&lt;? extends Number&gt; numConsumer = new Consumer&lt;Number&gt;(BigDecimal.TEN) {    @Override    void accept() {        System.out.println(getContent());    }};numConsumer.accept();final Consumer&lt;?&gt; objConsumer = new Consumer&lt;Object&gt;(&quot;看山&quot;) {    @Override    void accept() {        System.out.println(getContent());    }};objConsumer.accept();</code></pre><p>在 Java9 之后就可以使用钻石操作符了：</p><pre><code class="java">final Consumer&lt;Integer&gt; intConsumer = new Consumer&lt;&gt;(1) {    @Override    void accept() {        System.out.println(getContent());    }};intConsumer.accept();final Consumer&lt;? extends Number&gt; numConsumer = new Consumer&lt;&gt;(BigDecimal.TEN) {    @Override    void accept() {        System.out.println(getContent());    }};numConsumer.accept();final Consumer&lt;?&gt; objConsumer = new Consumer&lt;&gt;(&quot;看山&quot;) {    @Override    void accept() {        System.out.println(getContent());    }};objConsumer.accept();</code></pre><h3 id="私有接口方法"><a href="#私有接口方法" class="headerlink" title="私有接口方法"></a>私有接口方法</h3><p>如果说钻石操作符是代码的简洁可读，那接口的私有方法就是比较实用的一个扩展了。</p><p>在 Java8 之前，接口只能有常量和抽象方法，想要有具体的实现，就只能借助抽象类，但是 Java 是单继承，有很多场景会受到限制。</p><p>在 Java8 之后，接口中可以定义默认方法和静态方法，提供了很多扩展。但这些方法都是<code>public</code>方法，是完全对外暴露的。如果有一个方法，只想在接口中使用，不想将其暴露出来，就没有办法了。这个问题在 Java9 中得到了解决。我们可以使用<code>private</code>修饰，限制其作用域。</p><p>比如：</p><pre><code class="java">public interface Metric {    // 常量    String NAME = &quot;METRIC&quot;;    // 抽象方法    void info();    // 私有方法    private void append(String tag, String info) {        buildMetricInfo();        System.out.println(NAME + &quot;[&quot; + tag + &quot;]:&quot; + info);        clearMetricInfo();    }    // 默认方法    default void appendGlobal(String message) {        append(&quot;GLOBAL&quot;, message);    }    // 默认方法    default void appendDetail(String message) {        append(&quot;DETAIL&quot;, message);    }    // 私有静态方法    private static void buildMetricInfo() {        System.out.println(&quot;build base metric&quot;);    }    // 私有静态方法    private static void clearMetricInfo() {        System.out.println(&quot;clear base metric&quot;);    }}</code></pre><h2 id="JShell"><a href="#JShell" class="headerlink" title="JShell"></a>JShell</h2><p>JShell 就是 Java 语言提供的 REPL(Read Eval Print Loop，交互式的编程环境）环境。在 Python、Node 之类的语言，很早就带有这种环境，可以很方便的执行 Java 语句，快速验证一些语法、功能等。</p><pre><code class="shell">$ jshell|  欢迎使用 JShell -- 版本 13.0.9|  要大致了解该版本，请键入：/help intro</code></pre><p>我们可以直接使用<code>/help</code>查看命令</p><pre><code class="shell">jshell&gt; /help|  键入 Java 语言表达式，语句或声明。|  或者键入以下命令之一：|  /list [&lt;名称或 id&gt;|-all|-start]|      列出您键入的源|  /edit &lt;名称或 id&gt;。很多的内容，鉴于篇幅，先隐藏</code></pre><p>我们看下一些简单的操作：</p><pre><code class="shell">jshell&gt; &quot;This is a test.&quot;.substring(5, 10);$2 ==&gt; &quot;is a &quot;jshell&gt; 3+1$3 ==&gt; 4</code></pre><p>也可以创建方法：</p><pre><code class="shell">jshell&gt; int mulitiTen(int i) { return i*10;}|  已创建 方法 mulitiTen(int)jshell&gt; mulitiTen(3)$6 ==&gt; 30</code></pre><p>想要退出 JShell 直接输入：</p><pre><code class="shell">jshell&gt; /exit|  再见</code></pre><h2 id="JCMD-新增子命令"><a href="#JCMD-新增子命令" class="headerlink" title="JCMD 新增子命令"></a>JCMD 新增子命令</h2><p><code>jcmd</code>是用于向本地 jvm 进程发送诊断命令，这个命令是从 JDK7 提供的命令行工具，常用于快速定位线上环境故障。</p><p>在 JDK9 之后，提供了一些新的子命令，查看 JVM 中加载的所有类及其继承结构的列表。比如：</p><pre><code class="shell">$ jcmd 22922 VM.class_hierarchy -i -s java.net.Socket22922:java.lang.Object/null|--java.net.Socket/null|  implements java.io.Closeable/null (declared intf)|  implements java.lang.AutoCloseable/null (inherited intf)|  |--sun.nio.ch.SocketAdaptor/null|  |  implements java.lang.AutoCloseable/null (inherited intf)|  |  implements java.io.Closeable/null (inherited intf)</code></pre><p>第一个参数是进程 ID，都是针对这个进程执行诊断。我们还可以使用<code>set_vmflag</code>参数在线修改 JVM 参数，这种操作无需重启 JVM 进程。</p><p>有时候还需要查看当前进程的虚拟机参数选项和当前值：<code>jcmd 22922 VM.flags -all</code>。</p><h2 id="多分辨率图像-API"><a href="#多分辨率图像-API" class="headerlink" title="多分辨率图像 API"></a>多分辨率图像 API</h2><p>在 Java9 中定义了多分辨率图像 API，我们可以很容易的操作和展示不同分辨率的图像了。<code>java.awt.image.MultiResolutionImage</code>将一组具有不同分辨率的图像封装到单个对象中。<code>java.awt.Graphics</code>类根据当前显示 DPI 度量和任何应用的转换从多分辨率图像中获取变量。</p><p>以下是多分辨率图像的主要操作方法：</p><ul><li><code>Image getResolutionVariant(double destImageWidth, double destImageHeight)</code>：获取特定分辨率的图像变体-表示一张已知分辨率单位为 DPI 的特定尺寸大小的逻辑图像，并且这张图像是最佳的变体。</li><li><code>List&lt;Image&gt; getResolutionVariants()</code>：返回可读的分辨率的图像变体列表。</li></ul><p>我们来看下应用：</p><pre><code class="java">final List&lt;Image&gt; images = List.of(        ImageIO.read(new URL(&quot;https://static.howardliu.cn/about/kanshanshuo_2.png&quot;)),        ImageIO.read(new URL(&quot;https://static.howardliu.cn/about/hellokanshan.png&quot;)),        ImageIO.read(new URL(&quot;https://static.howardliu.cn/about/evil%20coder.jpg&quot;)));// 读取所有图片final MultiResolutionImage multiResolutionImage = new BaseMultiResolutionImage(images.toArray(new Image[0]));// 获取图片的所有分辨率final List&lt;Image&gt; variants = multiResolutionImage.getResolutionVariants();System.out.println(&quot;Total number of images: &quot; + variants.size());for (Image img : variants) {    System.out.println(img);}// 根据不同尺寸获取对应的图像分辨率Image variant1 = multiResolutionImage.getResolutionVariant(100, 100);System.out.printf(&quot;\nImage for destination[%d,%d]: [%d,%d]&quot;,        100, 100, variant1.getWidth(null), variant1.getHeight(null));Image variant2 = multiResolutionImage.getResolutionVariant(200, 200);System.out.printf(&quot;\nImage for destination[%d,%d]: [%d,%d]&quot;,        200, 200, variant2.getWidth(null), variant2.getHeight(null));Image variant3 = multiResolutionImage.getResolutionVariant(300, 300);System.out.printf(&quot;\nImage for destination[%d,%d]: [%d,%d]&quot;,        300, 300, variant3.getWidth(null), variant3.getHeight(null));Image variant4 = multiResolutionImage.getResolutionVariant(400, 400);System.out.printf(&quot;\nImage for destination[%d,%d]: [%d,%d]&quot;,        400, 400, variant4.getWidth(null), variant4.getHeight(null));Image variant5 = multiResolutionImage.getResolutionVariant(500, 500);System.out.printf(&quot;\nImage for destination[%d,%d]: [%d,%d]&quot;,        500, 500, variant5.getWidth(null), variant5.getHeight(null));</code></pre><h2 id="变量句柄（Variable-Handles）"><a href="#变量句柄（Variable-Handles）" class="headerlink" title="变量句柄（Variable Handles）"></a>变量句柄（Variable Handles）</h2><p>变量句柄（Variable Handles）的 API 主要是用来替代<code>java.util.concurrent.atomic</code>包和<code>sun.misc.Unsafe</code>类的部分功能，并且提供了一系列标准的内存屏障操作，用来更加细粒度的控制内存排序。一个变量句柄是一个变量（任何字段、数组元素、静态表里等）的类型引用，支持在不同访问模型下对这些类型变量的访问，包括简单的 read/write 访问，volatile 类型的 read/write 访问，和 CAS(compare-and-swap) 等。</p><blockquote><p>这部分内容涉及反射、内联、并发等内容，后续会单独介绍，文章最终会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 中，敬请关注。</p></blockquote><h2 id="发布-订阅框架"><a href="#发布-订阅框架" class="headerlink" title="发布-订阅框架"></a>发布-订阅框架</h2><p>在 Java9 中增加的<code>java.util.concurrent.Flow</code>支持响应式 API 的发布-订阅框架，他们提供在 JVM 上运行的许多异步系统之间的互操作性。我们可以借助<code>SubmissionPublisher</code>定制组件。</p><blockquote><p>关于响应式 API 的内容可以先查看 <a href="http://www.reactive-streams.org/的内容，后续单独介绍，文章最终会发布在" target="_blank" rel="noopener">http://www.reactive-streams.org/的内容，后续单独介绍，文章最终会发布在</a> <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 中，敬请关注。怎么感觉给自己刨了这么多坑，得抓紧时间填坑了。</p></blockquote><h2 id="统一-JVM-日志记录"><a href="#统一-JVM-日志记录" class="headerlink" title="统一 JVM 日志记录"></a>统一 JVM 日志记录</h2><p>在这个版本中，为 JVM 的所有组件引入了一个通用的日志系统。它提供了日志记录的基础。这个功能是通过<code>-Xlog</code>启动参数指定，并且定义很多标签用来定义不同类型日志，比如：gc（垃圾收集）、compiler（编译）、threads（线程）等等。比如，我们定义<code>debug</code>等级的 gc 日志，日志存储在<code>gc.log</code>文件中：</p><pre><code class="shell">java -Xlog:gc=debug:file=gc.log:none</code></pre><p>因为参数比较多，我们可以通过<code>java -Xlog:help</code>查看具体定义参数。而且日志配置可以通过<code>jcmd</code>命令动态修改，比如，我们将日志输出文件修改为<code>gc_other.log</code>：</p><pre><code class="shell">jcmd ${PID} VM.log output=gc_other.log what=gc</code></pre><h2 id="新的-API"><a href="#新的-API" class="headerlink" title="新的 API"></a>新的 API</h2><h3 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h3><p>在 Java9 中增加的<code>java.util.List.of()</code>、<code>java.util.Set.of()</code>、<code>java.util.Map.of()</code>系列方法，可以一行代码创建不可变集合。在 Java9 之前，我们想要初始化一个有指定值的集合，需要执行一堆<code>add</code>或<code>put</code>方法，或者依赖<code>guava</code>框架。</p><p>而且，这些集合对象是可变的，假设我们将值传入某个方法，我们就没有办法控制这些集合的值不会被修改。在 Java9 之后，我们可以借助<code>ImmutableCollections</code>中的定义实现初始化一个不可变的、有初始值的集合了。如果对这些对象进行修改（新增元素、删除元素），就会抛出<code>UnsupportedOperationException</code>异常。</p><p>这里不得不提的是，Java 开发者们也是考虑了性能，针对不同数量的集合，提供了不同的实现类：</p><ul><li><code>List12</code>、<code>Set12</code>、<code>Map1</code>专门用于少量（List 和 Set 是 2 个，对于 Map 是 1 对）元素数量的场景</li><li><code>ListN</code>、<code>SetN</code>、<code>MapN</code>用于数据量多（List 和 Set 是超过 2 个，对于 Map 是多余 1 对）的场景</li></ul><h3 id="改进的-Optional-类"><a href="#改进的-Optional-类" class="headerlink" title="改进的 Optional 类"></a>改进的 Optional 类</h3><p>Java9 中为<code>Optional</code>添加了三个实用方法：<code>stream</code>、<code>ifPresentOrElse</code>、<code>or</code>。</p><p><code>stream</code>是将<code>Optional</code>转为一个<code>Stream</code>，如果该<code>Optional</code>中包含值，那么就返回包含这个值的<code>Stream</code>，否则返回<code>Stream.empty()</code>。比如，我们有一个集合，需要过滤非空数据，在 Java9 之前，写法如下：</p><pre><code class="java">final List&lt;Optional&lt;String&gt;&gt; list = Arrays.asList(        Optional.empty(),        Optional.of(&quot;看山&quot;),        Optional.empty(),        Optional.of(&quot;看山的小屋&quot;));final List&lt;String&gt; filteredList = list.stream()        .flatMap(o -&gt; o.isPresent() ? Stream.of(o.get()) : Stream.empty())        .collect(Collectors.toList());</code></pre><p>在 Java9 之后，我们可以借助<code>stream</code>方法：</p><pre><code class="java">final List&lt;String&gt; filteredListJava9 = list.stream()        .flatMap(Optional::stream)        .collect(Collectors.toList());</code></pre><p><code>ifPresentOrElse</code>：如果一个<code>Optional</code>包含值，则对其包含的值调用函数<code>action</code>，即<code>action.accept(value)</code>，这与<code>ifPresent</code>方法一致；如果<code>Optional</code>不包含值，那会调用<code>emptyAction</code>，即<code>emptyAction.run()</code>。效果如下：</p><pre><code class="java">Optional&lt;Integer&gt; optional = Optional.of(1);optional.ifPresentOrElse(x -&gt; System.out.println(&quot;Value: &quot; + x), () -&gt; System.out.println(&quot;Not Present.&quot;));optional = Optional.empty();optional.ifPresentOrElse(x -&gt; System.out.println(&quot;Value: &quot; + x), () -&gt; System.out.println(&quot;Not Present.&quot;));// 输出结果为：// 作者：看山// 佚名</code></pre><p><code>or</code>：如果值存在，返回<code>Optional</code>指定的值，否则返回一个预设的值。效果如下：</p><pre><code class="java">Optional&lt;String&gt; optional1 = Optional.of(&quot;看山&quot;);Supplier&lt;Optional&lt;String&gt;&gt; supplierString = () -&gt; Optional.of(&quot;佚名&quot;);optional1 = optional1.or(supplierString);optional1.ifPresent(x -&gt; System.out.println(&quot;作者：&quot; + x));optional1 = Optional.empty();optional1 = optional1.or(supplierString);optional1.ifPresent(x -&gt; System.out.println(&quot;作者：&quot; + x));// 输出结果为：// 作者：看山// 作者：佚名</code></pre><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java9 新增的特性，完整的特性清单可以从<a href="https://openjdk.java.net/projects/jdk9/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk9/</a>查看。文中也给自己刨了几个坑，碍于篇幅，没有办法展开，所有这些需要展开的功能细述，都会在 Java8 到 Java17 的新特性系列完成后补充，博文会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-9-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java9 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java9 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Java9 的新特性。Java9 发布于 2017 年 9 月 22 日，带来了很多新特性，其中包括Jigsaw模块化、新的HTTP客户端（Java9中处于孵化中，到Java11可以正式使用）、进程API、JShell、JCMD新增子命令、多分辨率图像API、变量句柄、发布-订阅框架、统一JVM日志等等，还有很多小功能。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java9" scheme="https://www.howardliu.cn/tags/Java9/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构的陷阱：从单体到分布式单体</title>
    <link href="https://www.howardliu.cn/avoid-the-distributed-monolith/"/>
    <id>https://www.howardliu.cn/avoid-the-distributed-monolith/</id>
    <published>2021-12-12T14:32:20.000Z</published>
    <updated>2021-12-12T14:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/squirrel-6846096_1920.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="微服务架构的陷阱：从单体到分布式单体"></p><p>你好，我是看山。</p><p>前面咱们聊了架构的演进过程，提到单体架构、SOA 架构、微服务架构、无服务架构。整个过程如下图：</p><p><img src="https://static.howardliu.cn/microservice/architect-gogogo.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="架构演进过程：单体架构、早期服务化、SOA 架构、微服务架构"></p><p>目前无服务架构还未成熟，只能满足一些简单场景。所以大家在设计软件架构时，首选还是微服务架构。然后我们又聊了聊如何把单体架构改造为微服务架构，推荐采用绞杀模式，一步一步的实现系统微服务化。</p><p>在这个过程中，我们会碰到微服务架构的一个大坑：分布式错觉，即将分布式当成了微服务的全部（充要条件）。</p><a id="more"></a><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>出现分布式单体的主要原因在于，只是用进程间的远程调用替换进程内的方法调用。</p><p><img src="https://static.howardliu.cn/microservice/monolitic-microservice-call.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="模块 A 与模块 B 之间的通信方式"></p><p>从上图可以看出，单体架构在模块 A 与模块 B 之间的请求是通过进程内通信（通常是方法调用）实现的；在微服务架构中，两者之间是通过 REST 或 RPC 调用。抛开进程和消息通知机制的差异，两种架构中模块 A 与模块 B 之间的通信形式完全一致：</p><p><img src="https://static.howardliu.cn/microservice/monolitic-microservice-call2.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="单体/微服务架构中模块间通信方式"></p><p>在这种情况下，模块 A 与模块 B 耦合在一起，任何一方变更请求契约（方法签名或接口参数），另外一个都必须同步修改。更糟糕的是，由于微服务架构服务之间是通过网络通信，由于其不可靠性和不稳定性，大大增加了出错的概率，使模块之间的调用关系更加脆弱。</p><p>模块 A 与模块 B 之间的网络请求是同步调用，请求过程中会占用一个网络连接和至少一个线程，如果模块 A 与模块 B 所在的服务的承压能力不同，很有可能模块 B 所在服务被打满，后续模块 A 的请求会阻塞等待，直到请求超时。</p><p>那又是什么原因让大家没有意识到这种方式不妥呢？原因有两个：</p><ol><li>想要在微服务架构中实现单体架构中模块间的关系；</li><li>想要在分布式应用中实现数据的强一致性。</li></ol><p>针对于微服务架构中的数据一致性问题，可以参考 <a href="https://mp.weixin.qq.com/s?__biz=MzI4OTU5NTA1Ng==&mid=2247484752&idx=1&sn=38e19e269e6609ab14b69d68d5e77529" target="_blank" rel="noopener">关于微服务系统中数据一致性的总结</a>。</p><p>下面我们重点说说如果解决第一个问题。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>对于模块之间的关系，主要在于通信模式，对于查询请求，由于数据依赖，模块之间的耦合是天然的，我们这里要解耦的是数据变更（增、删、改）时的模块调用。</p><p>类比一下现实，我们如果想要通知某些人一个消息，会怎么处理？一般来说，有两种方式：</p><ol><li>点对点主动通知，直接找到这个人，给这个人打电话，不通继续打，保证对方能够收到消息；</li><li>点对面广播通知，比如，群里发给公告、公司的告示栏等，这种方式需要消息接受者主动查看公告信息。</li></ol><p>这两种方式对应了我们系统设计中消息传递的两个模式：指令（Command）、事件（Event）。</p><h3 id="指令（Command）和事件（Event）"><a href="#指令（Command）和事件（Event）" class="headerlink" title="指令（Command）和事件（Event）"></a>指令（Command）和事件（Event）</h3><p><img src="https://static.howardliu.cn/microservice/command_event.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="command 与 event，指令与事件"></p><p>指令（Command）是表示从发起者（source）向执行者（destination）传递（send）一个必须执行某个动作（action）的请求（request）。这个模式有如下特点：</p><ul><li>明确的知道发起者和执行者，发起者依赖执行者；</li><li>请求发送方式一般是点对点同步请求，一般是 RPC 请求；</li><li>动作已发生或即将发生，有可能由于执行者拒绝执行而取消；</li><li>执行者有可能拒绝执行；</li><li>执行者会很明确的告知发起者指令执行情况：拒绝、成功、失败等。</li><li>为了保证指令的有效触达，发起者在网络超时时会重复调用执行者，所以执行者需要实现请求幂等；</li><li>执行者可能会成为下一个指令的发起者。</li></ul><p>事件（event）是表示由生产者（producer）发布（public）一个已经发生的事情，表示行为（action）已经发生，某些状态（status）发生了改变，消费者（consumer）订阅这些事件，然后做出响应。这个模式有如下特点：</p><ul><li>事件有明确的生产者，但是消费者不明确，甚至可能不存在；</li><li>一般借助消息中间件实现事件发送、存储、传递等；</li><li>行为已经发生，不可改变，不可逆，事件是对已经发生事情的客观描述；</li><li>消费者根据消息选择处理方式：执行、抛弃等；</li><li>消费者处理完成后，不需要回复生产者；</li><li>一般消息中间件采用“至少一次”通知机制，所以消费者需要实现消息处理的幂等；</li><li>消费者可能会成为下一个事件的生产者。</li></ul><p><img src="https://static.howardliu.cn/microservice/command-and-event.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="指令与事件之间的区别"></p><p>由于请求模式的不同，在依赖关系上就会发生改变：</p><p>在指令模式中，模块 A 调用模块 B，属于直接调用，模块 A 需要依赖模块 B；在事件模式中，模块 A 把事件发送给消息中间件，其他需要订阅事件的服务，直接从消息中间件获取，这种会产生依赖倒置，模块 B 依赖模块 A。这是解耦模块 A 与模块 B 很好的方式。</p><h3 id="重新定义微服务"><a href="#重新定义微服务" class="headerlink" title="重新定义微服务"></a>重新定义微服务</h3><p>我们再回过头来看看我们的问题：</p><p><img src="https://static.howardliu.cn/microservice/monolitic-microservice-call2.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="单体/微服务架构中模块间通信方式"></p><p>此时我们会比较清晰，由于全系统中使用了指令模式，上次调用者依赖下层，由于是同步请求，依赖会发生传递，这种依赖传递，将整个系统耦合在一起，一处修改，处处变动，也就是我们在抨击单体架构时常说的牵一发而动全身。</p><p>此时，我们就可以借助事件模式，将依赖链条打断。但是需要注意，不要矫枉过正的全部改为事件模式，那将会是另一个火坑。一般我们会将系统改造成下面的样子：</p><p><img src="https://static.howardliu.cn/microservice/refactor-monolitic.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="重新定义微服务"></p><p>根据业务具体情况，我们可以归纳一下改造结果：</p><ol><li>服务 A 接到的请求可能是事件或指令；</li><li>服务 A 会向服务 B 发送指令，也会向消息中间件发送事件；</li><li>服务 B 接到指令后开始执行，执行完毕后，可能会向消息中间件发送事件；</li><li>服务 C 定于事件，从消息中间件接到消息后处理，它可能发送事件或指令。</li></ol><p>需要注意的是，每个服务内部还有有一些操作。抽象一下，整个系统中的指令、事件、操作如下图：</p><p><img src="https://static.howardliu.cn/microservice/command-event-definition.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="指令和事件的定义"></p><ul><li>输入：以一个指令或事件作为输入，开始整个业务执行；</li><li>服务内部操作：服务内部会有执行逻辑，比如操作数据库、访问缓存服务等。可选，0-N 个；</li><li>指令调用：同步调用依赖服务，发送指令，获得结果。可选，0-N 个；</li><li>发布事件：以消息形式发布事件，一般发布到消息中间件，其他发布订阅消息中间件，执行事件需要的行为。可选，事件一般是 0-1 个。</li></ul><p>架构设计的过程不是非此即彼，全部指令会造成耦合，全部事件会致使开发难度提升以及边界不清。我们需要理性的看待两种模式，做到不偏不倚。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文从分布式单体陷阱展开，讲述了分布式错觉带来的问题，然后通过事件、指令两种模式相结合的方式解决问题。微服务是目前比较完善的架构风格，从单体到微服务架构，是要实现架构的升级，所以调用模式不会一成不变。这个陷阱，也是我们在做新系统时需要避免的。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/09ILTzijUr3knHBj13t_kQ" target="_blank" rel="noopener">什么是微服务？</a></li><li><a href="https://mp.weixin.qq.com/s/n1eKTlLP_BbyBkKG4OyLSw" target="_blank" rel="noopener">微服务编程范式</a></li><li><a href="https://mp.weixin.qq.com/s/sRkYdrAwvn8UrGSraAURpA" target="_blank" rel="noopener">微服务的基建工作</a></li><li><a href="https://mp.weixin.qq.com/s/sRX04UhPiFWSDOazTSXuXw" target="_blank" rel="noopener">微服务中服务注册和发现的可行性方案</a></li><li><a href="https://mp.weixin.qq.com/s/NcftJ1jNAd-DHpzBXKk8RA" target="_blank" rel="noopener">从单体架构到微服务架构</a></li><li><a href="https://mp.weixin.qq.com/s/gSWFUsFnaqRKyGXVgdUqew" target="_blank" rel="noopener">除了微服务，我们还有其他选择吗？</a></li><li><a href="https://mp.weixin.qq.com/s/M0sla4LVvp2lEiFpzwyVrA" target="_blank" rel="noopener">如何在微服务团队中高效使用 Git 管理代码？</a></li><li><a href="https://mp.weixin.qq.com/s/apHFXB2cUqDALpJJebNp9A" target="_blank" rel="noopener">关于微服务系统中数据一致性的总结</a></li><li><a href="https://mp.weixin.qq.com/s/AE0n4d_zRZOEeYEQt-rSKw" target="_blank" rel="noopener">实现 DevOps 的三步工作法</a></li><li><a href="https://mp.weixin.qq.com/s/mMjbafRIhia3u9DmXPSfPQ" target="_blank" rel="noopener">系统设计系列之如何设计一个短链服务</a></li><li><a href="https://mp.weixin.qq.com/s/mtt_wsUChGIwnR-Nz5BE4g" target="_blank" rel="noopener">系统设计系列之任务队列</a></li><li><a href="https://mp.weixin.qq.com/s/_PI5jRP99ktPs3lxCbBLSg" target="_blank" rel="noopener">软件架构-缓存技术</a></li><li><a href="https://mp.weixin.qq.com/s/668L2NK7LWo3c8U8ZI_1ng" target="_blank" rel="noopener">软件架构-事件驱动架构</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/avoid-the-distributed-monolith/">微服务架构的陷阱：从单体到分布式单体</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/121944074" target="_blank" rel="noopener">微服务架构的陷阱：从单体到分布式单体</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      目前无服务架构还未成熟，只能满足一些简单场景。所以大家在设计软件架构时，首选还是微服务架构。然后我们又聊了聊如何把单体架构改造为微服务架构，推荐采用绞杀模式，一步一步的实现系统微服务化。在这个过程中，我们会碰到微服务架构的一个大坑：分布式错觉，即将分布式当成了微服务的全部（充要条件）。
    
    </summary>
    
    
      <category term="microservice" scheme="https://www.howardliu.cn/categories/microservice/"/>
    
    
      <category term="微服务" scheme="https://www.howardliu.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="架构" scheme="https://www.howardliu.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>如何实现单体架构到微服务架构的蜕变？</title>
    <link href="https://www.howardliu.cn/from-monolith-to-microservices-2/"/>
    <id>https://www.howardliu.cn/from-monolith-to-microservices-2/</id>
    <published>2021-12-05T14:40:49.000Z</published>
    <updated>2021-12-05T14:40:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/rose-leaf-6831355_1920.jpg" alt="如何实现单体架构到微服务架构的蜕变？" title="如何实现单体架构到微服务架构的蜕变？"></p><p>你好，我是看山。</p><p>前文我们聊了介绍了单体架构、SOA 架构、微服务架构、无服务架构。如果原来是单体架构，想要切换到微服务架构，该怎么解决呢？本文来聊聊这个话题，解决“什么时候（WHEN）、怎样做（HOW）”。</p><a id="more"></a><h2 id="什么时候"><a href="#什么时候" class="headerlink" title="什么时候"></a>什么时候</h2><p>微服务架构是一种架构风格，专注于软件研发效能，主要包括单位时间内实现更多功能，或者软件从想法到上线的整个持续交付的过程。在当前的互联网环境中，业务变化迅速，使用微服务架构，可以让团队迅速反应，快速实施，在方案没有过期之前已经上线运行，经受市场考察和考验。</p><p>目前国内大多数公司正在运行的系统都是单体架构系统，不可否认，这些系统在公司发展过程中，发挥了不可替代的作用，保障了公司正常运行，创造了很多价值。但是，随着系统的日渐膨胀，集成的功能越来越多，开发效率变得越来越低，一个功能从想法到实现，需要花费越来越长的时间。更严重的是，由于代码模块纠结在一起，很多已经老化的架构或者废弃的功能，已经成为新功能的阻碍。</p><p><img src="https://static.howardliu.cn/microservice/737565-20181016193114922-488026211.png" alt="单体架构与微服务架构的成本" title="单体架构与微服务架构的成本"></p><p>上图中，X 轴是业务复杂度，Y 轴是单位效益。绿色线条代表单体架构，蓝色线条代表微服务架构。</p><p>可以看到，在业务发展初期，系统复杂度不高，业务不够成熟，我们主要经历在于业务试错。如果采用单体架构，可以将所有的功能、模块放在一个进程；如果此时采用微服务架构，我们就需要考虑进程间通信、不可靠网络故障等，还需要实现微服务的基础组件。这个时候，单体架构的单位效益是高于微服务架构的。</p><p>随着业务发展，系统承载的功能越来越多，单体架构的劣势凸显，比如：</p><ol><li>硬件能力难以跟上急速发展的业务；</li><li>系统隔离性差，所有功能都在一个进程中，一个功能的异常可能影响其他功能；</li><li>代码复杂度提升，团队合作越来越难，代码冲突的可能性越来越高；</li><li>庞大的代码量，在日常开发、测试时，IDE 难以支持；</li><li>系统构建、部署时间延长；</li><li>技术绑定，没有办法根据系统功能需要灵活使用不同技术；</li><li>……</li></ol><p>总而言之，单体架构随着功能增多，不可避免的是研发效能的降低：研发周期变长、研发资源占用增多。从而引发的情况是：新员工培训时间增多、员工加班时间变长、员工要求涨薪或者跳槽。</p><p>当达到图中的交叉点时，说明单体架构已经不能够满足企业发展需要，这个时候，需要升级架构来提升研发效能，比如微服务架构。</p><p>有人会问，这个时间点不太好把握。我们只需要考虑三个问题即可：</p><ol><li>产品是否已经经过市场考验？</li><li>是否需要超过一个团队来保证产品发布？</li><li>系统是否对可靠性、可伸缩性有较高要求？</li></ol><p>如果都是肯定回答，那就该着手准备将单体架构切换为微服务架构了。</p><h2 id="怎样做"><a href="#怎样做" class="headerlink" title="怎样做"></a>怎样做</h2><p>从单体架构到微服务架构，从一个大一统的系统，拆分成一个一个单独的小服务，我们需要投入精力，做基础的准备：</p><ol><li>先要了解什么是服务、该怎么拆分；</li><li>然后需要搭建基础设施，为拆分出来的服务做好后勤保障；</li><li>最后才是一步一步完成架构切换。</li></ol><h3 id="认识服务"><a href="#认识服务" class="headerlink" title="认识服务"></a>认识服务</h3><p>首先，什么是微服务架构呢？通俗的定义是：“一组围绕业务领域建模的、小而自治的、彼此协同工作的服务。”</p><p>微服务架构中的服务，是根据业务能力抽取的业务模块，独立开发和部署，但是需要彼此配合完成整个业务功能。服务不是单纯的数据存储组件，也不是单纯的逻辑函单元。只有同时包括数据+逻辑，才是真正意义上的服务。</p><p>服务拆解过程中，DDD（领域驱动设计）可以作为微服务架构的指导方针。因为微服务是围绕业务功能定义服务，根据服务定义团队，这与 DDD 将业务域拆解为业务子域、定义限定上下文的方法论如出一辙，于是 DDD 作为微服务的指导方针，快速定义各个服务组件，完成从单体架构到微服务架构的迁移。</p><p><img src="https://static.howardliu.cn/microservice/121148382613129.jpg" alt="领域驱动设计" title="领域驱动设计"></p><p>Alberto Brandolini 提出识别服务上下文的方式叫做“Event Storming”。第一步是识别业务域中发生的事件，也就是说，我们的关注点是行为，不是数据结构。这样做的好处是，系统中不同服务之间是松散耦合关系，而且单个服务能够自治。</p><p>定义好了服务边界，还需要定义事务边界。过去，我们的服务在一个进程中，后面挂着一个数据库，事务可以选择强一致性事务，也就是 ACID。当服务增多，彼此配合，这个时候可以使用最终一致性事务，也就是 BASE。不同于 ACID，BASE 更加灵活，只要数据在最终能够保持一致就可以了。这个最终的时间范围，根据不同的业务场景不同，可能是分钟、小时、天，甚至是周或者月。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>微服务架构愿景美好，属于重型武器，优点众多，缺点也很明显。服务增多，运维难度增大，错误调试难度增大。所以需要自动化构建、配置、测试和部署，需要日志收集、指标监控、调用链监控等工具，也就是需要 DevOps 实践。<a href="https://www.howardliu.cn/the-three-ways-principles-underpinning-devops/">实现 DevOps 的三步工作法</a> 中说明了实现 DevOps 文化的三个步骤。</p><p>除了上面提到的基础，还需要在早期确定服务之间如何集成和彼此调用方式，还需要确定数据体系，包括事务一致性和数据可靠性方法。随着服务增多，还需要配置管理、服务发现等众多组件。具体需要的基础组件可以参考 <a href="https://www.howardliu.cn/the-base-of-microservice/">微服务的基建工作</a>。</p><p><img src="https://static.howardliu.cn/microservice/microservice-architecture.png" alt="微服务架构中的基础组件" title="微服务架构中的基础组件"></p><p>这些基础的服务和设计，最好在早期定义，否则，后期需要花费更多的资源才能够完善架构。如果前期缺失，后期也没有补足，造成的后果就是微服务架构迁移失败，最后的系统也只是披着微服务外衣的单体架构。</p><h3 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h3><p>当我们确定开始使用微服务架构时，接下来的问题就是应该怎么做？是逐步进化更新系统、还是破釜沉舟重构整个系统。</p><p>第二种方式很诱人，比较符合大多数技术人的思维，系统不行，推倒重来，名为重构。但是在大多数情况下，这种方式不能被允许，因为市场变化迅速、竞争激烈，大多数公司不会停止业务，去等待重构一个能够运行、只是有些缺点的系统。所以，逐步替换更新系统才是王道，大多数公司也能接受。这种方式又被称为绞杀模式。</p><p>该如何逐步过渡到微服务架构？下面一步步进行展示：</p><p><img src="https://static.howardliu.cn/microservice/from_monolith_to_microservice_0.jpg" alt="实现单体架构到微服务架构：单体架构" title="实现单体架构到微服务架构：单体架构"></p><p>第一步，将视图层与服务层部分逻辑进行分离。业务逻辑委托给服务层，支持页面展示的查询定向到数据库。这个阶段，我们不修改数据库本身。</p><p><img src="https://static.howardliu.cn/microservice/from_monolith_to_microservice_1.jpg" alt="实现单体架构到微服务架构：部分拆分视图和业务逻辑" title="实现单体架构到微服务架构：部分拆分视图和业务逻辑"></p><p>第二步，用户视图层与数据库完全分离，依赖于服务层操作数据库。</p><p><img src="https://static.howardliu.cn/microservice/from_monolith_to_microservice_2.jpg" alt="实现单体架构到微服务架构：完全拆分视图和业务逻辑" title="实现单体架构到微服务架构：完全拆分视图和业务逻辑"></p><p>第三步，将用户视图层与服务层拆分为不同服务，并在服务层创建一个 API 层，用于视图层与服务层之间通信。</p><p><img src="https://static.howardliu.cn/microservice/from_monolith_to_microservice_3.jpg" alt="实现单体架构到微服务架构：物理拆分视图和业务逻辑" title="实现单体架构到微服务架构：物理拆分视图和业务逻辑"></p><p>第四步，拆分数据库，将不同业务数据拆分到不同的数据库中，同时对应业务服务层拆分到不同的服务。用户视图层通过 API 网关与不同业务服务层的 API 组件通信。这个时候需要注意，如果团队没有微服务开发经验，可以在这一步基础使用绞杀方式，先抽取简单业务域服务，因为业务简单，实现简单，可以练手，积累经验。</p><p><img src="https://static.howardliu.cn/microservice/from_monolith_to_microservice_4.jpg" alt="实现单体架构到微服务架构：业务服务层拆分、垂直拆分数据库" title="实现单体架构到微服务架构：业务服务层拆分、垂直拆分数据库"></p><p>最后一步，拆分用户视图层。</p><p><img src="https://static.howardliu.cn/microservice/from_monolith_to_microservice_5.jpg" alt="实现单体架构到微服务架构：拆分用户视图层" title="实现单体架构到微服务架构：拆分用户视图层"></p><p>绞杀模式的优势就在于，我们可以随着业务变化随时调整方案，不会造成整个业务进化过程的停摆。</p><h2 id="成功标准"><a href="#成功标准" class="headerlink" title="成功标准"></a>成功标准</h2><p><img src="https://static.howardliu.cn/Illustration/measuring-success-with-guavabox.jpg" alt="If you cannot measure it, you cannot manage it!" title="If you cannot measure it, you cannot manage it!"></p><p><strong>If you cannot measure it, you cannot manage it!</strong></p><p>引入微服务的目的首先是改善开发流程，我们可以通过简单的指标来衡量：</p><ul><li>开发周期：从概念到上线持续的时间</li><li>开发效能：单位时间内团队或个人完成的功能或用户故事</li><li>系统可伸缩性：系统的水平、垂直扩展能力</li><li>平均维修时间：查找和排除故障所需时间</li></ul><p>通过对比老架构和新架构的这些特性值，可以评估升级过程取得的效果。我们要时刻关注这些指标，只有一个个小阶段的胜利，才能组成最终完整的胜利。如果再某个阶段失败了，可能达不到我们最终的目的，或者埋下技术债务，后期不得不花更大的代价补偿。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>想要说明微服务架构的好处，可以来一个比喻。我们建了一个空间站，为此，我们需要将人、货物和设备运输到空间站中，这个时候，运载火箭是比较好的选择，尽管运载火箭造价也比较高，但是几个月发射一次，也能够满足需求。随着空间站的扩大，火箭发射的间隔变短，运输成本高的离谱，而且越来越没法满足空间站运转需求。这个时候，可以尝试另外一种方式，比如，太空电梯。当然太空电梯的造价成本高于一次飞行的费用，但是只要建成，以后的成本就降低了很多。</p><p>这个比喻也是说明了微服务带来的美好期望，同时也说明一个问题，实施微服务架构会带来巨大的投资。所以，我们在建造太空电梯之前需要想好，我们真的需要这种投入，否则只能是一种浪费。</p><p>作为攻城狮，我们为能够解决或改善周围世界而自豪，着迷于提供解决方案。同时，我们也要意识到，我们付出的每一份努力，都要有回报。如果不能带来任何回报的重构升级，都是浪费时间。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/09ILTzijUr3knHBj13t_kQ" target="_blank" rel="noopener">什么是微服务？</a></li><li><a href="https://mp.weixin.qq.com/s/n1eKTlLP_BbyBkKG4OyLSw" target="_blank" rel="noopener">微服务编程范式</a></li><li><a href="https://mp.weixin.qq.com/s/sRkYdrAwvn8UrGSraAURpA" target="_blank" rel="noopener">微服务的基建工作</a></li><li><a href="https://mp.weixin.qq.com/s/sRX04UhPiFWSDOazTSXuXw" target="_blank" rel="noopener">微服务中服务注册和发现的可行性方案</a></li><li><a href="https://mp.weixin.qq.com/s/NcftJ1jNAd-DHpzBXKk8RA" target="_blank" rel="noopener">从单体架构到微服务架构</a></li><li><a href="https://mp.weixin.qq.com/s/M0sla4LVvp2lEiFpzwyVrA" target="_blank" rel="noopener">如何在微服务团队中高效使用 Git 管理代码？</a></li><li><a href="https://mp.weixin.qq.com/s/apHFXB2cUqDALpJJebNp9A" target="_blank" rel="noopener">关于微服务系统中数据一致性的总结</a></li><li><a href="https://mp.weixin.qq.com/s/AE0n4d_zRZOEeYEQt-rSKw" target="_blank" rel="noopener">实现DevOps的三步工作法</a></li><li><a href="https://mp.weixin.qq.com/s/mMjbafRIhia3u9DmXPSfPQ" target="_blank" rel="noopener">系统设计系列之如何设计一个短链服务</a></li><li><a href="https://mp.weixin.qq.com/s/mtt_wsUChGIwnR-Nz5BE4g" target="_blank" rel="noopener">系统设计系列之任务队列</a></li><li><a href="https://mp.weixin.qq.com/s/_PI5jRP99ktPs3lxCbBLSg" target="_blank" rel="noopener">软件架构-缓存技术</a></li><li><a href="https://mp.weixin.qq.com/s/668L2NK7LWo3c8U8ZI_1ng" target="_blank" rel="noopener">软件架构-事件驱动架构</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/from-monolith-to-microservices-2/">如何实现单体架构到微服务架构的蜕变？</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">如何实现单体架构到微服务架构的蜕变？</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      如果原来是单体架构，想要切换到微服务架构，该怎么解决呢？本文来聊聊这个话题，解决“什么时候（WHEN）、怎样做（HOW）”。
    
    </summary>
    
    
      <category term="microservice" scheme="https://www.howardliu.cn/categories/microservice/"/>
    
    
      <category term="微服务" scheme="https://www.howardliu.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="单体架构" scheme="https://www.howardliu.cn/tags/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    
      <category term="重构" scheme="https://www.howardliu.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>除了微服务，我们还有其他选择吗？</title>
    <link href="https://www.howardliu.cn/do-we-have-any-other-options-besides-microservices/"/>
    <id>https://www.howardliu.cn/do-we-have-any-other-options-besides-microservices/</id>
    <published>2021-12-05T14:25:56.000Z</published>
    <updated>2021-12-05T14:25:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/bird-6720306_1920.jpg" alt="除了微服务，我们还有其他选择吗？"></p><p>你好，我是看山。</p><p>前面我们聊了微服务的话题，现在微服务已经是业内通识。但凡系统开发、系统设计，必然采用微服务架构，或者宣称是微服务架构。</p><p>但大家有没有想过，微服务架构不是一开始就有的。如果追溯历史，微服务最早在 2005 的云计算博览会，由 Peter Rodgers 博士提出（那时候称为微 Web 服务（Micro-Web-Service））。到了 2014 年，Martin Fowler 与 James Lewis 共同提出微服务（Micron-Service）的概念，算是对概念归纳总结，天下一统。这一年也被称为微服务元年。</p><p><img src="https://static.howardliu.cn/Illustration/1565046133.jpg" alt="看山的小屋"></p><p>那就要问了，在 2014 年之前呢？大家用啥架构？再往前呢？上次互联网大潮的时候，大家又是用啥？我们今天来聊聊这段历史，可能你会对现在习以为常的架构，产生一些新的看法。在架构上，可以有更多的选择。</p><a id="more"></a><h2 id="人人喊打的单体架构"><a href="#人人喊打的单体架构" class="headerlink" title="人人喊打的单体架构"></a>人人喊打的单体架构</h2><blockquote><p>单体架构，人人都说这种架构不好，为什么不好呢？真的不好吗？可能真相并不是你认为的那样简单。</p></blockquote><p>当前来说，如果有人说某个系统是单体架构，一定会有人投来怀疑的眼神，有的会带着些许不可思议，甚至带有一丝鄙夷。但是不得不说，单体架构（又称巨石系统，Monolithic）是整个软件发展过程中，出现时间最早、应用范围最广的一种架构风格。从另一个方面，原来本没有单体架构这个称呼，只是后来有了微服务架构，为了区分，才把所有“自包含”的系统称为单体架构。</p><p><img src="https://static.howardliu.cn/microservice/699473-20171125103303375-138169041.png" alt="人人喊打的单体架构构"></p><p>上面这个图就是单体架构，所谓“自包含”，简单说就是自给自足，所有业务功能靠自己，不依赖其他业务系统。其优点有下面这些：</p><ul><li>不涉及进程间通信，效率可控；</li><li>不依赖网络通讯，可以规避不可靠的网络通讯带来难以预知的故障；</li><li>开发生态良好，目前的 IDE 对单体架构的支持更好；</li><li>编码重构容易，单体架构完全的自控制，只要修改自己即可，不需要上下游支持；</li><li>端到端测试简单，因为没有上下游依赖，测试起来更加方便，部署一套环境，就可以实现当前功能的完全测试；</li><li>部署简单，只要打包成 EAR、WAR、JAR 等需要的运行包，扔进服务器就能跑；</li><li>运维简单，一个进程运行的服务，无论是日志还是运行态，都能够很简单的监控；</li><li>横向扩展容易，前面一个负载均衡器做代理，后面可以无限扩展。</li></ul><p>从这个角度，只要单机优势明显，就不该把单体架构视为地狱。</p><p>所谓“成也萧何败也萧何”，统一“集中”成就了单体架构，难以“隔离”也成为了单体架构最大的弊端。这里将隔离简单分为开发期隔离和运行期隔离。</p><p>单体架构省去了进程间通信、性能损失这些麻烦事，但因为在一个进程中执行，如果内部的某处逻辑异常，可能会造成整个系统的崩溃。最常见的内存溢出，可能仅仅是一个不相干的功能查了全表，整个系统都都会宕掉。</p><p><img src="https://static.howardliu.cn/Illustration/300.jpeg" alt="系统崩溃"></p><p>运行期没有办法隔离，升级的时候也没有办法隔离。想要对某些模块功能升级，只能重启整个服务。还要担心会不会有没有覆盖测试的点，提前做好预案，挂好停机维护页。</p><p>因此，一个成功的单体架构系统隐含了一个要求，需要一个对系统完全了解的大脑（一个人或一组人），大脑可以总控系统的开发、升级、运行，把控这个系统的每个细节，实现系统中的各个组件、模块有很高的品质，从而保障系统可在其生命周期内可以稳定的运行。</p><p>比如，SAP 和 Hyperion，妥妥的单体架构，作为国际化的软件公司，为什么不对它们升级改造？是能力不行，还是技术不行？是没有必要。所以，单体架构也不是一无是处，一切都要在合适的前提下评价。</p><h2 id="开疆拓土的-SOA-架构"><a href="#开疆拓土的-SOA-架构" class="headerlink" title="开疆拓土的 SOA 架构"></a>开疆拓土的 SOA 架构</h2><blockquote><p>都说 SOA 架构太重，但他是开创服务化江山的鼻祖。</p></blockquote><p><img src="https://static.howardliu.cn/microservice/Enterprise-service-bus-architecture.png" alt="开疆拓土的 SOA 架构"></p><p>单体架构对团队的要求较高，随着团队的扩大，必然会有短板或薄弱的环节，或者是组织、或者是个人，这样就会给系统代理风险。于是，很多前辈就开始思考，一个庞然大物难以维护，那就分为治之，拆分成多个规模小一些的单体架构，彼此之间通过某种方式交互。这种方案被称为面向服务架构（SOA，Service-Oriented Architecture）。</p><p>SOA 在 1994 年就被提出，这种架构风格是自然演化来的。只不过当时没有足够的条件支持，一直只能处于理论阶段。后来随着 webservice 等技术的提出，才有了技术支撑。到 2006 年，OSOA 成立，共同制定 SOA 架构相关行业标准，这套架构有了理论、技术、规范等一系列约定，从而真正落地。</p><p>SOA 架构开疆拓土，开创了很多目前也在使用的概念，比如服务注册/发现、服务治理、系统隔离、服务编排等。是不是觉得这些概念很熟悉，是的，在微服务架构中，同样有这些概念的身影。SOA 架构有自己的一套风格，使用下面一些组件实现普适的方法论：</p><ol><li>采用 SOAP 作为远程调用的协议；</li><li>利用 ESB（Enterprise Service Bus，企业服务总线）实现各个子系统之间的通信交互；</li><li>使用 BPM（Business Process Management，业务流程管理系统）实现业务流程编排；</li><li>使用 SDO（Service Data Object，服务数据对象）来访问和表示数据；</li><li>使用 SCA（Service Component Architecture，服务组件架构）来定义服务封装的形式和服务运行的容器；</li><li>……</li></ol><p>SOA 架构是各大软件服务商共同愿景下的产物，总结出了一套自上而下的软件研发方法论，期望能够解决软件开发过程中的所有问题。有些类似于八股文，规定好起承转合，只要按照要求来，系统就不会出现太多问题。</p><p>愿景虽好，但是却忽略了一点，一套大而全的架构体系，不是所有公司都能够支撑起来的。有时候，大而全不如小而美。但是，我们不能否认 SOA 架构对于面向服务理论的贡献，在某些场景下的企业内部，SOA 是能够快速打破信息孤岛的重要手段。</p><h2 id="另立门户的微服务架构"><a href="#另立门户的微服务架构" class="headerlink" title="另立门户的微服务架构"></a>另立门户的微服务架构</h2><blockquote><p>本来是作为 SOA 的一种简化方案，结果直接发动宣武门之变，逼着 SAO 禅让。</p></blockquote><p><img src="https://static.howardliu.cn/microservice/microservice-architecture.png" alt="另立门户的微服务架构"></p><p>如开篇所说，微服务架构是在 2005 年提出，在 2014 年崛起。经历了将近 10 年的时间，之所以没有得到太多重视，是因为 2014 年之前，微服务只是在作为 SOA 架构的简化版出现。直到 2014 年才作为独立的架构风格，与 SOA 架构划清界限。</p><p>Martin Fowler 与 James Lewis 在合写的 <a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">《Microservices》</a> 对微服务下了定义：“微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。”</p><p>文中还提出了微服务架构的 9 个核心特征：</p><ol><li>通过服务来实现独立自治的组件（Componentization via Services）</li><li>围绕业务能力构建（Organized around Business Capability）</li><li>产品化思维（Products not Projects）</li><li>强终端弱管道（Smart Endpoint and Dumb Pipe）</li><li>分散治理（Decentralized Governance）</li><li>数据去中心化（Decentralized Data Management）</li><li>基础设施自动化（Infrastructure Automation）</li><li>容错性设计（Design for Failure）</li><li>演进式设计（Evolutionary Design）</li></ol><p>由于微服务架构是从 SOA 架构中演化而来，所以很多的表现形式都是一致的。从《Microservices》对微服务架构全面细致阐述之后，也算是将微服务架构与 SOA 架构彻底划清界限。</p><p>在笔者看来，微服务架构与 SOA 架构最大的不同在于对于实现的约束，SOA 架构有一套完整的规约，微服务架构只有建议，追求的是根据实际情况自由变化，简单的理解就是“想怎么玩就怎么玩”。比如通信协议，SOA 架构明确要求使用 SOAP 通信协议；微服务架构只要求使用轻量级的 RPC 协议，这个选择就比较宽泛了，常见的就有 HTTP（一般采用 Restful 风格）、gRPC、Dubbo、Thrift、Motan2 等等。</p><p>自由意味着可以根据实际情况变化，需要什么引入什么，哪种技术能更好的解决问题就使用哪种技术。在 Java 栈中，也出现了 SpringCloud Netflix 和 SpringCloud Alibaba 之类的全家桶组件，作为开发者，只需要在需要的时候添加依赖即可。</p><p>从架构师的角度，自由带来的是约束力的下降，同时也缺少了规约的指导性。我们需要更加了解系统本身，也要更加了解各种技术的优缺点，才能够在架构设计时，更好的权衡利弊，做好取舍。加油，少年。</p><p><img src="https://static.howardliu.cn/Illustration/jiayou.jpg" alt="架构师养成计划"></p><p>我们来看下微服务中的基础组件：弹性伸缩、服务发现、配置中心、服务网关、负载均衡、服务安全、跟踪监控、降级熔断等等，其实从本质来说，这些组件都是业务无关的。实现软件开发过程中，可以将这些与业务隔离开，也就是所谓的“透明化”。</p><p>比如服务发现，可选的方案包括 Nginx、HAProxy、DNS、Eureka、Nacos、KubeDNS，但是我们真的关心吗？不需要，只需要知道我们要进行网络调用，有一个目标即可，至于这个目标是通过哪种方式发现、传输、寻址，都与我们要实现的功能无关。那就将服务发现与业务剥离，通过承载服务的运行环境处理。这就是所谓的边车模型。</p><p><img src="https://static.howardliu.cn/microservice/service-mesh-with-side-car.png" alt="边车模型"></p><p>微服务之所以应用普及，不仅仅在于其独特优势，还与容器化技术的普及有密切关系。微服务与 Docker 虚拟化的高效结合，相当于给了微服务二次加速的动力，资源调度 Kubernetes 的成功，可以认为是直接实现了曲速推进。先进的理念还需要先进的技术实现。</p><h2 id="有待成熟的无服务架构"><a href="#有待成熟的无服务架构" class="headerlink" title="有待成熟的无服务架构"></a>有待成熟的无服务架构</h2><blockquote><p>又想要快，还想要简单。那就不要服务了，随便写个函数跑跑得了。</p></blockquote><p><img src="https://static.howardliu.cn/microservice/Serverless_Architecture.png" alt="有待成熟的无服务架构"></p><p>就目前而言，绝大部分的系统开发都是为了解决业务问题。在这个过程中，我们需要选择一些业务无关的技术组件。有时候，我们受限于研发环境，需要的某种技术组件不存在时，需要采购部署，或者使用替代方案。这就会分散我们的注意力。</p><p>于是，很多云服务商提出了无服务架构。无服务架构将系统开发涉及的资源分为两部分：后端设施（Backend）、函数（Function），对应的就是 BaaS（Backend as a Service，后端即服务）和 FaaS（Function as a Service，函数即服务）。</p><p>这种不能算是架构风格，只能算是一种系统开发过程中的美好愿景。让开发者只需要关注业务，需要的基础设施全部由云服务提供，不需要考虑运行容器、基础设施的部署、服务器运行能力等。只要将开发好的代码上传，就可以拥有一个可运行的系统。</p><p>但是愿景虽好，但是与自己掌控部署的区别仅在于对于基础设施的管控程度上。除非出现重大变革，否则这种架构很难像微服务架构一样普适。但是对于小程序、小型 web 网站、咨询平台等模板化的小型系统，采用这种架构还是有很大优势的。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文从架构演进的角度分析了单体架构、SOA 架构、微服务架构、无服务架构的适用场景，作为架构师，我们在选择架构师，不应该一味追求主流，也不能盲从大厂的思路。我们要根据自身情况权衡利弊，找到适合的架构风格。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/09ILTzijUr3knHBj13t_kQ" target="_blank" rel="noopener">什么是微服务？</a></li><li><a href="https://mp.weixin.qq.com/s/n1eKTlLP_BbyBkKG4OyLSw" target="_blank" rel="noopener">微服务编程范式</a></li><li><a href="https://mp.weixin.qq.com/s/sRkYdrAwvn8UrGSraAURpA" target="_blank" rel="noopener">微服务的基建工作</a></li><li><a href="https://mp.weixin.qq.com/s/sRX04UhPiFWSDOazTSXuXw" target="_blank" rel="noopener">微服务中服务注册和发现的可行性方案</a></li><li><a href="https://mp.weixin.qq.com/s/NcftJ1jNAd-DHpzBXKk8RA" target="_blank" rel="noopener">从单体架构到微服务架构</a></li><li><a href="https://mp.weixin.qq.com/s/M0sla4LVvp2lEiFpzwyVrA" target="_blank" rel="noopener">如何在微服务团队中高效使用 Git 管理代码？</a></li><li><a href="https://mp.weixin.qq.com/s/apHFXB2cUqDALpJJebNp9A" target="_blank" rel="noopener">关于微服务系统中数据一致性的总结</a></li><li><a href="https://mp.weixin.qq.com/s/AE0n4d_zRZOEeYEQt-rSKw" target="_blank" rel="noopener">实现DevOps的三步工作法</a></li><li><a href="https://mp.weixin.qq.com/s/mMjbafRIhia3u9DmXPSfPQ" target="_blank" rel="noopener">系统设计系列之如何设计一个短链服务</a></li><li><a href="https://mp.weixin.qq.com/s/mtt_wsUChGIwnR-Nz5BE4g" target="_blank" rel="noopener">系统设计系列之任务队列</a></li><li><a href="https://mp.weixin.qq.com/s/_PI5jRP99ktPs3lxCbBLSg" target="_blank" rel="noopener">软件架构-缓存技术</a></li><li><a href="https://mp.weixin.qq.com/s/668L2NK7LWo3c8U8ZI_1ng" target="_blank" rel="noopener">软件架构-事件驱动架构</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/do-we-have-any-other-options-besides-microservices/">除了微服务，我们还有其他选择吗？</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/121760358" target="_blank" rel="noopener">除了微服务，我们还有其他选择吗？</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      从单体架构、SOA架构，到微服务架构，再到容器化、无服务架构，我们的选择很多，没有必要非在一棵树上吊死。
    
    </summary>
    
    
      <category term="microservice" scheme="https://www.howardliu.cn/categories/microservice/"/>
    
    
      <category term="微服务" scheme="https://www.howardliu.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="架构" scheme="https://www.howardliu.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java8 的新特性</title>
    <link href="https://www.howardliu.cn/java-8-features/"/>
    <id>https://www.howardliu.cn/java-8-features/</id>
    <published>2021-11-24T23:53:04.000Z</published>
    <updated>2021-11-24T23:53:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/fruits-6786607_1920.jpg" alt="Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java8 的新特性"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/visionpics-4638469/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6786607" target="_blank" rel="noopener">Alexandr Podvalny</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6786607" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《Java 进阶》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中仍有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述从 Java8 开始各个版本的新特性。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Java8 从 2014 年问世，到现在已是数个年头。这个版本新增了 Stream API、Lambda 表达式、新时间 API 等各种新特性，相比很多新兴语言也不遑多让。今天就来聊聊 Java8 中好玩好使的特性功能（完整特性请参见 <a href="https://openjdk.java.net/projects/Java8/features" target="_blank" rel="noopener">这里</a>）。</p><h2 id="接口方法"><a href="#接口方法" class="headerlink" title="接口方法"></a>接口方法</h2><p>在 Java8 之前，接口只能够定义<code>public abstract</code>方法，默认可以不写修饰符。当在接口中新增方法定义，该接口的所有实现类都需要新增这个方法的实现，这样对于升级扩展很不友好。</p><p>从 Java8 开始，我们可以在接口中定义静态方法和默认方法了，也就是我们可以在接口中定义具有具体操作行为的方法定义，这样接口的实现类可以有选择的实现接口方法。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>Java8 之前，静态方法是类的专属技能，这样会引起概念上的一些歧义。比如，我们定义一个生产者<code>Producer</code>接口，所有生产者都继承该接口，这个时候，我们需要一个静态方法提供<code>Producer</code>的名字。这个时候，在单独定义一个类提供一个静态方法提供名字，可以实现功能，但是略显复杂。</p><p>现在我们直接在<code>Producer</code>生产者接口中定义静态方法即可：</p><pre><code class="java">static String producer() {    return &quot;target: &quot; + System.currentTimeMillis();}</code></pre><p>沿用约定的限定范围，我们不需要在方法前面加<code>public</code>。这个静态方法只能通过接口调用，或者在接口内部直接引用。比如：</p><pre><code class="java">final String target = Producer.producer();</code></pre><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>接口的默认方法定义需要使用<code>default</code>关键字，接口中定义的默认方法可以在实现类中重写。</p><p>比如，我们的生产者<code>Producer</code>需要生产东西，我们可以在接口中定义一个默认方法：</p><pre><code class="java">default String produce() {    return &quot;NULL&quot;;}</code></pre><p>我们可以定义<code>Producer</code>的实现类是<code>Hamburger</code>，可以选择重写接口的默认方法，也可以不用重写。比如：</p><pre><code class="java">public class Hamburger implements Producer {}</code></pre><p>使用的时候直接调用：</p><pre><code class="java">final Producer producer = new Hamburger();System.out.println(producer.produce());</code></pre><p>这个时候会打印“NULL”。我们还可以在<code>Hamburger</code>中重写<code>produce</code>方法：</p><pre><code class="java">@Overridepublic String produce() {    return &quot;HAMBURGER&quot;;}</code></pre><p>这个时候会打印“HAMBURGER”。</p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>我们在使用 Lambda 表达式时，可以使用方法引用，使表达式更短、更易读。方法引用有四种表达形式：</p><ul><li>静态方法引用</li><li>实例方法引用</li><li>特定类型的实例方法引用</li><li>构造方法引用</li></ul><p>下面我们分别说一下。</p><h3 id="静态方法引用"><a href="#静态方法引用" class="headerlink" title="静态方法引用"></a>静态方法引用</h3><p>静态方法引用语法是：<code>类名：: 方法名</code>。假设我们需要判断一个<code>List&lt;String&gt;</code>队列中所有元素是否为空，通过 Stream API 我们可以这样判断：</p><pre><code class="java">final List&lt;String&gt; list = Lists.newArrayList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, null, &quot;4&quot;);final boolean hasNullElement = list.stream()        .anyMatch(x -&gt; Objects.isNull(x));System.out.println(hasNullElement);</code></pre><p>可以看到，<code>anyMath</code>方法中只调用了<code>Objects.isNull</code>方法，而且方法的入参直接是列表中的元素，此时，我们可以直接使用静态方法引用，将代码改写一下：</p><pre><code class="java">final boolean hasNullElementAlso = list.stream().anyMatch(Objects::isNull);</code></pre><p>这样看起来清爽多了。</p><h3 id="实例方法引用"><a href="#实例方法引用" class="headerlink" title="实例方法引用"></a>实例方法引用</h3><p>实例方法引用语法是：<code>实例：: 方法名</code>。比如，我们有一个列表中全是<code>LocalDate</code>类型数据，现在需要对其进行格式化，返回一个字符串列表。我们可以这样使用：</p><pre><code class="java">final DateTimeFormatter fmt = DateTimeFormatter.ISO_LOCAL_DATE;final List&lt;LocalDate&gt; dates = Lists.newArrayList(        LocalDate.MIN,        LocalDate.now(),        LocalDate.MAX);final List&lt;String&gt; dateStrs = dates.stream()        .map(d -&gt; fmt.format(d))        .collect(Collectors.toList());</code></pre><p><code>map</code>方法中通过<code>DateTimeFormatter</code>的实例对象调用了<code>format</code>方法，入参也是 Lambda 表达式中的元素，这样就可以使用实例方法引用，代码可以改写为：</p><pre><code class="java">final List&lt;String&gt; dateStrList = dates.stream()        .map(fmt::format)        .collect(Collectors.toList());</code></pre><p>这样写起来顺手多了。</p><h3 id="特定类型的实例方法引用"><a href="#特定类型的实例方法引用" class="headerlink" title="特定类型的实例方法引用"></a>特定类型的实例方法引用</h3><p>这种方法引用有一个前提条件，就是必须是 Lambda 表达式元素类型对应的方法。语法是：<code>特定类型：: 方法名</code>。比如，我们需要判断一个全都不为<code>null</code>的字符串列表中，空字符的数量，我们可以这样写：</p><pre><code class="java">final List&lt;String&gt; nonNullList = Lists.newArrayList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;&quot;, &quot;4&quot;, &quot;&quot;);final long emptyCount = nonNullList.stream()        .filter(x -&gt; x.isEmpty())        .count();</code></pre><p>我们可以看到，<code>filter</code>方法中引用的函数是利用 Lambda 表达式元素对象的方法，这个时候我们可以将代码改写为：</p><pre><code class="java">final long emptyElementCount = nonNullList.stream()        .filter(String::isEmpty)        .count();</code></pre><p>这样能够清晰的看出是哪个类的方法了。</p><h3 id="构造方法引用"><a href="#构造方法引用" class="headerlink" title="构造方法引用"></a>构造方法引用</h3><p>构造方法引用的语法是：<code>类名：:new</code>。在 Java 中，构造方法是一种特殊的方法，所以构造方法的引用与上面几种方法类似。比如，想要将字符串列表中的元素全部转换为<code>Integer</code>格式：</p><pre><code class="java">final List&lt;String&gt; allIntList = Lists.newArrayList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;);final List&lt;Integer&gt; ints = allIntList.stream()        .map(x -&gt; new Integer(x))        .collect(Collectors.toList());</code></pre><p>我们可以改写为：</p><pre><code class="java">final List&lt;Integer&gt; intList = allIntList.stream()        .map(Integer::new)        .collect(Collectors.toList());</code></pre><h2 id="Optional-神器"><a href="#Optional-神器" class="headerlink" title="Optional 神器"></a>Optional 神器</h2><p>空指针异常（NullPointException，NPE）是特别低级但又很难避免的异常，说他低级是因为只要看到这个异常，就能够很容易的修复，但是我们很难百分之百的避免这个异常的存在。在 Java8 之前，我们只能通过类似<code>obj != null</code>这种模板式方法判断。在 Java8 新增的神器<code>Optional</code>可以更加优雅的解决这个问题。</p><h3 id="创建-Optional"><a href="#创建-Optional" class="headerlink" title="创建 Optional"></a>创建 Optional</h3><p><code>Optional</code>的构造方法是使用<code>private</code>修饰的，其提供了三个静态方法，用于创建<code>Optional</code>实例，分别是<code>empty</code>、<code>of</code>、<code>ofNullable</code>，创建之后，<code>Optional</code>是不可变的。</p><p>我们可以使用<code>empty</code>定义一个具有空值的<code>Optional</code>对象：</p><pre><code class="java">final Optional&lt;String&gt; optional = Optional.empty();</code></pre><p>使用<code>of</code>定义一个不为空的对象：</p><pre><code class="java">final String str = &quot;value&quot;;final Optional&lt;String&gt; optional = Optional.of(str);</code></pre><p>这里需要注意一下，<code>of</code>方法赋值时，使用<code>Objects.requireNonNull</code>验证参数是否为空，为空就会抛出<code>NullPointerException</code>异常。</p><p>如果不太确定是否为空，可以使用<code>ofNullable</code>创建对象：</p><pre><code class="java">final String str = getSomeStr();final Optional&lt;String&gt; optional = Optional.ofNullable(str);</code></pre><h3 id="使用-Optional"><a href="#使用-Optional" class="headerlink" title="使用 Optional"></a>使用 Optional</h3><p>比如，我们需要返回一个字符串列表<code>List&lt;String&gt;</code>，当结果是<code>null</code>的时候，我们返回返回<code>new ArrayList&lt;&gt;()</code>。如果是在 Java8 之前，我们得这样写：</p><pre><code class="java">List&lt;String&gt; list = getList();List&lt;String&gt; listOpt = list != null ? list : new ArrayList&lt;&gt;();</code></pre><p>现在，我们可以借助<code>Optional</code>的能力：</p><pre><code class="java">List&lt;String&gt; listOpt = Optional.ofNullable(getList())        .orElse(new ArrayList&lt;&gt;());</code></pre><p>小试牛刀，还不错，下面放大招。</p><p><img src="https://static.howardliu.cn/20211124232900.jpeg" alt="前方高能，请注意"></p><p>假设，我们有一个<code>User</code>类，内部有个<code>Address</code>类，在内部有个<code>street</code>属性，我们现在想要获取一个<code>User</code>对象的<code>street</code>值。如果是以前，我们需要各种判断是否是<code>null</code>，代码会写成这样：</p><pre><code class="java">User user = getUser();if (user != null) {    Address address = user.getAddress();    if (address != null) {        String street = address.getStreet();        if (street != null) {            return street;        }    }}return &quot;not specified&quot;;</code></pre><p>是不是似曾相识，或者以前亲手写过。现在有了<code>Optional</code>，我们就不需要这么麻烦了：</p><pre><code class="java">String result = Optional.ofNullable(getUser())        .map(User::getAddress)        .map(Address::getStreet)        .orElse(&quot;not specified&quot;);</code></pre><p>是不是相当的优雅，<code>map</code>方法返回的也是<code>Optional</code>对象，所以我们可以无限处理下去。</p><p>如果<code>User</code>类中的<code>getAddress</code>方法返回的本身就是<code>Optional</code>对象，我们可以使用<code>flatMap</code>替换<code>map</code>。</p><p>还有一种情况是我们需要捕捉 NPE 的情况，但是需要包装为其他自定义异常，这个时候可以使用<code>orElseThrow</code>方法：</p><pre><code class="java">String value = null;Optional&lt;String&gt; valueOpt = Optional.ofNullable(value);String result = valueOpt.orElseThrow(CustomException::new).toUpperCase();</code></pre><p>这里只是简单给出几个例子，更多功能可以参见 <a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">《一文掌握 Java8 的 Optional 的 6 种操作》</a>。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文给出了 Java8 中几个比较有意思的特性，完整的特性清单可以从<a href="https://openjdk.java.net/projects/Java8/features" target="_blank" rel="noopener">https://openjdk.java.net/projects/Java8/features</a>查看。</p><p>本文所有代码都可以通过在公众号「看山的小屋」回复“java”获取。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-8-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java8 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/121529334" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java8 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Java8 从 2014 年问世，到现在已是数个年头。这个版本新增了 Stream API、Lambda 表达式、新时间 API 等各种新特性，相比很多新兴语言也不遑多让。今天就来聊聊 Java8 中好玩好使的特性功能
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java8" scheme="https://www.howardliu.cn/tags/Java8/"/>
    
      <category term="optional" scheme="https://www.howardliu.cn/tags/optional/"/>
    
  </entry>
  
  <entry>
    <title>人人都会设计模式：策略模式</title>
    <link href="https://www.howardliu.cn/strategy-pattern/"/>
    <id>https://www.howardliu.cn/strategy-pattern/</id>
    <published>2021-11-15T15:05:51.000Z</published>
    <updated>2021-11-15T15:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/autumn-6752841_1920.jpg" alt="人人都会设计模式：策略模式"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/daschorsch-1537217/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6752841" target="_blank" rel="noopener">daschorsch</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6752841" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><blockquote><p>本文收录在<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1750195552933199874&scene=126&devicetype=iOS15.0.2&version=18000f2a&lang=zh_CN&nettype=WIFI&ascene=59&session_us=gh_9bcfdc303e2f&fontScale=100&wx_header=1" target="_blank" rel="noopener">《一个架构师的职业素养》</a>专栏，日拱一卒，功不唐捐。</p></blockquote><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>策略模式，英文全称是 Strategy Design Pattern。在 GoF 的《设计模式》一书中，它是这样定义的：</p><blockquote><p>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</p></blockquote><p>翻译成中文就是：定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端。</p><p>这里所说的客户端代指使用算法的代码。</p><p>根据使用场景分类，策略模式是一种行为型模式，用于运行时控制类的行为或算法。</p><p>使用上的直观感受是，策略模式可以减少了 if-else/switch 分支代码。那减少分支代码有什么好处呢？</p><ol><li>解耦代码，策略模式就是解耦不同算法实现；</li><li>减少 bug 产生概率，减少分支，就是减少 bug 发生概率。</li></ol><p>有编程经验的都知道，很多 bug 都是从分支逻辑产生的。我刚开始工作时晚上 12 点开始抓虫，一直抓到凌晨 2 点多，最后发现是有一个 if-else 分支中，在某个 if 前面少写了一个 else。下面是示例，实际代码比这个复杂很多：</p><pre><code class="java">if (a &lt; 1) {} else if (a &lt; 2) {} else if (a &lt; 3) {}</code></pre><p>结果写成了：</p><pre><code class="java">if (a &lt; 1) {} else if (a &lt; 2) {} if (a &lt; 3) {}</code></pre><p>代码编译不会错，但是在执行时，某些 case 会不符合预期。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我们来看看策略模式出现的场景。</p><p>以电商系统的支付功能为例，最早的时候，我们可能为了更快上线，选择一个较多人使用的支付方式，比如微信支付（也有可能是支付宝支付，根据售卖场景不同区分）。这个时候，我们只需要判断用户是从 PC 页面进入还是 H5 进入即可。</p><p>后来，业务发展比较好，涉及人群更多了，于是需要对接支付宝支付。支付宝支付也分为了多种的支付场景，对接接口变多了，但是也在可控范围内。</p><p>再后来，我们需要对接银联支付、对接各银行接口，等等，支付接口变得越来越臃肿。于是，每对接一种支付方式，支付相关接口就会增加一倍。此时，这坨臃肿的代码，无论是修复简单的 bug，还是微调传输参数，都会影响整个支付逻辑，从而增加了在已有正常运行代码中引入错误的风险。</p><p><img src="https://static.howardliu.cn/20211116075137.jpeg" alt="越来越臃肿的系统"></p><p>如果是多人协作开发，我们还会陷入代码合并时应付各种冲突的情况。终于，在某一时刻，我们看着这一坨代码，已经无从下手维护了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>首先，我们来分析一下上面的场景，不变的是系统内部的支付业务逻辑，变化的是支付方式。</p><p>支付方式的可变性在于，可能会与多种支付方式对接，对接参数、协议、地址等都会不同。根据设计模式的整体思想，我们将变化的单独出去，将不变的稳定下来。</p><p>这种处理方式就是策略模式建议的：找出负责用许多不同方式完成特定任务的类，然后将其中的算法抽取到一族被称为策略的独立类中。</p><p>调用这些策略类的是调用上下文，它持有对所有策略类的引用。上下文不执行任务，它是任务的指挥者，将工作委派给已连接的策略对象。关系如下：</p><p><img src="https://static.howardliu.cn/20211116075124.png" alt="策略模式类图"></p><p>很多教程到这里就结束了，如果你能够看到这里，而且还用心看了，你就会发现一丝丝的不一样。</p><p>根据迪米特法则（LOD，Law of Demeter），上下文不需要知道具体策略类的功能，只需要通过特定的接口，用于触发选中策略即可。也就是说，完整的策略模式，应该有具体的策略判断是否由该策略执行，上下文只需要知道有哪些策略就行了。这样改动之后，上下文还能够与工厂模式结合。如果策略是无状态策略，还可以在上下文中引入单例模式。</p><h2 id="适用与不适用"><a href="#适用与不适用" class="headerlink" title="适用与不适用"></a>适用与不适用</h2><p>根据上面的定义，策略模式是围绕可以互换的算法来创建业务的。简单的说就是，分支逻辑隔离。</p><ol><li>当你想使用各种不同算法变体，且能够在运行时切换算法。策略模式可以将对象关联到不同实现方式的不同子任务中，可以间接的修改对象；</li><li>只有在执行时有些许不同的相似算法。可以将不同的行为抽象到独立的类中，在原来的类中调用这些独立的算法；</li><li>算法在业务逻辑中不是特别重要。我们可以通过策略模式将算法、数据、依赖等抽离出来，在运行时调用即可。</li></ol><p>设计模式只是解决问题的优雅实现，并不一定适用所有情况，比如下面这几种，就可以不用非得实现策略模式：</p><ol><li>如果算法极少变化，就没有任何理由引入新的类和接口。</li><li>如果使用了 Java8 之后的版本，可以使用函数式编程，有时候就使用 Lambda 表达式或者匿名内部类的方式实现具体算法即可。</li></ol><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>还是以支付为例，因为都是演示，一切从简。我曾经主导过支付中台，如果想要具体实现，可以具体聊一下。</p><p>首先定义支付策略接口：</p><pre><code class="java">public interface PayStrategy {    String payType();    void callPay(BigDecimal amount);}</code></pre><p><code>payType()</code>是在具体的策略实现中定义策略可执行的支付方式，也可以通过传参数的方式返回<code>boolean</code>类型用于判断是否可执行。</p><p>然后是微信支付和支付宝支付分别实现支付策略接口：</p><pre><code class="java">public class WxpayPayStrategy implements PayStrategy {    @Override    public String payType() {        return &quot;WXPAY&quot;;    }    @Override    public void callPay(BigDecimal amount) {        // 微信支付接口        // 这里只是演示，即使都是微信支付，也会分不同的接口        System.out.println(&quot;调用微信支付接口&quot;);    }}public class AlipayPayStrategy implements PayStrategy {    @Override    public String payType() {        return &quot;ALIPAY&quot;;    }    @Override    public void callPay(BigDecimal amount) {        // 调用支付宝支付接口        // 这里只是演示，即使都是支付宝支付，也会分不同的接口        System.out.println(&quot;调用支付宝支付接口&quot;);    }}</code></pre><p>我们再来看看持有策略算法的上下文：</p><pre><code class="java">public class StrategyContext {    private static final Map&lt;String, PayStrategy&gt; PAY_STRATEGY_MAP = new HashMap&lt;&gt;();    static {        final AlipayPayStrategy alipayPayStrategy = new AlipayPayStrategy();        final WxpayPayStrategy wxpayPayStrategy = new WxpayPayStrategy();        PAY_STRATEGY_MAP.put(alipayPayStrategy.payType(), alipayPayStrategy);        PAY_STRATEGY_MAP.put(wxpayPayStrategy.payType(), wxpayPayStrategy);    }    public void pay(String payType, BigDecimal amount) {        final PayStrategy payStrategy = PAY_STRATEGY_MAP.get(payType);        payStrategy.callPay(amount);    }}</code></pre><p>可以看到，上下文只需要知道策略算法的存在，至于算法是否符合要求，由算法自己判断。</p><p>调用就比较简单了：</p><pre><code class="java">public class Main {    public static void main(String[] args) {        final StrategyContext strategyContext = new StrategyContext();        strategyContext.pay(&quot;ALIPAY&quot;, BigDecimal.TEN);        strategyContext.pay(&quot;WXPAY&quot;, BigDecimal.ONE);    }}</code></pre><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>策略模式可能用来减少分支逻辑，将不同的算法分离开来。如果配合工厂模式、单例模式，可以更加灵活的使用。如果是在 Spring 当中，借助自动注入，上下文甚至可以不知道具体策略实现。</p><p>最近刚看到一句话，“日拱一卒，功不唐捐”。坚持下去，每天学点新东西，给生活加点色彩。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/Bpblou6RkZua4jE4gaZylA" target="_blank" rel="noopener">Java 中的单例模式（完整篇）</a></li><li><a href="https://mp.weixin.qq.com/s/ynajBpu0xJYGzcgqaIDjMg" target="_blank" rel="noopener">设计模式：建造者模式</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/strategy-pattern/">人人都会设计模式：策略模式</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/121347845" target="_blank" rel="noopener">人人都会设计模式：策略模式</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端。
    
    </summary>
    
    
      <category term="design pattern" scheme="https://www.howardliu.cn/categories/design-pattern/"/>
    
    
      <category term="设计模式" scheme="https://www.howardliu.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶：使用 Lambda 表达式实现超强的排序功能</title>
    <link href="https://www.howardliu.cn/java-lambda-powerful-comparation/"/>
    <id>https://www.howardliu.cn/java-lambda-powerful-comparation/</id>
    <published>2021-11-07T12:32:59.000Z</published>
    <updated>2021-11-07T12:32:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cairn-g9fca0fd5f_1920.jpg" alt="Java 进阶：使用 Lambda 表达式实现超强的排序功能"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/mike_68-10359383/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6754295" target="_blank" rel="noopener">Michael Kleinsasser</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6754295" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><blockquote><p>本文被<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378&scene=126&devicetype=iOS15.0.2&version=18000f2a&lang=zh_CN&nettype=WIFI&ascene=59&session_us=gh_9bcfdc303e2f&fontScale=100&wx_header=1" target="_blank" rel="noopener">《Java 进阶》</a>专栏收录，在公众号「看山的小屋」，回复“java”可获取源码。</p></blockquote><p>我们在系统开发过程中，对数据排序是很常见的场景。一般来说，我们可以采用两种方式：</p><a id="more"></a><ol><li>借助存储系统（SQL、NoSQL、NewSQL 都支持）的排序功能，查询的结果即是排好序的结果</li><li>查询结果为无序数据，在内存中排序。</li></ol><p>今天要说的是第二种排序方式，在内存中实现数据排序。</p><p>首先，我们定义一个基础类，后面我们将根据这个基础类演示如何在内存中排序。</p><pre><code class="java">@Data@NoArgsConstructor@AllArgsConstructorpublic class Student {    private String name;    private int age;    @Override    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        Student student = (Student) o;        return age == student.age &amp;&amp; Objects.equals(name, student.name);    }    @Override    public int hashCode() {        return Objects.hash(name, age);    }}</code></pre><h2 id="基于Comparator排序"><a href="#基于Comparator排序" class="headerlink" title="基于Comparator排序"></a>基于<code>Comparator</code>排序</h2><p>在 Java8 之前，我们都是通过实现<code>Comparator</code>接口完成排序，比如：</p><pre><code class="java">new Comparator&lt;Student&gt;() {    @Override    public int compare(Student h1, Student h2) {        return h1.getName().compareTo(h2.getName());    }};</code></pre><p>这里展示的是匿名内部类的定义，如果是通用的对比逻辑，可以直接定义一个实现类。使用起来也比较简单，如下就是应用：</p><pre><code class="java">@Testvoid baseSortedOrigin() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12)    );    Collections.sort(students, new Comparator&lt;Student&gt;() {        @Override        public int compare(Student h1, Student h2) {            return h1.getName().compareTo(h2.getName());        }    });    Assertions.assertEquals(students.get(0), new Student(&quot;Jerry&quot;, 12));}</code></pre><blockquote><p>这里使用了 Junit5 实现单元测试，用来验证逻辑非常适合。</p></blockquote><p>因为定义的<code>Comparator</code>是使用<code>name</code>字段排序，在 Java 中，<code>String</code>类型的排序是通过单字符的 ASCII 码顺序判断的，<code>J</code>排在<code>T</code>的前面，所以<code>Jerry</code>排在第一个。</p><h2 id="使用-Lambda-表达式替换Comparator匿名内部类"><a href="#使用-Lambda-表达式替换Comparator匿名内部类" class="headerlink" title="使用 Lambda 表达式替换Comparator匿名内部类"></a>使用 Lambda 表达式替换<code>Comparator</code>匿名内部类</h2><p>使用过 Java8 的 Lamdba 的应该知道，匿名内部类可以简化为 Lambda 表达式为：</p><pre><code class="java">Collections.sort(students, (Student h1, Student h2) -&gt; h1.getName().compareTo(h2.getName()));</code></pre><p>在 Java8 中，<code>List</code>类中增加了<code>sort</code>方法，所以<code>Collections.sort</code>可以直接替换为：</p><pre><code class="java">students.sort((Student h1, Student h2) -&gt; h1.getName().compareTo(h2.getName()));</code></pre><p>根据 Java8 中 Lambda 的类型推断，我们可以将指定的<code>Student</code>类型简写：</p><pre><code class="java">students.sort((h1, h2) -&gt; h1.getName().compareTo(h2.getName()));</code></pre><p>至此，我们整段排序逻辑可以简化为：</p><pre><code class="java">@Testvoid baseSortedLambdaWithInferring() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12)    );    students.sort((h1, h2) -&gt; h1.getName().compareTo(h2.getName()));    Assertions.assertEquals(students.get(0), new Student(&quot;Jerry&quot;, 12));}</code></pre><h2 id="通过静态方法抽取公共的-Lambda-表达式"><a href="#通过静态方法抽取公共的-Lambda-表达式" class="headerlink" title="通过静态方法抽取公共的 Lambda 表达式"></a>通过静态方法抽取公共的 Lambda 表达式</h2><p>我们可以在<code>Student</code>中定义一个静态方法：</p><pre><code class="java">public static int compareByNameThenAge(Student s1, Student s2) {    if (s1.name.equals(s2.name)) {        return Integer.compare(s1.age, s2.age);    } else {        return s1.name.compareTo(s2.name);    }}</code></pre><p>这个方法需要返回一个<code>int</code>类型参数，在 Java8 中，我们可以在 Lambda 中使用该方法：</p><pre><code class="java">@Testvoid sortedUsingStaticMethod() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12)    );    students.sort(Student::compareByNameThenAge);    Assertions.assertEquals(students.get(0), new Student(&quot;Jerry&quot;, 12));}</code></pre><h2 id="借助Comparator的comparing方法"><a href="#借助Comparator的comparing方法" class="headerlink" title="借助Comparator的comparing方法"></a>借助<code>Comparator</code>的<code>comparing</code>方法</h2><p>在 Java8 中，<code>Comparator</code>类新增了<code>comparing</code>方法，可以将传递的<code>Function</code>参数作为比较元素，比如：</p><pre><code class="java">@Testvoid sortedUsingComparator() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12)    );    students.sort(Comparator.comparing(Student::getName));    Assertions.assertEquals(students.get(0), new Student(&quot;Jerry&quot;, 12));}</code></pre><h2 id="多条件排序"><a href="#多条件排序" class="headerlink" title="多条件排序"></a>多条件排序</h2><p>我们在静态方法一节中展示了多条件排序，还可以在<code>Comparator</code>匿名内部类中实现多条件逻辑：</p><pre><code class="java">@Testvoid sortedMultiCondition() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12),            new Student(&quot;Jerry&quot;, 13)    );    students.sort((s1, s2) -&gt; {        if (s1.getName().equals(s2.getName())) {            return Integer.compare(s1.getAge(), s2.getAge());        } else {            return s1.getName().compareTo(s2.getName());        }    });    Assertions.assertEquals(students.get(0), new Student(&quot;Jerry&quot;, 12));}</code></pre><p>从逻辑来看，多条件排序就是先判断第一级条件，如果相等，再判断第二级条件，依次类推。在 Java8 中可以使用<code>comparing</code>和一系列<code>thenComparing</code>表示多级条件判断，上面的逻辑可以简化为：</p><pre><code class="java">@Testvoid sortedMultiConditionUsingComparator() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12),            new Student(&quot;Jerry&quot;, 13)    );    students.sort(Comparator.comparing(Student::getName).thenComparing(Student::getAge));    Assertions.assertEquals(students.get(0), new Student(&quot;Jerry&quot;, 12));}</code></pre><p>这里的<code>thenComparing</code>方法是可以有多个的，用于表示多级条件判断，这也是函数式编程的方便之处。</p><h2 id="在Stream中进行排序"><a href="#在Stream中进行排序" class="headerlink" title="在Stream中进行排序"></a>在<code>Stream</code>中进行排序</h2><p>Java8 中，不但引入了 Lambda 表达式，还引入了一个全新的流式 API：Stream API，其中也有<code>sorted</code>方法用于流式计算时排序元素，可以传入<code>Comparator</code>实现排序逻辑：</p><pre><code class="java">@Testvoid streamSorted() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12)    );    final Comparator&lt;Student&gt; comparator = (h1, h2) -&gt; h1.getName().compareTo(h2.getName());    final List&lt;Student&gt; sortedStudents = students.stream()            .sorted(comparator)            .collect(Collectors.toList());    Assertions.assertEquals(sortedStudents.get(0), new Student(&quot;Jerry&quot;, 12));}</code></pre><p>同样的，我们可以通过 Lambda 简化书写：</p><pre><code class="java">@Testvoid streamSortedUsingComparator() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12)    );    final Comparator&lt;Student&gt; comparator = Comparator.comparing(Student::getName);    final List&lt;Student&gt; sortedStudents = students.stream()            .sorted(comparator)            .collect(Collectors.toList());    Assertions.assertEquals(sortedStudents.get(0), new Student(&quot;Jerry&quot;, 12));}</code></pre><h2 id="倒序排列"><a href="#倒序排列" class="headerlink" title="倒序排列"></a>倒序排列</h2><h3 id="调转排序判断"><a href="#调转排序判断" class="headerlink" title="调转排序判断"></a>调转排序判断</h3><p>排序就是根据<code>compareTo</code>方法返回的值判断顺序，如果想要倒序排列，只要将返回值取返即可：</p><pre><code class="java">@Testvoid sortedReverseUsingComparator2() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12)    );    final Comparator&lt;Student&gt; comparator = (h1, h2) -&gt; h2.getName().compareTo(h1.getName());    students.sort(comparator);    Assertions.assertEquals(students.get(0), new Student(&quot;Tom&quot;, 10));}</code></pre><p>可以看到，正序排列的时候，我们是<code>h1.getName().compareTo(h2.getName())</code>，这里我们直接倒转过来，使用的是<code>h2.getName().compareTo(h1.getName())</code>，也就达到了取反的效果。在 Java 的<code>Collections</code>中定义了一个<code>java.util.Collections.ReverseComparator</code>内部私有类，就是通过这种方式实现元素反转。</p><h3 id="借助Comparator的reversed方法倒序"><a href="#借助Comparator的reversed方法倒序" class="headerlink" title="借助Comparator的reversed方法倒序"></a>借助<code>Comparator</code>的<code>reversed</code>方法倒序</h3><p>在 Java8 中新增了<code>reversed</code>方法实现倒序排列，用起来也是很简单：</p><pre><code class="java">@Testvoid sortedReverseUsingComparator() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12)    );    final Comparator&lt;Student&gt; comparator = (h1, h2) -&gt; h1.getName().compareTo(h2.getName());    students.sort(comparator.reversed());    Assertions.assertEquals(students.get(0), new Student(&quot;Tom&quot;, 10));}</code></pre><h3 id="在Comparator-comparing中定义排序反转"><a href="#在Comparator-comparing中定义排序反转" class="headerlink" title="在Comparator.comparing中定义排序反转"></a>在<code>Comparator.comparing</code>中定义排序反转</h3><p><code>comparing</code>方法还有一个重载方法，<code>java.util.Comparator#comparing(java.util.function.Function&lt;? super T,? extends U&gt;, java.util.Comparator&lt;? super U&gt;)</code>，第二个参数就可以传入<code>Comparator.reverseOrder()</code>，可以实现倒序：</p><pre><code class="java">@Testvoid sortedUsingComparatorReverse() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12)    );    students.sort(Comparator.comparing(Student::getName, Comparator.reverseOrder()));    Assertions.assertEquals(students.get(0), new Student(&quot;Jerry&quot;, 12));}</code></pre><h3 id="在Stream中定义排序反转"><a href="#在Stream中定义排序反转" class="headerlink" title="在Stream中定义排序反转"></a>在<code>Stream</code>中定义排序反转</h3><p>在<code>Stream</code>中的操作与直接列表排序类似，可以反转<code>Comparator</code>定义，也可以使用<code>Comparator.reverseOrder()</code>反转。实现如下：</p><pre><code class="java">@Testvoid streamReverseSorted() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12)    );    final Comparator&lt;Student&gt; comparator = (h1, h2) -&gt; h2.getName().compareTo(h1.getName());    final List&lt;Student&gt; sortedStudents = students.stream()            .sorted(comparator)            .collect(Collectors.toList());    Assertions.assertEquals(sortedStudents.get(0), new Student(&quot;Tom&quot;, 10));}@Testvoid streamReverseSortedUsingComparator() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12)    );    final List&lt;Student&gt; sortedStudents = students.stream()            .sorted(Comparator.comparing(Student::getName, Comparator.reverseOrder()))            .collect(Collectors.toList());    Assertions.assertEquals(sortedStudents.get(0), new Student(&quot;Tom&quot;, 10));}</code></pre><h2 id="null-值的判断"><a href="#null-值的判断" class="headerlink" title="null 值的判断"></a>null 值的判断</h2><p>前面的例子中都是有值元素排序，能够覆盖大部分场景，但有时候我们还是会碰到元素中存在<code>null</code>的情况：</p><ol><li>列表中的元素是 null</li><li>列表中的元素参与排序条件的字段是 null</li></ol><p>如果还是使用前面的那些实现，我们会碰到<code>NullPointException</code>异常，即 NPE，简单演示一下：</p><pre><code class="java">@Testvoid sortedNullGotNPE() {    final List&lt;Student&gt; students = Lists.newArrayList(            null,            new Student(&quot;Snoopy&quot;, 12),            null    );    Assertions.assertThrows(NullPointerException.class,            () -&gt; students.sort(Comparator.comparing(Student::getName)));}</code></pre><p>所以，我们需要考虑这些场景。</p><h3 id="元素是-null-的笨拙实现"><a href="#元素是-null-的笨拙实现" class="headerlink" title="元素是 null 的笨拙实现"></a>元素是 null 的笨拙实现</h3><p>最先想到的就是判空：</p><pre><code class="java">@Testvoid sortedNullNoNPE() {    final List&lt;Student&gt; students = Lists.newArrayList(            null,            new Student(&quot;Snoopy&quot;, 12),            null    );    students.sort((s1, s2) -&gt; {        if (s1 == null) {            return s2 == null ? 0 : 1;        } else if (s2 == null) {            return -1;        }        return s1.getName().compareTo(s2.getName());    });    Assertions.assertNotNull(students.get(0));    Assertions.assertNull(students.get(1));    Assertions.assertNull(students.get(2));}</code></pre><p>我们可以将判空的逻辑抽取出一个<code>Comparator</code>，通过组合方式实现：</p><pre><code class="java">class NullComparator&lt;T&gt; implements Comparator&lt;T&gt; {    private final Comparator&lt;T&gt; real;    NullComparator(Comparator&lt;? super T&gt; real) {        this.real = (Comparator&lt;T&gt;) real;    }    @Override    public int compare(T a, T b) {        if (a == null) {            return (b == null) ? 0 : 1;        } else if (b == null) {            return -1;        } else {            return (real == null) ? 0 : real.compare(a, b);        }    }}</code></pre><p>在 Java8 中已经为我们准备了这个实现。</p><h3 id="使用Comparator-nullsLast和Comparator-nullsFirst"><a href="#使用Comparator-nullsLast和Comparator-nullsFirst" class="headerlink" title="使用Comparator.nullsLast和Comparator.nullsFirst"></a>使用<code>Comparator.nullsLast</code>和<code>Comparator.nullsFirst</code></h3><p>使用<code>Comparator.nullsLast</code>实现<code>null</code>在结尾：</p><pre><code class="java">@Testvoid sortedNullLast() {    final List&lt;Student&gt; students = Lists.newArrayList(            null,            new Student(&quot;Snoopy&quot;, 12),            null    );    students.sort(Comparator.nullsLast(Comparator.comparing(Student::getName)));    Assertions.assertNotNull(students.get(0));    Assertions.assertNull(students.get(1));    Assertions.assertNull(students.get(2));}</code></pre><p>使用<code>Comparator.nullsFirst</code>实现<code>null</code>在开头：</p><pre><code class="java">@Testvoid sortedNullFirst() {    final List&lt;Student&gt; students = Lists.newArrayList(            null,            new Student(&quot;Snoopy&quot;, 12),            null    );    students.sort(Comparator.nullsFirst(Comparator.comparing(Student::getName)));    Assertions.assertNull(students.get(0));    Assertions.assertNull(students.get(1));    Assertions.assertNotNull(students.get(2));}</code></pre><p>是不是很简单，接下来我们看下如何实现排序条件的字段是 null 的逻辑。</p><h3 id="排序条件的字段是-null"><a href="#排序条件的字段是-null" class="headerlink" title="排序条件的字段是 null"></a>排序条件的字段是 null</h3><p>这个就是借助<code>Comparator</code>的组合了，就像是套娃实现了，需要使用两次<code>Comparator.nullsLast</code>，这里列出实现：</p><pre><code class="java">@Testvoid sortedNullFieldLast() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(null, 10),            new Student(&quot;Snoopy&quot;, 12),            null    );    final Comparator&lt;Student&gt; nullsLast = Comparator.nullsLast(            Comparator.nullsLast( // 1                    Comparator.comparing(                            Student::getName,                            Comparator.nullsLast( // 2                                    Comparator.naturalOrder() // 3                            )                    )            )    );    students.sort(nullsLast);    Assertions.assertEquals(students.get(0), new Student(&quot;Snoopy&quot;, 12));    Assertions.assertEquals(students.get(1), new Student(null, 10));    Assertions.assertNull(students.get(2));}</code></pre><p>代码逻辑如下：</p><ol><li>代码 1 是第一层 null-safe 逻辑，用于判断元素是否为 null；</li><li>代码 2 是第二层 null-safe 逻辑，用于判断元素的条件字段是否为 null；</li><li>代码 3 是条件<code>Comparator</code>，这里使用了<code>Comparator.naturalOrder()</code>，是因为使用了<code>String</code>排序，也可以写为<code>String::compareTo</code>。如果是复杂判断，可以定义一个更加复杂的<code>Comparator</code>，组合模式就是这么好用，一层不够再套一层。</li></ol><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文演示了使用 Java8 中使用 Lambda 表达式实现各种排序逻辑，新增的语法糖真香。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/4jVPnaOr-rve3GQdukDFmA" target="_blank" rel="noopener">JDK 中居然也有反模式接口常量</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-lambda-powerful-comparation/">Java 进阶：使用 Lambda 表达式实现超强的排序功能</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">Java 进阶：使用 Lambda 表达式实现超强的排序功能</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文演示了使用 Java8 中使用 Lambda 表达式实现各种排序逻辑，新增的语法糖真香。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="JDK8" scheme="https://www.howardliu.cn/tags/JDK8/"/>
    
      <category term="Comparator" scheme="https://www.howardliu.cn/tags/Comparator/"/>
    
  </entry>
  
  <entry>
    <title>看山聊 Java：从零实现“百度网盘批量重命名”工具</title>
    <link href="https://www.howardliu.cn/effective-java-tools-batch-rename-baiduwangpan/"/>
    <id>https://www.howardliu.cn/effective-java-tools-batch-rename-baiduwangpan/</id>
    <published>2021-10-25T15:16:13.000Z</published>
    <updated>2021-10-25T15:16:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/20211025231948.jpeg" alt="看山聊 Java：从零实现“百度网盘批量重命名”工具"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/roshan_bhatia-17147583/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6693577" target="_blank" rel="noopener">Roshan Bhatia</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6693577" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>工具的发明能够节省体力，同时也可以减少重复劳动，软件也是工具的一种。今天要说的是，引用 IT 技术，减少大量文件重命名这种重复的劳动。</p><a id="more"></a><p>一直在用的存储云盘是百度网盘，里面收集了大量文件。各种资料、电子书，使用空间达到了 2500G。之前还清理过一些低质的书籍，结果使用工具导出发现，在待整理目录中，居然有 1942 条电子书的记录。如果有小伙伴想要什么书，可以从公号留言，只要不是商用，无私共享。</p><h2 id="提出需求"><a href="#提出需求" class="headerlink" title="提出需求"></a>提出需求</h2><p>书归正传，这么多的文件，命名格式千奇百怪，因为有一些资料是从别人的分享中保存的，有的还会带网址的，可见网站运营也是无所不用其极了。从网上找到一些批量改名的工具，大多是 Windows 版本的，而且是加前缀或者后缀之类的，不太适用。</p><p>我想要的是，自己指定文件名，然后批量执行。就相当于有一双手，帮我在百度网盘中执行官方提供的重命名。之所以不用官方的重命名，是因为太难用，而且浪费时间（后面会具体说一下百度网盘的这个设计，也是可以借鉴的）。</p><p>想要实现自己的想法，需要有两步：</p><ol><li>以 Excel 格式导出所有文件名</li><li>在导出的 Excel 文件中，定义目标名称，不需要改名的可以不用修改</li><li>导入整理后的文件，检查是否重命名成功</li></ol><h2 id="设计方案"><a href="#设计方案" class="headerlink" title="设计方案"></a>设计方案</h2><p>根据需求，我们来设计方案。</p><h3 id="找到关键接口"><a href="#找到关键接口" class="headerlink" title="找到关键接口"></a>找到关键接口</h3><p>首先，我们需要能够导出所有的文件名。</p><p>百度网盘提供了网页版、客户端版，为了省时省事，我们使用网页版检查逻辑。打开控制台，发现进入目录时会有一个<code>/api/list</code>的请求，如下图：</p><p><img src="https://static.howardliu.cn/20211024165119.png" alt="查询目录中文件列表"></p><p>根据响应内容，我们可以看出来，这个接口可以获取指定目录的文件列表。这个请求是 Get 请求，包含了好几个参数，还不太请求参数的作用，先放过。</p><p>通常来说，简单的网络请求是通过 Cookie 鉴权，所以我们就无脑使用 Cookie 了。</p><p>接下来需要找到重命名的请求，同样的，执行百度网盘提供的重命名即可，新增了哪些请求。如下图：</p><p><img src="https://static.howardliu.cn/20211024165729.png" alt="重命名并查询结果"></p><p>可以看到，这里的重命名分为了两步：</p><ol><li>提交重命名任务，返回任务 id</li><li>使用任务 id 查询任务执行情况</li></ol><p>这就是前面说的可借鉴的地方。对于百度网盘这种应用，虽然下载限速被各种诟病，还有阿里云盘的强势追击，但是不得不说，百度网盘还是现在用的比较多的云存储工具。必须有针对性的优化，将某些二级功能异步任务化，比如重命名。</p><ol><li>先通过一个请求创建重命名任务，任务创建成功返回任务 ID。这个时候，百度网盘后端服务监听新任务，如果后端压力大，任务可以缓慢执行或不执行；</li><li>既然是异步任务化，客户端（包括网页或客户端）需要检查任务执行情况。任务执行情况根据约定可以有进行中或者完成，还可以有拒绝、失败、过期等其他情况。</li></ol><h3 id="导出导入文件"><a href="#导出导入文件" class="headerlink" title="导出导入文件"></a>导出导入文件</h3><p>我们可以借助阿里开源的 EasyExcel 导出 Excel 文件（具体操作，可以查看 <a href="https://mp.weixin.qq.com/s/CYiY7wNuOnhVk4Mw5L8Wrw" target="_blank" rel="noopener">写文件</a>、<a href="https://mp.weixin.qq.com/s/edCvwrP1NYd8ryBHcp35fA" target="_blank" rel="noopener">写的好看</a>、<a href="https://mp.weixin.qq.com/s/4QGSjKUSm_KAF009grd4hw" target="_blank" rel="noopener">填充文件</a> 三篇）。</p><p>这个时候需要定义导出文件的内容，根据重命名的请求我们可以知道，我们需要文件路径、文件的新名字，为了操作简单，我们可以直接把原名也导出来。为了检查网盘文件是否有重复的，最好把文件的摘要码也导出来。</p><p>至此，我们的需求和方案都设计好了，下面就开始编码。</p><h2 id="开始编码"><a href="#开始编码" class="headerlink" title="开始编码"></a>开始编码</h2><p>开始编码前，我们需要定义一下鉴权参数：cookie、bdstoken，再定义一个扩展参数 path，我们只导出指定目录的文件列表。</p><h3 id="定义基础类"><a href="#定义基础类" class="headerlink" title="定义基础类"></a>定义基础类</h3><p>根据设计方案中的定义，我们先创建导出文件的基础类：</p><pre><code class="java">@Datapublic class FileName {    @ExcelProperty(&quot;路径&quot;)    private String path;    @ExcelProperty(&quot;MD5&quot;)    private String md5;    @ExcelProperty(&quot;原名称&quot;)    private String originName;    @ExcelProperty(&quot;新名称&quot;)    private String newName;}</code></pre><p>因为涉及到网络请求，我们需要定义请求参数。请求有一些共同参数：</p><pre><code class="java">@Datapublic abstract class BaseRequest {    protected String channel = &quot;chunlei&quot;;    protected String web = &quot;1&quot;;    protected String appId = &quot;250528&quot;;    protected String bdstoken = &quot;&quot;;    protected String logid = &quot;&quot;;    protected String clienttype = &quot;0&quot;;}</code></pre><p>文件列表参数为：</p><pre><code class="java">@EqualsAndHashCode(callSuper = true)@Datapublic class FileListRequest extends BaseRequest {    private String order = &quot;name&quot;;    private String desc = &quot;0&quot;;    private String showempty = &quot;0&quot;;    private int page = 1;    private int num = 100;    private String dir = &quot;/&quot;;    private String t = &quot;&quot;;}</code></pre><p>重命名参数为：</p><pre><code class="java">@EqualsAndHashCode(callSuper = true)@Datapublic class FileRenameRequest extends BaseRequest {    private String opera = &quot;rename&quot;;    private String async = &quot;2&quot;;    private String onnest = &quot;fail&quot;;}</code></pre><p>我们还需要一个查询任务状态的参数：</p><pre><code class="java">@EqualsAndHashCode(callSuper = true)@Datapublic class TaskStatusRequest extends BaseRequest {    private Long taskid;}</code></pre><h3 id="定义请求类"><a href="#定义请求类" class="headerlink" title="定义请求类"></a>定义请求类</h3><p>前面有了基础类和请求类，接下来我们定义请求接口，这些类就是模板化的方法了，我们简单看一下。如果想要获取源码，关注公号「看山的小屋」回复“java”获取源码。</p><p>先定义文件列表请求方法：</p><pre><code class="java">private List&lt;FileListItem&gt; listFileCurrentPath(FileListRequest fileListRequest) {    final String body = HttpRequest.get(&quot;https://pan.baidu.com/api/list&quot;)            .form(fileListRequest.paramMap())            .header(this.headers)            .cookie(this.cookie)            .execute()            .body();    final FileListResponse response = JSONUtil.toBean(body, FileListResponse.class);    if (response.getErrno() == 0) {        return response.getList();    }    return Collections.emptyList();}</code></pre><p>在定义文件重命名请求方法：</p><pre><code class="java">private Long rename(FileRenameRequest fileRenameRequest, String params) {    final String queryParam = HttpUtil.toParams(fileRenameRequest.paramMap());    final HttpRequest httpRequest = HttpRequest.post(&quot;https://pan.baidu.com/api/filemanager?&quot; + queryParam)            .header(this.headers)            .cookie(this.cookie)            .body(params);    final String body = httpRequest.execute().body();    final FileRenameResponse response = JSONUtil.toBean(body, FileRenameResponse.class);    if (response.getErrno() == 0) {        return response.getTaskid();    }    return -1L;}</code></pre><p>最后定义检查任务状态请求方法：</p><pre><code class="java">private TaskStatusResponse queryTaskStatus(TaskStatusRequest taskStatusRequest, String params) {    TaskStatusResponse response;    final String queryParam = HttpUtil.toParams(taskStatusRequest.paramMap());    do {        final String body = HttpRequest.post(&quot;https://pan.baidu.com/share/taskquery?&quot; + queryParam)                .header(this.headers)                .cookie(this.cookie)                .body(params)                .execute()                .body();        response = JSONUtil.toBean(body, TaskStatusResponse.class);    } while (response.getErrno() != 0 || StringUtils.equalsAny(response.getStatus(), &quot;running&quot;, &quot;pending&quot;));    return response;}</code></pre><h2 id="体验升级"><a href="#体验升级" class="headerlink" title="体验升级"></a>体验升级</h2><p>全部类定义完成后，我们可以直接在 IDE 中运行。但是，既然是工具，每次使用还得打开 IDE，是不是有些 low 了。为了升级体验，我们可以打成 jar 包，使用的时候直接运行 jar 包就行了。可以借助 maven 插件<code>maven-assembly-plugin</code>实现，这个插件能够把我们的源码和三方库都打在一个 jar 包中，这样就是一个 FatJar 走天下了。</p><pre><code class="xml">&lt;plugin&gt;    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;    &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;    &lt;version&gt;2.3&lt;/version&gt;    &lt;configuration&gt;        &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;        &lt;descriptorRefs&gt;            &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;        &lt;/descriptorRefs&gt;        &lt;archive&gt;            &lt;manifest&gt;                &lt;addClasspath&gt;true&lt;/addClasspath&gt;                &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;                &lt;mainClass&gt;cn.howardliu.effectjava.rename.TaskRunner&lt;/mainClass&gt;            &lt;/manifest&gt;        &lt;/archive&gt;    &lt;/configuration&gt;    &lt;executions&gt;        &lt;execution&gt;            &lt;id&gt;make-assembly&lt;/id&gt;            &lt;phase&gt;package&lt;/phase&gt;            &lt;goals&gt;                &lt;goal&gt;assembly&lt;/goal&gt;            &lt;/goals&gt;        &lt;/execution&gt;    &lt;/executions&gt;&lt;/plugin&gt;</code></pre><p>干完，手工。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文从零开始实现制作一个网络小工具，实现百度网盘文件的批量重命名。这个工具是这类工具的一个代表，只要是网络应用，存在 http 请求，我们都可以通过这类方式实现网络小工具。</p><p>如果想要获取源码，关注公号「看山的小屋」回复“java”获取源码。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1841595569366974465#wechat_redirect" target="_blank" rel="noopener">SpringBoot 实战系列</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">Java 进阶系列</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=2051833877391818754#wechat_redirect" target="_blank" rel="noopener">微服务架构设计</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1750195552933199874#wechat_redirect" target="_blank" rel="noopener">一个架构师的素养修炼</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/effective-java-tools-batch-rename-baiduwangpan/">看山聊 Java：从零实现“百度网盘批量重命名”工具</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/121392246" target="_blank" rel="noopener">看山聊 Java：从零实现“百度网盘批量重命名”工具</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      工具的发明能够节省体力，同时也可以减少重复劳动，软件也是工具的一种。今天要说的是，引用 IT 技术，减少大量文件重命名这种重复的劳动。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Effective Java" scheme="https://www.howardliu.cn/tags/Effective-Java/"/>
    
      <category term="工具" scheme="https://www.howardliu.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实战：加载和读取资源文件</title>
    <link href="https://www.howardliu.cn/springboot-action-classpath-file-access/"/>
    <id>https://www.howardliu.cn/springboot-action-classpath-file-access/</id>
    <published>2021-10-24T02:34:08.000Z</published>
    <updated>2021-10-24T02:34:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/20211024104517.jpeg" alt="SpringBoot 实战：加载和读取资源文件内容"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/anramb-20789083/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6137612" target="_blank" rel="noopener">Marna Buys</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6137612" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>本文聊一聊在 SpringBoot 应用中，访问加载类路径（classpath）中的文件内容的多种方法。</p><a id="more"></a><h2 id="通过Resource接口"><a href="#通过Resource接口" class="headerlink" title="通过Resource接口"></a>通过<code>Resource</code>接口</h2><p><code>Resource</code>接口抽象出一种更底层的方式管理资源，可以实现通过统一的方式处理各类文件资源。下面是几种获取资源实例的方法。</p><h3 id="手动加载"><a href="#手动加载" class="headerlink" title="手动加载"></a>手动加载</h3><p>访问类路径中的文件，我们可以直接使用<code>ClassPathResource</code>加载内容，比如：</p><pre><code class="java">new ClassPathResource(&quot;data/resource-data.txt&quot;);</code></pre><p>默认情况下，<code>ClassPathResource</code>会在线程的上下文类加载器和默认系统类加载器之间进行选择，以删除样板文件。我们也可以直接指定类加载器，比如：</p><pre><code class="java">new ClassPathResource(&quot;data/resource-data.txt&quot;, this.getClass().getClassLoader());</code></pre><p>或者是通过指定类的类加载器：</p><pre><code class="java">new ClassPathResource(&quot;data/resource-data.txt&quot;, Employee.class.getClassLoader());</code></pre><p>从<code>Resource</code>对象，我们可以很容易的将其转换为<code>InputStream</code>或<code>File</code>对象。</p><p>上面说的方式都是相对于类路径的地址。如果想要指定某个类的相对路径，我们和可以通过指定具体类来定义，比如：</p><pre><code class="java">new ClassPathResource(&quot;../../../data/resource-data.txt&quot;, Example.class).getFile();</code></pre><p>这样就是相对于<code>Example</code>的相对路径了。在实际使用中，不太建议通过类获取其相对路径的文件。这样会将类与文件的相对坐标绑定，如果修改了类的包路径，但是忘记修改文件位置，就会出现错误。而且，大家现在一般是使用 Maven 之类的包管理器管理，可以直接在<code>resources</code>目录中定义配置文件，使用类路径的相对地址加载文件即可。</p><h3 id="通过-Value自动转换"><a href="#通过-Value自动转换" class="headerlink" title="通过@Value自动转换"></a>通过<code>@Value</code>自动转换</h3><p>我们还可以使用<code>@Value</code>直接注入<code>Resource</code>对象，比如：</p><pre><code class="java">@Value(&quot;classpath:data/resource-data.txt&quot;)Resource resourceFile;</code></pre><p><code>@Value</code>还能支持其他的加载协议，比如<code>file:</code>或<code>url:</code>。</p><h3 id="通过ResourceLoader加载"><a href="#通过ResourceLoader加载" class="headerlink" title="通过ResourceLoader加载"></a>通过<code>ResourceLoader</code>加载</h3><p>我们还能使用注入<code>ResourceLoader</code>来实现资源的懒加载，比如，先注入<code>ResourceLoader</code>实例：</p><pre><code class="java">@AutowiredResourceLoader resourceLoader;</code></pre><p>然后在我们需要的地方，通过<code>ResourceLoader</code>实例加载资源：</p><pre><code class="java">resourceLoader.getResource(&quot;classpath:data/resource-data.txt&quot;);</code></pre><p>在 Spring 中，<code>ApplicationContext</code>实现了<code>ResourceLoader</code>，所以，我们也可以直接通过<code>ApplicationContext</code>实例加载资源，比如：</p><pre><code class="java">ApplicationContext context;public Resource loadEmployeesWithApplicationContext() {    return context.getResource(&quot;classpath:data/resource-data.txt&quot;);}</code></pre><h2 id="使用ResourceUtils加载资源"><a href="#使用ResourceUtils加载资源" class="headerlink" title="使用ResourceUtils加载资源"></a>使用<code>ResourceUtils</code>加载资源</h2><p>在 Spring 内部，还提供了一个工具类<code>ResourceUtils</code>，可以很方便的获取类路径中额资源。但是通过这个类的 Javadoc 可以看到，这个类主要是在 Spring 内部使用，也就是说，不太推荐这种用法。不过我们可以了解一下：</p><pre><code class="java">public File loadEmployeesWithSpringInternalClass()   throws FileNotFoundException {    return ResourceUtils.getFile(      &quot;classpath:data/resource-data.txt&quot;);}</code></pre><p>我们可以了解其内部实现，但是还是建议使用其他更加标准的做法。</p><h2 id="读取资源中的内容"><a href="#读取资源中的内容" class="headerlink" title="读取资源中的内容"></a>读取资源中的内容</h2><p>上面都是通过各种方式获取了<code>Resource</code>资源，接下来我们就聊聊如果获取资源对象的数据。</p><p>比如，我们的资源文件内容如下：</p><pre><code class="txt">站点：https://www.howardliu.cn作者：看山公号：看山的小屋 (kanshanshuo)关注公号得福利：不知道多少 G 的资料（电子书、视频等等）</code></pre><h3 id="通过File对象读取"><a href="#通过File对象读取" class="headerlink" title="通过File对象读取"></a>通过<code>File</code>对象读取</h3><p>我们可以使用<code>getFile</code>方法得到<code>File</code>实例，就可以用读取<code>File</code>对象的方式读取文件了，比如：</p><pre><code class="java">@TestFile resource = new ClassPathResource(&quot;data/resource-data.txt&quot;).getFile();String content = new String(Files.readAllBytes(resource.toPath()));</code></pre><p>但是这种方式不适用于读取 jar 包中的文件，鉴于现在很多应用都是通过 FatJar 方式部署，我们还需要找找其他方式。</p><h3 id="通过InputStream对象读取"><a href="#通过InputStream对象读取" class="headerlink" title="通过InputStream对象读取"></a>通过<code>InputStream</code>对象读取</h3><p><code>File</code>对象不适合 jar 包中资源读取的原因在于文件路径格式不一样，所以我们可以直接将资源内容读取为流的形式，这样就没有文件路径的问题了。比如：</p><pre><code class="java">InputStream resource = new ClassPathResource(&quot;data/resource-data.txt&quot;).getInputStream();try (BufferedReader reader = new BufferedReader(new InputStreamReader(resource))) {    String content = reader.lines().collect(Collectors.joining(&quot;\n&quot;));}</code></pre><p>读取完毕。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文从加载资源、读取内容两个方法讲解，给出了多种读取方式。</p><p>《SpringBoot 实战》是一个系列，我会通过实战+原理的方式完整整个专栏，可以关注公众号「看山的小屋」回复 spring 获取源码。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response/">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response-exception/">SpringBoot 实战：如何优雅的处理异常</a></li><li><a href="https://www.howardliu.cn/spring-beanpostprocessor/">SpringBoot 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://www.howardliu.cn/spring-request-recorder/">SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li><li><a href="https://www.howardliu.cn/spring-enum-params/">SpringBoot 实战：优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-enum-params-principle/">SpringBoot 实战：优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody-principle/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-junit5-mockmvc-mockito/">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a></li><li><a href="https://www.howardliu.cn/springboot-action-classpath-file-access/">SpringBoot 实战：加载和读取资源文件</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/springboot-action-classpath-file-access/">SpringBoot 实战：加载和读取资源文件</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/120930968" target="_blank" rel="noopener">SpringBoot 实战：加载和读取资源文件</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文聊一聊在 SpringBoot 应用中，访问加载类路径（classpath）中的文件内容的多种方法。
    
    </summary>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/categories/spring/"/>
    
    
      <category term="SpringBoot 实战" scheme="https://www.howardliu.cn/tags/SpringBoot-%E5%AE%9E%E6%88%98/"/>
    
      <category term="Spring" scheme="https://www.howardliu.cn/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="https://www.howardliu.cn/tags/SpringBoot/"/>
    
      <category term="Resource" scheme="https://www.howardliu.cn/tags/Resource/"/>
    
      <category term="InputStream" scheme="https://www.howardliu.cn/tags/InputStream/"/>
    
      <category term="File" scheme="https://www.howardliu.cn/tags/File/"/>
    
  </entry>
  
  <entry>
    <title>我们如何拿到自己满意的薪资呢？这些套路还是需要掌握的</title>
    <link href="https://www.howardliu.cn/we-should-know-when-changing-job/"/>
    <id>https://www.howardliu.cn/we-should-know-when-changing-job/</id>
    <published>2021-10-20T15:04:14.000Z</published>
    <updated>2021-10-20T15:04:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/20211020230809.jpeg" alt="我们如何拿到自己满意的薪资呢？这些套路还是需要掌握的"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/eddiekphoto-23547624/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6680642" target="_blank" rel="noopener">Eddie K</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6680642" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>实力要有，技巧也要有。我不是教你诈，而是有些技巧你需要了解。</p><a id="more"></a><h2 id="定好目标很重要"><a href="#定好目标很重要" class="headerlink" title="定好目标很重要"></a>定好目标很重要</h2><p>既然是谈薪，那就得有自己的一个期望薪资，这个期望薪资不是拍脑袋想出来的，而是需要有依据的。</p><p>说到拍脑袋一词，回想一下，我们是不是在工作中经常吐槽，“领导的某些想法是拍脑袋想出来的”。轮到我们自己做重大决策的时候，我们是否做到有理有据的理性处理呢？要求别人总是容易的，要求自己还是需要一些努力。</p><p>扯远了，继续聊薪资。</p><h3 id="先要明确自己心意"><a href="#先要明确自己心意" class="headerlink" title="先要明确自己心意"></a>先要明确自己心意</h3><p>首先，我们要确定目标收益。这个收益包括薪资、公司福利、社会声誉、自主时间等一些列的因素。</p><p>目前社会发展基本上可以达到零边际成本，简单的说就是分工明确。分工越是明确，某岗位的收益总和不会差太多。比如，同是研发岗，互联网公司的薪资普遍高于国企，但是其他方面，国企直接碾压互联网。互联网薪资高，但普遍要求 996，有时甚至 007，到哪都得背着电脑，随时在线解决问题。国企薪资相对低一些，但是福利待遇好，人文关怀多，工作时间基本上可以保证 965，出去玩不需要带电脑，碰到问题走流程。</p><p>因此，我们首先要知道自己想要什么。全都要的岗位不是没有，而是太少，需要掂量下自己是否够分量。</p><p>所以，世间哪得双全法，总会有一些取舍。在互联网公司羡慕国企的时间自由，在国企又想要互联网的高薪。事之不如意十之八九，想清楚现在要的是什么，别做围城中的人。</p><p>想清楚之后，就需要确定符合这个期望的公司范围。找到这些公司的所有信息，比如，某歌搜、某眼查、亲朋好友打听、同学同行咨询。这些信息会比较庞杂，需要筛选其中的有效信息，最好是能够找到客观信息。依靠这些，可以把目标公司分成几类：</p><ol><li>特别想去</li><li>想去</li><li>不太想去</li><li>打死也不去</li></ol><p>然后看看这些公司岗位要求，这个比较容易了，从招聘网站找就行。然后根据拿自己条件与之匹配，又能有几种情况：</p><ol><li>完全不达标</li><li>现在不达标</li><li>达标</li></ol><p><img src="https://static.howardliu.cn/20211021081537.png" alt="能力匹配模型"></p><p>拿公司分组与自己的能力分组做匹配，可以找到比较适合的公司或岗位。</p><h3 id="再要评定市场价格"><a href="#再要评定市场价格" class="headerlink" title="再要评定市场价格"></a>再要评定市场价格</h3><p>确定了目标公司或者目标岗位，接下来就需要搞清楚对应的薪资范围了。</p><p>之所以只能搞清楚范围，是因为大部分公司都是密薪，明文规定严禁同事之间讨论薪资，私下讨论的情况也存在，如果不是非常要好的朋友，你又怎知他说的是否有水分。还一个原因，薪资结构比较复杂，工资、年终奖、五险一金、期权、股票、过节费、房补、餐补、加班费……所以能够了解一个范围，就已经很好了。</p><p><img src="https://static.howardliu.cn/20211021081836.jpeg" alt="再要评定市场价格"></p><p>一般有下面几种方式：</p><ol><li>咨询前同事。如果有一个恰好刚跳槽的同事，他跳槽的公司正好是你目标公司或者同类公司，那就可以问他了，约出来撸串吃饭，几杯酒下肚，大家就是兄弟。而且还能聊聊原来的薪资，如果聊得好，还能知道其他同事的薪资。</li><li>某脉职言挖掘信息。直接找在某脉的职言频道找人问，总会找到那种喜欢聊天的耿直 boy。多聊几个，聊聊基本工资，聊聊年终奖，期权和股票估计是问不到了。</li><li>某聘找职位。一般来说，招聘平台发布的职位信息，都是标着薪资面议。有的猎头发的职位会标注薪资范围，可以作为判定依据。多找一些相似岗位、相似量级的公司对比，通过取交集的方式，能够筛选出一个大概的数据范围。</li><li>根据自身薪资定位。如果准备是从互联网跳互联网，比较好的是可以根据自己的薪资做判断。目前很多人薪资涨幅比例是 20%，能够达到 50%的就比较少了，直接涨幅 100%就更少了。这个涨幅指的是工资，其他方面的涨幅就看个人了。</li></ol><p>明确了心意，确定了薪资范围。那就需要给自己定一个比较靠谱的目标了，比如，目标公司是什么，期望薪资是多少，准备争取哪种岗位。</p><h2 id="投递简历找准路"><a href="#投递简历找准路" class="headerlink" title="投递简历找准路"></a>投递简历找准路</h2><p>找到心仪的公司之后，接下来就是要投递简历。这里会有几种操作：</p><ol><li>直接投递招聘信息</li><li>找朋友内推</li><li>联系猎头</li></ol><h3 id="自己敲门恐费时"><a href="#自己敲门恐费时" class="headerlink" title="自己敲门恐费时"></a>自己敲门恐费时</h3><p>刚毕业或者工作 1-3 年的，都会在招聘网站找工作。这个时候自己的履历一般，没有能够很吸引人的地方，挂在网上很久都不会有人看，主动投递也会被卡脖子。如果有岗位比较急的，从筛选简历到面试会进行的很快，否则就直接进人才库。这就是卖方市场。</p><p>3-5 年，会出现第一个分水岭，有的人简历一旦挂上去，就会很多人找过来；有的人却是无人问津。第一种，随着工作的深入，经历的项目多了，能力有了很大的提升，成为了大家都喜欢的香饽饽。第二种，5 年工作 1 年经验，一直在做重复的工作，没有什么技术含量，做的项目也都拿不出手。市场不缺普通工，缺的是高级工。</p><p><img src="https://static.howardliu.cn/20211021081940.jpeg" alt="投递简历找准路"></p><p>因此，给 3-5 年的小伙伴一个建议，不要虚度光阴，现在的你已经能够胜任大部分工作，那就去挑战更有难度的工作。走平路甚至走下坡路是最省事的，向上攀爬是辛苦的，“世之奇伟、瑰怪，非常之观，常在于险远”，不要只是羡慕别人看到了美丽的风景，自己也上去看看。</p><p>5-10 年及以后，自己刷简历找工作比较少了，一般会借助熟人内推或者通过猎头了。</p><h3 id="熟人内推挺靠谱"><a href="#熟人内推挺靠谱" class="headerlink" title="熟人内推挺靠谱"></a>熟人内推挺靠谱</h3><p>熟人内推是比较推崇的一种，适合 3 年以后的同学。一般公司都会鼓励内推，理由是“物以类聚人以群分”，优秀的人周围一般也是优秀的人，有很大概率，被内推的人也是能够胜任工作的。而且，为了鼓励本公司内推，帮着公司挖人，还设置了内推奖之类的。</p><p>前几年有句话比较流行“花若盛开，蝴蝶自来”。你是什么样的人，决定了你周围人的样子，同样的，你周围是什么人，也决定了你的样子。我们都生活在社会中，每天与很多人擦肩而过，与很多人协作共事，我们所散发的能量，会吸引相同频率的人。不要去妄图结交大佬，加了微信好友，可能只是对方的小号，亦或是直接被收进某个群组、打上某个标签。当自己成为了大佬，他自然会是你的朋友。</p><p><img src="https://static.howardliu.cn/20211021082245.jpeg" alt="熟人内推挺靠谱"></p><blockquote><p>话说想要内推的可以后台留言细聊</p></blockquote><h3 id="找找猎头也不错"><a href="#找找猎头也不错" class="headerlink" title="找找猎头也不错"></a>找找猎头也不错</h3><p>找猎头也是个不错的选择，当然需要有一定能力后。如果是小白，那这一单成功率不高，猎头自然不会很上心。但这并不妨碍小白的时候就加一些猎头好友，你能够从他的朋友圈一些业内动态。而且，可以告诉他自己的下一个目标，问问有没有什么要求（一定会有的），然后就可以有的放矢的朝着那个方向使劲了。</p><p>这里给猎头同学正名，不要把他们当成假想敌，其实你和猎头才是一伙的。因为最后拿提成时，猎头的提成是根据你的职级和薪资确定的。明白了吧，在你拿到 offer 入职之前，他都会帮你很多。我认识好几个这么优秀的猎头，如果需要可以加我微信，推荐给你。</p><p><img src="https://static.howardliu.cn/20211021082447.jpeg" alt="找找猎头也不错"></p><h2 id="面试博弈小妙招"><a href="#面试博弈小妙招" class="headerlink" title="面试博弈小妙招"></a>面试博弈小妙招</h2><p>前面都做好了之后，就该进入到面试环节，面试就是纯看实力和运气的过程，没有什么取巧的妙招，只能稳扎稳打的准备。所以，这里只有正常面试 ok 之后的谈薪技巧。</p><h3 id="谈薪博弈先锚定"><a href="#谈薪博弈先锚定" class="headerlink" title="谈薪博弈先锚定"></a>谈薪博弈先锚定</h3><p>有的面试技巧会告诉你，被问到期望薪资的时候，要说一个范围，不要直接说固定值，这样也能有迂回的空间。但是，是否有想过，你给自己的迂回空间，恰恰让对方知道了你的底线。比如 5000-8000，对方给出 5000 的薪资，这个 offer 你是接还是不接，接了心理不舒服，不接又在自己给出的范围。所以，直接给出一个自己的期望值，这个值是高于你的底线的。</p><p>这里需要强调一下，我们所给出的期望薪资，不是拍脑袋的，而是根据前期的调研给出的相对合理的薪资。比如市场普遍的范围在 6000-9000，你直接要 10000。这样不会让对方高看你，只是从侧面告诉对方你不懂行情，可以随意忽悠你了。</p><p>心理学上有个锚定效应，简单的说，结果会偏向先提出期望值的一方。</p><p><img src="https://static.howardliu.cn/20211021082535.jpeg" alt="谈薪博弈先锚定"></p><p>这里再说一个技巧，就是告诉对方期望薪资之前，要问一下面试公司的薪酬结构、五险一金缴纳情况、福利情况等，最好在眉头紧锁，假装自己核算（真的算也行，但这需要一定的心算能力），然后给出结果。是不是显得很专业，是不是这样的结果更能让对方信服。</p><h3 id="入职时间留出-buffer"><a href="#入职时间留出-buffer" class="headerlink" title="入职时间留出 buffer"></a>入职时间留出 buffer</h3><p>有时候，在最终发 offer 前，面试官会问入职时间。假设你现在是离职状态，非常急着找工作，也不要直接回答随时，因为你不可能随时。我所面试的公司，都会在发 offer 之后，要求背调，一般会委托背调公司进行，时间大约在 2-3 天。然后入职需要的手续、证件等，公司还需要提前准备，所以完全不可能今天发 offer，明天就能入职。</p><p>回答随时，只会让面试官感觉你很着急入职，可能在薪资上再压一压。这里再给 HR 正名，压薪资的真不一定是 HR，也有可能是你的上级领导。上级领导需要控人力成本，HR 负责你入离职，所以，谁最有可能压你的工资呢？</p><p>如果是在职，标准的回答是：收到 offer 之后，会立马提交离职信息，准备交接工作，按照规定，需要 1 个月的离职交接时间，我会争取能够提前，所以月内可以到岗。</p><p>如果是离职状态，标准回答是：收到 offer 之后，会开始为入职做准备，同时也会协调好自己的时间，如果公司比较着急，可以 1 周内到岗。</p><h3 id="晋升路径问清楚"><a href="#晋升路径问清楚" class="headerlink" title="晋升路径问清楚"></a>晋升路径问清楚</h3><p>这是一个建议，是可选项。问情况晋升路径。我们工作说白了就是升职加薪，然后实现自我价值。如果不能升职，很有可能加薪无望。所以，一定要知道升职的路径。</p><p><img src="https://static.howardliu.cn/20211021082714.jpeg" alt="晋升路径问清楚"></p><p>说起这个，奉劝一下小伙伴，换工作，我们不能只考虑加薪，不考虑职位。有时候，我们在原单位职位已经达到一定等级，然后开始找到一个薪资不错的工作，但是职级降了。如果是你，你会怎么选？</p><p>我的建议是，如果原来只是个小组长，降为普通组员，那无关痛痒，自己看心情决定。但是如果原来是总监，降为小组长，就需要考虑一下了。这种变动差距太大，你的话语权、决策权，甚至是你所能产生的能量，都缩小太多。这个时候不是考虑是否要换工作，而是需要认真思考自己的定位是否准确。是原来的职位太高，还是自己面试时候降得太低？如果这点没有想清楚，建议还是不要一时冲动。</p><h2 id="祝君早日心自由"><a href="#祝君早日心自由" class="headerlink" title="祝君早日心自由"></a>祝君早日心自由</h2><p>最后就是祝福，升职加薪，早日实现自由。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/when-to-leave-your-programming-job/">程序员什么时候该考虑辞职</a></li><li><a href="https://www.howardliu.cn/why-it-is-difficult-to-get-high-salaries-for-iters/">IT 人为什么难以拿高薪？</a></li><li><a href="https://www.howardliu.cn/we-should-know-when-changing-job/">我们如何拿到自己满意的薪资呢？这些套路还是需要掌握的</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/we-should-know-when-changing-job/">我们如何拿到自己满意的薪资呢？这些套路还是需要掌握的</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/120896294" target="_blank" rel="noopener">我们如何拿到自己满意的薪资呢？这些套路还是需要掌握的</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      我不是教你诈，而是有些技巧需要了解。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="薪资" scheme="https://www.howardliu.cn/tags/%E8%96%AA%E8%B5%84/"/>
    
      <category term="换工作" scheme="https://www.howardliu.cn/tags/%E6%8D%A2%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="套路" scheme="https://www.howardliu.cn/tags/%E5%A5%97%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>阿里开源的这个库，让 Excel 导出不再复杂（填充模板的使用指南）</title>
    <link href="https://www.howardliu.cn/effective-java-easyexcel-action-fill/"/>
    <id>https://www.howardliu.cn/effective-java-easyexcel-action-fill/</id>
    <published>2021-10-10T07:38:15.000Z</published>
    <updated>2021-10-10T07:38:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/20211010155846.jpeg" alt="阿里开源的这个库，让 Excel 导出不再复杂（填充模板的使用指南）"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/宅-ken-21259066/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6674689" target="_blank" rel="noopener">宅-KEN</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6674689" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p><a href="https://www.howardliu.cn/effective-java-easyexcel-action-write/">前文</a> 说了写操作，可以实现简单的列表导出，还能 <a href="https://www.howardliu.cn/effective-java-easyexcel-action-write-pretty/">定义样式</a>。有时候，我们还需要导出的一个大表单，或者是表单+列表的形式，这个时候，我们就需要填充功能。</p><a id="more"></a><p>内容比较多，文内只会列出关键代码，想要完整源码，可以关注公号「看山的小屋」回复“easyexcel”获取。</p><p>在 EasyExcel 中，写操作可以完成大部分工作，填充的优势在于，可以实现自定义样式的，只要在模板中设置好样式，填充的数据就能够带着样式。</p><h2 id="先写个表单"><a href="#先写个表单" class="headerlink" title="先写个表单"></a>先写个表单</h2><p>既然是使用模板，写来定义一个模板。</p><p><img src="https://static.howardliu.cn/20211010154155.png" alt="先写个表单"></p><p>在 EasyExcel 的模板填充定义中，使用<code>{}</code>来表示你要用的变量，如果本来就有”{“,”}”特殊字符，需要对其进行转义，用”{“,”}“代替。</p><h3 id="写对象"><a href="#写对象" class="headerlink" title="写对象"></a>写对象</h3><p>既然是写对象，先定义一下对象结构。</p><pre><code class="java">@Datapublic class Item {    private String name;    private double number;}</code></pre><p>然后开始填充：</p><pre><code class="java">private static void fillUseObject() {    String fileName = defaultFileName(&quot;fillUseObject&quot;);    String templateFile = getPath() + File.separator + &quot;template_fill_sample.xlsx&quot;;    Item item = new Item();    item.setName(&quot;法外狂徒张三&quot;);    item.setNumber(89757);    EasyExcelFactory.write(fileName)            .withTemplate(templateFile)            .sheet()            .doFill(item);}</code></pre><p>在写操作中我们也使用过模板写列表，这里填充模板，使用的是同样的方法：<code>com.alibaba.excel.write.builder.ExcelWriterBuilder#withTemplate(java.lang.String)</code>指定模板文件路径，这里再重复一遍。withTemplate 方法有几个重载实现：</p><ol><li>指定模板文件路径<code>ExcelWriterBuilder#withTemplate(java.lang.String)</code></li><li>指定模板文件对象<code>ExcelWriterBuilder#withTemplate(java.io.File)</code></li><li>指定模板文件输入流<code>ExcelWriterBuilder#withTemplate(java.io.InputStream)</code></li></ol><p>指定模板文件和模板文件对象都是操作文件的，需要有文件信息。</p><p>指定模板文件输入流是只要文件流，这个可操作性空间就比较大了。比如，模板文件是可变的，我们可以基于一个带变量的模板文件，使用填充写入的方式初始化模板文件，然后再用模板写入的方式，写入列表。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211010154224.png" alt="写对象"></p><h3 id="写-Map"><a href="#写-Map" class="headerlink" title="写 Map"></a>写 Map</h3><p>我们也可以不用非得创建类，用 Map 也能实现相同的功能。</p><pre><code class="java">private static void fillUseMap() {    String fileName = defaultFileName(&quot;fillUseMap&quot;);    String templateFile = getPath() + File.separator + &quot;template_fill_sample.xlsx&quot;;    Map&lt;String, Object&gt; data = new HashMap&lt;&gt;();    data.put(&quot;name&quot;, &quot;法外狂徒张三&quot;);    data.put(&quot;number&quot;, 89757);    EasyExcelFactory.write(fileName)            .withTemplate(templateFile)            .sheet()            .doFill(data);}</code></pre><p>虽然 Map 能够功能相同，不过还是建议定义具体的类。因为类是可校验的，Map 是弱检测机制，纯靠约定或者测试，不是很安全。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211010154251.png" alt="写 Map"></p><p>从效果上看，结果是相同的。</p><h2 id="再写个列表"><a href="#再写个列表" class="headerlink" title="再写个列表"></a>再写个列表</h2><p>先定义模板：</p><p><img src="https://static.howardliu.cn/20211010154354.png" alt="再写个列表"></p><p>可以看到，填充列表的参数定义，与填充对象的有些差别，模板中<code>{.}</code>多了个点。</p><p>对于表格的场景，从大体上会分为少量数据和大量数据。对于少量数据，直接在内存中操作即可。对于大量数据，可以使用分批写入，借助文件缓存的方式节省内存。</p><h3 id="少量写"><a href="#少量写" class="headerlink" title="少量写"></a>少量写</h3><p>上代码：</p><pre><code class="java">private static void fillListInMemory() {    String fileName = defaultFileName(&quot;fillListInMemory&quot;);    String templateFile = getPath() + File.separator + &quot;template_fill_list.xlsx&quot;;    EasyExcelFactory.write(fileName)            .withTemplate(templateFile)            .sheet()            .doFill(sampleItems());}</code></pre><p>可以看到，填充列表与前文说到的写文件操作在代码实现上没有太大差异，这也是 EasyExcel 架构设计上的强悍。通过建造器模式的 fluent 写法，屏蔽啰嗦的写入，同时也屏蔽不同业务实现参数的差异，只在<code>doFill</code>的时候，根据不同参数实现不同逻辑。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211010154428.png" alt="少量写"></p><h3 id="大量写"><a href="#大量写" class="headerlink" title="大量写"></a>大量写</h3><p>接下来就是大量数据填充了。与上面的差异在于需要手动创建<code>ExcelWriter</code>和<code>WriteSheet</code>对象，然后使用<code>com.alibaba.excel.ExcelWriter.fill</code>方法多次写入数据。</p><p><code>fill</code>方法支持直接写入列表和使用 lambda 函数方式，注意是<code>fill</code>，不是<code>doFill</code>。<code>doFill</code>会调用<code>finish</code>方法自动关闭流，<code>fill</code>方法只做数据填充，需要手动关闭流。</p><p>代码为：</p><pre><code class="java">private static void fillListSegment() {    String fileName = defaultFileName(&quot;fillListSegment&quot;);    String templateFile = getPath() + File.separator + &quot;template_fill_list.xlsx&quot;;    final ExcelWriter excelWriter = EasyExcelFactory.write(fileName).withTemplate(templateFile).build();    try {        final WriteSheet writeSheet = EasyExcelFactory.writerSheet().build();        excelWriter.fill(BaseFill::sampleItems, writeSheet);        excelWriter.fill(sampleItems(), writeSheet);    } finally {        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211010154502.png" alt="大量写"></p><h2 id="最后写个表单-列表"><a href="#最后写个表单-列表" class="headerlink" title="最后写个表单+列表"></a>最后写个表单+列表</h2><p>最后来个表单与列表的形式。比如销售统计，表头需要填写参数信息，比如店铺信息、时间等，然后是销售记录，最后需要增加类似合计之类的信息。</p><p>这种的话，可以实现的方式也挺多，这里介绍固定列表的实现，在技巧篇中会再介绍一种动态列表的实现。</p><h3 id="填充对象-列表"><a href="#填充对象-列表" class="headerlink" title="填充对象+列表"></a>填充对象+列表</h3><p>先定义模板：</p><p><img src="https://static.howardliu.cn/20211010154533.png" alt="填充对象+列表"></p><p>从模板中可以看到，开头是时间信息，结尾有统计信息，中间是一个列表。</p><p>上代码：</p><pre><code class="java">/** * 填充对象+列表，因为列表之后还有一个字段，所以需要将{@link FillConfigBuilder#forceNewRow(Boolean)}设置为 TRUE 才行。 * &lt;p&gt; * 这样会有一个副作用：所有数据会在内存中，即数据量大的时候特别耗内存。 * &lt;p&gt; * 想要解决有两种方式： * * &lt;ul&gt; *     &lt;li&gt;list 之后没有数据了，{@link FillConfigBuilder#forceNewRow(Boolean)}设置为 FALSE&lt;/li&gt; *     &lt;li&gt;list 写完之后，手动写后面的数据&lt;/li&gt; * &lt;/ul&gt; */private static void fillObjectAndListInMemory() {    String fileName = defaultFileName(&quot;fillObjectAndListInMemory&quot;);    String templateFile = getPath() + File.separator + &quot;template_fill_object_and_list.xlsx&quot;;    final ExcelWriter excelWriter = EasyExcelFactory.write(fileName).withTemplate(templateFile).build();    try {        final WriteSheet writeSheet = EasyExcelFactory.writerSheet().build();        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;date&quot;, DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(LocalDateTime.now()));        map.put(&quot;total&quot;, System.currentTimeMillis());        excelWriter.fill(map, writeSheet);        FillConfig fillConfig = FillConfig.builder().forceNewRow(Boolean.TRUE).build();        excelWriter.fill(BaseFill::sampleItems, fillConfig, writeSheet);        excelWriter.fill(sampleItems(), fillConfig, writeSheet);    } finally {        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>这里有一个新增的配置类：<code>FillConfig fillConfig = FillConfig.builder().forceNewRow(Boolean.TRUE).build()</code>，这个是用来定义写入时的配置信息。配置为 true，代表在写入列表的时候，不管下面有没有空行，都会创建一行，然后下面的数据往后移动。如果不定义或者设置为 false，最后那行的统计信息会被覆盖。</p><p>但是只要设置为 true 了，整个填充操作将都在内存中操作，比较耗费内存。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211010154632.png" alt="填充对象+列表"></p><h3 id="填充对象-列表（大数据量）"><a href="#填充对象-列表（大数据量）" class="headerlink" title="填充对象+列表（大数据量）"></a>填充对象+列表（大数据量）</h3><p>如果列表数据比较大，还在内存中操作就比较容易内存溢出了。所以需要特殊的操作：</p><ol><li>列表之后没有表单填充了，这种最容易实现，一句话实现不了，改需求。</li><li>只能在列表之后手动写数据</li></ol><p>代码如下：</p><pre><code class="java">private static void fillObjectAndListManual() {    String fileName = defaultFileName(&quot;fillObjectAndListManual&quot;);    String templateFile = getPath() + File.separator + &quot;template_fill_object_and_list_manual.xlsx&quot;;    final ExcelWriter excelWriter = EasyExcelFactory.write(fileName).withTemplate(templateFile).build();    try {        final WriteSheet writeSheet = EasyExcelFactory.writerSheet().build();        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;date&quot;, DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(LocalDateTime.now()));        excelWriter.fill(map, writeSheet);        FillConfig fillConfig = FillConfig.builder().forceNewRow(Boolean.TRUE).build();        excelWriter.fill(BaseFill::sampleItems, fillConfig, writeSheet);        excelWriter.fill(sampleItems(), fillConfig, writeSheet);        // 下面是纯手工写数据        List&lt;List&lt;String&gt;&gt; totalListList = new ArrayList&lt;&gt;();        List&lt;String&gt; totalList = new ArrayList&lt;&gt;();        totalListList.add(totalList);        totalList.add(null);        totalList.add(&quot;统计：1000&quot;);        excelWriter.write(totalListList, writeSheet);    } finally {        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211010154712.png" alt="填充对象+列表（大数据量）"></p><h3 id="横向填充数据"><a href="#横向填充数据" class="headerlink" title="横向填充数据"></a>横向填充数据</h3><p>先定义模板：</p><p><img src="https://static.howardliu.cn/20211010154752.png" alt="横向填充数据"></p><pre><code class="java">private static void fillObjectAndListHorizontal() {    String fileName = defaultFileName(&quot;fillObjectAndListHorizontal&quot;);    String templateFile = getPath() + File.separator + &quot;template_fill_list_horizontal.xlsx&quot;;    final ExcelWriter excelWriter = EasyExcelFactory.write(fileName).withTemplate(templateFile).build();    try {        final WriteSheet writeSheet = EasyExcelFactory.writerSheet().build();        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;date&quot;, DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(LocalDateTime.now()));        excelWriter.fill(map, writeSheet);        FillConfig fillConfig = FillConfig.builder().direction(WriteDirectionEnum.HORIZONTAL).build();        excelWriter.fill(BaseFill::sampleItems, fillConfig, writeSheet);        excelWriter.fill(sampleItems(), fillConfig, writeSheet);    } finally {        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>这里配置<code>FillConfig fillConfig = FillConfig.builder().direction(WriteDirectionEnum.HORIZONTAL).build()</code>，用于定义写入方向。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211010154823.png" alt="横向填充数据"></p><h3 id="填充多个表格"><a href="#填充多个表格" class="headerlink" title="填充多个表格"></a>填充多个表格</h3><p>与写操作相同，填充操作也可以实现多表格的写入。</p><p><img src="https://static.howardliu.cn/20211010154844.png" alt="填充多个表格"></p><p>对于多表格写入，定义模板时，必须有<code>{前缀。}</code>。</p><pre><code class="java">private static void fillMultiList() {    String fileName = defaultFileName(&quot;fillMultiList&quot;);    String templateFile = getPath() + File.separator + &quot;template_fill_multi_list.xlsx&quot;;    final ExcelWriter excelWriter = EasyExcelFactory.write(fileName).withTemplate(templateFile).build();    try {        final WriteSheet writeSheet = EasyExcelFactory.writerSheet().build();        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;date&quot;, DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(LocalDateTime.now()));        excelWriter.fill(map, writeSheet);        FillConfig fillConfig = FillConfig.builder().direction(WriteDirectionEnum.HORIZONTAL).build();        excelWriter.fill(new FillWrapper(&quot;data1&quot;, sampleItems()), fillConfig, writeSheet);        // data2 分批写入        excelWriter.fill(new FillWrapper(&quot;data2&quot;, sampleItems()), writeSheet);        excelWriter.fill(new FillWrapper(&quot;data3&quot;, sampleItems()), writeSheet);    } finally {        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>这里用到了<code>FillWrapper</code>，用来包装前缀。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211010154911.png" alt="填充多个表格"></p><p>至此，写操作和填充操作全部介绍完成。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文从实战角度说了一下 EasyExcel 如果实现填充模板导出表格，有了模板填充逻辑，再加上写逻辑，我们会有更多的玩法，接下来就会说一下这些好玩的骚操作。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/effective-java-easyexcel-action-write/">阿里开源的这个库，让 Excel 导出不再复杂（简简单单的写）</a></li><li><a href="https://www.howardliu.cn/effective-java-easyexcel-action-write-pretty/">阿里开源的这个库，让 Excel 导出不再复杂（既要能写，还要写的好看）</a></li><li><a href="https://www.howardliu.cn/effective-java-easyexcel-action-fill/">阿里开源的这个库，让 Excel 导出不再复杂（填充模板的使用指南）</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/effective-java-easyexcel-action-fill/">阿里开源的这个库，让 Excel 导出不再复杂（填充模板的使用指南）</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/120687567" target="_blank" rel="noopener">阿里开源的这个库，让 Excel 导出不再复杂（填充模板的使用指南）</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      在 EasyExcel 中，写操作可以完成大部分工作，填充的优势在于，可以实现自定义样式的，只要在模板中设置好样式，填充的数据就能够带着样式。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Effective Java" scheme="https://www.howardliu.cn/tags/Effective-Java/"/>
    
      <category term="EasyExcel" scheme="https://www.howardliu.cn/tags/EasyExcel/"/>
    
  </entry>
  
  <entry>
    <title>阿里开源的这个库，让 Excel 导出不再复杂（既要能写，还要写的好看）</title>
    <link href="https://www.howardliu.cn/effective-java-easyexcel-action-write-pretty/"/>
    <id>https://www.howardliu.cn/effective-java-easyexcel-action-write-pretty/</id>
    <published>2021-10-07T07:50:47.000Z</published>
    <updated>2021-10-07T07:50:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/20211007160914.jpeg" alt="阿里开源的这个库，让 Excel 导出不再复杂（既要能写，还要写的好看）"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/birgl-6508325/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5760752" target="_blank" rel="noopener">birgl</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5760752" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p><a href="https://www.howardliu.cn/effective-java-easyexcel-action-write/">前文</a> 聊了 EasyExcel 的内容导出，本文主要说一下导出文件的格式化，格式化包括工作表/单元格样式和内容格式化。毕竟，有时候还是要看脸。</p><a id="more"></a><p>内容比较多，文内只会列出关键代码，想要完整源码，可以关注公号「看山的小屋」回复“easyexcel”获取。</p><h2 id="注解格式"><a href="#注解格式" class="headerlink" title="注解格式"></a>注解格式</h2><p>通过注解定义格式是 EasyExcel 封装的高级功能，可以让我们很方便的定义格式。</p><h3 id="格式化内容"><a href="#格式化内容" class="headerlink" title="格式化内容"></a>格式化内容</h3><p>先定义一个使用注解格式化内容的实体类：</p><pre><code class="java">@Datapublic class FormatContentItem {    @ExcelProperty(value = &quot;字符串标题&quot;, converter = TitleFormatConverter.class)    private String string;    @DateTimeFormat(&quot;yyyy 年 MM 月 dd 日 HH 时 mm 分 ss 秒&quot;)    @ExcelProperty(value = &quot;日期标题&quot;)    private Date date;    @NumberFormat(&quot;0.000%&quot;)    @ExcelProperty(&quot;数字标题&quot;)    private Double doubleData;}</code></pre><p>其中<code>DateTimeFormat</code>和<code>NumberFormat</code>两个注解都是自带的注解，用于格式化时间和数字。</p><p><code>DateTimeFormat</code>注解有两个属性，一个属性是<code>value</code>，用来定义时间格式，可以参考<code>java.text.SimpleDateFormat</code>；另一个属性是<code>use1904windowing</code>，表示使用时间使用 1904 时间系统还是 1900 时间系统，默认是否。</p><p><code>NumberFormat</code>注解有两个属性，一个属性是<code>value</code>，用来定义数字格式，可以参考<code>java.text.DecimalFormat</code>；另一个属性是<code>roundingMode</code>，用来定义保留小数的方式，使用的是<code>java.math.RoundingMode</code>枚举。</p><p>想要格式化字符串，可以借助<code>ExcelProperty</code>的 converter 属性，这个属性传入实现<code>Converter</code>的类。比如示例中的<code>TitleFormatConverter</code>，代码如下：</p><pre><code class="java">public class TitleFormatConverter implements Converter&lt;String&gt; {    @Override    public Class&lt;?&gt; supportJavaTypeKey() {        return String.class;    }    @Override    public CellDataTypeEnum supportExcelTypeKey() {        return CellDataTypeEnum.STRING;    }    @Override    public WriteCellData&lt;?&gt; convertToExcelData(String value, ExcelContentProperty contentProperty,            GlobalConfiguration globalConfiguration) {        return new WriteCellData&lt;&gt;(String.format(&quot;标题：%s（自定义）&quot;, value));    }}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211007155354.png" alt="格式化内容"></p><h3 id="定义行高、列宽"><a href="#定义行高、列宽" class="headerlink" title="定义行高、列宽"></a>定义行高、列宽</h3><p>使用注解定义行高的话，可以使用<code>HeadRowHeight</code>定义表头高度，使用<code>ContentRowHeight</code>定义表体高度，这个注解定义之后，所有表体高度都是相同的。列宽可以使用<code>ColumnWidth</code>注解定义，这个注解可以定义在类上，表示整个表格的列都一样宽，也可以定义的属性上，表示指定列的宽度。</p><pre><code class="java">@Data@HeadRowHeight(20)@ContentRowHeight(10)@ColumnWidth(25)public class FormatCellItem {    @ExcelProperty(&quot;字符串标题&quot;)    private String string;    @ExcelProperty(&quot;日期标题&quot;)    private Date date;    @ColumnWidth(50)    @ExcelProperty(&quot;数字标题&quot;)    private Double doubleData;}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211007155431.png" alt="定义行高、列宽"></p><h3 id="单元格定义样式"><a href="#单元格定义样式" class="headerlink" title="单元格定义样式"></a>单元格定义样式</h3><p>控制单元格样式有四个注解：<code>HeadStyle</code>、<code>HeadFontStyle</code>、<code>ContentStyle</code>、<code>ContentFontStyle</code>，这四个注解可以定义在类上作为全局表格的样式，也可以定义在字段上，作为当前列的样式。下面分别说一下这几个注解中比较常用的配置。</p><ul><li>*Style：分为<code>HeadStyle</code>和<code>ContentStyle</code>，分别定义表头和表体样式<ul><li>dataFormat：表头格式化，short 格式，是<code>org.apache.poi.ss.usermodel.BuiltinFormats</code>类中已定义格式的小标</li><li>border*：分别是 borderLeft、borderRight、borderTop、borderBottom 四个属性，类型是<code>com.alibaba.excel.enums.poi.BorderStyleEnum</code>枚举，用来定义表头单元格边框样式。边框的颜色也可以定义，使用、*BorderColor 定义即可。</li><li>fillPatternType：填充类型，类型是<code>com.alibaba.excel.enums.poi.FillPatternTypeEnum</code>枚举，如果想要填充背景色，这个属性需要设置为<code>SOLID_FOREGROUND</code>。</li><li>fillForegroundColor：前景色，类型是 short，值却是使用的<code>org.apache.poi.ss.usermodel.IndexedColors</code>枚举的 idx 值，只不过，两个类型不一致，一个是 short，一个是 int，没有办法直接引用。可见 java 中的依赖之间，还是有很多坑的。</li><li>fillBackgroundColor：背景色，同<code>fillForegroundColor</code>。</li><li>rotation：内容旋转角度</li></ul></li><li>*FontStyle：有<code>HeadFontStyle</code>和<code>ContentFontStyle</code>，分别定义表头和表体的字体样式。<ul><li>fontName：定义字体名称，类型字符串</li><li>fontHeightInPoints：字号大小，类型是 short</li><li>italic：是否斜体，类型是<code>com.alibaba.excel.enums.BooleanEnum</code></li><li>bold：是否加粗，类型是<code>com.alibaba.excel.enums.BooleanEnum</code></li><li>strikeout：是否使用删除线（这个词本意是三振出局的意思，应该是与棒球有关）</li><li>color：文本颜色，值使用的是<code>org.apache.poi.ss.usermodel.IndexedColors</code>，依然有类型不一致的情况</li><li>underline：下划线，类型是 byte，可以直接使用<code>Font.U_NONE</code>、<code>Font.U_SINGLE</code>、<code>Font.U_DOUBLE</code>、<code>Font.U_SINGLE_ACCOUNTING</code>、<code>Font.U_DOUBLE_ACCOUNTING</code>。</li></ul></li></ul><p>我们可以这么定义：</p><pre><code class="java">@Data// 头背景设置成红色 IndexedColors.RED.getIndex()@HeadStyle(fillPatternType = FillPatternTypeEnum.SOLID_FOREGROUND, fillForegroundColor = 10)// 头字体设置成 20@HeadFontStyle(fontHeightInPoints = 20)// 内容的背景设置成绿色 IndexedColors.GREEN.getIndex()@ContentStyle(fillPatternType = FillPatternTypeEnum.SOLID_FOREGROUND, fillForegroundColor = 17)// 内容字体设置成 20@ContentFontStyle(fontHeightInPoints = 20)public class FormatStyleCellItem {    // 字符串的头背景设置成粉红 IndexedColors.PINK.getIndex()    @HeadStyle(fillPatternType = FillPatternTypeEnum.SOLID_FOREGROUND, fillForegroundColor = 14)    // 字符串的头字体设置成 20    @HeadFontStyle(fontHeightInPoints = 30)    // 字符串的内容的背景设置成天蓝 IndexedColors.SKY_BLUE.getIndex()    @ContentStyle(fillPatternType = FillPatternTypeEnum.SOLID_FOREGROUND, fillForegroundColor = 40)    // 字符串的内容字体设置成 20    @ContentFontStyle(fontHeightInPoints = 30)    @ExcelProperty(&quot;字符串标题&quot;)    private String string;    @ExcelProperty(&quot;日期标题&quot;)    private Date date;    @ExcelProperty(&quot;数字标题&quot;)    private Double doubleData;}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211007155504.png" alt="单元格定义样式"></p><h2 id="类对象定义格式"><a href="#类对象定义格式" class="headerlink" title="类对象定义格式"></a>类对象定义格式</h2><p>这种方式可以说是纯手工组装数据了，使用的是<code>com.alibaba.excel.metadata.data.WriteCellData</code>类，这个类相当于是单元格的定义，通过设置<code>com.alibaba.excel.enums.CellDataTypeEnum</code>枚举类型的 type 属性，可以指明当前单元格格式。</p><p>守恒定律一直存在。这种方式灵活度很高，可以精细到具体的单元格格式，但是繁琐程度也增加了。</p><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>超链接使用的是<code>com.alibaba.excel.metadata.data.HyperlinkData</code>类，需要设置地址、超链类型（<code>com.alibaba.excel.metadata.data.HyperlinkData.HyperlinkType</code>枚举），然后将值写入到<code>WriteCellData</code>对象的<code>hyperlinkData</code>属性即可。</p><pre><code class="java">// 设置超链接HyperlinkData hyperlinkData = new HyperlinkData();hyperlinkData.setAddress(&quot;https://www.howardliu.cn&quot;);hyperlinkData.setHyperlinkType(HyperlinkType.URL);WriteCellData&lt;String&gt; hyperlink = new WriteCellData&lt;&gt;(&quot;网站&quot;);hyperlink.setHyperlinkData(hyperlinkData);</code></pre><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>备注使用的是<code>com.alibaba.excel.metadata.data.CommentData</code>类，需要设置作者、备注内容（<code>com.alibaba.excel.metadata.data.RichTextStringData</code>类型），因为备注的默认大小是单元格大小，如果感觉太小，还可以设置相对高度和宽度。</p><pre><code class="java">// 设置备注CommentData commentData = new CommentData();commentData.setAuthor(&quot;Howard Liu&quot;);commentData.setRichTextStringData(new RichTextStringData(&quot;这是一个备注&quot;));// 备注的默认大小是按照单元格的大小 这里想调整到 4 个单元格那么大 所以向后 向下 各额外占用了一个单元格commentData.setRelativeLastColumnIndex(1);commentData.setRelativeLastRowIndex(1);WriteCellData&lt;String&gt; comment = new WriteCellData&lt;&gt;(&quot;备注的单元格信息&quot;);comment.setCommentData(commentData);</code></pre><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>公式使用的是<code>com.alibaba.excel.metadata.data.FormulaData</code>类，可以直接设置<code>formulaValue</code>公式，不过官方不太推荐使用公式。</p><pre><code class="java">// 设置公式FormulaData formulaData = new FormulaData();// 将 123456789 中的第一个数字替换成 2// 这里只是例子 如果真的涉及到公式 能内存算好尽量内存算好 公式能不用尽量不用formulaData.setFormulaValue(&quot;REPLACE(123456789,1,1,2)&quot;);WriteCellData&lt;String&gt; formula = new WriteCellData&lt;&gt;();formula.setFormulaData(formulaData);</code></pre><h3 id="单元格格式"><a href="#单元格格式" class="headerlink" title="单元格格式"></a>单元格格式</h3><p>通过类定义单元格格式，与通过注解定义本质是一样的。所以与注解<code>HeadStyle</code>、<code>HeadFontStyle</code>、<code>ContentStyle</code>、<code>ContentFontStyle</code>对应，设置单元格格式的类是<code>WriteCellStyle</code>，设置字体的类是<code>WriteFont</code>。其中这些类的属性与注解的也是类似，不再赘述太多，直接上例子。（其实我觉得使用类定义格式的场景不多，真的碰到了，看看类定义就明白了）</p><pre><code class="java">// 设置单个单元格的样式 当然样式 很多的话 也可以用注解等方式。WriteCellStyle writeCellStyleData = new WriteCellStyle();// 这里需要指定 FillPatternType 为 FillPatternType.SOLID_FOREGROUND 不然无法显示背景颜色。writeCellStyleData.setFillPatternType(FillPatternType.SOLID_FOREGROUND);// 背景绿色writeCellStyleData.setFillForegroundColor(IndexedColors.GREEN.getIndex());WriteCellData&lt;String&gt; writeCellStyle = new WriteCellData&lt;&gt;(&quot;单元格样式&quot;);writeCellStyle.setWriteCellStyle(writeCellStyleData);writeCellStyle.setType(CellDataTypeEnum.STRING);// 设置单个单元格多种样式RichTextStringData richTextStringData = new RichTextStringData();richTextStringData.setTextString(&quot;红色绿色默认&quot;);// 前 2 个字红色WriteFont writeFont = new WriteFont();writeFont.setColor(IndexedColors.RED.getIndex());richTextStringData.applyFont(0, 2, writeFont);// 接下来 2 个字绿色writeFont = new WriteFont();writeFont.setColor(IndexedColors.GREEN.getIndex());richTextStringData.applyFont(2, 4, writeFont);WriteCellData&lt;String&gt; richTest = new WriteCellData&lt;&gt;();richTest.setType(CellDataTypeEnum.RICH_TEXT_STRING);richTest.setRichTextStringDataValue(richTextStringData);</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211007155542.png" alt="单元格格式"></p><h2 id="拦截器定义格式"><a href="#拦截器定义格式" class="headerlink" title="拦截器定义格式"></a>拦截器定义格式</h2><p>除了直接使用类定义格式，我们还可以借助拦截器实现。（这里在名称上会有一些歧义，所用的类对象命名都是 xxxStrategy，翻译过来就是 xxx 策略，但是官方对其命名为拦截器）</p><h3 id="已有拦截器"><a href="#已有拦截器" class="headerlink" title="已有拦截器"></a>已有拦截器</h3><p>前面示例中使用<code>WriteCellStyle</code>、<code>WriteFont</code>可以实现单元格的样式，如果想要实现整行数据都是相同的格式，可以借助<code>com.alibaba.excel.write.style.HorizontalCellStyleStrategy</code>拦截器。</p><pre><code class="java">/** * 使用已有策略实现自定义样式 * * &lt;ul&gt; *     &lt;li&gt;HorizontalCellStyleStrategy 每一行的样式都一样 或者隔行一样&lt;/li&gt; *     &lt;li&gt;AbstractVerticalCellStyleStrategy 每一列的样式都一样 需要自己回调每一页&lt;/li&gt; * &lt;/ul&gt; */private static void writeByCellStyleStrategy() {    String fileName = defaultFileName(&quot;writeByCellStyleStrategy&quot;);    // 表头策略    WriteCellStyle headWriteCellStyle = new WriteCellStyle();    // 背景设置为红色    headWriteCellStyle.setFillForegroundColor(IndexedColors.RED.getIndex());    WriteFont headWriteFont = new WriteFont();    headWriteFont.setFontHeightInPoints((short) 40);    headWriteCellStyle.setWriteFont(headWriteFont);    // 表体策略    WriteCellStyle contentWriteCellStyle = new WriteCellStyle();    // 这里需要指定 FillPatternType 为 FillPatternType.SOLID_FOREGROUND 不然无法显示背景颜色。表头默认了 FillPatternType 所以可以不指定    contentWriteCellStyle.setFillPatternType(FillPatternType.SOLID_FOREGROUND);    // 背景绿色    contentWriteCellStyle.setFillForegroundColor(IndexedColors.GREEN.getIndex());    WriteFont contentWriteFont = new WriteFont();    // 字体大小    contentWriteFont.setFontHeightInPoints((short) 20);    contentWriteCellStyle.setWriteFont(contentWriteFont);    // 这个策略是 头是头的样式 内容是内容的样式 其他的策略可以自己实现    HorizontalCellStyleStrategy horizontalCellStyleStrategy =            new HorizontalCellStyleStrategy(headWriteCellStyle, contentWriteCellStyle);    // 这里 需要指定写用哪个 class 去写，然后写到第一个 sheet，名字为模板 然后文件流会自动关闭    EasyExcelFactory.write(fileName)            .head(Item.class)            .registerWriteHandler(horizontalCellStyleStrategy)            .sheet()            .doWrite(sampleItems());}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211007155615.png" alt="已有拦截器"></p><p>正如上面的结果，如果我们某个单元格数据比较长，可能会有遮挡，这个时候我们可以使用<code>com.alibaba.excel.write.style.column.LongestMatchColumnWidthStyleStrategy</code>实现自动列宽调整。不过这个不太精确，但聊胜于无。</p><pre><code class="java">private static void writeUseLongestMatchColumnWidthStyleStrategy() {    String fileName = defaultFileName(&quot;writeUseLongestMatchColumnWidthStyleStrategy&quot;);    EasyExcelFactory.write(fileName)            .head(Item.class)            .registerWriteHandler(new LongestMatchColumnWidthStyleStrategy())            .sheet()            .doWrite(sampleItems());}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211007155646.png" alt="已有拦截器"></p><p>可以看到，确实不够精确。</p><h3 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h3><p>上面展示的拦截器，都是实现了<code>com.alibaba.excel.write.handler.WriteHandler</code>接口，然后使用<code>com.alibaba.excel.write.builder.AbstractExcelWriterParameterBuilder.registerWriteHandler</code>方法注册到写函数中。所以，我们也可能根据需要，自己定义需要的拦截器。</p><blockquote><p>这种自定义拦截器属于低级功能，需要了解很多底层设计和 API，鉴于篇幅，本文没有办法覆盖，这里只给出例子。如果有需要，可以留言沟通。</p></blockquote><p>比如，我们需要某些单元格设置数据验证，展现形式就是下拉菜单，我们可以这样写：</p><pre><code class="java">public class ColumnValidationWriteHandler implements SheetWriteHandler {    @Override    public void afterSheetCreate(SheetWriteHandlerContext context) {        // 区间设置 第一列第一行和第二行的数据。由于第一行是头，所以第一、二行的数据实际上是第二三行        CellRangeAddressList cellRangeAddressList = new CellRangeAddressList(1, 2, 0, 0);        DataValidationHelper helper = context.getWriteSheetHolder().getSheet().getDataValidationHelper();        DataValidationConstraint constraint = helper.createExplicitListConstraint(new String[] {&quot;测试 1&quot;, &quot;测试 2&quot;});        DataValidation dataValidation = helper.createValidation(constraint, cellRangeAddressList);        context.getWriteSheetHolder().getSheet().addValidationData(dataValidation);    }}</code></pre><p>如果我们需要将某个单元格的格式设置为超链，也可以使用拦截器：</p><pre><code class="java">public class CellStyleWriteHandler implements CellWriteHandler {    @Override    public void afterCellDispose(CellWriteHandlerContext context) {        Cell cell = context.getCell();        // 这里可以对 cell 进行任何操作        if (BooleanUtils.isTrue(context.getHead()) &amp;&amp; cell.getColumnIndex() == 0) {            CreationHelper createHelper = context.getWriteSheetHolder().getSheet().getWorkbook().getCreationHelper();            Hyperlink hyperlink = createHelper.createHyperlink(HyperlinkType.URL);            hyperlink.setAddress(&quot;https://www.howardliu.cn&quot;);            cell.setHyperlink(hyperlink);        }    }}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211007155715.png" alt="自定义拦截器"></p><h2 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h2><p>EasyExcel 提供的合并单元格功能比较简单，有两种方式：基于注解的合并、基于拦截器的合并。</p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>基于注解的合并单元格提供了两个注解：</p><ul><li><code>OnceAbsoluteMerge</code>注解实现指定位置的合并</li><li><code>ContentLoopMerge</code>这个是内容的循环合并，指定某一列每几行合并。</li></ul><pre><code class="java">// 将第 6-7 行的 2-3 列合并成一个单元格@OnceAbsoluteMerge(firstRowIndex = 5, lastRowIndex = 6, firstColumnIndex = 1, lastColumnIndex = 2)@Datapublic class MergeCellItem {    @ContentLoopMerge(eachRow = 2)    @ExcelProperty(&quot;字符串标题&quot;)    private String string;    @ExcelProperty(&quot;日期标题&quot;)    private Date date;    @ExcelProperty(&quot;数字标题&quot;)    private Double doubleData;}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211007155745.png" alt="合并单元格注解"></p><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>拦截器合并也是有两种，对应着注解：</p><ul><li><code>OnceAbsoluteMergeStrategy</code>，相对位置合并</li><li><code>LoopMergeStrategy</code>循环合并</li></ul><pre><code class="java">private static void writeMergeCellCustom() {    String fileName = defaultFileName(&quot;writeMergeCellCustom&quot;);    // 每隔 2 行会合并    // 把 eachColumn 设置成 3 也就是我们数据的长度，所以就第一列会合并。当然其他合并策略也可以自己写    LoopMergeStrategy loopMergeStrategy = new LoopMergeStrategy(2, 0);    EasyExcelFactory.write(fileName)            .head(Item.class)            .registerWriteHandler(loopMergeStrategy)            .sheet()            .doWrite(sampleItems());}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211007155820.png" alt="合并单元格拦截器"></p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文从实战角度说了一下 EasyExcel 如果实现写出好看的表格，EasyExcel中提供了很多用于格式化的注解、拦截器，可以实现通用的格式化输出，如果还有更加个性化的格式要求，也可以自定义拦截器实现。接下来聊一下如何填充模板。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/effective-java-easyexcel-action-write/">阿里开源的这个库，让 Excel 导出不再复杂（简简单单的写）</a></li><li><a href="https://www.howardliu.cn/effective-java-easyexcel-action-write-pretty/">阿里开源的这个库，让 Excel 导出不再复杂（既要能写，还要写的好看）</a></li><li><a href="https://www.howardliu.cn/effective-java-easyexcel-action-fill/">阿里开源的这个库，让Excel导出不再复杂（填充模板的使用指南）</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/effective-java-easyexcel-action-write-pretty/">阿里开源的这个库，让 Excel 导出不再复杂（既要能写，还要写的好看）</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/120637460" target="_blank" rel="noopener">阿里开源的这个库，让 Excel 导出不再复杂（既要能写，还要写的好看）</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      既要能写，还要写的好看。毕竟，有时候还是要看脸。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Effective Java" scheme="https://www.howardliu.cn/tags/Effective-Java/"/>
    
      <category term="EasyExcel" scheme="https://www.howardliu.cn/tags/EasyExcel/"/>
    
  </entry>
  
  <entry>
    <title>阿里开源的这个库，让 Excel 导出不再复杂（简简单单的写）</title>
    <link href="https://www.howardliu.cn/effective-java-easyexcel-action-write/"/>
    <id>https://www.howardliu.cn/effective-java-easyexcel-action-write/</id>
    <published>2021-10-03T22:40:34.000Z</published>
    <updated>2021-10-03T22:40:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/20211004065308.jpeg" alt="阿里开源的这个库，让 Excel 导出不再复杂（简简单单的写）"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/kimdaejeung-7703165/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6549208" target="_blank" rel="noopener">dae jeung kim</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6549208" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>导出是中后台常见的功能，Excel文件是常见的导出格式。</p><a id="more"></a><p>在Java栈中，常用的是<a href="https://sourceforge.net/projects/jexcelapi/" target="_blank" rel="noopener">JXL（目前改名为JExcel）</a>和<a href="http://poi.apache.org/" target="_blank" rel="noopener">Apache POI</a>。其中jxl最后的更新时间是2012，除了老系统中能看到影子，几乎见不到踪迹了。目前基本上是POI一统天下。</p><p>今天要说的EasyExcel阿里巴巴开源的Excel导出类库，是对POI的封装，实现了很多高级功能，并且留出扩展口，支持扩展定制化功能。打个比喻，POI相当于乐高积木，一个个的小积木可以自由组装，只能动手能力强，就可以随心所欲的组装。EasyExcel更像是把这些小积木提前组装好，想要搭建房子，就直接找组装好的屋顶、围墙就行。如果仅仅如此，那EasyExcel仅仅就是简单的工具包，其更加吸引人的地方是对于内存的控制，它通过压缩文件、分批读取、抛弃不重要数据、文件缓存等多种方式，降低内存消耗。</p><p>内容比较多，文内只会列出关键代码，想要完整源码，可以关注公号「看山的小屋」回复“easyexcel”获取。</p><h2 id="最简单的写表格"><a href="#最简单的写表格" class="headerlink" title="最简单的写表格"></a>最简单的写表格</h2><p>开始之前，先定义一下基础类，这个类将贯穿全文，所有的功能都是在这个类的简单变形。</p><pre><code class="java">@Datapublic class Item {    @ExcelProperty(&quot;字符串标题&quot;)    private String string;    @ExcelProperty(&quot;日期标题&quot;)    private Date date;    @ExcelProperty(&quot;数字标题&quot;)    private Double doubleData;    @ExcelIgnore    private String ignore;}</code></pre><h3 id="根据头对象和列表向一个工作表中写一个表格"><a href="#根据头对象和列表向一个工作表中写一个表格" class="headerlink" title="根据头对象和列表向一个工作表中写一个表格"></a>根据头对象和列表向一个工作表中写一个表格</h3><p>这是最简单的一种实现，只需要定义一个对象类，然后读取数据列表即可。</p><pre><code class="java">/** * 借助{@link com.alibaba.excel.write.builder.ExcelWriterSheetBuilder}自动创建{@link com.alibaba.excel.ExcelWriter}写入数据。 * &lt;p&gt; * 提供列表和函数作为数据源 */public static void writeAutoWriter() {    final String fileName = defaultFileName(&quot;writeAutoWriter&quot;);    EasyExcelFactory.write(fileName)            .head(Item.class)            .sheet(&quot;模板&quot;)            .doWrite(WriteSample::sampleItems);}</code></pre><p>EasyExcel提供了<code>EasyExcelFactory</code>类，API方法也是fluent方式，可以如丝般顺滑的实现生成Excel文件。如果感觉<code>EasyExcelFactory</code>太长，还可以直接写作<code>EasyExcel</code>，这是<code>EasyExcelFactory</code>的子类，类似于别名。</p><blockquote><p>不过，这种别名定义方式，在有些规范中属于<code>smell code</code>，所以，根据自己或者公司规范选择吧。</p></blockquote><p><code>com.alibaba.excel.EasyExcelFactory#write(java.lang.String)</code>方法的参数传的是导出文件的文件名，如果并不需要生成文件，只需要创建文件流，也可以传入一个输出流<code>OutputStream</code>，这样就可以更加灵活的实现生成逻辑了。</p><p><code>com.alibaba.excel.metadata.AbstractParameterBuilder#head()</code>方法是定义表头，只要传入一个类，就会读取这个类的所有字段作为表头。如果字段上<code>com.alibaba.excel.annotation.ExcelProperty</code>注解，定义了<code>value</code>，就会取<code>value</code>的值作为表头。此处还有很多操作，比如，<code>value</code>是数组，可以定义多个，如果是相邻字段定义了相同的表头，会合并单元格，表体内容会选择第一个单元格的内容。这个注解还可以定义<code>index</code>、<code>order</code>、<code>converter</code>等，后面会一一给出例子。</p><p><code>com.alibaba.excel.write.builder.ExcelWriterBuilder#sheet()</code>方法定义工作表，有多个重载方法，可以定义<code>sheetNo</code>指明是第几个工作表，可以传入<code>sheetName</code>指明工作表名称。</p><p><code>com.alibaba.excel.write.builder.ExcelWriterSheetBuilder#doWrite()</code>方法就是写Excel文件了，传入全部的列表数据，或者使用Java8+的<code>Supplier</code>函数。还可以实现分页写入，后面会给出例子。这个方法会自动关闭文件流，真是很贴心。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004065644.png" alt="根据头对象和列表向一个工作表中写一个表格"></p><h3 id="根据头对象和列表向多个工作表中写数据"><a href="#根据头对象和列表向多个工作表中写数据" class="headerlink" title="根据头对象和列表向多个工作表中写数据"></a>根据头对象和列表向多个工作表中写数据</h3><p>上面是向一个工作表写数据，接下来我们向多个工作表写数据。</p><blockquote><p>这个例子会涉及更多的内部对象，比如：ExcelWriter、WriteSheet。</p></blockquote><pre><code class="java">/** * 手动创建{@link com.alibaba.excel.ExcelWriter}，指定sheet写入数据。 * &lt;p&gt; * 提供列表和函数作为数据源 */public static void writeManualWither() {    String fileName = defaultFileName(&quot;writeManualWriter&quot;);    ExcelWriter excelWriter = null;    try {        excelWriter = EasyExcelFactory.write(fileName)                .head(Item.class)                .build();        final WriteSheet writeSheet1 = EasyExcelFactory.writerSheet(&quot;模板1&quot;).build();        excelWriter.write(WriteSample::sampleItems, writeSheet1);        final WriteSheet writeSheet2 = EasyExcelFactory.writerSheet(&quot;模板2&quot;).build();        excelWriter.write(sampleItems(), writeSheet2);    } finally {        // 千万别忘记finish 会帮忙关闭流        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>因为是想多个工作表中写数据，我们就不能直接使用<code>doWrite</code>方法了。</p><p><code>com.alibaba.excel.ExcelWriter</code>类是Excel写对象，用来创建Excel工作簿的。<code>com.alibaba.excel.write.metadata.WriteSheet</code>类是Sheet写对象，用来创建Sheet工作表的。通过<code>com.alibaba.excel.ExcelWriter#write()</code>方法，指定写入数据和写入的目标工作表，就可以实现向多个工作表中写数据的功能。</p><p>此处需要注意，我们在创建<code>ExcelWriter</code>对象时，调用了<code>head()</code>方法定义了表头，这是整个Excel的定义，sheet会继承这个定义。这样，整个Excel文件中的所有工作表，表头都是相同的。不要停，后面会给出不同工作表定义不同表头的示例。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004065724.png" alt="根据头对象和列表向多个工作表中写数据"></p><h2 id="按照定义指定导出列"><a href="#按照定义指定导出列" class="headerlink" title="按照定义指定导出列"></a>按照定义指定导出列</h2><p>在后台系统中，会有行列权限的控制。行权限，通过数据行实现，只导出有权限的行数据即可。列权限，可以通过只导出有权限的列，排除没有权限的列（通常是分等级的敏感数据）。</p><p>有时候需要定制化导出，导出所有列表格比较大，用户根据需要指定需要导出的列。</p><h3 id="排除指定列"><a href="#排除指定列" class="headerlink" title="排除指定列"></a>排除指定列</h3><pre><code class="java">private static void writeExcludeColumn() {    String fileName = defaultFileName(&quot;writeExcludeColumn&quot;);    Set&lt;String&gt; excludeColumnFiledNames = new HashSet&lt;&gt;();    excludeColumnFiledNames.add(&quot;date&quot;);    EasyExcelFactory.write(fileName)            .head(Item.class)            .excludeColumnFiledNames(excludeColumnFiledNames)            .sheet(&quot;模板&quot;)            .doWrite(WriteSample::sampleItems);}</code></pre><p>这个需求，需要借助<code>com.alibaba.excel.write.builder.AbstractExcelWriterParameterBuilder#excludeColumnFiledNames</code>方法。这个方法是在<code>ExcelWriterBuilder</code>、<code>ExcelWriterSheetBuilder</code>、<code>ExcelWriterTableBuilder</code>的父类中定义，也就是说，可以是整个Excel工作簿都排除指定字段，也可以是某个sheet工作表排除指定字段，还可以是table表格排除指定字段。</p><p>除了<code>excludeColumnFiledNames</code>通过字段名排除字段，还可以使用<code>excludeColumnIndexes</code>指定字段下标排除列，如果需要控制下标，需要在字段上定义<code>ExcelProperty</code>指明index属性，这样也能够更好的固定字段下标。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004065753.png" alt="排除指定列"></p><h3 id="只导出指定列"><a href="#只导出指定列" class="headerlink" title="只导出指定列"></a>只导出指定列</h3><pre><code class="java">private static void writeIncludeColumn() {    String fileName = defaultFileName(&quot;writeIncludeColumn&quot;);    Set&lt;String&gt; includeColumnFiledNames = new HashSet&lt;&gt;();    includeColumnFiledNames.add(&quot;date&quot;);    EasyExcelFactory.write(fileName)            .head(Item.class)            .includeColumnFiledNames(includeColumnFiledNames)            .sheet(&quot;模板&quot;)            .doWrite(WriteSample::sampleItems);}</code></pre><p>这个需求，需要借助<code>com.alibaba.excel.write.builder.AbstractExcelWriterParameterBuilder#includeColumnFiledNames</code>方法。与<code>excludeColumnFiledNames</code>是相似，都是可以分级定义，用起来也是一样的，只不过功能相反而已。</p><p>同样的，也可以使用<code>includeColumnIndexes</code>方法，通过指定字段下标指定列。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004065816.png" alt="只导出指定列"></p><h2 id="表头"><a href="#表头" class="headerlink" title="表头"></a>表头</h2><p>表头的定义是比较关键的，会直接影响Excel文件的质量。所以，EasyExcel提供了比较丰富的表头定义方法。</p><h3 id="原始表头"><a href="#原始表头" class="headerlink" title="原始表头"></a>原始表头</h3><p>这里定义了一个新的基础类：<code>EmptyItem</code>，与<code>Item</code>的区别是移除了<code>ExcelProperty</code>的定义。</p><pre><code class="java">@Datapublic class EmptyItem {    private String string;    private Date date;    private Double doubleData;}</code></pre><p>在这种情况下，会直接使用<code>EmptyItem</code>对象的字段作为表头名称。</p><pre><code class="java">private static void writeNoAnnotation() {    final String fileName = defaultFileName(&quot;writeNoAnnotation&quot;);    EasyExcelFactory.write(fileName)            .head(EmptyItem.class)            .sheet(&quot;模板&quot;)            .doWrite(WriteSample::sampleItems);}</code></pre><blockquote><p>这里可以看到，EasyExcel对于表头对象、表体列表对象，没有强制要求必须是相同的对象，只要字段一致，就能够正常组装数据。</p></blockquote><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004065847.png" alt="原始表头"></p><h3 id="自定义表头"><a href="#自定义表头" class="headerlink" title="自定义表头"></a>自定义表头</h3><p>使用字段作为表头显然不是我们想要的，EasyExcel提供了<code>ExcelProperty</code>注解，可以定义表头的名称。这个注解还提供了<code>index</code>、<code>order</code>两个属性，可以定义列的位置和顺序。</p><pre><code class="java">@Datapublic class IndexItem {    @ExcelProperty(value = &quot;字符串标题&quot;, index = 1)    private String string;    @ExcelProperty(value = &quot;日期标题&quot;, index = 3)    private Date date;    @ExcelProperty(value = &quot;数字标题&quot;, index = 5)    private Double doubleData;}</code></pre><p>使用起来也很简单：</p><pre><code class="java">private static void writeWithIndex() {    final String fileName = defaultFileName(&quot;writeWithIndex&quot;);    EasyExcelFactory.write(fileName)            .head(IndexItem.class)            .sheet(&quot;模板&quot;)            .doWrite(WriteSample::sampleItems);}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004065911.png" alt="自定义表头"></p><p>这里需要注意一下，在使用<code>ExcelProperty</code>注解时，index表示字段放置第几列，order表示顺序。</p><p>根据index和order的不同语义，对两者的控制不同。如果index相同，直接会抛出异常，因为程序无法判断这个列放那个字段。如果index值中间有空的数字，就会出现空列。如果order和index同时使用，index优先占据位置，order做排序。index=-1的话，使用java默认排序，order值越小，列越靠前。</p><p><code>ExcelProperty</code>的value属性是字符串数组，相当于一个字段可以定义多个头，这样就可以实现多级表头。同时，如果位置相邻的列定义列明相同，还会合并列。比如：</p><pre><code class="java">@Datapublic class ComplexHeadItem {    @ExcelProperty({&quot;大标题&quot;, &quot;字符串标题&quot;})    private String string;    @ExcelProperty(&quot;日期标题&quot;)    private Date date;    @ExcelProperty({&quot;大标题&quot;, &quot;数字标题0&quot;})    private Double doubleData;    @ExcelProperty({&quot;数字标题&quot;})    private Double doubleData1;    @ExcelProperty({&quot;数字标题&quot;})    private Double doubleData2 = 0.0;}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004065935.png" alt="自定义表头-合并"></p><h3 id="动态表头、表体"><a href="#动态表头、表体" class="headerlink" title="动态表头、表体"></a>动态表头、表体</h3><p>前面的例子中，表头定义都是传入一个对象，通过解析对象的属性字段，抽取表头定义。有的时候，我们没有办法提前定义表头对象，或者说，表头是根据条件、权限等因素动态变化的，这个时候，就可以使用EasyExcel提供的动态表头功能了。</p><pre><code class="java">/** * 动态表头，传入的是{@code List&lt;List&lt;String&gt;&gt;}格式数据。 * &lt;p&gt; * 可以实现多层表头。 */private static void writeDynamicHead() {    String fileName = defaultFileName(&quot;writeDynamicHead&quot;);    EasyExcelFactory.write(fileName)            .head(dynamicHead())            .sheet()            .doWrite(sampleItems());}private static List&lt;List&lt;String&gt;&gt; dynamicHead() {    List&lt;List&lt;String&gt;&gt; heads = new ArrayList&lt;&gt;();    final List&lt;String&gt; head0 = new ArrayList&lt;&gt;(Arrays.asList(&quot;头0&quot;, &quot;字符串标题【动态】&quot;));    heads.add(head0);    final List&lt;String&gt; head1 = new ArrayList&lt;&gt;(Arrays.asList(&quot;头0&quot;, &quot;日期标题【动态】&quot;));    heads.add(head1);    final List&lt;String&gt; head2 = new ArrayList&lt;&gt;(Collections.singletonList(&quot;数字标题【动态】&quot;));    heads.add(head2);    return heads;}</code></pre><p>使用<code>com.alibaba.excel.metadata.AbstractParameterBuilder#head(java.util.List&lt;java.util.List&lt;java.lang.String&gt;&gt;)</code>方法，传入<code>List&lt;List&lt;String&gt;&gt;</code>类型的数据即可。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004070011.png" alt="动态表头、表体"></p><p>当然，这样做还不是彻底的动态。我们可以使用<code>com.alibaba.excel.write.builder.ExcelWriterSheetBuilder#doWrite(java.util.Collection&lt;?&gt;)</code>实现动态表体。代码如下：</p><pre><code class="java">private static void writeDynamicData() {    String fileName = defaultFileName(&quot;writeDynamicData&quot;);    EasyExcelFactory.write(fileName)            .head(dynamicHead())            .sheet()            .doWrite(dynamicData());}private static List&lt;List&lt;Object&gt;&gt; dynamicData() {    List&lt;List&lt;Object&gt;&gt; list = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; 10; i++) {        List&lt;Object&gt; data = new ArrayList&lt;&gt;();        data.add(&quot;字符串&quot; + i);        data.add(new Date());        data.add((i + 1) * 0.1);        list.add(data);    }    return list;}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004070036.png" alt="动态表头、表体"></p><h3 id="表头国际化"><a href="#表头国际化" class="headerlink" title="表头国际化"></a>表头国际化</h3><p>互联网无国界，很多时候，我们需要实现国际化。这个时候，我们可以使用动态表头功能，传入不同的表头定义，生成不同的Excel文件。有时候，我们还需要提前定义表体的格式，使用动态表体可以实现。有没有更加简单方法呢？必须有。</p><p>先定义格式化表头对象：</p><pre><code class="java">@Datapublic class FormatContentItem {    @ExcelProperty(value = &quot;字符串标题&quot;, converter = TitleFormatConverter.class)    private String string;    @DateTimeFormat(&quot;yyyy年MM月dd日HH时mm分ss秒&quot;)    @ExcelProperty(value = &quot;日期标题&quot;)    private Date date;    @NumberFormat(&quot;0.000%&quot;)    @ExcelProperty(&quot;数字标题&quot;)    private Double doubleData;}</code></pre><p>再实现国际化：</p><pre><code class="java">/** * 可以同时设置head参数： * {@link AbstractParameterBuilder#head(java.util.List)} * {@link AbstractParameterBuilder#head(java.lang.Class)} * &lt;p&gt; * 对于表头设置，最终起作用的是{@link AbstractParameterBuilder#head(java.util.List)}，这样的话，我们可以实现国际化的配置。 */private static void writeDynamicMultiHead() {    String fileName = defaultFileName(&quot;writeDynamicMultiHead&quot;);    EasyExcelFactory.write(fileName)            .head(dynamicHead())            .head(FormatContentItem.class)            .sheet()            .doWrite(sampleItems());}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004070102.png" alt="表头国际化"></p><h2 id="多次写入"><a href="#多次写入" class="headerlink" title="多次写入"></a>多次写入</h2><p>一般来说，中后台的数据量都不小，有时候需要一次导出几十万行数据，甚至更多，而这种操作并不是常态，如果内存配置比较大，那大多数时间内存都是闲置状态。此时，就可以借助EasyExcel的文件缓存能力，分批写入数据。</p><h3 id="向同一个excel同一个sheet中多次写入"><a href="#向同一个excel同一个sheet中多次写入" class="headerlink" title="向同一个excel同一个sheet中多次写入"></a>向同一个excel同一个sheet中多次写入</h3><p>首先是比较常见的场景，向一个sheet工作表中分批写入数据。</p><pre><code class="java">private static void writeOneSheet() {    String fileName = defaultFileName(&quot;writeOneSheet&quot;);    ExcelWriter excelWriter = null;    try {        excelWriter = EasyExcelFactory.write(fileName)                .head(Item.class)                .build();        final WriteSheet writeSheet = EasyExcelFactory.writerSheet(&quot;模板&quot;).build();        for (int i = 0; i &lt; 5; i++) {            excelWriter.write(sampleItems(), writeSheet);        }    } finally {        // 千万别忘记finish 会帮忙关闭流        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>首先定义<code>ExcelWriter</code>可以操作整个Excel工作簿，然后定义<code>ExcelWriter</code>sheet工作表，接下来就是循环调用<code>com.alibaba.excel.ExcelWriter.write(java.util.Collection&lt;?&gt;, com.alibaba.excel.write.metadata.WriteSheet)</code>方法，将数据写入到指定的sheet工作表中。这里需要注意的是，最后一定要调用<code>com.alibaba.excel.ExcelWriter.finish</code>方法，表示停止写入并关闭流。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004070128.png" alt="向同一个excel同一个sheet中多次写入"></p><h3 id="向同一个excel不同sheet中多次写入（表头相同）"><a href="#向同一个excel不同sheet中多次写入（表头相同）" class="headerlink" title="向同一个excel不同sheet中多次写入（表头相同）"></a>向同一个excel不同sheet中多次写入（表头相同）</h3><p>还有一种场景是按月导出全年的订单数据，每个月一个sheet工作表，这种导出的方式，表头都是相同的。根据上面的经验，我们需要定义多个<code>WriteSheet</code>工作表对象，然后向该对象中写数据。</p><p>这里还可能有一种情况，就是我们需要在多个<code>WriteSheet</code>工作表对象之间切换写入，为了不会找错对象，可以指定<code>sheetNo</code>。</p><p>代码如下：</p><pre><code class="java">private static void writeDiffSheetWithSameHead() {    String fileName = defaultFileName(&quot;writeDiffSheetWithSameHead&quot;);    ExcelWriter excelWriter = null;    try {        excelWriter = EasyExcelFactory.write(fileName)                .head(Item.class)                .build();        for (int i = 0; i &lt; 5; i++) {            final WriteSheet writeSheet = EasyExcelFactory.writerSheet(i, &quot;模板&quot; + i)                    .build();            excelWriter.write(sampleItems(), writeSheet);        }    } finally {        // 千万别忘记finish 会帮忙关闭流        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004070152.png" alt="向同一个excel不同sheet中多次写入（表头相同）"></p><p><img src="https://static.howardliu.cn/20211004070212.png" alt="向同一个excel不同sheet中多次写入（表头相同）"></p><h3 id="向同一个excel不同sheet中多次写入（表头不同）"><a href="#向同一个excel不同sheet中多次写入（表头不同）" class="headerlink" title="向同一个excel不同sheet中多次写入（表头不同）"></a>向同一个excel不同sheet中多次写入（表头不同）</h3><p>还有一种场景，导出指定时间范围的订单信息，一个sheet工作表放具体的商品信息，另一个sheet工作表放订单收货地址信息。这种场景就需要不同的表头，根据前面的讲解，我们知道，只需要在定义<code>WriteSheet</code>对象时指定不同的表头对象即可。</p><p>代码如下：</p><pre><code class="java">private static void writeDiffSheetWithDiffHead() {    String fileName = defaultFileName(&quot;writeDiffSheetWithDiffHead&quot;);    ExcelWriter excelWriter = null;    try {        excelWriter = EasyExcelFactory.write(fileName)                .build();        final WriteSheet writeSheet0 = EasyExcelFactory.writerSheet(0, &quot;模板1&quot;)                .head(Item.class)                .build();        excelWriter.write(sampleItems(), writeSheet0);        final WriteSheet writeSheet1 = EasyExcelFactory.writerSheet(1, &quot;模板2&quot;)                .head(ComplexHeadItem.class)                .build();        excelWriter.write(sampleItems(), writeSheet1);    } finally {        // 千万别忘记finish 会帮忙关闭流        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004070229.png" alt="向同一个excel不同sheet中多次写入（表头不同）"></p><p><img src="https://static.howardliu.cn/20211004070246.png" alt="向同一个excel不同sheet中多次写入（表头不同）"></p><h2 id="实现多表"><a href="#实现多表" class="headerlink" title="实现多表"></a>实现多表</h2><p>EasyExcel对于Excel文件定义分成了三层，</p><ol><li>工作簿，也就是Excel文件</li><li>工作表，对应是Excel文件中的Sheet</li><li>表格，对应是Sheet中的有表头、表体的组合</li></ol><p>这里所说的功能就是在一个Sheet中创建多个表格。</p><h3 id="同一表单中创建表格"><a href="#同一表单中创建表格" class="headerlink" title="同一表单中创建表格"></a>同一表单中创建表格</h3><p>这个是开胃菜，演示一下怎么单独指定表格。</p><pre><code class="java">private static void writeTable() {    String fileName = defaultFileName(&quot;writeTable&quot;);    final ExcelWriter excelWriter = EasyExcelFactory.write(fileName)            .head(Item.class)            .build();    try {        // 把sheet设置为不需要头 不然会输出sheet的头 这样看起来第一个table 就有2个头了        WriteSheet writeSheet = EasyExcelFactory.writerSheet()                .needHead(Boolean.FALSE)                .build();        // 这里必须指定需要头，table 会继承sheet的配置，sheet配置了不需要，table 默认也是不需要        WriteTable writeTable0 = EasyExcelFactory.writerTable(0)                .needHead(Boolean.TRUE)                .build();        excelWriter.write(sampleItems(), writeSheet, writeTable0);    } finally {        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>可以看到，除了前面提过的<code>ExcelWriter</code>和<code>WriteSheet</code>，这里还用到了<code>WriteTable</code>，这个就是表格的写对象。有了这个对象，我们只要多创建几个，就能够实现在一个Sheet工作表中，创建多个表格的功能。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004070309.png" alt="同一表单中创建表格"></p><p>与前面的例子完全没有差别，条条大路通罗马。</p><h3 id="同一表单中创建不同表格（相同表头）"><a href="#同一表单中创建不同表格（相同表头）" class="headerlink" title="同一表单中创建不同表格（相同表头）"></a>同一表单中创建不同表格（相同表头）</h3><p>有了上面的铺垫，我们直接上代码：</p><pre><code class="java">private static void writeTables() {    String fileName = defaultFileName(&quot;writeTables&quot;);    final ExcelWriter excelWriter = EasyExcelFactory.write(fileName)            .build();    try {        // 把sheet设置为不需要头 不然会输出sheet的头 这样看起来第一个table 就有2个头了        WriteSheet writeSheet = EasyExcelFactory.writerSheet()                .head(Item.class)                .needHead(Boolean.FALSE)                .build();        // 这里必须指定需要头，table 会继承sheet的配置，sheet配置了不需要，table 默认也是不需要        WriteTable writeTable0 = EasyExcelFactory.writerTable(0)                .needHead(Boolean.TRUE)                .build();        WriteTable writeTable1 = EasyExcelFactory.writerTable(1)                .needHead(Boolean.TRUE)                .build();        // 第一次写入会创建头        excelWriter.write(sampleItems(), writeSheet, writeTable0);        // 第二次写如也会创建头，然后在第一次的后面写入数据        excelWriter.write(sampleItems(), writeSheet, writeTable1);    } finally {        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>因为使用的是相同的表头，我们可以直接在<code>WriteSheet</code>中定义表头对象，通过继承的方式，实现两个表格的表头是相同的。这里需要注意一下，<code>WriteSheet</code>构建时，设置<code>needHead(Boolean.FALSE)</code>，如果不设置或者设置为true，那第一个表格就会有两个表头。</p><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004070331.png" alt="同一表单中创建不同表格（相同表头）"></p><h3 id="同一表单中创建不同表格（不同表头）"><a href="#同一表单中创建不同表格（不同表头）" class="headerlink" title="同一表单中创建不同表格（不同表头）"></a>同一表单中创建不同表格（不同表头）</h3><p>举一反三，对于不同表头，我们只需要为<code>WriteTable</code>对象设置不同表头即可：</p><pre><code class="java">private static void writeTablesWithDiffHead() {    String fileName = defaultFileName(&quot;writeTablesWithDiffHead&quot;);    final ExcelWriter excelWriter = EasyExcelFactory.write(fileName)            .build();    try {        WriteSheet writeSheet = EasyExcelFactory.writerSheet()                .build();        WriteTable writeTable0 = EasyExcelFactory.writerTable(0)                .head(Item.class)                .build();        excelWriter.write(sampleItems(), writeSheet, writeTable0);        WriteTable writeTable1 = EasyExcelFactory.writerTable(1)                .head(ComplexHeadItem.class)                .build();        excelWriter.write(sampleItems(), writeSheet, writeTable1);    } finally {        if (excelWriter != null) {            excelWriter.finish();        }    }}</code></pre><p>结果为：</p><p><img src="https://static.howardliu.cn/20211004070353.png" alt="同一表单中创建不同表格（不同表头）"></p><h2 id="写入模板文件（非填充）"><a href="#写入模板文件（非填充）" class="headerlink" title="写入模板文件（非填充）"></a>写入模板文件（非填充）</h2><p>有时候，我们需要按照某种模板导出数据，这类模板文件属于固定样式，没有动态数据。比如前面几行是标题、权限声明、责任声明之类的，紧跟着就是列表数据。如果全靠手工拼写数据比较繁琐，EasyExcel提供了写入模板文件的方式。先看代码：</p><pre><code class="java">private static void writeByTemplate() {    String fileName = defaultFileName(&quot;writeByTemplate&quot;);    String templateFile = getPath() + File.separator + &quot;template_write_after_fill.xlsx&quot;;    EasyExcelFactory.write(fileName)            .withTemplate(templateFile)            .head(Item.class)            .sheet()            .doWrite(sampleItems());}</code></pre><p>需要使用<code>com.alibaba.excel.write.builder.ExcelWriterBuilder#withTemplate(java.lang.String)</code>指定模板文件路径。withTemplate方法有几个重载实现：</p><ol><li>指定模板文件路径<code>ExcelWriterBuilder#withTemplate(java.lang.String)</code></li><li>指定模板文件对象<code>ExcelWriterBuilder#withTemplate(java.io.File)</code></li><li>指定模板文件输入流<code>ExcelWriterBuilder#withTemplate(java.io.InputStream)</code></li></ol><p>指定模板文件和模板文件对象都是操作文件的，需要有文件信息。</p><p>指定模板文件输入流是只要文件流，这个可操作性空间就比较大了。比如，模板文件是可变的，我们可以基于一个带变量的模板文件，使用填充写入的方式初始化模板文件，然后再用模板写入的方式，写入列表。（这个会在技巧篇中详细说明）</p><p>代码中的模板文件内容：</p><p><img src="https://static.howardliu.cn/20211004070420.png" alt="写入模板文件（非填充）"></p><p>导出文件的内容：</p><p><img src="https://static.howardliu.cn/20211004070440.png" alt="写入模板文件（非填充）"></p><p>可以看出，这种方式写入的列表是以追加的方式写入，原有的模板内容不会修改，会从第一行空白行开始写列表信息。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文从实战角度说了一下 EasyExcel 如果实现写表格，接下来会讲解一下如何更好看的写。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/effective-java-easyexcel-action-write/">阿里开源的这个库，让 Excel 导出不再复杂（简简单单的写）</a></li><li><a href="https://www.howardliu.cn/effective-java-easyexcel-action-write-pretty/">阿里开源的这个库，让 Excel 导出不再复杂（既要能写，还要写的好看）</a></li><li><a href="https://www.howardliu.cn/effective-java-easyexcel-action-fill/">阿里开源的这个库，让Excel导出不再复杂（填充模板的使用指南）</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/effective-java-easyexcel-action-write/">阿里开源的这个库，让 Excel 导出不再复杂（简简单单的写）</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/120600688" target="_blank" rel="noopener">阿里开源的这个库，让 Excel 导出不再复杂（简简单单的写）</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      今天要说的EasyExcel阿里巴巴开源的Excel导出类库，是对POI的封装，实现了很多高级功能，并且留出扩展口，支持扩展定制化功能。打个比喻，POI相当于乐高积木，一个个的小积木可以自由组装，只能动手能力强，就可以随心所欲的组装。EasyExcel更像是把这些小积木提前组装好，想要搭建房子，就直接找组装好的屋顶、围墙就行。如果仅仅如此，那EasyExcel仅仅就是简单的工具包，其更加吸引人的地方是对于内存的控制，它通过压缩文件、分批读取、抛弃不重要数据、文件缓存等多种方式，降低内存消耗。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Effective Java" scheme="https://www.howardliu.cn/tags/Effective-Java/"/>
    
      <category term="EasyExcel" scheme="https://www.howardliu.cn/tags/EasyExcel/"/>
    
  </entry>
  
</feed>
