<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沉潜飞动</title>
  
  <subtitle>君子藏器于身，待时而动。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.howardliu.cn/"/>
  <updated>2021-09-11T14:30:27.000Z</updated>
  <id>https://www.howardliu.cn/</id>
  
  <author>
    <name>Howard Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</title>
    <link href="https://www.howardliu.cn/springboot-action-junit5-mockmvc-mockito/"/>
    <id>https://www.howardliu.cn/springboot-action-junit5-mockmvc-mockito/</id>
    <published>2021-09-11T14:30:27.000Z</published>
    <updated>2021-09-11T14:30:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/coffee-beans-6603499_1920.jpg" alt="SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/nickype-10327513/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6603499" target="_blank" rel="noopener">NickyPe</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6603499" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>今天聊聊如何在 SpringBoot 中集成 Junit5、MockMvc、Mocktio。Junit5 是在 Java 栈中应用最广的测试框架，Junit4 一度霸榜。</p><a id="more"></a><p>升级到 Junit5 之后，除了增加 Java8 的很多特性，做了很多功能增强，在结构上做了优化调整，拆分了很多不同的模块，可以按需引入，比如：</p><ul><li>JUnit Platform - 在 JVM 上启动测试框架</li><li>JUnit Jupiter - 在 JUnit5 中编写测试和扩展</li><li>JUnit Vintage - 提供运行基于 JUnit3 和 JUnit4 的测试引擎</li></ul><p>从 SpringBoot 2.2.0 之后，Junit5 已经成为了默认的 Junit 版本。有了 JUnit Vintage，从 Junit4 迁移到 Junit5 的成本极低。所以本文就直接针对 Junit5 开始了。</p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>先说版本，是为了避免因为版本差异出现各种奇怪的问题：</p><ul><li>JDK：jdk8（小版本可以忽略）</li><li>SpringBoot：2.5.2<ul><li>继承<code>spring-boot-starter-parent</code></li><li>依赖<code>spring-boot-starter-web</code></li><li>依赖<code>spring-boot-starter-test</code></li></ul></li><li>JUnit：5.7.2</li><li>Mockito：3.9.0</li><li>hamcrest：2.2</li></ul><p>SpringBoot 的好处在于，只要继承<code>spring-boot-starter-parent</code>或引入<code>spring-boot-pom-dependencies</code>，然后添加<code>spring-boot-starter-test</code>依赖即可。定义的 POM 内容如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.5.2&lt;/version&gt;    &lt;/parent&gt;    &lt;groupId&gt;cn.howardliu.effective.spring&lt;/groupId&gt;    &lt;artifactId&gt;springboot-junit5-mockito&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;springboot-junit5-mockio&lt;/name&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>因为继承了<code>spring-boot-starter-parent</code>，所以我们依赖的<code>spring-boot-starter-test</code>不需要写具体的版本，可以直接集成父级的版本定义。其中，<code>spring-boot-starter-web</code>是用于提供 REST API 的 web 容器，<code>spring-boot-starter-test</code>可以提供各种测试框架的，<code>spring-boot-maven-plugin</code>是将 SpringBoot 应用打包为可执行 jar 的插件。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>因为是 DEMO 示例，我们实现一个 Echo 接口，能够接收请求参数，并返回加工后的字符串。按照惯例，我们使用万能的<code>Hello, World!</code>。</p><p>我们的项目结构如下：</p><pre><code class="txt">├── pom.xml└── src    ├── main    │   ├── java    │   │   └── cn    │   │       └── howardliu    │   │           └── effective    │   │               └── spring    │   │                   └── springbootjunit5mockio    │   │                       ├── SpringbootJunit5MockioApplication.java    │   │                       ├── controller    │   │                       │   └── EchoController.java    │   │                       └── service    │   │                           ├── EchoService.java    │   │                           └── impl    │   │                               └── EchoServiceImpl.java    │   └── resources    │       └── application.yaml    └── test        └── java            └── cn                └── howardliu                    └── effective                        └── spring                            └── springbootjunit5mockio                                └── controller                                    ├── EchoControllerMockTest.java                                    └── EchoControllerNoMockitoTest.java</code></pre><ul><li>SpringbootJunit5MockioApplication：SpringBoot 应用启动入口</li><li>EchoController：接口定义</li><li>EchoService：实现业务逻辑接口</li><li>EchoServiceImpl：接口实现</li><li>EchoControllerMockTest：使用 Mock 代理 EchoService 实现</li><li>EchoControllerNoMockitoTest：直接测试接口实现</li></ul><h3 id="EchoServiceImpl"><a href="#EchoServiceImpl" class="headerlink" title="EchoServiceImpl"></a>EchoServiceImpl</h3><p>我们看下<code>EchoService</code>的实现，这将是我们 DEMO 的核心实现：</p><pre><code class="java">@Servicepublic class EchoServiceImpl implements EchoService {    @Override    public String echo(String foo) {        return &quot;Hello, &quot; + foo;    }}</code></pre><h3 id="EchoControllerNoMockitoTest"><a href="#EchoControllerNoMockitoTest" class="headerlink" title="EchoControllerNoMockitoTest"></a>EchoControllerNoMockitoTest</h3><p>我们先使用 Junit5+MockMvc 实现 Controller 接口的普通调用，代码如下：</p><pre><code class="java">@SpringBootTest(classes = SpringbootJunit5MockioApplication.class)@AutoConfigureMockMvcclass EchoControllerNoMockitoTest {    @Autowired    private MockMvc mockMvc;    @Test    void echo() throws Exception {        final String result = mockMvc.perform(                MockMvcRequestBuilders.get(&quot;/echo/&quot;)                        .param(&quot;name&quot;, &quot;看山&quot;)        )                .andExpect(MockMvcResultMatchers.status().isOk())                .andDo(MockMvcResultHandlers.print())                .andReturn()                .getResponse()                .getContentAsString(StandardCharsets.UTF_8);        Assertions.assertEquals(&quot;Hello, 看山&quot;, result);    }}</code></pre><p>我们通过<code>SpringBootTest</code>注解定义这是一个 SpringBoot 应用的测试用例，然后通过<code>AutoConfigureMockMvc</code>启动测试容器。这样，就可以直接注入<code>MockMvc</code>实例测试 Controller 接口。</p><p>这里需要注意一点，网上很多教程会让写<code>@ExtendWith({SpringExtension.class})</code>这样一个注解，其实完全没有必要。通过源码我们可以知道，<code>SpringBootTest</code>注解已经添加了<code>ExtendWith</code>。</p><h3 id="EchoControllerMockTest"><a href="#EchoControllerMockTest" class="headerlink" title="EchoControllerMockTest"></a>EchoControllerMockTest</h3><p>这个测试用例中，我们通过 Mockito 组件代理<code>EchoService</code>的<code>echo</code>方法，代码如下：</p><pre><code class="java">@SpringBootTest(classes = SpringbootJunit5MockioApplication.class)@ExtendWith(MockitoExtension.class)@AutoConfigureMockMvcclass EchoControllerMockTest {    @Autowired    private MockMvc mockMvc;    @MockBean    private EchoService echoService;    @BeforeEach    void setUp() {        Mockito.when(echoService.echo(Mockito.any()))                .thenReturn(&quot;看山说：&quot; + System.currentTimeMillis());    }    @Test    void echo() throws Exception {        final String result = mockMvc.perform(                MockMvcRequestBuilders.get(&quot;/echo/&quot;)                        .param(&quot;name&quot;, &quot;看山的小屋&quot;)        )                .andExpect(MockMvcResultMatchers.status().isOk())                .andDo(MockMvcResultHandlers.print())                .andReturn()                .getResponse()                .getContentAsString(StandardCharsets.UTF_8);        Assertions.assertTrue(result.startsWith(&quot;看山&quot;));    }}</code></pre><p>在这个示例中，我们需要注意<code>@ExtendWith(MockitoExtension.class)</code>注解，这个注解是用于引入<code>MockBean</code>的，我们通过对<code>echo</code>方法的拦截，使其返回我们定义好的响应结果。这种方式是为了在多系统或者多功能测试时，不需要真正调用接口。</p><p>比如，我们需要获取用户手机号，通常在接口中会校验用户有没有登录，我们就可以使用 Mockito 的能力代理登录验证，使结果永远是 true。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>至此，我们完成了 SpringBoot 集成 Junit5、MockMvc、Mockito 的示例。想要获取源码，只需要关注公众号「看山的小屋」，回复<code>spring</code>即可。</p><p>很多同学感觉单元测试没有编写的必要，直接使用 Swagger 或者 Postman 之类的工具就能很好的测试接口。确实如此，对于简单的 CRUD 接口，写单元测试的必要性不太高。但是，如果是复杂接口呢？接口参数有很多的组合，响应结果也需要各种验证，如果使用一次性的工具，每次测试组合参数就已经让人崩溃了，而且组合参数不能存留甚至不能在多人间传承，就会浪费很多的人力。</p><p>此时，单元测试的效果就会显现。我们只需要编写一次参数组合，放在 csv 之类的文件中，通过单元测试的参数化测试方式，即可多次运行，验证接口的正确性。</p><p>或者，当我们感觉系统已经臭味弥漫，对其重构之后，为了验证接口功能不变，也可以直接使用原来的测试用例加以验证。</p><p>综上，虽然测试用例编写麻烦，但是妙用无穷。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response/">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response-exception/">SpringBoot 实战：如何优雅的处理异常</a></li><li><a href="https://www.howardliu.cn/spring-beanpostprocessor/">SpringBoot 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://www.howardliu.cn/spring-request-recorder/">SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li><li><a href="https://www.howardliu.cn/spring-enum-params/">SpringBoot 实战：优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-enum-params-principle/">SpringBoot 实战：优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody-principle/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-junit5-mockmvc-mockito/">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/springboot-action-junit5-mockmvc-mockito/">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/120244720" target="_blank" rel="noopener">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://static.howardliu.cn/coffee-beans-6603499_1920.jpg&quot; alt=&quot;SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该图片由&lt;a href=&quot;https://pixabay.com/zh/users/nickype-10327513/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=6603499&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NickyPe&lt;/a&gt;在&lt;a href=&quot;https://pixabay.com/zh/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=6603499&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pixabay&lt;/a&gt;上发布&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你好，我是看山。&lt;/p&gt;
&lt;p&gt;今天聊聊如何在 SpringBoot 中集成 Junit5、MockMvc、Mocktio。Junit5 是在 Java 栈中应用最广的测试框架，Junit4 一度霸榜。&lt;/p&gt;
    
    </summary>
    
    
      <category term="springboot" scheme="https://www.howardliu.cn/categories/springboot/"/>
    
    
      <category term="实战" scheme="https://www.howardliu.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
      <category term="SpringBoot" scheme="https://www.howardliu.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</title>
    <link href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody-principle/"/>
    <id>https://www.howardliu.cn/springboot-action-enum-params-in-requestbody-principle/</id>
    <published>2021-08-28T08:39:56.000Z</published>
    <updated>2021-08-28T08:39:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/lesser-sand-plover-6535531_1920.jpg" alt="SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/johnnys_pic-21062476/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6535531" target="_blank" rel="noopener">Johnnys_pic</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6535531" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>在<a href="https://www.howardliu.cn/springboot-enum-params-principle/">优雅的使用枚举参数（原理篇）</a>中我们聊过，Spring对于不同的参数形式，会采用不同的处理类处理参数，这种形式，有些类似于策略模式。将针对不同参数形式的处理逻辑，拆分到不同处理类中，减少耦合和各种if-else逻辑。本文就来扒一扒，RequestBody参数中使用枚举参数的原理。</p><a id="more"></a><h2 id="找入口"><a href="#找入口" class="headerlink" title="找入口"></a>找入口</h2><p>对 Spring 有一定基础的同学一定知道，请求入口是<code>DispatcherServlet</code>，所有的请求最终都会落到<code>doDispatch</code>方法中的<code>ha.handle(processedRequest, response, mappedHandler.getHandler())</code>逻辑。我们从这里出发，一层一层向里扒。</p><p>跟着代码深入，我们会找到<code>org.springframework.web.method.support.InvocableHandlerMethod#invokeForRequest</code>的逻辑：</p><pre><code class="java">public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,        Object... providedArgs) throws Exception {    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);    if (logger.isTraceEnabled()) {        logger.trace(&quot;Arguments: &quot; + Arrays.toString(args));    }    return doInvoke(args);}</code></pre><p>可以看出，这里面通过<code>getMethodArgumentValues</code>方法处理参数，然后调用<code>doInvoke</code>方法获取返回值。<code>getMethodArgumentValues</code>方法内部又是通过<code>HandlerMethodArgumentResolverComposite</code>实例处理参数。这个类内部是一个<code>HandlerMethodArgumentResolver</code>实例列表，列表中是Spring处理参数逻辑的集合，跟随代码Debug，可以看到有27个元素。这些类也是可以定制扩展，实现自己的参数解析逻辑，这部分内容后续再做介绍。</p><h2 id="选择Resolver"><a href="#选择Resolver" class="headerlink" title="选择Resolver"></a>选择Resolver</h2><p>这个Resolver列表中，包含我们常用的几个处理类。Get请求的普通参数是通过<code>RequestParamMethodArgumentResolver</code>处理参数，包装类通过<code>ModelAttributeMethodProcessor</code>处理参数，RequestBody形式的参数，则是通过<code>RequestResponseBodyMethodProcessor</code>处理参数。这段就是Spring中策略模式的使用，通过实现<code>org.springframework.web.method.support.HandlerMethodArgumentResolver#supportsParameter</code>方法，判断输入参数是否可以解析。下面贴上<code>RequestResponseBodyMethodProcessor</code>的实现：</p><pre><code class="java">public boolean supportsParameter(MethodParameter parameter) {    return parameter.hasParameterAnnotation(RequestBody.class);}</code></pre><p>可以看到，<code>RequestResponseBodyMethodProcessor</code>是通过判断参数是否带有<code>RequestBody</code>注解来判断，当前参数是否可以解析。</p><h2 id="解析参数"><a href="#解析参数" class="headerlink" title="解析参数"></a>解析参数</h2><p><code>RequestResponseBodyMethodProcessor</code>继承自<code>AbstractMessageConverterMethodArgumentResolver</code>，真正解析<code>RequestBody</code>参数的逻辑在<code>org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#readWithMessageConverters</code>方法中。我们看下源码（因为源码比较长，文中仅留下核心逻辑。）：</p><pre><code class="java">protected &lt;T&gt; Object readWithMessageConverters(HttpInputMessage inputMessage, MethodParameter parameter,        Type targetType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException {    MediaType contentType = inputMessage.getHeaders().getContentType();// 1    Class&lt;?&gt; contextClass = parameter.getContainingClass();// 2    Class&lt;T&gt; targetClass = (targetType instanceof Class ? (Class&lt;T&gt;) targetType : null);// 3    Object body = NO_VALUE;    EmptyBodyCheckingHttpInputMessage message = new EmptyBodyCheckingHttpInputMessage(inputMessage);// 4    for (HttpMessageConverter&lt;?&gt; converter : this.messageConverters) {// 5        Class&lt;HttpMessageConverter&lt;?&gt;&gt; converterType = (Class&lt;HttpMessageConverter&lt;?&gt;&gt;) converter.getClass();        GenericHttpMessageConverter&lt;?&gt; genericConverter =                (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter&lt;?&gt;) converter : null);        if (genericConverter != null ? genericConverter.canRead(targetType, contextClass, contentType) :                (targetClass != null &amp;&amp; converter.canRead(targetClass, contentType))) {            if (message.hasBody()) {                HttpInputMessage msgToUse =                        getAdvice().beforeBodyRead(message, parameter, targetType, converterType);                body = (genericConverter != null ? genericConverter.read(targetType, contextClass, msgToUse) :                        ((HttpMessageConverter&lt;T&gt;) converter).read(targetClass, msgToUse));// 6                body = getAdvice().afterBodyRead(body, msgToUse, parameter, targetType, converterType);            }            else {                body = getAdvice().handleEmptyBody(null, message, parameter, targetType, converterType);            }            break;        }    }    return body;}</code></pre><p>跟着代码说明一下各部分用途：</p><ol><li>获取请求content-type</li><li>获取参数容器类</li><li>获取目标参数类型</li><li>将请求参数转换为<code>EmptyBodyCheckingHttpInputMessage</code>类型</li><li>循环各种RequestBody参数解析器，这些解析器都是<code>HttpMessageConverter</code>接口的实现类。Spring对各种情况做了全量覆盖，总有一款适合的。文末给出<code>HttpMessageConverter</code>各个扩展类的类图。</li><li>for循环体中就是选择一款适合的，进行解析<ol><li>首先调用<code>canRead</code>方法判断是否可用</li><li>判断请求请求参数是否为空，为空则通过AOP的<code>advice</code>处理一下空请求体，然后返回</li><li>不为空，先通过AOP的<code>advice</code>做前置处理，然后调用<code>read</code>方法转换对象，在通过<code>advice</code>做后置处理</li></ol></li></ol><blockquote><p>Spring的AOP不在本文范围内，所以一笔带过。后续有专题说明。</p></blockquote><p>本例中，<code>HttpMessageConverter</code>使用的是<code>MappingJackson2HttpMessageConverter</code>，该类继承自<code>AbstractJackson2HttpMessageConverter</code>。看名称就知道，这个类是使用Jackson处理请求参数。其中<code>read</code>方法之后，会调用内部私有方法<code>readJavaType</code>，下面给出该方法的核心逻辑：</p><pre><code class="java">private Object readJavaType(JavaType javaType, HttpInputMessage inputMessage) throws IOException {    MediaType contentType = inputMessage.getHeaders().getContentType();// 1    Charset charset = getCharset(contentType);    ObjectMapper objectMapper = selectObjectMapper(javaType.getRawClass(), contentType);// 2    Assert.state(objectMapper != null, &quot;No ObjectMapper for &quot; + javaType);    boolean isUnicode = ENCODINGS.containsKey(charset.name()) ||            &quot;UTF-16&quot;.equals(charset.name()) ||            &quot;UTF-32&quot;.equals(charset.name());// 3    try {        if (isUnicode) {            return objectMapper.readValue(inputMessage.getBody(), javaType);// 4        } else {            Reader reader = new InputStreamReader(inputMessage.getBody(), charset);            return objectMapper.readValue(reader, javaType);        }    }    catch (InvalidDefinitionException ex) {        throw new HttpMessageConversionException(&quot;Type definition error: &quot; + ex.getType(), ex);    }    catch (JsonProcessingException ex) {        throw new HttpMessageNotReadableException(&quot;JSON parse error: &quot; + ex.getOriginalMessage(), ex, inputMessage);    }}</code></pre><p>跟着代码说明一下各部分用途：</p><ol><li>获取请求的<code>content-type</code>，这个是Spring实现的扩展逻辑，根据不同的<code>content-type</code>可以选择不同的<code>ObjectMapper</code>实例。也就是第2步的逻辑</li><li>根据<code>content-type</code>和目标类型，选择<code>ObjectMapper</code>实例。本例中直接返回的是默认的，也就是通过<code>Jackson2ObjectMapperBuilder.cbor().build()</code>方法创建的。</li><li>检查请求是否是unicode字符，目前来说，大家用的都是<code>UTF-8</code>的</li><li>通过<code>ObjectMapper</code>将请求json转换为对象。其实这部分还有一段判断<code>inputMessage</code>是否是<code>MappingJacksonInputMessage</code>实例的，考虑到大家使用的版本，这部分就不说了。</li></ol><p>至此，Spring的逻辑全部结束，似乎还是没有找到我们使用的<code>JsonCreator</code>注解或者<code>JsonDeserialize</code>的逻辑。不过也能想到，这两个都是Jackson的类，那必然应该是Jackson的逻辑。接下来，就扒一扒Jackson的转换逻辑了。</p><h2 id="深入Jackson的ObjectMapper逻辑"><a href="#深入Jackson的ObjectMapper逻辑" class="headerlink" title="深入Jackson的ObjectMapper逻辑"></a>深入Jackson的ObjectMapper逻辑</h2><p>牵扯Jackson的逻辑主要分布在<code>AbstractMessageConverterMethodArgumentResolver#readWithMessageConverters</code>和<code>ObjectMapper#readValue</code>这两个方法中。先说一下<code>ObjectMapper#readValue</code>方法的逻辑，这里面会调用<code>GenderIdCodeEnum#create</code>方法，完成类型转换。</p><p><code>ObjectMapper#readValue</code>方法直接调用了当前类中的<code>_readMapAndClose</code>方法，这个方法里面比较关键的是<code>ctxt.readRootValue(p, valueType, _findRootDeserializer(ctxt, valueType), null)</code>，这个方法就是将输入json转换为对象。咱们再继续深入，可以找到Jackson内部是通过<code>BeanDeserializer</code>这个类转换对象的，比较重要的是<code>deserializeFromObject</code>方法，源码如下（删除一下不太重要的代码）：</p><pre><code class="java">public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException{    // 这里根据上下文中目标类型，创建实例对象，其中 _valueInstantiator 是 StdValueInstantiator 实例。    final Object bean = _valueInstantiator.createUsingDefault(ctxt);    // [databind#631]: Assign current value, to be accessible by custom deserializers    p.setCurrentValue(bean);    if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {        String propName = p.currentName();        do {            p.nextToken();            // 根据字段名找到 属性对象，对于gender字段，类型是 MethodProperty。            SettableBeanProperty prop = _beanProperties.find(propName);            if (prop != null) { // normal case                try {                    // 开始进行解码操作，并将解码结果写入到对象中                    prop.deserializeAndSet(p, ctxt, bean);                } catch (Exception e) {                    wrapAndThrow(e, bean, propName, ctxt);                }                continue;            }            handleUnknownVanilla(p, ctxt, bean, propName);        } while ((propName = p.nextFieldName()) != null);    }    return bean;}</code></pre><p>咱们看一下<code>MethodProperty#deserializeAndSet</code>的逻辑（只保留关键代码）：</p><pre><code class="java">public void deserializeAndSet(JsonParser p, DeserializationContext ctxt,        Object instance) throws IOException{    Object value;    // 调用 FactoryBasedEnumDeserializer 实例的解码方法    value = _valueDeserializer.deserialize(p, ctxt);    // 通过反射将值写入对象中    _setter.invoke(instance, value);}</code></pre><p>其中<code>_valueDeserializer</code>是<code>FactoryBasedEnumDeserializer</code>实例，快要接近目标了，看下这段逻辑：</p><pre><code class="java">public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException{    // 获取json中的值    Object value = _deser.deserialize(p, ctxt);    // 调用 GenderIdCodeEnum#create 方法    return _factory.callOnWith(_valueClass, value);}</code></pre><p><code>_factory</code>是<code>AnnotatedMethod</code>实例，主要是对<code>JsonCreator</code>注解定义的方法的包装，然后<code>callOnWith</code>中调用<code>java.lang.reflect.Method#invoke</code>反射方法，执行<code>GenderIdCodeEnum#create</code>。</p><p>至此，我们终于串起来所有逻辑。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文通过一个示例串起来<code>@JsonCreator</code>注解起作用的逻辑，<code>JsonDeserializer</code>接口的逻辑与之类型，可以耐心debug一番。下面给出主要类的类图：</p><p><img src="https://static.howardliu.cn/RequestResponseBodyMethodProcessor.png" alt="SpringBoot参数解析类图"></p><p><img src="https://static.howardliu.cn/HttpMessageConverter.png" alt="HttpMessageConverter"></p><p><img src="https://static.howardliu.cn/ObjectMapper.png" alt="ObjectMapper"></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response/">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response-exception/">SpringBoot 实战：如何优雅的处理异常</a></li><li><a href="https://www.howardliu.cn/spring-beanpostprocessor/">SpringBoot 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://www.howardliu.cn/spring-request-recorder/">SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li><li><a href="https://www.howardliu.cn/spring-enum-params/">SpringBoot 实战：优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-enum-params-principle/">SpringBoot 实战：优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody-principle/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-junit5-mockmvc-mockito/">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody-principle/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/120052842" target="_blank" rel="noopener">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://static.howardliu.cn/lesser-sand-plover-6535531_1920.jpg&quot; alt=&quot;SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该图片由&lt;a href=&quot;https://pixabay.com/zh/users/johnnys_pic-21062476/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=6535531&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Johnnys_pic&lt;/a&gt;在&lt;a href=&quot;https://pixabay.com/zh/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=6535531&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pixabay&lt;/a&gt;上发布&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你好，我是看山。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.howardliu.cn/springboot-enum-params-principle/&quot;&gt;优雅的使用枚举参数（原理篇）&lt;/a&gt;中我们聊过，Spring对于不同的参数形式，会采用不同的处理类处理参数，这种形式，有些类似于策略模式。将针对不同参数形式的处理逻辑，拆分到不同处理类中，减少耦合和各种if-else逻辑。本文就来扒一扒，RequestBody参数中使用枚举参数的原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/categories/spring/"/>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/tags/spring/"/>
    
      <category term="enum" scheme="https://www.howardliu.cn/tags/enum/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</title>
    <link href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody/"/>
    <id>https://www.howardliu.cn/springboot-action-enum-params-in-requestbody/</id>
    <published>2021-08-22T07:45:44.000Z</published>
    <updated>2021-08-22T07:45:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/macroperspective-6558526_1920.jpg" alt="SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/christian_crowd-22911196/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6558526" target="_blank" rel="noopener">Christian_Crowd</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6558526" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>前文说到 <a href="https://www.howardliu.cn/spring-enum-params/">优雅的使用枚举参数</a> 和 <a href="https://www.howardliu.cn/springboot-enum-params-principle/">实现原理</a>，本文继续说一下如何在 RequestBody 中优雅使用枚举。</p><p>本文先上实战，说一下如何实现。在 <a href="https://www.howardliu.cn/spring-enum-params/">优雅的使用枚举参数</a> 代码的基础上，我们继续实现。如果想要获取源码，可以关注公号「看山的小屋」，回复 spring 即可。</p><a id="more"></a><h2 id="确认需求"><a href="#确认需求" class="headerlink" title="确认需求"></a>确认需求</h2><p>需求与前文类似，只不过这里需要是在 RequestBody 中使用。与前文不同的是，这种请求是通过 Http Body 的方式传输到后端，通常是 json 或 xml 格式，Spring 默认借助 Jackson 反序列化为对象。</p><p>同样的，我们需要在枚举中定义 int 类型的 id、String 类型的 code，id 取值不限于序号（即从 0 开始的 orinal 数据），code 不限于 name。客户端请求过程中，可以传 id，可以传 code，也可以传 name。服务端只需要在对象中定义一个枚举参数，不需要额外的转换，即可得到枚举值。</p><p>好了，接下来我们定义一下枚举对象。</p><h2 id="定义枚举和对象"><a href="#定义枚举和对象" class="headerlink" title="定义枚举和对象"></a>定义枚举和对象</h2><p>先定义我们的枚举类<code>GenderIdCodeEnum</code>，包含 id 和 code 两个属性：</p><pre><code class="java">public enum GenderIdCodeEnum implements IdCodeBaseEnum {    MALE(1, &quot;male&quot;),    FEMALE(2, &quot;female&quot;);    private final Integer id;    private final String code;    GenderIdCodeEnum(Integer id, String code) {        this.id = id;        this.code = code;    }    @Override    public String getCode() {        return code;    }    @Override    public Integer getId() {        return id;    }}</code></pre><p>这个枚举类的要求与前文一致，不清楚的可以再去看一下。</p><p>在定义一个包装类<code>GenderIdCodeRequestBody</code>，用于接收 json 数据的请求体：</p><pre><code class="java">@Datapublic class GenderIdCodeRequestBody {    private String name;    private GenderIdCodeEnum gender;    private long timestamp;}</code></pre><p>除了<code>GenderIdCodeEnum</code>参数外，其他都是示例，所以随便定义一下。</p><h2 id="实现转换逻辑"><a href="#实现转换逻辑" class="headerlink" title="实现转换逻辑"></a>实现转换逻辑</h2><p>前奏铺垫好，接下来入正题了。Jackson 提供了两种方案：</p><ul><li>方案一：精准攻击，指定需要转换的字段，不影响其他类对象中的字段</li><li>方案二：全范围攻击，所有借助 Jackson 反序列化的枚举字段，全部具备自动转换功能</li></ul><h3 id="方案一：精准攻击"><a href="#方案一：精准攻击" class="headerlink" title="方案一：精准攻击"></a>方案一：精准攻击</h3><p>这种方案中，我们首先需要实现<code>JsonDeserialize</code>抽象类：</p><pre><code class="java">public class IdCodeToEnumDeserializer extends JsonDeserializer&lt;BaseEnum&gt; {    @Override    public BaseEnum deserialize(JsonParser jsonParser, DeserializationContext deserializationContext)            throws IOException {        final String param = jsonParser.getText();// 1        final JsonStreamContext parsingContext = jsonParser.getParsingContext();// 2        final String currentName = parsingContext.getCurrentName();// 3        final Object currentValue = parsingContext.getCurrentValue();// 4        try {            final Field declaredField = currentValue.getClass().getDeclaredField(currentName);// 5            final Class&lt;?&gt; targetType = declaredField.getType();// 6            final Method createMethod = targetType.getDeclaredMethod(&quot;create&quot;, Object.class);// 7            return (BaseEnum) createMethod.invoke(null, param);// 8        } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException | NoSuchFieldException e) {            throw new CodeBaseException(ErrorResponseEnum.PARAMS_ENUM_NOT_MATCH, new Object[] {param}, &quot;&quot;, e);        }    }}</code></pre><p>然后在指定枚举字段上定义<code>@JsonDeserialize</code>注解，比如：</p><pre><code class="java">@JsonDeserialize(using = IdCodeToEnumDeserializer.class)private GenderIdCodeEnum gender;</code></pre><p>具体说一下每行的作用：</p><ol><li>获取参数值。根据需要，此处可能是 id、code 或 name，也就是源值，需要将其转换为枚举；</li><li>获取转换上线文，这个是为 3、4 步做准备的；</li><li>获取标记<code>@JsonDeserialize</code>注解的字段，此时<code>currentName</code>的值是<code>gender</code>；</li><li>获取包装对象，也就是<code>GenderIdCodeRequestBody</code>对象；</li><li>根据包装对象的<code>Class</code>对象，以及字段名<code>gender</code>获取<code>Field</code>对象，为第 5 步做准备；</li><li>获取<code>gender</code>字段对应的枚举类型，也即是<code>GenderIdCodeEnum</code>。之所以这样做，是要实现一个通用的反序列化类；</li><li>这里是写死的一种实现，就是在枚举类中，需要定义一个静态方法，方法名是<code>create</code>，请求参数是<code>Object</code>；</li><li>通过反射调用<code>create</code>方法，将第一步获取的请求参数传入。</li></ol><p>我们来看一下枚举类中定义的<code>create</code>方法：</p><pre><code class="java">public static GenderIdCodeEnum create(Object code) {    final String stringCode = code.toString();    final Integer intCode = BaseEnum.adapter(stringCode);    for (GenderIdCodeEnum item : values()) {        if (Objects.equals(stringCode, item.name())) {            return item;        }        if (Objects.equals(item.getCode(), stringCode)) {            return item;        }        if (Objects.equals(item.getId(), intCode)) {            return item;        }    }    return null;}</code></pre><p>为了性能考虑，我们可以提前定义三组 map，分别以 id、code、name 为 key，以枚举值为 value，这样就可以通过 O(1) 的时间复杂度返回了。可以参考前文的<code>Converter</code>类的实现逻辑。</p><p>这样，我们就可以实现精准转换了。</p><h3 id="方案二：全范围攻击"><a href="#方案二：全范围攻击" class="headerlink" title="方案二：全范围攻击"></a>方案二：全范围攻击</h3><p>这种方案是全范围攻击了，只要是 Jackson 参与的反序列化，只要其中有目标枚举参数，就会受到这种进入这种方案的逻辑中。这种方案是在枚举类中定义一个静态转换方法，通过<code>@JsonCreator</code>注解注释，Jackson 就会自动转换了。</p><p>这个方法的定义与方案一中的<code>create</code>方法完全一致，所以只需要在<code>create</code>方法上加上注解即可：</p><pre><code class="java">@JsonCreator(mode = Mode.DELEGATING)public static GenderIdCodeEnum create(Object code) {    final String stringCode = code.toString();    final Integer intCode = BaseEnum.adapter(stringCode);    for (GenderIdCodeEnum item : values()) {        if (Objects.equals(stringCode, item.name())) {            return item;        }        if (Objects.equals(item.getCode(), stringCode)) {            return item;        }        if (Objects.equals(item.getId(), intCode)) {            return item;        }    }    return null;}</code></pre><p>其中<code>Mode</code>类有四个值：<code>DEFAULT</code>、<code>DELEGATING</code>、<code>PROPERTIES</code>、<code>DISABLED</code>，这四种的差别会在原理篇中说明。还是那句话，对于应用类技术，我们可以先知其然，再知其所以然，也一定要知其所以然。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>先定义一个 controller 方法：</p><pre><code class="java">@PostMapping(&quot;gender-id-code-request-body&quot;)public GenderIdCodeRequestBody bodyGenderIdCode(@RequestBody GenderIdCodeRequestBody genderRequest) {    genderRequest.setTimestamp(System.currentTimeMillis());    return genderRequest;}</code></pre><p>然后定义测试用例，还是借助 JUnit5：</p><pre><code class="java">@ParameterizedTest@ValueSource(strings = {&quot;\&quot;MALE\&quot;&quot;, &quot;\&quot;male\&quot;&quot;, &quot;\&quot;1\&quot;&quot;, &quot;1&quot;})void postGenderIdCode(String gender) throws Exception {    final String result = mockMvc.perform(            MockMvcRequestBuilders.post(&quot;/echo/gender-id-code-request-body&quot;)                    .contentType(MediaType.APPLICATION_JSON_UTF8)                    .accept(MediaType.APPLICATION_JSON_UTF8)                    .content(&quot;{\&quot;gender\&quot;: &quot; + gender + &quot;, \&quot;name\&quot;: \&quot;看山\&quot;}&quot;)    )            .andExpect(MockMvcResultMatchers.status().isOk())            .andDo(MockMvcResultHandlers.print())            .andReturn()            .getResponse()            .getContentAsString();    ObjectMapper objectMapper = new ObjectMapper();    final GenderIdCodeRequestBody genderRequest = objectMapper.readValue(result, GenderIdCodeRequestBody.class);    Assertions.assertEquals(GenderIdCodeEnum.MALE, genderRequest.getGender());    Assertions.assertEquals(&quot;看山&quot;, genderRequest.getName());    Assertions.assertTrue(genderRequest.getTimestamp() &gt; 0);}</code></pre><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文主要说明了如何在 RequestBody 中优雅的使用枚举参数，借助了 Jackson 的反序列化扩展，可以定制类型转换逻辑。碍于文章篇幅，没有罗列大段代码。关注公号「看山的小屋」回复 spring 可以获取源码。关注我，下一篇我们进入原理篇。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response/">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response-exception/">SpringBoot 实战：如何优雅的处理异常</a></li><li><a href="https://www.howardliu.cn/spring-beanpostprocessor/">SpringBoot 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://www.howardliu.cn/spring-request-recorder/">SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li><li><a href="https://www.howardliu.cn/spring-enum-params/">SpringBoot 实战：优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-enum-params-principle/">SpringBoot 实战：优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody-principle/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-junit5-mockmvc-mockito/">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://static.howardliu.cn/macroperspective-6558526_1920.jpg&quot; alt=&quot;SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该图片由&lt;a href=&quot;https://pixabay.com/zh/users/christian_crowd-22911196/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=6558526&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Christian_Crowd&lt;/a&gt;在&lt;a href=&quot;https://pixabay.com/zh/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=6558526&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pixabay&lt;/a&gt;上发布&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你好，我是看山。&lt;/p&gt;
&lt;p&gt;前文说到 &lt;a href=&quot;https://www.howardliu.cn/spring-enum-params/&quot;&gt;优雅的使用枚举参数&lt;/a&gt; 和 &lt;a href=&quot;https://www.howardliu.cn/springboot-enum-params-principle/&quot;&gt;实现原理&lt;/a&gt;，本文继续说一下如何在 RequestBody 中优雅使用枚举。&lt;/p&gt;
&lt;p&gt;本文先上实战，说一下如何实现。在 &lt;a href=&quot;https://www.howardliu.cn/spring-enum-params/&quot;&gt;优雅的使用枚举参数&lt;/a&gt; 代码的基础上，我们继续实现。如果想要获取源码，可以关注公号「看山的小屋」，回复 spring 即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/categories/spring/"/>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/tags/spring/"/>
    
      <category term="enum" scheme="https://www.howardliu.cn/tags/enum/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实战：优雅的使用枚举参数（原理篇）</title>
    <link href="https://www.howardliu.cn/springboot-enum-params-principle/"/>
    <id>https://www.howardliu.cn/springboot-enum-params-principle/</id>
    <published>2021-08-13T13:30:21.000Z</published>
    <updated>2021-08-13T13:30:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/wheat-6536039_1920.jpg" alt="SpringBoot 实战：优雅的使用枚举参数（原理篇）"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/minka2507-3728206/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6536039" target="_blank" rel="noopener">minka2507</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6536039" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p><a href="https://howardliu.cn/spring-enum-params/" target="_blank" rel="noopener">SpringBoot 实战：优雅的使用枚举参数</a> 中聊了怎么优雅的使用枚举参数，本文就来扒一扒 Spring 是如何找到对应转换器 Converter 的。</p><a id="more"></a><h2 id="找入口"><a href="#找入口" class="headerlink" title="找入口"></a>找入口</h2><p>对 Spring 有一定基础的同学一定知道，请求入口是<code>DispatcherServlet</code>，所有的请求最终都会落到<code>doDispatch</code>方法中的<code>ha.handle(processedRequest, response, mappedHandler.getHandler())</code>逻辑。我们从这里出发，一层一层向里扒。</p><p>跟着代码深入，我们会找到<code>org.springframework.web.method.support.InvocableHandlerMethod#invokeForRequest</code>的逻辑：</p><pre><code class="java">public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,        Object... providedArgs) throws Exception {    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);    if (logger.isTraceEnabled()) {        logger.trace(&quot;Arguments: &quot; + Arrays.toString(args));    }    return doInvoke(args);}</code></pre><p>可以看出，这里面通过<code>getMethodArgumentValues</code>方法处理参数，然后调用<code>doInvoke</code>方法获取返回值。</p><p>继续深入，能够找到<code>org.springframework.web.method.annotation.RequestParamMethodArgumentResolver#resolveArgument</code>方法，这个方法就是解析参数的逻辑。</p><p>试想一下，如果是我们自己实现这段逻辑，会怎么做呢？</p><ol><li>获取输入参数</li><li>找到目标参数</li><li>检查是否需要特殊转换逻辑</li><li>如果需要，进行转换</li><li>如果不需要，直接返回</li></ol><p><img src="http://static.howardliu.cn/spring/spring-resolveArgument.jpg" alt="解析参数"></p><p>获取输入参数的逻辑在<code>org.springframework.web.method.annotation.RequestParamMethodArgumentResolver#resolveName</code>，单参数返回的是 String 类型，多参数返回 String 数组。核心代码如下：</p><pre><code class="java">String[] paramValues = request.getParameterValues(name);if (paramValues != null) {    arg = (paramValues.length == 1 ? paramValues[0] : paramValues);}</code></pre><p>所以说，无论我们的目标参数是什么，输入参数都是 String 类型或 String 数组，然后 Spring 把它们转换为我们期望的类型。</p><p>找到目标参数的逻辑在<code>DispatcherServlet</code>中，根据 uri 找到对应的 Controller 处理方法，找到方法就找到了目标参数类型。</p><p>接下来就是检查是否需要转换逻辑，也就是<code>org.springframework.validation.DataBinder#convertIfNecessary</code>，顾名思义，如果需要就转换，将字符串类型转换为目标类型。在我们的例子中，就是将 String 转换为枚举值。</p><h2 id="查找转换器"><a href="#查找转换器" class="headerlink" title="查找转换器"></a>查找转换器</h2><p>继续深扒，会在<code>org.springframework.beans.TypeConverterDelegate#convertIfNecessary</code>方法中找到这么一段逻辑：</p><pre><code class="java">if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {    try {        return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);    }    catch (ConversionFailedException ex) {        // fallback to default conversion logic below        conversionAttemptEx = ex;    }}</code></pre><p>这段逻辑中，调用了<code>org.springframework.core.convert.support.GenericConversionService#canConvert</code>方法，检查是否可转换，如果可以转换，将会执行类型转换逻辑。</p><p>检查是否可转换的本质就是检查是否能够找到对应的转换器。如果能找到，就用找到的转换器开始转换逻辑，如果找不到，那就是不能转换，走其他逻辑。</p><p>我们可以看看查找转换器的代码<code>org.springframework.core.convert.support.GenericConversionService#getConverter</code>，可以对我们自己写代码有一些启发：</p><pre><code class="java">private final Map&lt;ConverterCacheKey, GenericConverter&gt; converterCache = new ConcurrentReferenceHashMap&lt;&gt;(64);protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {    ConverterCacheKey key = new ConverterCacheKey(sourceType, targetType);    GenericConverter converter = this.converterCache.get(key);    if (converter != null) {        return (converter != NO_MATCH ? converter : null);    }    converter = this.converters.find(sourceType, targetType);    if (converter == null) {        converter = getDefaultConverter(sourceType, targetType);    }    if (converter != null) {        this.converterCache.put(key, converter);        return converter;    }    this.converterCache.put(key, NO_MATCH);    return null;}</code></pre><p>转换为伪代码就是：</p><ol><li>根据参数类型和目标类型，构造缓存 key</li><li>根据缓存 key，从缓存中查询转换器</li><li>如果能找到且不是 NO_MATCH，返回转换器；如果是 NO_MATCH，返回 null；如果未找到，继续</li><li>通过<code>org.springframework.core.convert.support.GenericConversionService.Converters#find</code>查询转换器</li><li>如果未找到，检查源类型和目标类型是否可以强转，也就是类型一致。如果是，返回 NoOpConverter，如果否，返回 null。</li><li>检查找到的转换器是否为 null，如果不是，将转换器加入到缓存中，返回该转换器</li><li>如果否，在缓存中添加 NO_MATCH 标识，返回 null</li></ol><p><img src="http://static.howardliu.cn/spring/spring-find-converter.jpg" alt="查找转换器"></p><p>Spring 内部使用<code>Map</code>作为缓存，用来存储通用转换器接口<code>GenericConverter</code>，这个接口会是我们自定义转换器的包装类。我们还可以看到，转换器缓存用的是<code>ConcurrentReferenceHashMap</code>，这个类是线程安全的，可以保证并发情况下，不会出现异常存储。但是<code>getConverter</code>方法没有使用同步逻辑。换句话说，并发请求时，可能存在性能损耗。不过，对于 web 请求场景，并发损耗好过阻塞等待。</p><p>我们在看下 Spring 是如何查找转换器的，在<code>org.springframework.core.convert.support.GenericConversionService.Converters#find</code>中就是找到对应转换器的核心逻辑：</p><pre><code class="java">private final Map&lt;ConvertiblePair, ConvertersForPair&gt; converters = new ConcurrentHashMap&lt;&gt;(256);@Nullablepublic GenericConverter find(TypeDescriptor sourceType, TypeDescriptor targetType) {    // Search the full type hierarchy    List&lt;Class&lt;?&gt;&gt; sourceCandidates = getClassHierarchy(sourceType.getType());    List&lt;Class&lt;?&gt;&gt; targetCandidates = getClassHierarchy(targetType.getType());    for (Class&lt;?&gt; sourceCandidate : sourceCandidates) {        for (Class&lt;?&gt; targetCandidate : targetCandidates) {            ConvertiblePair convertiblePair = new ConvertiblePair(sourceCandidate, targetCandidate);            GenericConverter converter = getRegisteredConverter(sourceType, targetType, convertiblePair);            if (converter != null) {                return converter;            }        }    }    return null;}@Nullableprivate GenericConverter getRegisteredConverter(TypeDescriptor sourceType,        TypeDescriptor targetType, ConvertiblePair convertiblePair) {    // Check specifically registered converters    ConvertersForPair convertersForPair = this.converters.get(convertiblePair);    if (convertersForPair != null) {        GenericConverter converter = convertersForPair.getConverter(sourceType, targetType);        if (converter != null) {            return converter;        }    }    // Check ConditionalConverters for a dynamic match    for (GenericConverter globalConverter : this.globalConverters) {        if (((ConditionalConverter) globalConverter).matches(sourceType, targetType)) {            return globalConverter;        }    }    return null;}</code></pre><p>我们可以看到，Spring 是通过源类型和目标类型组合起来，查找对应的转换器。而且，Spring 还通过<code>getClassHierarchy</code>方法，将源类型和目标类型的家族族谱全部列出来，用双层 for 循环遍历查找。</p><p>上面的代码中，还有一个<code>matches</code>方法，在这个方法里面，调用了<code>ConverterFactory#getConverter</code>方法，也就是用这个工厂方法，创建了指定类型的转换器。</p><pre><code class="java">private final ConverterFactory&lt;Object, Object&gt; converterFactory;public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {    boolean matches = true;    if (this.converterFactory instanceof ConditionalConverter) {        matches = ((ConditionalConverter) this.converterFactory).matches(sourceType, targetType);    }    if (matches) {        Converter&lt;?, ?&gt; converter = this.converterFactory.getConverter(targetType.getType());        if (converter instanceof ConditionalConverter) {            matches = ((ConditionalConverter) converter).matches(sourceType, targetType);        }    }    return matches;}</code></pre><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>经过上面的逻辑，已经找到判断可以进行转换。其核心逻辑就是已经找到对应的转换器了，下面就是转换逻辑，在<code>org.springframework.core.convert.support.GenericConversionService#convert</code>中：</p><pre><code class="java">public Object convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {    Assert.notNull(targetType, &quot;Target type to convert to cannot be null&quot;);    if (sourceType == null) {        Assert.isTrue(source == null, &quot;Source must be [null] if source type == [null]&quot;);        return handleResult(null, targetType, convertNullSource(null, targetType));    }    if (source != null &amp;&amp; !sourceType.getObjectType().isInstance(source)) {        throw new IllegalArgumentException(&quot;Source to convert from must be an instance of [&quot; +                sourceType + &quot;]; instead it was a [&quot; + source.getClass().getName() + &quot;]&quot;);    }    GenericConverter converter = getConverter(sourceType, targetType);    if (converter != null) {        Object result = ConversionUtils.invokeConverter(converter, source, sourceType, targetType);        return handleResult(sourceType, targetType, result);    }    return handleConverterNotFound(source, sourceType, targetType);}</code></pre><p>其中的<code>GenericConverter converter = getConverter(sourceType, targetType)</code>就是前文中<code>getConverter</code>方法。此处还是可以给我们编码上的一些借鉴的：<code>getConverter</code>方法在<code>canConvert</code>中调用了一次，然后在后续真正转换的时候又调用一次，这是参数转换逻辑，我们该怎么优化这种同一请求内多次调用相同逻辑或者请求相同参数呢？那就是使用缓存。为了保持一次请求中前后两次数据的一致性和请求的高效，推荐使用内存缓存。</p><p>执行到这里，直接调用<code>ConversionUtils.invokeConverter(converter, source, sourceType, targetType)</code>转换，其内部是使用<code>org.springframework.core.convert.support.GenericConversionService.ConverterFactoryAdapter#convert</code>方法，代码如下：</p><pre><code class="java">public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {    if (source == null) {        return convertNullSource(sourceType, targetType);    }    return this.converterFactory.getConverter(targetType.getObjectType()).convert(source);}</code></pre><p>这里就是调用<code>ConverterFactory</code>工厂类构建转换器（即<code>IdCodeToEnumConverterFactory</code>类的<code>getConverter</code>方法），然后调用转换器的<code>conver</code>方法（即<code>IdCodeToEnumConverter</code>类的<code>convert</code>方法），将输入参数转换为目标类型。具体实现可以看一下实战篇中的代码，这里不做赘述。</p><p>至此，我们把整个路程通了下来。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>在本文中，我们跟随源码找到自定义转换器工厂类和转换器类的实现逻辑。这里需要强调一下的是，由于实战篇中我们用到的例子是简单参数的方式，也就是<code>Controller</code>的方法参数都是直接参数，没有包装成对象。这样的话，Spring 是通过<code>RequestParamMethodArgumentResolver</code>处理参数。如果是包装成对象，会使用<code>ModelAttributeMethodProcessor</code>处理参数。这两个处理类中查找类型转换器逻辑都是相同的。</p><p>无论是<code>GET</code>请求，还是传参式的<code>POST</code>请求（即<code>Form</code>模式），都可以使用上面这种方式，实现枚举参数的类型转换。但是是 HTTP Body 方式却不行，为什么呢？</p><p>Spring 对于 body 参数是通过<code>RequestResponseBodyMethodProcessor</code>处理的，其内部使用了<code>MappingJackson2HttpMessageConverter</code>转换器，逻辑完全不同。所以，想要实现 body 的类型转换，还需要走另外一种方式。将在下一篇中给出。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response/">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response-exception/">SpringBoot 实战：如何优雅的处理异常</a></li><li><a href="https://www.howardliu.cn/spring-beanpostprocessor/">SpringBoot 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://www.howardliu.cn/spring-request-recorder/">SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li><li><a href="https://www.howardliu.cn/spring-enum-params/">SpringBoot 实战：优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-enum-params-principle/">SpringBoot 实战：优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody-principle/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-junit5-mockmvc-mockito/">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/springboot-enum-params-principle/">SpringBoot 实战：优雅的使用枚举参数（原理篇）</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/119725983" target="_blank" rel="noopener">SpringBoot 实战：优雅的使用枚举参数（原理篇）</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      SpringBoot 实战：优雅的使用枚举参数中聊了怎么优雅的使用枚举参数，本文就来扒一扒 Spring 是如何找到对应转换器 Converter 的。
    
    </summary>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/categories/spring/"/>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/tags/spring/"/>
    
      <category term="enum" scheme="https://www.howardliu.cn/tags/enum/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实战：优雅的使用枚举参数</title>
    <link href="https://www.howardliu.cn/spring-enum-params/"/>
    <id>https://www.howardliu.cn/spring-enum-params/</id>
    <published>2021-08-10T14:40:04.000Z</published>
    <updated>2021-08-10T14:40:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/scarlet-lily-beetle-6389888_1920.jpg" alt="SpringBoot 实战：优雅的使用枚举参数"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/sinousxl-7554155/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6389888" target="_blank" rel="noopener">Sinousxl</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6389888" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>接口开发过程中不免有表示类型的参数，比如 0 表示未知，1 表示男，2 表示女。通常有两种做法，一种是用数字表示，另一种是使用枚举实现。</p><a id="more"></a><p>使用数字表示就是通过契约形式，约定每个数字表示的含义，接口接收到参数，就按照约定对类型进行判断，接口维护成本比较大。</p><p>在 Spring 体系中，使用枚举表示，是借助 Spring 的 Converter 机制，可以将数字或字符串对应到枚举的序号或者 name，然后将前端的输入转换为枚举类型。</p><p>在场景不复杂的场景中，枚举可以轻松胜任。</p><p>于是，迅速实现逻辑，准备提测。这个时候需求变了，不允许选择未知性别，只能选男或女，就没有 0 值。这样，因为取值是从 1 开始，而枚举的序号是从 0 开始，就会产生冲突。</p><p>还有一些不太多的场景，就是前端不期望类型都是用数字，可能期望用一些有意义的字符串表示。但是按照前端规范，需要用小写或者驼峰命名。但是后端的规范中，枚举必须是大写，又是冲突。</p><p>需求合不合理暂且不论，我们要保存对技术的探索精神。</p><h2 id="确认需求"><a href="#确认需求" class="headerlink" title="确认需求"></a>确认需求</h2><p>首先确认需求。我们期望定义一个枚举类作为参数，接口访问的时候，可以是 int 类型的 id，id 取值不限于枚举的序号；也可以是 String 类型的 code，code 取值不限于枚举的 name。换句话说，这个枚举有个 id 和 code，随意定义，只要接口传过来匹配上，就能够自动转成枚举类型。</p><p>既然这样，我们就规范下 id 和 code 取值。为了扩展，定义三个接口：IdBaseEnum、CodeBaseEnum 以及 IdCodeBaseEnum。</p><pre><code class="java">public interface IdBaseEnum {    Integer getId();}public interface CodeBaseEnum {    String getCode();}public interface IdCodeBaseEnum extends IdBaseEnum, CodeBaseEnum {}</code></pre><p>接下来就该定义我们的主角了。</p><h2 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h2><p>前面定义了三个接口，分别是单独 id、单独 code，和有 id 和 code 的。这样，我们就可以定义三种枚举，分别对应三个接口。三种方式类似，所以就不在文中重复列举了。感兴趣的可以关注公众号「看山的小屋」回复 spring 获取源码。</p><p>我们定义一个性别枚举，枚举包含 id 和 code 两个属性。</p><pre><code class="java">public enum GenderIdCodeEnum implements IdCodeBaseEnum {    MALE(1, &quot;male&quot;),    FEMALE(2, &quot;female&quot;);    private final Integer id;    private final String code;    GenderIdCodeEnum(Integer id, String code) {        this.id = id;        this.code = code;    }    @Override    public String getCode() {        return code;    }    @Override    public Integer getId() {        return id;    }}</code></pre><p>这里需要注意一点，id 和 code 不能重复。</p><ol><li>id 与 id、code 与 code 不能重复，比如 MAIL 定义 id 是 1，FAMLE 就不能定义 id 是 1 了。</li><li>id 与 code 之间也不能重复，比如，MALE 定义 id 是 1001，FEMALE 定义 code 是 1001。</li></ol><p>这是由于 Spring 在转换参数的时候，将输入参数全部视为 String 类型。虽然我们定义 id 和 code 类型不同，但是在匹配的时候，都是按照字符串匹配的。如果存在相同值，就会产生歧义。</p><h2 id="Converter-和-ConverterFactory"><a href="#Converter-和-ConverterFactory" class="headerlink" title="Converter 和 ConverterFactory"></a>Converter 和 ConverterFactory</h2><p>根据规范，接下来定义一下 Converter 和 ConverterFactory。这些是 Spring 留给我们的扩展口，按照规范定义即可。</p><p>Converter 类：</p><pre><code class="java">public class IdCodeToEnumConverter&lt;T extends IdCodeBaseEnum&gt; implements Converter&lt;String, T&gt; {    private final Map&lt;String, T&gt; idEnumMap = Maps.newHashMap();    private final Map&lt;String, T&gt; codeEnumMap = Maps.newHashMap();    public IdCodeToEnumConverter(Class&lt;T&gt; enumType) {        Arrays.stream(enumType.getEnumConstants())                .forEach(x -&gt; {                    idEnumMap.put(x.getId().toString(), x);                    codeEnumMap.put(x.getCode(), x);                });    }    @Override    public T convert(String source) {        return Optional.of(source)                .map(codeEnumMap::get)                .orElseGet(() -&gt; Optional.of(source)                        .map(idEnumMap::get)                        .orElseThrow(() -&gt; new CodeBaseException(ErrorResponseEnum.PARAMS_ENUM_NOT_MATCH)));    }}</code></pre><p>ConverterFactory 类：</p><pre><code class="java">public class IdCodeToEnumConverterFactory implements ConverterFactory&lt;String, IdCodeBaseEnum&gt; {    @SuppressWarnings(&quot;rawtypes&quot;)    private static final Map&lt;Class, Converter&gt; CONVERTERS = Maps.newHashMap();    @Override    public &lt;T extends IdCodeBaseEnum&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) {        //noinspection unchecked        Converter&lt;String, T&gt; converter = CONVERTERS.get(targetType);        if (converter == null) {            converter = new IdCodeToEnumConverter&lt;&gt;(targetType);            CONVERTERS.put(targetType, converter);        }        return converter;    }}</code></pre><p>这两个就是转换的核心了，我们只要将他们装配到 Spring 的类型转换器中，就能够实现枚举类型的自动转化了。</p><h2 id="加载配置"><a href="#加载配置" class="headerlink" title="加载配置"></a>加载配置</h2><p>将我们定义的 Converter 和 ConverterFactory 注册到 Spring 的类型转换器中。</p><pre><code class="java">@Configurationpublic class WebConfig implements WebMvcConfigurer {    @Override    public void addFormatters(FormatterRegistry registry) {        registry.addConverterFactory(new IdCodeToEnumConverterFactory());        registry.addConverterFactory(new CodeToEnumConverterFactory());        registry.addConverterFactory(new IdToEnumConverterFactory());    }}</code></pre><p>至此，核心定义全部结束。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>写一个 Controller 作为测试入口：</p><pre><code class="java">@RestController@RequestMapping(&quot;echo&quot;)public class EchoController {    @GetMapping(&quot;gender-id-code&quot;)    public String genderIdCode(@RequestParam(&quot;gender&quot;) GenderIdCodeEnum gender) {        return gender.name();    }}</code></pre><p>准备测试用例测试：</p><pre><code class="java">@SpringBootTest(classes = SpringEnumParamApplication.class)@AutoConfigureMockMvcclass EchoControllerTest {    @Autowired    private MockMvc mockMvc;    @ParameterizedTest    @ValueSource(strings = {&quot;MALE&quot;, &quot;male&quot;, &quot;1&quot;})    void genderIdCode(String gender) throws Exception {        final String result = mockMvc.perform(                MockMvcRequestBuilders.get(&quot;/echo/gender-id-code&quot;)                        .param(&quot;gender&quot;, gender)        )                .andExpect(MockMvcResultMatchers.status().isOk())                .andDo(MockMvcResultHandlers.print())                .andReturn()                .getResponse()                .getContentAsString();        Assertions.assertEquals(&quot;MALE&quot;, result);    }}</code></pre><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>实现枚举参数并不难，只要按照 Spring 的扩展规范实现即可。需要注意的是，注意枚举类中唯一的 id 和 code。</p><p>本文是应用，下篇说一下原理。以及 http body 形式请求的枚举转换逻辑。</p><p>关注公众号「看山的小屋」回复 spring 获取源码。源码中完整定义了三种枚举形式。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response/">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response-exception/">SpringBoot 实战：如何优雅的处理异常</a></li><li><a href="https://www.howardliu.cn/spring-beanpostprocessor/">SpringBoot 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://www.howardliu.cn/spring-request-recorder/">SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li><li><a href="https://www.howardliu.cn/spring-enum-params/">SpringBoot 实战：优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-enum-params-principle/">SpringBoot 实战：优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody-principle/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-junit5-mockmvc-mockito/">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/spring-enum-params/">SpringBoot 实战：优雅的使用枚举参数</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/119581202" target="_blank" rel="noopener">SpringBoot 实战：优雅的使用枚举参数</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      接口开发过程中不免有表示类型的参数，比如 0 表示未知，1 表示男，2 表示女。通常有两种做法，一种是用数字表示，另一种是使用枚举实现。
    
    </summary>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/categories/spring/"/>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/tags/spring/"/>
    
      <category term="enum" scheme="https://www.howardliu.cn/tags/enum/"/>
    
  </entry>
  
  <entry>
    <title>看山聊 Java：检查日期字符串是否合法</title>
    <link href="https://www.howardliu.cn/java-date-string-valid-date/"/>
    <id>https://www.howardliu.cn/java-date-string-valid-date/</id>
    <published>2021-08-06T13:47:46.000Z</published>
    <updated>2021-08-06T13:47:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/berries-6514669_1920.jpg" alt="看山聊 Java：检查日期字符串是否合法"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/nastasyaday-11197808/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6514669" target="_blank" rel="noopener">Анастасия Белоусова</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6514669" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><a id="more"></a><p>这次说一下，怎样检查给出的字符串，是否是合法日期字符串。本文将从 Java 原生和第三方组件两种方式来说明。</p><h2 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h2><p>后端接口在接收数据的时候，都需要进行检查。检查全部通过后，才能够执行业务逻辑。对于时间格式，我们一般需要检查这么几方面：</p><ol><li>字符串格式是否正确，比如格式是不是<code>yyyy-MM-dd</code></li><li>时间在合法范围内，比如我们需要限定在一个月内的时间</li><li>字符串可以解析为正常的时间，比如 2 月 30 号就不是正常时间</li></ol><p>对于时间格式的判断，我们可以通过正则表达式来检查。不过考虑到正则表达式的性能、输入数据的复杂性，一般能用别的方式，就不选正则表达式。我们还是选择一种更加通用、更加高效的检查方式。</p><p>首先，定义时间校验器的接口：</p><pre><code class="java">public interface DateValidator {    boolean isValid(String dateStr);}</code></pre><p>接口方法接收一个字符串，返回布尔类型，表示字符串是否是合法的时间格式。</p><h2 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h2><p>接下来就是通过不同方式实现<code>DateValidator</code>。</p><h3 id="使用-DateFormat-检查"><a href="#使用-DateFormat-检查" class="headerlink" title="使用 DateFormat 检查"></a>使用 DateFormat 检查</h3><p>Java 提供了格式化和解析时间的工具：<code>DateFormat</code>抽象类和<code>SimpleDataFormat</code>实现类。我们借此实现时间校验器：</p><pre><code class="java">public class DateValidatorUsingDateFormat implements DateValidator {    private final String dateFormat;    public DateValidatorUsingDateFormat(String dateFormat) {        this.dateFormat = dateFormat;    }    @Override    public boolean isValid(String dateStr) {        final DateFormat sdf = new SimpleDateFormat(this.dateFormat);        sdf.setLenient(false);        try {            sdf.parse(dateStr);        } catch (ParseException e) {            return false;        }        return true;    }}</code></pre><p>这里需要注意一下，<code>DateFormat</code>和<code>SimpleDataFormat</code>是非线程安全的，所以每次方法调用时，都需要新建实例。</p><p>我们通过单元测试验证下：</p><pre><code class="java">class DateValidatorUsingDateFormatTest {    @Test    void isValid() {        final DateValidator validator = new DateValidatorUsingDateFormat(&quot;yyyy-MM-dd&quot;);        Assertions.assertTrue(validator.isValid(&quot;2021-02-28&quot;));        Assertions.assertFalse(validator.isValid(&quot;2021-02-30&quot;));    }}</code></pre><p>在 Java8 之前，一般都是用这种方式来验证。Java8 之后，我们有了更多的选择。</p><h3 id="使用-LocalDate-检查"><a href="#使用-LocalDate-检查" class="headerlink" title="使用 LocalDate 检查"></a>使用 LocalDate 检查</h3><p>Java8 引入了更加好用日期和时间 API（想要了解更多内容，请移步参看 <a href="https://www.howardliu.cn/java-date-and-time-intro/">Java8 中的时间类及常用 API</a>）。其中包括<code>LocalDate</code>类，是一个不可变且线程安全的时间类。</p><p><code>LocalDate</code>提供了两个静态方法，用来解析时间。这两个方法内部都是使用<code>java.time.format.DateTimeFormatter</code>来处理数据：</p><pre><code class="java">// 使用 DateTimeFormatter.ISO_LOCAL_DATE 处理数据public static LocalDate parse(CharSequence text) {    return parse(text, DateTimeFormatter.ISO_LOCAL_DATE);}// 使用提供的 DateTimeFormatter 处理数据public static LocalDate parse(CharSequence text, DateTimeFormatter formatter) {        Objects.requireNonNull(formatter, &quot;formatter&quot;);    return formatter.parse(text, LocalDate::from);}</code></pre><p>通过<code>LocalDate</code>的<code>parse</code>方法实现我们的校验器：</p><pre><code class="java">public class DateValidatorUsingLocalDate implements DateValidator {    private final DateTimeFormatter dateFormatter;    public DateValidatorUsingLocalDate(DateTimeFormatter dateFormatter) {        this.dateFormatter = dateFormatter;    }    @Override    public boolean isValid(String dateStr) {        try {            LocalDate.parse(dateStr, this.dateFormatter);        } catch (DateTimeParseException e) {            return false;        }        return true;    }}</code></pre><p><code>java.time.format.DateTimeFormatter</code>类是不可变的，也就是天然的线程安全，我们可以在不同线程使用同一个校验器实例。</p><p>我们通过单元测试验证下：</p><pre><code class="java">class DateValidatorUsingLocalDateTest {    @Test    void isValid() {        final DateTimeFormatter dateFormatter = DateTimeFormatter.ISO_LOCAL_DATE;        final DateValidator validator = new DateValidatorUsingLocalDate(dateFormatter);        Assertions.assertTrue(validator.isValid(&quot;2021-02-28&quot;));        Assertions.assertFalse(validator.isValid(&quot;2021-02-30&quot;));    }}</code></pre><p>既然<code>LocalDate#parse</code>是通过<code>DateTimeFormatter</code>实现的，那我们也可以直接使用<code>DateTimeFormatter</code>。</p><h3 id="使用-DateTimeFormatter-检查"><a href="#使用-DateTimeFormatter-检查" class="headerlink" title="使用 DateTimeFormatter 检查"></a>使用 DateTimeFormatter 检查</h3><p><code>DateTimeFormatter</code>解析文本总共分两步。第一步，根据配置将文本解析为日期和时间字段；第二步，用解析后的字段创建日期和时间对象。</p><p>实现验证器：</p><pre><code class="java">public class DateValidatorUsingDateTimeFormatter implements DateValidator {    private final DateTimeFormatter dateFormatter;    public DateValidatorUsingDateTimeFormatter(DateTimeFormatter dateFormatter) {        this.dateFormatter = dateFormatter;    }    @Override    public boolean isValid(String dateStr) {        try {            this.dateFormatter.parse(dateStr);        } catch (DateTimeParseException e) {            return false;        }        return true;    }}</code></pre><p>通过单元测试验证：</p><pre><code class="java">class DateValidatorUsingDateTimeFormatterTest {    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(&quot;uuuu-MM-dd&quot;, Locale.CHINA);    @Test    void isValid() {        final DateTimeFormatter dateFormatter = DATE_FORMATTER.withResolverStyle(ResolverStyle.STRICT);        final DateValidator validator = new DateValidatorUsingDateTimeFormatter(dateFormatter);        Assertions.assertTrue(validator.isValid(&quot;2021-02-28&quot;));        Assertions.assertFalse(validator.isValid(&quot;2021-02-30&quot;));    }}</code></pre><p>可以看到，我们指定了转换模式是<code>ResolverStyle.STRICT</code>，这个类型是说明解析模式。共有三种：</p><ul><li>STRICT：严格模式，日期、时间必须完全正确。</li><li>SMART：智能模式，针对日可以自动调整。月的范围在 1 到 12，日的范围在 1 到 31。比如输入是 2 月 30 号，当年 2 月只有 28 天，返回的日期就是 2 月 28 日。</li><li>LENIENT：宽松模式，主要针对月和日，会自动后延。结果类似于<code>LocalData#plusDays</code>或者<code>LocalDate#plusMonths</code>。</li></ul><p>我们通过例子看下区别：</p><pre><code class="java">class DateValidatorUsingDateTimeFormatterTest {    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(&quot;uuuu-MM-dd&quot;, Locale.CHINA);    @Test    void testResolverStyle() {        Assertions.assertEquals(LocalDate.of(2021, 2,28), parseDate(&quot;2021-02-28&quot;, ResolverStyle.STRICT));        Assertions.assertNull(parseDate(&quot;2021-02-29&quot;, ResolverStyle.STRICT));        Assertions.assertEquals(LocalDate.of(2021, 2,28), parseDate(&quot;2021-02-28&quot;, ResolverStyle.STRICT));        Assertions.assertNull(parseDate(&quot;2021-13-28&quot;, ResolverStyle.STRICT));        Assertions.assertEquals(LocalDate.of(2021, 2,28), parseDate(&quot;2021-02-28&quot;, ResolverStyle.SMART));        Assertions.assertEquals(LocalDate.of(2021, 2,28), parseDate(&quot;2021-02-29&quot;, ResolverStyle.SMART));        Assertions.assertNull(parseDate(&quot;2021-13-28&quot;, ResolverStyle.SMART));        Assertions.assertNull(parseDate(&quot;2021-13-29&quot;, ResolverStyle.SMART));        Assertions.assertEquals(LocalDate.of(2021, 2,28), parseDate(&quot;2021-02-28&quot;, ResolverStyle.LENIENT));        Assertions.assertEquals(LocalDate.of(2021, 3,1), parseDate(&quot;2021-02-29&quot;, ResolverStyle.LENIENT));        Assertions.assertEquals(LocalDate.of(2022, 1,28), parseDate(&quot;2021-13-28&quot;, ResolverStyle.LENIENT));        Assertions.assertEquals(LocalDate.of(2022, 2,2), parseDate(&quot;2021-13-33&quot;, ResolverStyle.LENIENT));    }    private static LocalDate parseDate(String dateString, ResolverStyle resolverStyle) {        try {            return LocalDate.parse(dateString, DATE_FORMATTER.withResolverStyle(resolverStyle));        } catch (DateTimeParseException e) {            return null;        }    }}</code></pre><p>从例子可以看出，<code>ResolverStyle.STRICT</code>是严格控制，用来做时间校验比较合适；<code>ResolverStyle.LENIENT</code>可以最大程度将字符串转化为时间对象，在合理范围内可以随便玩；<code>ResolverStyle.SMART</code>名为智能，但智力有限，两不沾边，优势不够明显。JDK 提供的<code>DateTimeFormatter</code>实现，都是<code>ResolverStyle.STRICT</code>模式。</p><p>说了 JDK 自带的实现，接下来说说第三方组件的实现方式。</p><h3 id="使用-Apache-出品的-commons-validator-检查"><a href="#使用-Apache-出品的-commons-validator-检查" class="headerlink" title="使用 Apache 出品的 commons-validator 检查"></a>使用 Apache 出品的 commons-validator 检查</h3><p>Apache Commons 项目提供了一个校验器框架，包含多种校验规则，包括日期、时间、数字、货币、IP 地址、邮箱、URL 地址等。本文主要说检查时间，所以重点看看<code>GenericValidator</code>类提供的<code>isDate</code>方法：</p><pre><code class="java">public class GenericValidator implements Serializable {    // 其他方法    public static boolean isDate(String value, Locale locale) {        return DateValidator.getInstance().isValid(value, locale);    }    public static boolean isDate(String value, String datePattern, boolean strict) {        return org.apache.commons.validator.DateValidator.getInstance().isValid(value, datePattern, strict);    }}</code></pre><p>先引入依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;commons-validator&lt;/groupId&gt;    &lt;artifactId&gt;commons-validator&lt;/artifactId&gt;    &lt;version&gt;1.7&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>实现验证器：</p><pre><code class="java">public class DateValidatorUsingCommonsValidator implements DateValidator {    private final String dateFormat;    public DateValidatorUsingCommonsValidator(String dateFormat) {        this.dateFormat = dateFormat;    }    @Override    public boolean isValid(String dateStr) {        return GenericValidator.isDate(dateStr, dateFormat, true);    }}</code></pre><p>通过单元测试验证：</p><pre><code class="java">class DateValidatorUsingCommonsValidatorTest {    @Test    void isValid() {        final DateValidator dateValidator = new DateValidatorUsingCommonsValidator(&quot;yyyy-MM-dd&quot;);        Assertions.assertTrue(dateValidator.isValid(&quot;2021-02-28&quot;));        Assertions.assertFalse(dateValidator.isValid(&quot;2021-02-30&quot;));    }}</code></pre><p>看<code>org.apache.commons.validator.DateValidator#isValid</code>源码可以发现，内部是通过<code>DateFormat</code>和<code>SimpleDateFormat</code>实现的。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>在本文中，我们通过四种方式实现了时间字符串校验逻辑。为了节省篇幅，文中代码只提供了核心内容。想要了解具体实现，可以关注公号「看山的小屋」，回复“date”获取源码。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol><li><a href="https://www.howardliu.cn/java-date-and-time-intro/">Java8 中的时间类及常用 API</a></li><li><a href="https://www.howardliu.cn/java-date-to-localdate-and-localdatetime/">Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://www.howardliu.cn/java-date-time-migrating-to-jsr310/">使用 Java8 中的时间类</a></li><li><a href="https://www.howardliu.cn/java-date-string-valid-date/">检查日期字符串是否合法</a></li></ol><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-date-string-valid-date/">看山聊 Java：检查日期字符串是否合法</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/119464230" target="_blank" rel="noopener">看山聊 Java：检查日期字符串是否合法</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      这次说一下，怎样检查给出的字符串，是否是合法日期字符串。本文将从 Java 原生和第三方组件两种方式来说明。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="Date" scheme="https://www.howardliu.cn/tags/Date/"/>
    
      <category term="Time" scheme="https://www.howardliu.cn/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>《Go 开发指南》-管理 Go 环境</title>
    <link href="https://www.howardliu.cn/manage-install/"/>
    <id>https://www.howardliu.cn/manage-install/</id>
    <published>2021-07-24T09:38:39.000Z</published>
    <updated>2021-07-24T09:38:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/kitten-6479019_1920.jpg" alt="《Go 开发指南》-管理 Go 环境"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/krystianwin-8237000/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6479019" target="_blank" rel="noopener">krystianwin</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6479019" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><blockquote><p>本文源自并发编程网的翻译邀请，文章来自 Go 官方网站。</p></blockquote><a id="more"></a><p>本文主要讲述了如何在同一台机器上安装多个版本 Go 环境，再描述一下如何卸载 Go 环境。</p><p>如果想要查看如何快速安装 Go 环境，可以访问：<a href="https://www.howardliu.cn/install-go/">快速安装 Go 环境</a>。</p><p>如果想要通过源码安装，可以访问：<a href="https://golang.google.cn/doc/install/source" target="_blank" rel="noopener">从源码安装 Go 环境</a>。</p><h2 id="如何安装多版本"><a href="#如何安装多版本" class="headerlink" title="如何安装多版本"></a>如何安装多版本</h2><p>有时候，我们希望用不同版本测试我们的代码，这就需要我们在一台机器上安装多个版本。有关版本列表，可以访问<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a>。</p><blockquote><p>注意：通过这种方式，需要提前装好<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a>。</p></blockquote><p>要安装其他版本，需要运行<code>go get</code>命令，指定下载位置。下面给出下载安装<code>1.10.7</code>版本的命令：</p><pre><code class="shell">go get golang.org/dl/go1.10.7go1.10.7 download</code></pre><p>使用最新下载的版本运行 go 命令，需要在 go 命令后附上版本号，比如：</p><pre><code class="shell">go1.10.7 version</code></pre><p>如果安装了多个版本，想要查看每个版本安装位置，可以查看指定版本的<code>GOROOT</code>值。比如：</p><pre><code class="shell">go1.10.7 env GOROOT</code></pre><p>如果想要卸载已下载版本，只需要移除<code>GOROOT</code>环境变量指定的目录和<code>goX.Y.Z</code>文件夹就行。</p><h2 id="如何卸载"><a href="#如何卸载" class="headerlink" title="如何卸载"></a>如何卸载</h2><p>本节说一下如何从你的系统中卸载 Go 环境。</p><h3 id="Linux-macOS-FreeBSD"><a href="#Linux-macOS-FreeBSD" class="headerlink" title="Linux / macOS / FreeBSD"></a>Linux / macOS / FreeBSD</h3><ol><li>删除 Go 目录，通常是<code>/usr/local/go</code>。</li><li>从<code>PATH</code>环境变量中移除 Go 的<code>bin</code>目录。在 Linux 和 FreeBSD 系统中，可以编辑<code>/etc/profile</code>或者<code>$HOME/.profile</code>修改<code>PATH</code>变量。如果是在 Mac 系统中，通过安装包安装的 Go 环境，需要删除<code>/etc/paths.d/go</code>文件。</li></ol><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在 Windows 系统中，最简单的方式是通过控制面板的“添加/删除程序”：</p><ol><li>在控制面板中，打开“添加/删除程序”</li><li>选择 Go 环境的卸载按钮，跟随步骤执行就行。</li></ol><p>要删除 Go 环境，还可以通过命令行的方式：</p><pre><code class="cmd">msiexec /x go{{version}}.windows-{{cpu-arch}}.msi /q</code></pre><blockquote><p>注：使用卸载程序卸载 Go，会自动删除创建时添加的环境变量。</p></blockquote><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/install-go/">《Go 开发指南》-快速安装 Go 环境</a></li><li><a href="https://www.howardliu.cn/manage-install/">《Go 开发指南》-管理 Go 环境</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>原文链接：<a href="https://golang.google.cn/doc/manage-install" target="_blank" rel="noopener">Managing Go installations</a><br>翻译：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>译文链接：<a href="https://www.howardliu.cn/manage-install/">《Go 开发指南》-管理 Go 环境</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/119061750" target="_blank" rel="noopener">《Go 开发指南》-管理 Go 环境</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      如何在同一台机器上安装多个版本 Go 环境，再描述一下如何卸载 Go 环境。
    
    </summary>
    
    
      <category term="go" scheme="https://www.howardliu.cn/categories/go/"/>
    
    
      <category term="go" scheme="https://www.howardliu.cn/tags/go/"/>
    
      <category term="开发指南" scheme="https://www.howardliu.cn/tags/%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>《Go 开发指南》-快速安装 Go 环境</title>
    <link href="https://www.howardliu.cn/install-go/"/>
    <id>https://www.howardliu.cn/install-go/</id>
    <published>2021-07-24T09:21:23.000Z</published>
    <updated>2021-07-24T09:21:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/travel-6470467_1920.jpg" alt="《Go 开发指南》-快速安装 Go 环境"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/jpdvg-11163235/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6470467" target="_blank" rel="noopener">JPierre Desvigne</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6470467" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><blockquote><p>本文源自并发编程网的翻译邀请，文章来自 Go 官方网站。</p></blockquote><a id="more"></a><p>按照下面的步骤，你可以实现快速安装。</p><p>如果想要通过源码安装，可以访问：<a href="https://golang.google.cn/doc/install/source" target="_blank" rel="noopener">从源码安装 Go 环境</a>。</p><p>如果想要安装多个版本的 Go 或者卸载，可以访问：<a href="https://www.howardliu.cn/manage-install/">管理 Go 环境</a>。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>下面提供了 Linux、Mac、Windows 三种系统 Go 语言安装包的下载路径：</p><ul><li>Linux：<a href="https://golang.org/dl/go1.16.5.linux-amd64.tar.gz" target="_blank" rel="noopener">https://golang.org/dl/go1.16.5.linux-amd64.tar.gz</a></li><li>Mac：<a href="https://golang.org/dl/go1.16.5.darwin-amd64.pkg" target="_blank" rel="noopener">https://golang.org/dl/go1.16.5.darwin-amd64.pkg</a></li><li>Windows：<a href="https://golang.org/dl/go1.16.5.windows-amd64.msi" target="_blank" rel="noopener">https://golang.org/dl/go1.16.5.windows-amd64.msi</a></li></ul><p>如果想要获取其他操作系统或者其他版本的，可以访问<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a>。</p><p>默认情况下，go 命令默认下载和验证模块时，使用的是 Google 提供的模块镜像服务和 checksum 验证。我们可以从<a href="https://golang.org/cmd/go/" target="_blank" rel="noopener">https://golang.org/cmd/go/</a>获取全面的 go 命令和配置。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ol><li><p>将下载的压缩包解压到<code>/usr/local</code>目录中，可以执行下面这条命令（需要切换到 root 用户或者使用 sudo）：</p><pre><code class="bash"> rm -rf /usr/local/go tar -C /usr/local -xzf go1.16.5.linux-amd64.tar.gz</code></pre><blockquote><p>注意：提供的这条命令会删除之前安装的 go 环境，在执行之前最好做下备份。</p></blockquote></li><li><p>将<code>/usr/local/go/bin</code>添加到<code>PATH</code>环境变量中，可以在<code>$HOME/.profile</code>或者<code>/etc/profile</code>中添加下面这条命令：</p><pre><code class="bash"> export PATH=$PATH:/usr/local/go/bin</code></pre><blockquote><p>注意：对配置文件的修改，需要等到下次登录计算机的时候才会生效。如果想要立即生效，可以直接运行 shell 命令，或者使用命令<code>source $HOME/.profile</code>重新执行一下配置内容。</p></blockquote></li><li><p>打开终端，输入下面的命令，验证下是否按照成功：</p><pre><code class="bash"> go version</code></pre></li><li><p>确认一下打印的版本号，与下载的版本号是否一致。如果一致，说明按照成功，如果说命令找不到或者版本不一致，那就是安装有问题。【译者注：如果条件允许，最好重启系统，然后在验证一次，避免环境变量配置错误。】</p></li></ol><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><ol><li><p>双击打开下载的安装包，按照提示安装。<br>这个安装包会直接将 Go 安装在<code>/usr/local/go</code>目录中，并将<code>/usr/local/go/bin</code>添加到<code>PATH</code>环境变量中。可能需要重启终端才能使环境变量生效。</p></li><li><p>打开终端，输入下面的命令，验证下是否按照成功：</p><pre><code class="bash"> go version</code></pre></li><li><p>确认一下打印的版本号</p></li></ol><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ol><li><p>双击打开下载的安装包，按照提示安装。<br>默认情况下，会安装在<code>Program Files</code>或者<code>Program Files (x86)</code>目录中，也可以根据自己的习惯修改。安装完成后，需要重启终端使环境变量生效。</p></li><li><p>验证安装是否成功</p><ol><li><p>在 Windows 系统中，打开菜单</p></li><li><p>搜索框中键入<code>cmd</code>然后回车，打开终端</p></li><li><p>在终端中，输入下面命令</p><pre><code class="bash"> go version</code></pre></li><li><p>确认一下打印的版本号</p></li></ol></li></ol><h2 id="开始-coding"><a href="#开始-coding" class="headerlink" title="开始 coding"></a>开始 coding</h2><p>经过上面步骤，你已经成功安装了 Go 环境，访问 <a href="https://golang.google.cn/doc/tutorial/getting-started.html" target="_blank" rel="noopener">Getting Started tutorial</a> 开始 Coding 之旅吧。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/install-go/">《Go 开发指南》-快速安装 Go 环境</a></li><li><a href="https://www.howardliu.cn/manage-install/">《Go 开发指南》-管理 Go 环境</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>原文链接：<a href="https://golang.google.cn/doc/install" target="_blank" rel="noopener">Download and install</a><br>翻译：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>译文链接：<a href="https://www.howardliu.cn/install-go/">《Go 开发指南》-快速安装 Go 环境</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/119061721" target="_blank" rel="noopener">《Go 开发指南》-快速安装 Go 环境</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      快速安装 Go 环境
    
    </summary>
    
    
      <category term="go" scheme="https://www.howardliu.cn/categories/go/"/>
    
    
      <category term="go" scheme="https://www.howardliu.cn/tags/go/"/>
    
      <category term="开发指南" scheme="https://www.howardliu.cn/tags/%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>好书不是通过价格可以衡量的，比如这本</title>
    <link href="https://www.howardliu.cn/about-the-fenix-project/"/>
    <id>https://www.howardliu.cn/about-the-fenix-project/</id>
    <published>2021-07-12T16:10:51.000Z</published>
    <updated>2021-07-12T16:10:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/bee-6354562_1920.jpg" alt="好书不是通过价格可以衡量的，比如这本"></p><p>你好，我是看山。</p><p>笔者主修Java，所以在<a href="https://www.howardliu.cn/lists-book-recommendations-2021/">《程序员进阶书单2021版》</a>主要推荐了一些Java工程师进阶必读书单。推荐原则是豆瓣的评分，结果，遗漏了一本开源书籍，甚是遗憾，今天补上。</p><a id="more"></a><p>推荐的书籍名为《凤凰架构》，开源地址是<a href="https://icyfenix.cn/" target="_blank" rel="noopener">https://icyfenix.cn/</a>。</p><p>看到凤凰，我们会想到凤凰涅槃、涅槃重生之类的词语。在作者看来，我们的系统不是一成不变的，只要在软件生命周期内，总会因为某些原因出现问题，或者是设计上的，或者是工程师代码问题，甚至最简单的网络问题。就像是凤凰浴火，经历考验，然后重生一般。</p><p>本书探讨的主题就是，如何构建一个可靠的分布式系统。这套方法论，可以让多人协作开发的系统，让一个大型的、分布式的系统，可靠的运行。这不是依赖团队成员个人能力，或者是研发质量管理就能够实现的，这是一个系统性的、架构层面的问题。想要实现这个目标，最终要依赖技术和架构。</p><p>全书主要分为5部分：</p><ul><li>演进中的架构：从历史演进过程，以全局视角，梳理微服务发展过程中出现的大量技术名词、概念。可以让我们了解技术的时代背景和探索过程。这里不得不推荐另外一本书《大型网站技术架构》，大家有时间可以看看。</li><li>架构师的视角：这一部分不是局限在某种架构的通用技巧，而是系统性地讲解做架构设计的时候，架构师都应该思考哪些问题、可以选择哪些主流的解决方案和行业标准做法，以及这些主流方案都有什么优缺点、会给架构设计带来什么影响，等等。这样一来，我们才可以把“架构设计”这样比较抽象的工作具体化、具象化。</li><li>分布式的基石：这一部分聚焦在分布式架构，探讨分布式带来的问题与应对策略。剖析分布式架构中出现的一系列问题，比如服务的注册发现、跟踪治理、负载均衡、故障隔离、认证授权、伸缩扩展、传输通讯、事务处理等，有哪些解决思路、方法和常见工具。</li><li>不可变基础设施：这一部分按照云原生时代“基础设施即代码”的新思路，深入理解基础设施不变性的目的、原理与实现途径，体会用代码和用基础设施，来解决分布式问题的差异，让我们更轻松的理解不可变基础设施的内涵，便于在实际工作中做运维、程序升级和部署等工作。</li><li>技术方法论：这一部分属于归纳总结的部分，前面都是从实践出发，让我们更加清楚如何是设计一个不断升级的系统。这一章讲述一些方法论，在我们有一定实践的基础上，构建可靠的理论体系，理论与实现相结合，相互螺旋上升。</li></ul><p>前面说了这么多，该介绍一下作者了，就是大名鼎鼎的周志明，<a href="https://book.douban.com/subject/34907497/" target="_blank" rel="noopener">《深入理解Java虚拟机》</a>作者。相信Java栈的开发者，即使没有读过这本书，也听过其名。就是这本书让笔者有爱有恨，爱的是提升了笔者对JVM的认识，恨的是提升了大家对JVM的认识。</p><p>再次附上开源地址<a href="https://icyfenix.cn/" target="_blank" rel="noopener">https://icyfenix.cn/</a>。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/lists-book-recommendations-2021/">程序员进阶书单2021版</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/about-the-fenix-project/">好书不是通过价格可以衡量的，比如这本</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/103794938" target="_blank" rel="noopener">好书不是通过价格可以衡量的，比如这本</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://static.howardliu.cn/cover/bee-6354562_1920.jpg&quot; alt=&quot;好书不是通过价格可以衡量的，比如这本&quot;&gt;&lt;/p&gt;
&lt;p&gt;你好，我是看山。&lt;/p&gt;
&lt;p&gt;笔者主修Java，所以在&lt;a href=&quot;https://www.howardliu.cn/lists-book-recommendations-2021/&quot;&gt;《程序员进阶书单2021版》&lt;/a&gt;主要推荐了一些Java工程师进阶必读书单。推荐原则是豆瓣的评分，结果，遗漏了一本开源书籍，甚是遗憾，今天补上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="书单" scheme="https://www.howardliu.cn/tags/%E4%B9%A6%E5%8D%95/"/>
    
      <category term="技术成长" scheme="https://www.howardliu.cn/tags/%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>想躺平不是错</title>
    <link href="https://www.howardliu.cn/relax-and-run/"/>
    <id>https://www.howardliu.cn/relax-and-run/</id>
    <published>2021-07-09T00:16:44.000Z</published>
    <updated>2021-07-09T00:16:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/caterpillar-6387049_1920.jpg" alt="想躺平不是错"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/jggrz-7998824/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6387049" target="_blank" rel="noopener">jggrz</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6387049" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>今天聊聊这段时间比较火的一个网络词：躺平。据说这个词还被某些网站屏蔽了，不知道这篇文章会不会也被屏蔽掉。</p><a id="more"></a><p>维基百科为<code>躺平</code>下了一个比较完善的定义：</p><blockquote><p>躺平或躺平主义是 2021 年开始在中华人民共和国流行的网络词语。指这一时期的年轻人在国内经济下滑、社会问题激化的大背景下，出于对现实环境的失望而做出的“与其跟随社会期望坚持奋斗，不如选择‘躺平’，无欲无求”的处事态度。被视为是对抗社会“内卷化”的一种方式。其具体内涵包括“不买房、不买车、不结婚、不生娃、不消费”及“维持最低生存标准，拒绝成为他人赚钱的机器和被剥削的奴隶”，是“低欲望青年”对于阶级固化的低移动性社会、中产阶级萎缩、在职贫穷、苛刻待遇、劳资关系失谐、以及不合理的社会经济结构等现况的回应。</p></blockquote><p>后面就是个人愚见了。</p><p>不禁有人会问，为什么现在年轻人要躺平呢？以前怎么没有？</p><p>怎么会没有？躺平这个词是新词，但这种想法却不是新的，新瓶装旧酒而已。</p><p>在更早的时候有一个词：三和大神。</p><p>维基百科依然可以找到解释：</p><blockquote><p>三和大神是指栖身在中国广东省深圳市龙华区景乐新村海新信人力资源市场附近的一群打工者，“三和”一词源自该区域最大的人力资源公司名称。他们居无定所，以日结薪资的临时工为生，号称“做一天可以玩三天”。这些打工者有的甚至没有身份证，身负债务，与家人鲜有来往。失去身份证无法购票，甚至无法离开三和地区。三和大神的定义同时有精神方面的因素，往往有着过一天算一天的豁达精神，不畏死，不惧穷、苦、脏。</p></blockquote><p>还有个词是“葛优躺”，2016 年的网络词，比喻自己的“颓废”的现状。</p><p><img src="http://static.howardliu.cn/raving/1f178a82b9014a90168ef327b977ad1ab21bee85.jpeg" alt="葛优躺"></p><p>再往前有个词是“佛系”，2014 年的网络词了，指无欲无求、不悲不喜、云淡风轻而追求内心平和的生活态度。</p><p>再往前，看看唐伯虎，躺的很潇洒。</p><blockquote><p>酒醒只在花前坐，酒醉还须花下眠。<br>花前花后日复日，酒醉酒醒年复年。<br>但愿老死花酒间，不愿鞠躬车马前。</p></blockquote><p>最后追上一句“世人笑我太疯癫，我笑世人看不穿。”简直是我躺平辈的真实心态。</p><p>再往前还有陶渊明，隐居山野间，“种豆南山下，草盛豆苗稀”，任由庄稼被杂草吞噬。</p><p>历史上的名人尚且如此，那些没有被历史记住的躺平青年，何其之多。躺平一词，只是给这种处事方式定了一个新说法而已。</p><p>从某度搜索这个词，结果有 1000 万条，可见热度如何。我天朝上国日益繁荣，怎么今年突然出来这么个词？</p><p>现在社会上工作的大部分人，是 80、90、00 这 30 年之间的人，正在接受生活工作的鞭挞。</p><p>改革开放 40 多年，经济迅速发展，几乎赶上欧美 200 多年的发展历程，甚至在某些领域已遥遥领先。</p><p>社会的发展不可能一蹴而就，必然是问题叠问题，不断解决问题。正在工作中努力拼搏的这批人，赶上了计划生育、90 年代的国企下岗、99 年的大学扩招、08 年的房价上涨、15 年二胎政策，以及今年的三胎政策、中考分流等。（中考分流和这批人没有直接关系，不过会跟这批人的子女有关系。）</p><p>能量守恒是自然规律。想要获得一些东西，必然需要通过等价的事物作为交换。社会发展也要遵循这个规律。</p><p>建国初期，百废待兴，需要发展。农业需要农民、工业需要工人、科研需要科学家、社会需要学者，各行各业都缺人，人多力量大。（不是说人多就有用，但是人多出现有用的人概率更大。）因此，人口数量稳步提升，但是国土面积就那么大，任由发展，就可能演变成“老鼠乌托邦”实验，所以必须刹车制动，于是有了计划生育。</p><p>后来，市场经济调控下，大锅饭不再能够保障大部分人的生活，国企经营能力赶不上社会发展，下岗成为了市场经济下的必然。但是下岗工人需要再就业、再创业。但是人口高速增长的那批正在读高中的学子马上也要毕业，怎么办？大学扩招，让这批即将毕业踏入社会的高中生，可以进入大学再学几年，大学成为分担就业压力的一个池子。</p><p>于是，本来大部分人上不了大学，变成了半数人有机会上大学。这样又造成了课外教培事业的繁荣，原本只有那些 90 分以上的孩子才能上大学。扩招之后，70 分以上都可以，那 60 分的就想往上提一下，70 分的怕被挤下来，也参加课外教培。学习上的内卷开始。也就是说，这批有躺平想法的年轻人，在学校读书的时候就被内卷过了。（这又是另外一个话题了，这里不做展开。）</p><p>等到这批扩招的大学生毕业，普通的流水线工厂肯定是不会去了，必然是要到大城市，进写字楼当白领。于是，当白领的人越来越多，但是资源就那么多，彼此竞争。白领人多了，蓝领就少了，也造成了各种用工荒。</p><p>大城市因其资源、人才、企业相互影响，产生人口聚集。人口多了，竞争压力大，教育资源紧缺，房价上涨，种种这些，压得这批年轻人喘不开气来。这些压力转变到生育上，就造成大家不愿生不敢生。人口增长缓慢，老龄化加剧，于是有了后来的鼓励生育，开放二胎三胎。</p><p>说了这么多，似乎和躺平没什么直接关系。仔细思考下，能够发现其中的必然联系。</p><p>目前 80、90、00 这群人，都是经历过社会高速发展的。到目前，我国经济水平已经赶上国际水平，跻身大国行列。后期就要更加良性的发展，不能以牺牲其他方面为代价的发展。所以，经济发展放缓必然是常态化。加上新冠疫情的出现，让这种常态化更快的到来。</p><p>总结下来，钱更难挣了。想要挣到相同的钱，需要我们的能力更强，付出更多的努力。对于这批人，车贷房贷教育费，赡养老人，抚育子女，各种事情都需要花钱。钱变得难挣，但是花钱并没有减少。</p><p>所以，想要躺会儿放松放松，把可能造成压力的事物都摒弃，让自己压力小一些。放松下来，什么也不管，无欲无求，简单度日即可。</p><p>但是，人毕竟是群居生物，有其社群关联。有父母、有妻儿，我朝亲情至上。所以上要孝敬父母，下要抚育子女，中间要与伴侣互相扶持。一时的放松可以，但是不能一直松下去。一时的放松是劳逸结合，一世的放松就是烂泥扶不上墙了。</p><p>推荐看看周董《稻香》的 MV，可以学学男主人公，当工作累了，可以回乡下老家，体验一下慢生活，给自己充充电。释放了压力，才能轻装前行。</p><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/relax-and-run/">想躺平不是错</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/118686355" target="_blank" rel="noopener">想躺平不是错</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      今天聊聊这段时间比较火的一个网络词：躺平。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="躺平" scheme="https://www.howardliu.cn/tags/%E8%BA%BA%E5%B9%B3/"/>
    
  </entry>
  
  <entry>
    <title>看山聊 Java：使用 Java8 中的时间类</title>
    <link href="https://www.howardliu.cn/java-date-time-migrating-to-jsr310/"/>
    <id>https://www.howardliu.cn/java-date-time-migrating-to-jsr310/</id>
    <published>2021-06-30T15:02:17.000Z</published>
    <updated>2021-06-30T15:02:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/chestnut-heath-6370080_1920.jpg" alt="看山聊 Java：使用 Java8 中的时间类"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/erik_karits-15012370/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6370080" target="_blank" rel="noopener">Erik Karits</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6370080" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>前面聊了聊 Java8 新版时间 API 的类，然后又说了说怎么与旧版时间 API 的转换，今天来聊聊怎样通过新 API 实现老 API 的功能，这样我们就可以逐步替换掉旧版 API，与时俱进。</p><a id="more"></a><p>Java8 之前，我们常用的时间类有<code>java.util.date</code>、<code>java.util.Calendar</code>和<code>java.util.Timezone</code>。还会有一些不那么常用的，<code>java.sql.Date</code>、<code>java.sql.TimeStamp</code>。</p><p>这些类可以实现一些简单的功能，但是要实现复杂的功能，我们只能自己实现很多工具类，或者借助第三方类库，其中比较著名的第三方库是 joda-time，后来 Java8 吸收其设计，直接让 joda-time 转正了。</p><blockquote><p>因为这个系列说的都是时间库，后文没有特殊说明，使用“新版 API”指代<code>JSR 310</code>提供的时间 API，使用“旧版 API”指代 Java 8 之前提供的官方时间 API。</p></blockquote><h2 id="新版-API-的优势"><a href="#新版-API-的优势" class="headerlink" title="新版 API 的优势"></a>新版 API 的优势</h2><p>新版 API 的优势，对应的就是旧版 API 的劣势。</p><h3 id="语义明确"><a href="#语义明确" class="headerlink" title="语义明确"></a>语义明确</h3><p>这点非常重要。</p><p>我们在定义一个实体的时候，能够做到语义明确没有歧义非常重要。</p><p>比如，我们需要定义出生日期，只需要年月日，在以前只能用<code>java.util.Date</code>，但是这个类包含时分秒。</p><p>或者，我们需要定义生日，正常只需要月日就行，连年都不需要，<code>java.util.Date</code>更加做不到。</p><p>在这些场景中，我们只能通过注释或者属性名做一些松散约束，很容易出错。</p><p>经验告诉我们，人是不可靠的，约定是不可靠的，只要有犯错的可能，就一定会犯错。</p><p>新版 API 完美解决这个问题，提供具有不同语义且语义明确的类。如果想表示日期可以用<code>LocalDate</code>，如果想表示生日，可以用<code>MonthDay</code>。这样，我们就能够借助编译器增强约束力。</p><h3 id="符合自然规律"><a href="#符合自然规律" class="headerlink" title="符合自然规律"></a>符合自然规律</h3><p>我们来通过一段代码感受下（测试日期是 2021 年 6 月 28 日），执行结果放在每行结尾处：</p><pre><code class="java">Date date = new Date();System.out.println(date);// Mon Jun 28 21:41:25 CST 2021System.out.println(date.getYear());// 121System.out.println(date.getMonth());// 5System.out.println(date.getDay());// 1Calendar calendar = Calendar.getInstance();calendar.setTime(date);System.out.println(calendar.get(Calendar.YEAR));// 2021System.out.println(calendar.get(Calendar.MONTH));// 5System.out.println(calendar.get(Calendar.DAY_OF_MONTH));// 28LocalDate localDate = LocalDate.now();System.out.println(localDate.getYear());// 2021System.out.println(localDate.getMonth());// JUNESystem.out.println(localDate.getDayOfMonth());// 28</code></pre><p>仅仅一个年月日的获取，旧版 API 已经是存在各种含义。</p><p><code>java.util.Date#getYear</code>表示的是当前年份减去 1900；<code>java.util.Date#getDay</code>返回的是当前是一周中的第几天，下标从 0 开始。当然，这几个 API 在 JDK1.1 的时候已经标记废弃了，但是知道现在也没有删除。相信很多初次使用旧版 API 的同学，都可能踩过坑。</p><p>更甚的是，<code>java.util.Date</code>和<code>java.util.Calendar</code>的返回的月份，都是从 0 开始计数的。但是年和日是从 1 开始计数，实在没有搞懂当时开发人员的脑回路是怎样的。</p><p>再看新版 API，完全符合我们的认知：年是自然年，月使用<code>Month</code>枚举（枚举的 value 值是自然月），日是自然日，一切都是根据我们对自然规律的理解。</p><p>而且，新版 API 很贴心的考虑了夏令时，在使用<code>ZonedDateTime</code>进行不同区域时间转换时，会自动计算。可以说，关于时间的逻辑，新版 API 已经都包含了。</p><h3 id="功能完善"><a href="#功能完善" class="headerlink" title="功能完善"></a>功能完善</h3><p>旧版 API 提供的时间类，只能实现一些简单的逻辑，想要做一些复杂的操作，就需要自己实现。新版 API 提供了灵活的时间功能 API。</p><ul><li><code>Instant</code>：表示时间戳，也就是一个时间点。</li><li><code>LocalDate</code>：表示日期，年、月、日</li><li><code>LocalTime</code>：表示时间，时、分、秒、纳秒</li><li><code>LocalDateTime</code>：表示日期+时间，内部也是通过<code>LocalDate</code>和<code>LocalTime</code>存储数据的</li><li><code>OffsetDateTime</code>：带有时间偏移的<code>LocalDateTime</code></li><li><code>OffsetTime</code>：带有时间偏移的<code>LocalTime</code></li><li><code>ZonedDateTime</code>：比<code>OffsetDateTime</code>多了时区，也就是带有时区、带有时间偏移的<code>LocalDateTime</code></li><li><code>MonthDay</code>：表示月、日，不包含年和时间</li><li><code>YearMonth</code>：表示年、月，不包含日和时间</li><li><code>Duration</code>：表示纳秒、秒的时间量，可以度量天、小时、分、秒、毫秒、纳秒。</li><li><code>Period</code>：表示年、月、日的时间量，可以度量年、月、日、周。</li></ul><p>有了上面这些类，我们可以在操作时间时横着走了。</p><h3 id="不可变（线程安全）"><a href="#不可变（线程安全）" class="headerlink" title="不可变（线程安全）"></a>不可变（线程安全）</h3><p>上面提到的这些类中，都是不可修改的，这些类的成员变量都使用<code>final</code>修饰，所有需要修改数据的方法，都是返回一个新实例。新版 API 通过这种方式实现了时间类的不可变性。</p><p>我们都知道，一个对象是不可变的，那它就是线程安全的。</p><p>旧版 API 的则不是这样，数据可变且对并发敏感。当然，这只能算是设计初衷不同。</p><p>新版 API 表示时间的类是线程安全的，可以对时间格式化的<code>DateTimeFormatter</code>也是时间安全的。</p><p>旧版的<code>SimpleDateFormat</code>也是类似的功能，但却不是线程安全的。这点就不是设计初衷不同了，而是缺少设计。相信很多没有被这个类毒打过的小白，会定义一些工具类，里面是<code>static</code>定义的<code>SimpleDateFormat</code>，然后对时间进行格式化，测试的时候没有一点问题，放在线上就出现各种诡异错误。</p><h2 id="开启征程"><a href="#开启征程" class="headerlink" title="开启征程"></a>开启征程</h2><p>我们通过一些常用场景，展示新旧版本 API 的实现方式。</p><h3 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h3><p>旧版 API：</p><pre><code class="java">Date now = new Date();</code></pre><p>新版 API：</p><pre><code class="java">// 没有偏移、没有时区概念的当前时间LocalDateTime now = LocalDateTime.now();// 有偏移和时区的当前时间ZonedDateTime now2 = ZonedDateTime.now();</code></pre><h3 id="指定日期"><a href="#指定日期" class="headerlink" title="指定日期"></a>指定日期</h3><p>旧版 API：</p><pre><code class="java">Date birthday = new GregorianCalendar(1988, Calendar.AUGUST, 20).getTime();</code></pre><p>新版 API：</p><pre><code class="java">LocalDate birthday = LocalDate.of(1988, Month.AUGUST, 20);LocalDate birthday2 = LocalDate.of(1988, 8, 20);</code></pre><h3 id="获取指定量"><a href="#获取指定量" class="headerlink" title="获取指定量"></a>获取指定量</h3><p>旧版 API：</p><pre><code class="java">int month = new GregorianCalendar().get(Calendar.MONTH);</code></pre><p>新版 API：</p><pre><code class="java">Month month = LocalDateTime.now().getMonth();</code></pre><h3 id="调整时间"><a href="#调整时间" class="headerlink" title="调整时间"></a>调整时间</h3><p>比如，获取当前之间 5 小时前的时间。</p><p>旧版 API：</p><pre><code class="java">GregorianCalendar calendar = new GregorianCalendar();calendar.add(Calendar.HOUR_OF_DAY, -5);Date fiveHoursBefore = calendar.getTime();</code></pre><p>新版 API：</p><pre><code class="java">LocalDateTime fiveHoursBefore = LocalDateTime.now().minusHours(5);</code></pre><h3 id="调整指定时间量"><a href="#调整指定时间量" class="headerlink" title="调整指定时间量"></a>调整指定时间量</h3><p>比如，将时间调整到 6 月。</p><p>旧版 API：</p><pre><code class="java">GregorianCalendar calendar = new GregorianCalendar();calendar.set(Calendar.MONTH, Calendar.JUNE);Date inJune = calendar.getTime();</code></pre><p>新版 API：</p><pre><code class="java">LocalDateTime inJune = LocalDateTime.now().withMonth(Month.JUNE.getValue());</code></pre><h3 id="截断时间量"><a href="#截断时间量" class="headerlink" title="截断时间量"></a>截断时间量</h3><p>我们有时候会将时间对象某个单位后面的所有时间量设置为 0，这个操作形象的称为截断。比如，将分、秒、毫秒设置为零。</p><p>旧版 API：</p><pre><code class="java">Calendar now = Calendar.getInstance();now.set(Calendar.MINUTE, 0);now.set(Calendar.SECOND, 0);now.set(Calendar.MILLISECOND, 0);Date truncated = now.getTime();</code></pre><p>新版 API：</p><pre><code class="java">LocalTime truncated = LocalTime.now().truncatedTo(ChronoUnit.HOURS);</code></pre><h3 id="时区转换"><a href="#时区转换" class="headerlink" title="时区转换"></a>时区转换</h3><p>旧版 API：</p><pre><code class="java">GregorianCalendar calendar = new GregorianCalendar();calendar.setTimeZone(TimeZone.getTimeZone(&quot;CET&quot;));Date centralEastern = calendar.getTime();</code></pre><p>新版 API：</p><pre><code class="java">ZonedDateTime centralEastern = LocalDateTime.now().atZone(ZoneId.of(&quot;CET&quot;));</code></pre><h3 id="计算时间跨度"><a href="#计算时间跨度" class="headerlink" title="计算时间跨度"></a>计算时间跨度</h3><p>旧版 API：</p><pre><code class="java">GregorianCalendar calendar = new GregorianCalendar();Date now = new Date();calendar.add(Calendar.HOUR, 1);Date hourLater = calendar.getTime();long elapsed = hourLater.getTime() - now.getTime();</code></pre><p>新版 API：</p><pre><code class="java">LocalDateTime now = LocalDateTime.now();LocalDateTime hourLater = LocalDateTime.now().plusHours(1);Duration span = Duration.between(now, hourLater);</code></pre><p><code>Duration</code>是跨度较小，可以度量天、小时、分、秒、毫秒、纳秒。如果跨度较大，可以使用<code>Period</code>，可以度量年、月、日、周。</p><h3 id="时间格式化和解析"><a href="#时间格式化和解析" class="headerlink" title="时间格式化和解析"></a>时间格式化和解析</h3><p>新版 API 使用<code>DateTimeFormatter</code>，这个类是线程安全的。而且相较于<code>SimpleDateFormat</code>提供了很多额外的功能。</p><p>旧版 API：</p><pre><code class="java">SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);Date now = new Date();String formattedDate = dateFormat.format(now);Date parsedDate = dateFormat.parse(formattedDate);</code></pre><p>新版 API：</p><pre><code class="java">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);LocalDate now = LocalDate.now();String formattedDate = now.format(formatter);LocalDate parsedDate = LocalDate.parse(formattedDate, formatter);</code></pre><h3 id="其他一些小功能"><a href="#其他一些小功能" class="headerlink" title="其他一些小功能"></a>其他一些小功能</h3><p>比如，计算一个月有几天：</p><p>旧版 API：</p><pre><code class="java">Calendar calendar = new GregorianCalendar(1990, Calendar.FEBRUARY, 20);int daysInMonth = calendar.getActualMaximum(Calendar.DAY_OF_MONTH);</code></pre><p>新版 API：</p><pre><code class="java">int daysInMonth = YearMonth.of(1990, 2).lengthOfMonth();</code></pre><h2 id="新旧版-API-的转换"><a href="#新旧版-API-的转换" class="headerlink" title="新旧版 API 的转换"></a>新旧版 API 的转换</h2><p>新版 API 虽然好用，但是罗马不是一天建成的。旧版 API 不会一夜消失，可能需要共用。Java 8 提供了很多方法，用来在新旧版本 API 之间进行转换。比如：</p><pre><code class="java">// 从 Calendar 转换 InstantInstant instantFromCalendar = GregorianCalendar.getInstance().toInstant();// 从 Calendar 转换 ZonedDateTimeZonedDateTime zonedDateTimeFromCalendar = new GregorianCalendar().toZonedDateTime();// 从 Instant 转换 DateDate dateFromInstant = Date.from(Instant.now());// 从 ZonedDateTime 转换 CalendarGregorianCalendar calendarFromZonedDateTime = GregorianCalendar.from(ZonedDateTime.now());// 从 Date 转换 InstantInstant instantFromDate = new Date().toInstant();// 从 TimeZone 转换 ZoneIdZoneId zoneIdFromTimeZone = TimeZone.getTimeZone(&quot;PST&quot;).toZoneId();</code></pre><p>更多的内容可以看看该系列的另一篇：<a href="https://www.howardliu.cn/java-date-to-localdate-and-localdatetime/">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a>。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>在本文中，我们讲解了旧版 API 的缺点、新版 API 的优点。新版 API 提供了很多友好的方法，而且不同类之间操作几乎一致，所以很多例子虽然只是说了一个类的使用，但是其他类也可以采用相似方式实现。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol><li><a href="https://www.howardliu.cn/java-date-and-time-intro/">Java8 中的时间类及常用 API</a></li><li><a href="https://www.howardliu.cn/java-date-to-localdate-and-localdatetime/">Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://www.howardliu.cn/java-date-time-migrating-to-jsr310/">使用 Java8 中的时间类</a></li><li><a href="https://www.howardliu.cn/java-date-string-valid-date/">检查日期字符串是否合法</a></li></ol><hr><p>你好，我是看山，10 年老猿，开源贡献者。游于码界，戏享人生。关注公众号：<a href="http://static.howardliu.cn/about/kanshanshuo.png" target="_blank" rel="noopener">看山的小屋</a>，领取学习资料。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-date-time-migrating-to-jsr310/">看山聊 Java：使用 Java8 中的时间类</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/103794938" target="_blank" rel="noopener">看山聊 Java：使用 Java8 中的时间类</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      前面聊了聊 Java8 新版时间 API 的类，然后又说了说怎么与旧版时间 API 的转换，今天来聊聊怎样通过新 API 实现老 API 的功能，这样我们就可以逐步替换掉旧版 API，与时俱进。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="Date" scheme="https://www.howardliu.cn/tags/Date/"/>
    
      <category term="Time" scheme="https://www.howardliu.cn/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>如果非要在多线程中使用 ArrayList 会发生什么？（第二篇）</title>
    <link href="https://www.howardliu.cn/arraylist-is-not-thread-safe-2/"/>
    <id>https://www.howardliu.cn/arraylist-is-not-thread-safe-2/</id>
    <published>2021-06-29T15:18:18.000Z</published>
    <updated>2021-06-29T15:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/home-studios-5249651_1920.jpg" alt="如果非要在多线程中使用 ArrayList 会发生什么？（第二篇）"></p><p>你好，我是看山。</p><p>前面写过一篇文章 <a href="https://howardliu.cn/arraylist-is-not-thread-safe/" target="_blank" rel="noopener">《如果非要在多线程中使用 ArrayList 会发生什么？》</a>，有读者反馈，Java 11 代码已经修复，还会出现 null 元素。</p><p>为了便于理解，当时只是通过代码执行顺序说明了异常原因。其实多线程中还会涉及 Java 内存模型，本文就从这方面说明一下。</p><a id="more"></a><h2 id="对比源码"><a href="#对比源码" class="headerlink" title="对比源码"></a>对比源码</h2><p>我们先来看看 Java 11 中，<code>add</code>方法做了什么调整。</p><p>Java 8 中<code>add</code>方法的实现：</p><pre><code class="java">public boolean add(E e) {    ensureCapacityInternal(size + 1);    elementData[size++] = e;    return true;}</code></pre><p>Java 11 中<code>add</code>方法的实现：</p><pre><code class="java">public boolean add(E e) {    modCount++;    add(e, elementData, size);    return true;}private void add(E e, Object[] elementData, int s) {    if (s == elementData.length)        elementData = grow();    elementData[s] = e;    size = s + 1;}</code></pre><p>两段逻辑的差异在于数组下标是否确定：</p><ul><li><code>elementData[size++] = e;</code>，Java 8 中直接使用<code>size</code>定位并赋值，然后通过<code>size++</code>自增</li><li><code>elementData[s] = e; size = s + 1;</code>，Java 11 借助临时变量<code>s</code>定位并赋值，然后通过<code>size = s + 1</code>给<code>size</code>赋新值</li></ul><p>Java 11 的优点在于，为数组指定元素赋值的时候，下标值是确定的。也就是说，只要进入<code>add(E e, Object[] elementData, int s)</code>方法中，就只会处理指定位置的数组元素。并且，<code>size</code>的值也是根据<code>s</code>增加。按照执行顺序推断，最终的结果可能会丢数，但是不会出现 null。（多个线程向同一个下标赋值，即<code>s</code>相等，那最终<code>size</code>也相等。）</p><h2 id="验证一下"><a href="#验证一下" class="headerlink" title="验证一下"></a>验证一下</h2><p>让我们来验证下。</p><pre><code class="java">package com.kuaishou.is.datamart;import java.util.ArrayList;import java.util.List;import java.util.concurrent.CountDownLatch;public class Main {    public static void main(String[] args) throws InterruptedException {        List&lt;String&gt; list = new ArrayList&lt;&gt;();        CountDownLatch latch = new CountDownLatch(1);        CountDownLatch waiting = new CountDownLatch(3);        Thread t1 = new Thread(() -&gt; {            try {                latch.await();                for (int i = 0; i &lt; 1000; i++) {                    list.add(&quot;1&quot;);                }            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                waiting.countDown();            }        });        Thread t2 = new Thread(() -&gt; {            try {                latch.await();                for (int i = 0; i &lt; 1000; i++) {                    list.add(&quot;2&quot;);                }            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                waiting.countDown();            }        });        Thread t2 = new Thread(() -&gt; {            try {                latch.await();                for (int i = 0; i &lt; 1000; i++) {                    list.add(&quot;2&quot;);                }            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                waiting.countDown();            }        });        t1.start();        t2.start();        latch.countDown();        waiting.await();        System.out.println(list);    }}</code></pre><p>在 Java 8 和 Java 11 中分别执行，果然，出现了<code>ArrayIndexOutOfBoundsException</code>和<code>null</code>的情况。如果没有出现，那就是姿势不对，需要多试几次或者多几个线程。</p><h2 id="换个角度想问题"><a href="#换个角度想问题" class="headerlink" title="换个角度想问题"></a>换个角度想问题</h2><p>上一篇通过代码执行顺序解释了出现问题的原因，这次再看看 JMM 的原因。</p><p><img src="http://static.howardliu.cn/java/jmm.png" alt="jmm"></p><p>从上图我们可以看到，Java 为每个线程创建了一个本地内存区域，也就是说，代码运行过程中使用的数据，是线程本地缓存的数据。这份缓存的数据，会与主内存的数据做交换（更新主内存数据或更新本次缓存中的数据）。</p><p>我们通过一个时序图看下为什么会出现 null（数组越界异常同理）：</p><p><img src="http://static.howardliu.cn/java/arraylist-add.png" alt="多线程场景下 ArrayList#add 方法的时序图"></p><p>从时序图我们可以看出现，在执行过程中，两个线程取的<code>size</code>值和<code>elementData</code>数组地址，大部分是操作自己本地缓存中的，执行一段时间后，会将本地缓存中的数据写回主内存数据，然后还会从主内存中读取最新数据更新本地缓存数据。异常就在这个交换过程中发生了。</p><p>这个时候，可能有读者会想，是不是把<code>size</code>和<code>elementData</code>两个变量加上<code>volatile</code>就可以解决了。如果这样想，那你就想简单。线程安全是整个类设计实现时已经确定了，除了属性需要考虑多线程的影响，方法（主要是会修改属性元素的方法）也需要考虑。</p><p><code>ArrayList</code>的定位是非线程安全的，其中的所有方法都没有考虑多线程下为共享资源加锁。即使<code>size</code>和<code>elementData</code>两个变量都是实时读写主内存，但是<code>add</code>和<code>grow</code>方法还是可能会覆盖另一个线程的数据。</p><p>我们从<code>ArrayList</code>的<code>add</code>方法注释可以得知，方法拆分不是为了实现线程安全，而是为了执行效率和内存占用：</p><blockquote><p>This helper method split out from add(E) to keep method bytecode size under 35 (the -XX:MaxInlineSize default value), which helps when add(E) is called in a C1-compiled loop.</p></blockquote><p>所以说，在多线程场景下使用<code>ArrayList</code>，该出现的异常，一个也不会少。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol><li><a href="https://www.howardliu.cn/arraylist-is-not-thread-safe/">如果非要在多线程中使用 ArrayList 会发生什么？</a></li><li><a href="https://www.howardliu.cn/arraylist-is-not-thread-safe-2/">如果非要在多线程中使用 ArrayList 会发生什么？（第二篇）</a></li></ol><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/arraylist-is-not-thread-safe-2/">如果非要在多线程中使用 ArrayList 会发生什么？（第二篇）</a><br>CSDN 主页：<a href="http://kanshan.csdn.net/" target="_blank" rel="noopener">http://kanshan.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.csdn.net/article/details/118346355" target="_blank" rel="noopener">如果非要在多线程中使用 ArrayList 会发生什么？（第二篇）</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      如果非要在多线程中使用 ArrayList 会发生什么？（第二篇）
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="ArrayList" scheme="https://www.howardliu.cn/tags/ArrayList/"/>
    
      <category term="线程安全" scheme="https://www.howardliu.cn/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>看山聊 Java：Date 与 LocalDate 或 LocalDateTime 互相转换</title>
    <link href="https://www.howardliu.cn/java-date-to-localdate-and-localdatetime/"/>
    <id>https://www.howardliu.cn/java-date-to-localdate-and-localdatetime/</id>
    <published>2021-06-22T14:50:46.000Z</published>
    <updated>2021-06-22T14:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/rome-6207755_1920.jpg" alt="看山聊 Java：Date 与 LocalDate 或 LocalDateTime 互相转换"></p><p>你好，我是看山。</p><p>从 Java1 到 Java8 将近 20 年，再加上 Java8 的普及时间、各种历史 API 兼容过渡时间。我们很多时候需要在旧时间 API 与新时间 API 之间切换，并行使用。今天就来说说，<code>java.util.Date</code>与<code>java.time.LocalDate/LocalDateTime</code>如何互相转换。</p><a id="more"></a><h2 id="java-util-Date转为java-time-LocalDate"><a href="#java-util-Date转为java-time-LocalDate" class="headerlink" title="java.util.Date转为java.time.LocalDate"></a><code>java.util.Date</code>转为<code>java.time.LocalDate</code></h2><p>Java8 发行的时候，也考虑到了新旧 API 之间的转换，所以在<code>java.util.Date</code>中增加了<code>toInstance()</code>方法，可以得到一个<code>Instance</code>实例。<code>Instance</code>没有时区概念，所以我们需要通过<code>atZone()</code>指定时区，得到<code>ZonedDateTime</code>实例，然后转换为<code>java.time.LocalDate</code>。如下：</p><pre><code class="java">public LocalDate convertToLocalDateViaInstant(Date dateToConvert) {    return dateToConvert.toInstant()            .atZone(ZoneId.systemDefault())            .toLocalDate();}</code></pre><p>同样的，我们也可以借助<code>Instance</code>的<code>ofEpochMilli()</code>方法创建实例。如下：</p><pre><code class="java">public LocalDate convertToLocalDateViaMilisecond(Date dateToConvert) {    return Instant.ofEpochMilli(dateToConvert.getTime())            .atZone(ZoneId.systemDefault())            .toLocalDate();}</code></pre><p>Java 中，除了<code>java.util.Date</code>，还有一个 Date 对象是<code>java.sql.Date</code>，java8 给这个类增加了一个直接转换为<code>LocalDate</code>的方法<code>toLocalDate()</code>。所以，我们也可以将<code>java.util.Date</code>转换为<code>java.sql.Date</code>，然后借助<code>toLocalDate()</code>方法。如下：</p><pre><code class="java">public LocalDate convertToLocalDateViaSqlDate(Date dateToConvert) {    return new java.sql.Date(dateToConvert.getTime()).toLocalDate();}</code></pre><h2 id="java-util-Date转为java-time-LocalDateTime"><a href="#java-util-Date转为java-time-LocalDateTime" class="headerlink" title="java.util.Date转为java.time.LocalDateTime"></a><code>java.util.Date</code>转为<code>java.time.LocalDateTime</code></h2><p><code>java.util.Date</code>是包含年月日时分秒的，转为<code>java.time.LocalDate</code>是把时分秒去掉，转为<code>java.time.LocalDateTime</code>是精度保留，转换方式完全一样，只不过要用到的是<code>toLocalDateTime()</code>方法。如下：</p><pre><code class="java">public LocalDateTime convertToLocalDateTimeViaInstant(Date dateToConvert) {    return dateToConvert.toInstant()            .atZone(ZoneId.systemDefault())            .toLocalDateTime();}public LocalDateTime convertToLocalDateTimeViaMilisecond(Date dateToConvert) {    return Instant.ofEpochMilli(dateToConvert.getTime())            .atZone(ZoneId.systemDefault())            .toLocalDateTime();}</code></pre><p><code>java.sql.Date</code>精度只有年月日，<code>java.sql.Timestamp</code>精度包含时分秒，所以还可以借助这个类的<code>toLocalDateTime()</code>方法实现转换：</p><pre><code class="java">LocalDateTime convertToLocalDateTimeViaSqlTimestamp(Date dateToConvert) {    return new java.sql.Timestamp(dateToConvert.getTime()).toLocalDateTime();}</code></pre><p>接下来，我们看看怎么从新时间 API 转旧时间 API。</p><h2 id="java-time-LocalDate转为java-util-Date"><a href="#java-time-LocalDate转为java-util-Date" class="headerlink" title="java.time.LocalDate转为java.util.Date"></a><code>java.time.LocalDate</code>转为<code>java.util.Date</code></h2><p>先来一个简单的方法，借助<code>java.sql.Date</code>的<code>valueOf()</code>方法，如下：</p><pre><code class="java">public java.util.Date convertToDateViaSqlDate(LocalDate dateToConvert) {    return java.sql.Date.valueOf(dateToConvert);}</code></pre><p><code>java.sql.Date.valueOf()</code>方法的实现也比较简单，我们也可以自己实现：</p><pre><code class="java">public static Date valueOf(LocalDate date) {    return new Date(date.getYear() - 1900,            date.getMonthValue() - 1,            date.getDayOfMonth());}</code></pre><blockquote><p>题外话：不知为何 Java8 这么偏爱<code>java.sql.Date</code>，提供了各种好用的转换方法。但是按照我的习惯，大部分时间用的都是<code>java.util.Date</code>类，是不是这个习惯得改改了。</p></blockquote><p>还有一种方式，是借助<code>java.util.Date</code>的<code>from(Instant instant)</code>方法，如下：</p><pre><code class="java">public java.util.Date convertToDateViaInstant(LocalDate dateToConvert) {    return java.util.Date.from(dateToConvert.atStartOfDay().atZone(ZoneId.systemDefault())            .toInstant());}</code></pre><h2 id="java-time-LocalDateTime转为java-util-Date"><a href="#java-time-LocalDateTime转为java-util-Date" class="headerlink" title="java.time.LocalDateTime转为java.util.Date"></a><code>java.time.LocalDateTime</code>转为<code>java.util.Date</code></h2><p>介绍两种方式。</p><p>一种是借助<code>java.sql.Timestamp</code>的<code>valueOf()</code>方法，如下：</p><pre><code class="java">public java.util.Date convertToDateViaSqlTimestamp(LocalDateTime dateToConvert) {    return java.sql.Timestamp.valueOf(dateToConvert);}</code></pre><p>另一种方式是：</p><pre><code class="java">public java.util.Date convertToDateViaInstant(LocalDateTime dateToConvert) {    return java.util.Date.from(dateToConvert.atZone(ZoneId.systemDefault())            .toInstant());}</code></pre><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>虽然 Java8 已经是行业底线，但是为了向下兼容，很多类库或者遗留代码依然保留了旧 API，不可能一夜之间替换完毕，所以我们还是会有新旧 API 的转换。本文提供几种转换方式，可供大家使用。当然，条条大路通罗马，这些方法都不是唯一的方式。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol><li><a href="https://www.howardliu.cn/java-date-and-time-intro/">Java8 中的时间类及常用 API</a></li><li><a href="https://www.howardliu.cn/java-date-to-localdate-and-localdatetime/">Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://www.howardliu.cn/java-date-time-migrating-to-jsr310/">使用 Java8 中的时间类</a></li><li><a href="https://www.howardliu.cn/java-date-string-valid-date/">检查日期字符串是否合法</a></li></ol><hr><p>你好，我是看山，10 年老猿，开源贡献者。游于码界，戏享人生。关注公众号：<a href="http://static.howardliu.cn/about/kanshanshuo.png" target="_blank" rel="noopener">看山的小屋</a>，领取学习资料。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-date-to-localdate-and-localdatetime/">看山聊 Java：Date 与 LocalDate 或 LocalDateTime 互相转换</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/118121634" target="_blank" rel="noopener">看山聊 Java：Date 与 LocalDate 或 LocalDateTime 互相转换</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      从 Java1 到 Java8 将近 20 年，再加上 Java8 的普及时间、各种历史 API 兼容过渡时间。我们很多时候需要在旧时间 API 与新时间 API 之间切换，并行使用。今天就来说说，java.util.Date 与 java.time.LocalDate/LocalDateTime 如何互相转换。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="Date" scheme="https://www.howardliu.cn/tags/Date/"/>
    
      <category term="Time" scheme="https://www.howardliu.cn/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>看山聊 Java：Java8 中的时间类及常用 API</title>
    <link href="https://www.howardliu.cn/java-date-and-time-intro/"/>
    <id>https://www.howardliu.cn/java-date-and-time-intro/</id>
    <published>2021-06-15T15:03:23.000Z</published>
    <updated>2021-06-15T15:03:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/strawberries-6165597_1920.jpg" alt="看山聊 Java：Java8 中的时间类及常用 API"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/onderortel-8618939/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6165597" target="_blank" rel="noopener">Önder Örtel</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6165597" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>年龄大的 Java 程序员都有体会，Java8 之前，Java 提供了一组时间类：<code>java.util.Date</code>、<code>java.util.Calendar</code>及其子类和工具类等。功能比较全面，最大的缺点是难用。所以很多团队直接放弃原生时间类，使用第三方的时间类库。后来，Java8 吸收了 joda-time 的优秀设计，提供了一组新的时间处理 API<code>java.time.</code>。</p><p>本文作为这个系列的第一篇，扒一扒<code>Date</code>和<code>Calendar</code>存在的问题，说说 Java8 提供的时间库是怎么解决这些问题的。后续再说一下 Java8 中<code>java.time.</code>包中的一些核心类，例如<code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>、<code>ZonedDateTime</code>、<code>Period</code>、<code>Duration</code>。</p><a id="more"></a><h2 id="老时间-API-存在的问题"><a href="#老时间-API-存在的问题" class="headerlink" title="老时间 API 存在的问题"></a>老时间 API 存在的问题</h2><ol><li>线程安全性：老的时间 API 是非线程安全的，而我们的代码都是运行在并发环境下，这样就不得不处理难以调试的并发问题，而且还需要额外的代码处理线程安全。一不小心，就会碰到一些比较诡异的错误，本地还不容易复现，比如定义了一个公用的<code>SimpleDateFormt</code>去操作时间，偶尔并发时会出错，只能通过迂回的办法实现（比如借助<code>ThreadLocal</code>）。在 Java8 中引入的新时间 API 是不可变对象，天然保证了线程安全。</li><li>API 设计和可理解性：老的时间 API 在这设计上没有一致的模型，而且日常操作功能不全。而且有一些比较让人诟病的设计，比如<code>Date</code>类的构造方法<code>public Date(int year, int month, int date)</code>，其中<code>month</code>字段取值是<code>0-11</code>，也就是按照计算机的 0 作为第一个数，但是<code>day</code>没有这种情况，取值是<code>1-31</code>，很容易搞错。新 API 以 ISO 为中心，遵循日期、时间、持续时间、时间间隔等一致的域模型，而且为时间 API 增加很多实用的工具方法。</li><li>时区处理：老的时间 API 在处理时区逻辑时比较繁琐，但是在新的 API 中，只需要通过<code>Local*</code>或<code>Zoned*</code>等类处理时区即可。</li></ol><p>下面就开始实际上手 Java8 的时间 API 了。</p><h2 id="LocalDate、LocalTime、LocalDateTime"><a href="#LocalDate、LocalTime、LocalDateTime" class="headerlink" title="LocalDate、LocalTime、LocalDateTime"></a>LocalDate、LocalTime、LocalDateTime</h2><p>这三个是最常用的几个时间类了，根据名字可以知道，这三个类是默认使用当前机器上的时区作为参考系的时间对象。也就是说，在不需要显示指定时区时，我们就可以使用这几个类。</p><h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><p><code>LocalDate</code>是 ISO 格式（yyyy-MM-dd）的日期，没有时分秒的时间数据。我们可以用它表示生日、放假等只关心日期的数据。通过<code>now</code>方法创建当前日期实例：</p><pre><code class="java">LocalDate localDate = LocalDate.now();</code></pre><p>这里是使用机器时间创建的。</p><p>我们还可以使用<code>of</code>方法或<code>parse</code>方法获取指定日期的<code>LocalDate</code>实例，比如，我们想要时间为 2021 年 6 月 11 号：</p><pre><code class="java">LocalDate.of(2021, 6, 11);LocalDate.parse(&quot;2021-06-11&quot;);</code></pre><p><code>LocalDate</code>还提供了各种实用方法来获取时间信息，接下来快速浏览一下这些 API 方法。</p><ol><li>获取明天的日期，即当前日期加一天：</li></ol><pre><code class="java">LocalDate tomorrow = LocalDate.now().plusDays(1);</code></pre><ol start="2"><li>获取上个月的今天，即当前日期并减去一个月（我们可以使用枚举单位操作数据）：</li></ol><pre><code class="java">LocalDate previousMonthSameDay = LocalDate.now().minus(1, ChronoUnit.MONTHS);`</code></pre><ol start="3"><li>解析日期“2021-06-11”，并获取周几（结果<code>DayOfWeek</code>是一个枚举类，设计很周到）：</li></ol><pre><code class="java">DayOfWeek friday = LocalDate.parse(&quot;2021-06-11&quot;).getDayOfWeek();</code></pre><ol start="4"><li>解析日期“2021-06-11”，并获取几号：</li></ol><pre><code class="java">int eleven = LocalDate.parse(&quot;2021-06-11&quot;).getDayOfMonth();</code></pre><ol start="5"><li>检查一个日期的年份是否是闰年：</li></ol><pre><code class="java">boolean leapYear = LocalDate.now().isLeapYear();</code></pre><ol start="6"><li>判断一个日期是否在另外一个日期之前：</li></ol><pre><code class="java">boolean isBefore = LocalDate.parse(&quot;2021-06-11&quot;).isBefore(LocalDate.parse(&quot;2021-06-12&quot;));</code></pre><ol start="7"><li>判断一个日期是否在另外一个日期之后：</li></ol><pre><code class="java">boolean isAfter = LocalDate.parse(&quot;2021-06-12&quot;).isAfter(LocalDate.parse(&quot;2021-06-11&quot;));</code></pre><ol start="8"><li>获取给定日期的当天开始时间，比如给定“2021-06-11”，想要获取“2021-06-11T00:00”（也就是当天的 0 点时间）：</li></ol><pre><code class="java">LocalDateTime beginningOfDay = LocalDate.parse(&quot;2021-06-11&quot;).atStartOfDay();</code></pre><ol start="9"><li>获取给定日期所在月份的的第一天，比如给定“2021-06-11”，想要获取“2021-06-01”：</li></ol><pre><code class="java">LocalDate firstDayOfMonth = LocalDate.parse(&quot;2021-06-11&quot;).with(TemporalAdjusters.firstDayOfMonth());</code></pre><h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p><code>LocalDate</code>是 ISO 格式（yyyy-MM-dd）的日期，没有时分秒的时间数据。我们可以用它表示生日、放假等只关心日期的数据。通过<code>now</code>方法创建当前日期实例：</p><p><code>LocalTime</code>提供的是没有日期数据的时间，只有时分秒数据。这个类很多方法与<code>LocalDate</code>类似，所以我们快速过一下这些 API 方法。</p><ol><li>创建当前时间</li></ol><pre><code class="java">LocalTime now = LocalTime.now();</code></pre><ol start="2"><li>解析给定的字符串时间，可以使用<code>of</code>和<code>parse</code>方法，比如下午 4:30：</li></ol><pre><code class="java">LocalTime sixty30 = LocalTime.parse(&quot;16:30&quot;);LocalTime sixty31 = LocalTime.of(16, 31);</code></pre><ol start="3"><li>解析给定字符串时间，并获取一小时后的时间实例：</li></ol><pre><code class="java">LocalTime seventy30 = LocalTime.parse(&quot;16:30&quot;).plus(1, ChronoUnit.HOURS);</code></pre><ol start="4"><li>获取给定字符串时间的小时数：</li></ol><pre><code class="java">int sixty = LocalTime.parse(&quot;16:30&quot;).getHour();</code></pre><ol start="5"><li>判断一个时间是否在另外一个时间之前：</li></ol><pre><code class="java">boolean isBeforeTime = LocalTime.parse(&quot;16:30&quot;).isBefore(LocalTime.parse(&quot;17:30&quot;));</code></pre><ol start="6"><li>判断一个时间是否在另外一个时间之后：</li></ol><pre><code class="java">boolean isAfterTime = LocalTime.parse(&quot;17:30&quot;).isAfter(LocalTime.parse(&quot;16:30&quot;));</code></pre><ol start="7"><li>常用的时间常量：</li></ol><pre><code class="java">LocalTime.MIN;// 00:00LocalTime.NOON;// 12:00LocalTime.MAX;// 23:59:59.999999999LocalTime.MIDNIGHT;// 00:00</code></pre><h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>顾名思义，<code>LocalDateTime</code>表示日期和时间的组合。有了前两个类做铺垫，这个类也是很类似的操作。</p><ol><li>创建当前时间</li></ol><pre><code class="java">LocalDateTime.now();</code></pre><ol start="2"><li>解析给定的字符串时间，可以使用<code>of</code>和<code>parse</code>方法，比如 2021 年 6 月 11 日 16 点 30 分：</li></ol><pre><code class="java">LocalDateTime.of(2021, Month.JUNE, 11, 16, 30);LocalDateTime.parse(&quot;2021-06-11T16:30:00&quot;);// 注意这个时间格式，这种写法属于 UTC 时间格式，后续再开文说一下时间格式的话题。</code></pre><p>其他与<code>LocalDate</code>和<code>LocalTime</code>类似的 API，比如<code>plusDays</code>、<code>MinsHours</code>、<code>getMonth</code>等。我们可以把<code>LocalDateTime</code>理解为<code>LocalDate</code>和<code>LocalTime</code>的合体。</p><p><code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>处理的都是当前系统所在时区的日期时间数据，有时候我们还需要处理特定时区的日期和时间，Java8 提供了<code>ZonedDateTime</code>，接下来我们说说这个类。</p><h2 id="ZonedDateTime"><a href="#ZonedDateTime" class="headerlink" title="ZonedDateTime"></a>ZonedDateTime</h2><p><code>ZonedDateTime</code>的使用需要配合<code>ZoneId</code>，<code>ZoneId</code>表示不同区域的标识符，在<code>${JAVA_HOME}/lib/tzdb.dat</code>文件中存放了默认的区域标识符，如果没有特别定义，需要是文件中指定的数据才能获取到<code>ZoneId</code>实例。</p><p>我们来创建我天朝的区域：<code>ZoneId zoneId = ZoneId.of(&quot;Asia/Shanghai&quot;);</code>。</p><p>如果不知道有哪些区域，可以通过<code>Set&lt;String&gt; allZoneIds = ZoneId.getAvailableZoneIds();</code>获取，我当前 jdk 版本是 jdk1.8.0_202，一共有 599 个区域标识。</p><p>我们对比我朝与漂亮国的时间，获取当前时间：</p><pre><code class="java">ZonedDateTime.now();// 2021-06-11T17:49:53.400+08:00[Asia/Shanghai]ZonedDateTime.now(ZoneId.systemDefault());// 2021-06-11T17:49:53.400+08:00[Asia/Shanghai]ZonedDateTime.now(ZoneId.of(&quot;America/New_York&quot;));// 2021-06-11T05:49:53.400-04:00[America/New_York]</code></pre><p>可以看到，<code>now</code>方法不传参数与使用当前时区参数结果一致，使用漂亮国时区时，在小时上有区别，但是两个时间，都是指当前时间。我们可以通过指定<code>ZoneId</code>获取不同时区的结果：</p><pre><code class="java">final ZonedDateTime newyorkZonedDateTime = ZonedDateTime.now(ZoneId.of(&quot;America/New_York&quot;));// 2021-06-11T05:57:00.655-04:00[America/New_York]final ZonedDateTime shanghaiZonedDateTime = newyorkZonedDateTime.withZoneSameInstant(ZoneId.of(&quot;Asia/Shanghai&quot;));// 2021-06-11T17:57:00.655+08:00[Asia/Shanghai]final ZonedDateTime shanghaiZonedDateTime2 = ZonedDateTime.now(ZoneId.of(&quot;Asia/Shanghai&quot;));// 2021-06-11T17:58:34.221+08:00[Asia/Shanghai]</code></pre><p>可以看到，我们直接获取北京时间与通过漂亮国时间转换为北京时间，结果是一样的。</p><p>这里有一点需要提醒，这点是我朝程序员容易忽略的。那就是夏令时，我国没有夏令时，但是国外有些国家使用夏令时。所以在处理时间的时候，我们最好不要通过手动加减时区差来计算时间，这样很容易忽略夏令时。</p><h2 id="Period、Duration"><a href="#Period、Duration" class="headerlink" title="Period、Duration"></a>Period、Duration</h2><p>这两个类都是表示时间量，也就是时间段。不过，<code>Period</code>类以年、月、日这种比较大的单位表示时间量，<code>Duration</code>类以秒、纳秒这种相对较小的单位表示时间量。</p><h3 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h3><p><code>Period</code>表示的单位是年或月或日这种相对大一些的单位。我们可以用它来增减时间，或者计算两个时间间的时间差。</p><p>比如，我们以 2021 年 6 月 15 日为基准，计算 5 天后的日期：</p><pre><code class="java">LocalDate initialDate = LocalDate.parse(&quot;2021-06-15&quot;);LocalDate finalDate = initialDate.plus(Period.ofDays(5));// 2021-06-20</code></pre><p><code>Period</code>提供了<code>ofYears</code>、<code>ofMonths</code>、<code>ofWeeks</code>、<code>ofDays</code>、<code>of</code>等方法，可以随情况处理时间。</p><p>除了锚定的特定时间，<code>Period</code>还可以计算两个日期之间的时间差。比如：</p><pre><code class="java">LocalDate initialDate = LocalDate.parse(&quot;2021-06-15&quot;);final LocalDate newDate = initialDate.plus(Period.of(1, 2, 3));final Period period = Period.between(initialDate, newDate);int years = period.getYears();// 1int months = period.getMonths();// 2int days = period.getDays();// 3</code></pre><p>这里需要注意一下，这三个方法是两个单位同单位的差，不会进行换算。我们可以借助<code>ChronoUnit</code>实现单位换算状态下的结果：</p><pre><code class="java">long allYears = ChronoUnit.YEARS.between(initialDate, newDate);// 1long allMonths = ChronoUnit.MONTHS.between(initialDate, newDate);// 14long allDays = ChronoUnit.DAYS.between(initialDate, newDate);// 429</code></pre><p><code>ChronoUnit</code>是借助<code>Duration</code>实现的，所以最细粒度可以到纳秒。</p><h3 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h3><p><code>Duration</code>可以表示的单位是天、小时、分、秒、毫秒、纳秒，其内部结果是通过秒、纳秒进行存储的，其他可表示的单位，都是通过这两个单位组合实现的。比如，一分钟等于 3600 秒，那内部存储就是 3600 秒 0 纳秒；1 毫秒等于 1000000 纳秒，内部存储就是 0 秒 1000000 纳秒。</p><p><code>Duration</code>用法与<code>Period</code>类似。比如，我们给 21 点 03 分 15 秒加 30 秒：</p><pre><code class="java">LocalTime initialTime = LocalTime.parse(&quot;21:02:15&quot;);LocalTime finalTime = initialTime.plus(Duration.ofSeconds(30));// 21:02:45</code></pre><p><code>Duration</code>也可以计算两个时间之间的时间差，只是单位较小一些，比如：</p><pre><code class="java">LocalTime initialTime = LocalTime.parse(&quot;21:02:15&quot;);LocalTime newTime = LocalTime.of(21, 02, 20);Duration duration = Duration.between(initialTime, newTime);long seconds = duration.getSeconds();// 5int nano = duration.getNano();// 0</code></pre><p>同样的，我们可以借助<code>ChronoUnit</code>实现更多单位的时间差，这里不做赘述。</p><h2 id="从老时间-API-创建"><a href="#从老时间-API-创建" class="headerlink" title="从老时间 API 创建"></a>从老时间 API 创建</h2><p>Java8 提供了<code>toInstant()</code>方法，可以将老时间 API 的<code>Date</code>和<code>Calendar</code>转换为新的对象：</p><pre><code class="java">Date date = new Date();LocalDateTime localDateTime = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());Calendar calendar = GregorianCalendar.getInstance();LocalDateTime localDateTime1 = LocalDateTime.ofInstant(calendar.toInstant(), ZoneId.systemDefault());</code></pre><h2 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h2><p>Java8 提供了易于使用的时间格式化 API，这里简单说下。比如：</p><pre><code class="java">LocalDateTime localDateTime = LocalDateTime.of(2021, Month.JUNE, 15, 21, 23);String localDateString = localDateTime.format(DateTimeFormatter.ISO_DATE);// 2021-06-15</code></pre><p>与老时间 API 一样，我们可以指定格式：</p><pre><code class="java">localDateTime.format(DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd&quot;));</code></pre><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>从 Java7 到 Java8，提供了很多特性，除了 Lambda 表达式，时间 API 绝对也是良心功能了。而且从发布到现在已经过去这么多年，我们还是要与时俱进，逐渐使用优秀的 API 替换老 API 了。如果还在用 Java7 或者 Java6，然后还想使用 Java8 这种时间 API，这里推荐两个第三方库：<code>threetenbp</code>和<code>joda-time</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/eugenp/tutorials/tree/master/core-java-modules/core-java-8-datetime" target="_blank" rel="noopener">core-java-8-datetime</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1303904694304801" target="_blank" rel="noopener">ZonedDateTime</a></li></ul><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol><li><a href="https://www.howardliu.cn/java-date-and-time-intro/">Java8 中的时间类及常用 API</a></li><li><a href="https://www.howardliu.cn/java-date-to-localdate-and-localdatetime/">Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://www.howardliu.cn/java-date-time-migrating-to-jsr310/">使用 Java8 中的时间类</a></li><li><a href="https://www.howardliu.cn/java-date-string-valid-date/">检查日期字符串是否合法</a></li></ol><hr><p>你好，我是看山，10 年老猿，开源贡献者。游于码界，戏享人生。关注公众号：<a href="http://static.howardliu.cn/about/kanshanshuo.png" target="_blank" rel="noopener">看山的小屋</a>，领取学习资料。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-date-and-time-intro/">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/117945803" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文作为这个系列的第一篇，扒一扒 Date 和 Calendar 存在的问题，说说 Java8 提供的时间库是怎么解决这些问题的。后续再说一下 Java8 中 java.time 包中的一些核心类，例如 LocalDate、LocalTime、LocalDateTime、ZonedDateTime、Period、Duration。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Date" scheme="https://www.howardliu.cn/tags/Date/"/>
    
      <category term="Time" scheme="https://www.howardliu.cn/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>程序员进阶书单2021版</title>
    <link href="https://www.howardliu.cn/lists-book-recommendations-2021/"/>
    <id>https://www.howardliu.cn/lists-book-recommendations-2021/</id>
    <published>2021-06-08T14:18:46.000Z</published>
    <updated>2021-06-08T14:18:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/woman-6175010_1920.jpg" alt="程序员进阶书单2021版"></p><p>你好，我是看山。</p><p>今天列一下技术相关的书单，本文是第一版，后续持续更新。</p><a id="more"></a><blockquote><p>文中提到的部分书目我也没有读过，作为todo list，明确接下来一段时间的学习方向。</p></blockquote><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>因为本人属于Java栈，所以主要推荐的还是属于Java领域内的书目。</p><ul><li><a href="https://book.douban.com/subject/34898994/" target="_blank" rel="noopener">《Java核心技术：卷I 基础知识》</a>：本书由拥有20多年教学与研究经验的资深Java技术专家撰写（获Jolt大奖），是程序员的优选Java指南。无论是Java初学者还是有一定经验的Java工程师，这是一本非常不错的值得时常翻阅的技术手册。</li><li><a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">《Java编程思想》</a>：从Java的基础语法到最高级特性（深入的面向对象概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握。属于经典书目，可能很多Java栈的程序猿，都是从这本书开始的。</li><li><a href="https://book.douban.com/subject/30133440/" target="_blank" rel="noopener">《Java编程的逻辑》</a>：Java专家撰写，力求透彻讲解每个知识点，逐步建立编程知识图谱。本书以Java语言为例，由基础概念入手，到背后实现原理与逻辑，再到应用实践，融会贯通。</li><li><a href="https://book.douban.com/subject/30412517/" target="_blank" rel="noopener">《Effective Java》</a>：模仿《Effective C++》而成，一共包含90个条目，每个条目讨论Java程序设计中的一条规则。这些规则反映了最有经验的优秀程序员在实践中常用的一些有益的做法。前人的经验之作，想要升阶，这本书一定绕不开。最好是看第三版的，增加了Java 8的规则。</li><li><a href="https://book.douban.com/subject/2000732/" target="_blank" rel="noopener">《Head First Java》</a>：完整的面向对象（object-oriented，OO）程序设计和Java的学习指导。此书是根据学习理论所设计的，让你可以从学习程序语言的基础开始一直到包括线程、网络与分布式程序等项目。最重要的，你会学会如何像个面向对象开发者一样去思考。而且不只是读死书，你还会玩游戏、拼图、解谜题以及以意想不到的方式与Java交互。在这些活动中，你会写出一堆真正的Java程序，包括了一个船舰炮战游戏和一个网络聊天程序。</li><li><a href="https://book.douban.com/subject/10484692/" target="_blank" rel="noopener">《Java并发编程实战》</a>：深入浅出地介绍了Java线程和并发，是一本完美的Java并发参考手册。书中从并发性和线程安全性的基本概念出发，介绍了如何使用类库提供的基本并发构建块，用于避免并发危险、构造线程安全的类及验证线程安全的规则，如何将小的线程安全类组合成更大的线程安全类，如何利用线程来提高并发应用程序的吞吐量，如何识别可并行执行的任务，如何提高单线程子系统的响应性，如何确保并发程序执行预期任务，如何提高并发代码的性能和可伸缩性等内容，最后介绍了一些高级主题，如显式锁、原子变量、非阻塞算法以及如何开发自定义的同步工具类。</li><li><a href="https://book.douban.com/subject/26740520/" target="_blank" rel="noopener">《Java性能权威指南》</a>：通过使用JVM和Java平台，以及Java语言和应用程序接口，本书详尽讲解了Java性能调优的相关知识，帮助读者深入理解Java平台性能的各个方面，最终使程序如虎添翼。</li><li><a href="https://book.douban.com/subject/34879022/" target="_blank" rel="noopener">《Java系统性能优化实战》</a>：基于作者在实际工作中遇到的与系统相关的问题及解决之道，通过改善代码来提高系统性能，解决因为代码导致的系统故障。国人写的新书也很好，一些细节，一些过时的传言，作者都用jmh给测了。</li><li><a href="https://book.douban.com/subject/35258148/" target="_blank" rel="noopener">《Java性能优化实践：JVM调优策略、工具与技巧》</a>：本书从实验科学的角度探讨了Java性能优化的方方面面，重点阐述了最新的实用JVM性能调优策略、工具和技巧。通过本书，我们不仅可以了解Java原理和技术如何充分利用现代硬件和操作系统、衡量Java性能的陷阱以及微基准测试的弊端有哪些，还能深入研究可能使团队烦恼的几种性能测试和常见反模式、JVM垃圾收集、JIT编译和Java语言性能技术等。</li><li><a href="https://book.douban.com/subject/34949443/" target="_blank" rel="noopener">《Spring实战》</a>：一本经典而实用的畅销Spring 学习指南。</li><li><a href="https://book.douban.com/subject/26857423/" target="_blank" rel="noopener">《SpringBoot实战》</a>：Spring应用程序开发为中心，全面讲解如何运用Spring Boot提高效率，使应用程序的开发和管理更加轻松有趣。</li><li><a href="https://book.douban.com/subject/26952826/" target="_blank" rel="noopener">《精通Spring 4.x》</a>：虽然现在都已经是Spring 5.x了，但是Spring的基础并没有变，本书把应用和原理都讲的很透彻，IoC和AOP分析的很棒，娓娓道来。</li><li><a href="https://book.douban.com/subject/34907497/" target="_blank" rel="noopener">《深入理解Java虚拟机》</a>：这是一部从工作原理和工程实践两个维度深入剖析JVM的著作，是计算机领域公认的经典。</li><li><a href="https://book.douban.com/subject/34441840/" target="_blank" rel="noopener">《实战Java虚拟机：JVM故障诊断与性能优化》</a>：本书将通过200余个示例详细介绍JVM中的各种参数配置、故障排查、性能监控及性能优化，帮助Java人突破瓶颈。</li><li><a href="https://book.douban.com/subject/34812818/" target="_blank" rel="noopener">《新一代垃圾回收器ZGC设计与实现》</a>：有了ZGC，就忘记CMS，G1什么的吧。ZGC 所针对的是这些在未来普遍存在的大容量内存：TB 级别的堆容量，具有很低的停顿时间（小于 10 毫秒），对整体应用性能的影响也很小（对吞吐量的影响低于 15％）。ZGC 所采用的机制也可以在未来进行扩展，以支持一些令人兴奋的特性，如多层堆（用于热对象的 DRAM 和用于低频访问对象的 NVMe 闪存）。</li><li><a href="https://book.douban.com/subject/35079283/" target="_blank" rel="noopener">《深入理解JVM字节码》</a>：这是一本揭示JVM字节码“黑科技”的著作，它从原理和应用两个维度深入剖析了JVM字节码。书中内容涉及JVM字节码的大部分应用场景，如Java性能优化、软件防护与破解、APM等，通过大量实战案例讲解了它在这些场景中的实操技巧。</li><li><a href="https://book.douban.com/subject/34895968/" target="_blank" rel="noopener">《Java实战》</a>：现代Java应用充分利用了微服务、反应式架构以及流式数据等创新设计。现代Java特性，譬如Lambda、流以及大家期待已久的Java模块系统让这些设计的实现极其便利。是时候更新技能工具箱了，只有这样，你才能从容应对迎面而来的种种挑战！</li><li><a href="https://book.douban.com/subject/26772632/" target="_blank" rel="noopener">《Java8实战》</a>：本书全面介绍了Java 8 这个里程碑版本的新特性，包括Lambdas、流和函数式编程。有了函数式的编程特性，可以让代码更简洁，同时也能自动化地利用多核硬件。</li><li><a href="https://book.douban.com/subject/30358019/" target="_blank" rel="noopener">《实战Java高并发程序设计》</a>：主要介绍基于Java的并行程序设计基础、思路、方法和实战。第一，立足于并发程序基础，详细介绍Java进行并行程序设计的基本方法。第二，进一步详细介绍了JDK对并行程序的强大支持，帮助读者快速、稳健地进行并行程序开发。第三，详细讨论了“锁”的优化和提高并行程序性能级别的方法和思路。第四，介绍了并行的基本设计模式，以及Java 8/9/10对并行程序的支持和改进。第五，介绍了高并发框架Akka的使用方法。第六，详细介绍了并行程序的调试方法。第七，分析Jetty代码并给出一些其在高并发优化方面的例子。</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li><a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener">《深入理解计算机系统》</a>：这本书是程序员必读的一本书，这本书最大的优点是为程序员描述计算机系统的实现细节，帮助其在大脑中构造一个层次型的计算机系统。从最底层的数据在内存中的表示到流水线指令的构成，到虚拟存储器，到编译系统，到动态加载库，到最后的用户态应用。通过掌握程序是如何映射到系统上，以及程序是如何执行的，你能够更好的理解程序的行为为什么是这样的，以及效率底下是如何造成的。</li><li><a href="https://book.douban.com/subject/30280001/" target="_blank" rel="noopener">《计算机网络》</a>：经典的计算机网络教材，采用作者独创的自顶向下方法来讲授计算机网络的原理及其协议。</li><li><a href="https://book.douban.com/subject/25900403/" target="_blank" rel="noopener">《UNIX环境高级编程》</a>：UNIX编程“圣经”</li><li><a href="https://book.douban.com/subject/26434583/" target="_blank" rel="noopener">《UNIX网络编程：卷1》</a>：UNIX编程“圣经”</li><li><a href="https://book.douban.com/subject/4118577/" target="_blank" rel="noopener">《UNIX网络编程：卷2》</a>：UNIX编程“圣经”。可以看到，三本圣经，都是大部头很难啃的书，比较枯燥。修行路就是比较枯燥的。</li><li><a href="https://book.douban.com/subject/26825411/" target="_blank" rel="noopener">《TCP/IP详解 卷1：协议》</a>：本书内容丰富、概念清晰、论述详尽，适合任何希望理解TCP/IP协议实现的人阅读，更是TCP/IP领域研究人员和开发人员的权威参考书。无论是初学者还是功底深厚的网络领域高手，本书都是案头必备。</li><li><a href="https://book.douban.com/subject/30387220/" target="_blank" rel="noopener">《Wireshark数据包分析实战》</a>：从数据包分析与数据包嗅探器的基础知识开始，循序渐进地介绍Wireshark的基本使用方法及其数据包分析功能特性，同时还介绍了针对不同协议层与无线网络的具体实践技术与经验技巧。在此过程中，作者结合大量真实的案例，图文并茂地演示使用Wireshark进行数据包分析的技术方法，使读者能够顺着本书思路逐步掌握网络数据包嗅探与分析技能。</li><li><a href="https://book.douban.com/subject/30359954/" target="_blank" rel="noopener">《鸟哥的Linux私房菜：基础学习篇》</a>：讲解细致，深入浅出。可以对计算机和操作系统，以及Linux有一个非常全面的了解，并能够管理或者操作好一个Linux系统。</li><li><a href="https://book.douban.com/subject/27096665/" target="_blank" rel="noopener">《现代操作系统》</a>：这本书是操作系统领域的经典之作，书中集中讨论了操作系统的基本原理，包括进程、线程、存储管理、文件系统、输入/输出、死锁等，同时还包含了有关计算机安全、多媒体操作系统、掌上计算机操作系统、微内核、多核处理器上的虚拟机以及操作系统设计等方面的内容。</li><li><a href="https://book.douban.com/subject/1148282/" target="_blank" rel="noopener">《计算机程序的构造和解释》</a>：在过去的二十多年里，对于计算机科学的教育计划产生了深刻的影响。</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li><a href="https://book.douban.com/subject/3354490/" target="_blank" rel="noopener">《MySQL必知必会》</a>：书中从介绍简单的数据检索开始，逐步深入一些复杂的内容，包括联结的使用、子查询、正则表达式和基于全文本的搜索、存储过程、游标、触发器、表约束，等等。</li><li><a href="https://book.douban.com/subject/24250054/" target="_blank" rel="noopener">《SQL必知必会》</a>：本书是深受世界各地读者欢迎的SQL经典畅销书，内容丰富，文字简洁明快，针对Oracle、SQL Server、MySQL、DB2、PostgreSQL、SQLite等各种主流数据库提供了大量简明的实例。与其他同类图书不同，它没有过多阐述数据库基础理论，而是专门针对一线软件开发人员，直接从SQL SELECT开始，讲述实际工作环境中最常用和最必需的SQL知识，实用性极强。</li><li><a href="https://book.douban.com/subject/10548379/" target="_blank" rel="noopener">《数据库系统概念》</a>：本书是数据库系统方面的经典教材之一，其内容由浅入深，既包含数据库系统基本概念，又反映数据库技术新进展。它被国际上许多著名大学所采用，包括斯坦福大学、耶鲁大学、得克萨斯大学、康奈尔大学、伊利诺伊大学等。</li></ul><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><ul><li><a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">《算法》</a>：算法领域的经典参考书。不但全面介绍了关于算法和数据结构的必备知识，还给出了每位程序员应知应会的50个算法，并提供了实际代码。最不错的是，其深入浅出的算法介绍，让一些比较难的算法也变得容易理解。其中，还有大量的图解，详尽的代码和讲解。</li><li><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">《算法图解》</a>：本书示例丰富，图文并茂，以让人容易理解的方式阐释了算法，旨在帮助程序员在日常项目中更好地发挥算法的能量。</li><li><a href="https://book.douban.com/subject/20432061/" target="_blank" rel="noopener">《算法导论》</a>：本书将严谨性和全面性融为一体，深入讨论各类算法，并着力使这些算法的设计和分析能为各个层次的读者接受。全书各章自成体系，可以作为独立的学习单元；算法以英语和伪代码的形式描述，具备初步程序设计经验的人就能看懂；说明和解释力求浅显易懂，不失深度和数学严谨性。</li><li><a href="https://book.douban.com/subject/26302533/" target="_blank" rel="noopener">《编程珠玑》</a>：历史上最伟大的计算机科学著作之一。在书中，作者选取许多具有典型意义的复杂编程和算法问题，生动描绘了历史上众大师们在探索解决方案中发生的轶事、走过的弯路和不断精益求精的历程，引导读者像真正的程序员和软件工程师那样富于创新性地思考，并透彻阐述和总结了许多独特而精妙的设计原则、思考和解决问题的方法以及实用程序设计技巧。解决方案的代码均以C/C++语言编写，不仅有趣，而且有很大的实战示范意义。每章后所附习题极具挑战性和启发性，书末给出了简洁的解答。</li><li><a href="https://book.douban.com/subject/3351237/" target="_blank" rel="noopener">《数据结构与算法分析：Java语言描述》</a>：是国外数据结构与算法分析方面的经典教材，使用卓越的Java编程语言作为实现工具讨论了数据结构（组织大量数据的方法）和算法分析（对算法运行时间的估计）。</li></ul><h2 id="编程素养"><a href="#编程素养" class="headerlink" title="编程素养"></a>编程素养</h2><ul><li><a href="https://book.douban.com/subject/4199741/" target="_blank" rel="noopener">《代码整洁之道》</a>：代码质量与其整洁度成正比。干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好基础。作为编程领域的佼佼者，本书作者给出了一系列行之有效的整洁代码操作实践。这些实践在本书中体现为一条条规则（或称“启示”），并辅以来自现实项目的正、反两面的范例。只要遵循这些规则，就能编写出干净的代码，从而有效提升代码质量。</li><li><a href="https://book.douban.com/subject/35006892/" target="_blank" rel="noopener">《程序员修炼之道》</a>：由一系列的独立的部分组成，涵盖的主题从个人责任、职业发展，直到用于使代码保持灵活、并且易于改编和复用的各种架构技术。</li><li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">《重构 改善既有代码的设计》</a>：重构，一言以蔽之，就是在不改变外部行为的前提下，有条不紊地改善代码。多年前，正是本书原版的出版，使重构终于从编程高手们的小圈子走出，成为众多普通程序员日常开发工作中不可或缺的一部分。本书也因此成为与《设计模式》齐名的经典著作，被译为中、德、俄、日等众多语言，在世界范围内畅销不衰。</li><li><a href="https://book.douban.com/subject/1052241/" target="_blank" rel="noopener">《设计模式》</a>：这本书结合设计实作例从面向对象的设计中精选出23个设计模式，总结了面向对象设计中最有价值的经验，并且用简洁可复用的形式表达出来。书中分类描述了一组设计良好、表达清楚的软件设计模式，这些模式在实用环境下特别有用。此书适合大学计算机专业的学生、研究生及相关人员参考。</li><li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">《Head First 设计模式》</a>：一本设计模式入门书籍，用实际的编程案例讲解算法设计中会遇到的各种问题和需求变更，并以此逐步推导出良好的设计模式解决办法。</li><li><a href="https://book.douban.com/subject/35157817/" target="_blank" rel="noopener">《设计模式就该这样学：基于经典框架源码和真实业务场景》</a>：本书从软件架构设计必备的通用技能UML开始，重点介绍常用的类图和时序图；然后介绍软件架构设计常用的七大原则；接着结合JDK、Spring、MyBatis、Tomcat、Netty等经典框架源码对GoF的23种设计模式展开分析，并结合作者多年“踩坑填坑”和“教学答疑”经验，用深刻、全面、通俗、生动、有趣、接地气的方式结合真实业务场景分析每种设计模式，治愈“设计模式选择困难症”；之后介绍4种常用的新设计模式；最后总结软件架构、设计模式与应用框架之间的区别。</li><li><a href="https://book.douban.com/subject/1477390/" target="_blank" rel="noopener">《代码大全》</a>：一本完整的软件构建手册，涵盖了软件构建过程中的所有细节。它从软件质量和编程思想等方面论述了软件构建的各个问题，并详细论述了紧跟潮流的新技术、高屋建瓴的观点、通用的概念，还含有丰富而典型的程序示例。这本书中所论述的技术不仅填补了初级与高级编程技术之间的空白，而且也为程序员们提供了一个有关编程技巧的信息来源。这本书对经验丰富的程序员、技术带头人、自学的程序员及几乎不懂太多编程技巧的学生们都是大有裨益的。可以说，无论是什么背景的读者，阅读这本书都有助于在更短的时间内、更容易地写出更好的程序。</li><li><a href="https://book.douban.com/subject/35088343/" target="_blank" rel="noopener">《编程的原则：改善代码质量的101个方法》</a>：本书介绍了软件开发领域101个重要的编程原则，涉及编程中的永恒真理，指导方针，编程思想，程序员的视角、习惯和工具，以及编程的反模式等内容。书中以“这个原则是什么”“为什么要遵循这个原则”“具体应该怎么做”为中心，对各个原则进行介绍，简明扼要，通俗易懂。这些原则凝聚了前人的智慧，经过了历史的考验，是指导程序员改善代码、进一步提升编程能力的实用指南。</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li><a href="https://book.douban.com/subject/30443578/" target="_blank" rel="noopener">《软件架构设计》</a>：围绕软件架构设计，系统化地梳理技术架构与业务架构的方法论与实践。</li><li><a href="https://book.douban.com/subject/35217473/" target="_blank" rel="noopener">《架构师修炼之道：思维、方法与实践》</a>：作者结合多年的架构学习和项目开发经验，总结出一套架构学习的体系，从技术方法、思维意识、工具等方面讲解做好互联网后端架构设计的相关知识。通过相关知识的学习，读者能够掌握设计稳定、易维护、易扩展的软件架构的方法，也能够提升日常维护已有项目的能力。书中讲解的技术方法具有通用性，在其他非互联网行业的软件开发中，也具有借鉴意义。</li><li><a href="https://book.douban.com/subject/34960995/" target="_blank" rel="noopener">《发布！设计与部署稳定的分布式系统》</a>：作者根据自己的亲身经历和某些大型企业的案例，讲述了如何创建高稳定性的软件系统，分析了设计和实现中导致系统出现问题的原因。</li><li><a href="https://book.douban.com/subject/35178755/" target="_blank" rel="noopener">《可伸缩架构：云环境下的高可用与风险管理》</a>：一本关于现代化软件架构的书。书中介绍了如何构建和更新你的关键应用程序来满足日益苛刻的数字化客户的需求。书中还介绍了如何实现高可用性，如何使用现代化的开发和运维技术来架构应用程序，如何组织开发团队帮助应用程序和业务获得成功，如何将系统扩展到最大规模，以及如何利用云计算的可用资源来迎接上述挑战。</li><li><a href="https://book.douban.com/subject/35030121/" target="_blank" rel="noopener">《携程架构实践》</a>：本书浓缩了携程公司的整个技术架构，可以帮助读者了解支撑一家大型企业所需要的核心技术产品，以及它们的架构和面临的挑战。</li><li><a href="https://book.douban.com/subject/35062026/" target="_blank" rel="noopener">《架构师应该知道的37件事》</a>：本书汇集了一名架构师20多年来在全球各大企业任职的经验，共分为5个部分，分别对应在帮助大型企业进行IT转型的过程中，首席架构师必须高效处理的5个方面：企业或IT架构师的角色和能力、架构工作在大型企业中的价值、与各种干系人的沟通、对组织结构和系统的理解、对传统组织进行转型。本书科学而系统地归纳出软件架构师应该具备的完整能力模型，不仅帮助软件开发人员系统地学习如何掌握这37项技能，而且还能让他们进一步理解软件架构师的角色和本质，使他们最终突破技术“天花板”，成为一名合格的软件架构师。</li><li><a href="https://book.douban.com/subject/26772677/" target="_blank" rel="noopener">《微服务设计》</a>：本书全面介绍了微服务的建模、集成、测试、部署和监控，通过一个虚构的公司讲解了如何建立微服务架构。</li><li><a href="https://book.douban.com/subject/35092430/" target="_blank" rel="noopener">《微服务治理：体系、架构及实践》</a>：在微服务技术流行的当下，企业在实施微服务架构的时候，会对整个研发体系，包括开发、运维、团队组织、协同都带来冲击。因此必须构建起一整套以服务治理为核心、从线下到线上的新的能力体系来支撑这套新的架构技术，否则很难保证微服务架构的顺畅落地。 本书是作者多年服务治理经验总结，希望能够给仍在（微）服务治理迷局中夺路狂奔的计算机技术人员一点启发和指引。</li><li><a href="https://book.douban.com/subject/34801161/" target="_blank" rel="noopener">《企业级业务架构设计：方法论与实践》</a>：作者是一位资深的业务架构师，在金融行业工作超过19年，有丰富的大规模复杂金融系统业务架构设计和落地实施经验。作者在书中倡导“知行合一”的业务架构思想，全书内容围绕“行线”和“知线”两条主线展开。“行线”涵盖企业级业务架构的战略分析、架构设计、架构落地、长期管理的完整过程，“知线”则重点关注架构方法论的持续改良。</li><li><a href="https://book.douban.com/subject/30333919/" target="_blank" rel="noopener">《架构整洁之道》</a>：创造“Clean神话”的Bob大叔在架构领域的登峰之作，围绕“架构整洁”这一重要导向，系统地剖析其缘起、内涵及应用场景，涵盖软件研发完整过程及所有核心架构模式。</li><li><a href="https://book.douban.com/subject/26819666/" target="_blank" rel="noopener">《领域驱动设计：软件核心复杂性应对之道》</a>：全书围绕着设计和开发实践，结合若干真实的项目案例，向读者阐述如何在真实的软件开发中应用领域驱动设计。书中给出了领域驱动设计的系统化方法，并将人们普遍接受的一些最佳实践综合到一起，融入了作者的见解和经验，展现了一些可扩展的设计最佳实践、已验证过的技术以及便于应对复杂领域的软件项目开发的基本原则。</li></ul><h2 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h2><ul><li><a href="https://book.douban.com/subject/6862062/" target="_blank" rel="noopener">《持续交付：发布可靠软件的系统方法》</a>：讲述如何实现更快、更可靠、低成本的自动化软件交付，描述了如何通过增加反馈，并改进开发人员、测试人员、运维人员和项目经理之间的协作来达到这个目标。</li><li><a href="https://book.douban.com/subject/30419555/" target="_blank" rel="noopener">《持续交付2.0》</a>：本书重新定义了“持续交付”，增补了组织管理和系统架构两个维度，并辅助以真实案例，对诸多持续交付原则与实践加以解读，并对持续交付过程中的实践取舍之道加以论述。</li><li><a href="https://book.douban.com/subject/26979886/" target="_blank" rel="noopener">《学习敏捷：构建高效团队》</a>：本书以敏捷软件开发为中心，系统阐述了敏捷原则和实践的先进理念和重要意义，并分别讲解了Scrum、极限编程、精益和看板四套敏捷实践的应用。作者从开发团队的日常困境入手，用讲故事的形式展开问题，由表及里，层层讲解，并在每一章最后附上参考书，便于读者进一步查找学习。本书内容生动，语言通俗易懂，集趣味性和实用性于一体，是学习敏捷开发、提升团队效率的极佳参考书。</li><li><a href="https://book.douban.com/subject/26875239/" target="_blank" rel="noopener">《SRE: Google运维解密》</a>：Google SRE的关键成员解释了他们是如何对软件进行生命周期的整体性关注的，以及为什么这样做能够帮助Google成功地构建、部署、监控和运维世界上现存最大的软件系统。</li><li><a href="https://book.douban.com/subject/30219010/" target="_blank" rel="noopener">《进化：运维技术变革与实践探索》</a>：本书依托作者在电信和互联网行业多年的从业经历，结合一线实际工作实践，从应用生命周期的视角，全面详细地介绍了分布式架构体系下，应用运维体系建设的方方面面，涵盖了体系建设方法论指导、持续交付体系建设思路和实践、稳定性体系规划建设，以及故障的科学管理方法等内容，视角新颖且独特，换一个角度看运维，能够带给读者不一样的思考方式。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>左耳朵耗子在《程序员练级攻略》推荐的必读书籍清单，关注【公众号：看山的小屋】，回复“左耳”领取。如果想要付费订阅《左耳听风》，可以点<a href="http://gk.link/a/10sq6" target="_blank" rel="noopener">这里</a>，购买成功的话在公众号留言找我返现。</li><li><a href="https://mp.weixin.qq.com/s/U6CMqnT074__x8BFbZy0_w" target="_blank" rel="noopener">江南白衣的书单</a></li></ul><hr><p>你好，我是看山，公众号：<a href="http://static.howardliu.cn/about/kanshanshuo.png" target="_blank" rel="noopener">看山的小屋</a>，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/lists-book-recommendations-2021/">程序员进阶书单2021版</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/117727787" target="_blank" rel="noopener">程序员进阶书单2021版</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      今天列一下技术相关的书单，本文是第一版，后续持续更新。
    
    </summary>
    
    
      <category term="书单" scheme="https://www.howardliu.cn/categories/%E4%B9%A6%E5%8D%95/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="书单" scheme="https://www.howardliu.cn/tags/%E4%B9%A6%E5%8D%95/"/>
    
      <category term="技术成长" scheme="https://www.howardliu.cn/tags/%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>Geek 青年说北京沙龙分享</title>
    <link href="https://www.howardliu.cn/geek-talk-20210523/"/>
    <id>https://www.howardliu.cn/geek-talk-20210523/</id>
    <published>2021-05-31T06:28:34.000Z</published>
    <updated>2021-05-31T06:28:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/hybrid-6274156_1920.jpg" alt="Geek 青年说北京沙龙分享"></p><p>你好，我是看山。</p><p>5 月 23 号参加了 infoQ 写作平台组织的线下沙龙，瞻仰了很多大佬的英姿。在 Geek 青年说的环节，也壮起胆量上台分享了自己的一些观点。第一次上台，面对台下的大佬们，难免有些紧张。不过思考不易，整理出来，希望能够帮到有相同困惑的同仁们。</p><a id="more"></a><p>@文字君 阿萌提前准备了几个问题，其本意是提供一些分享的思路。奈何，京城的程序猿们比较保守，将这些思路当成了题目，完全打乱了阿萌的计划。下面是几个问题：</p><ol><li>我是如何走上写作之路的？</li><li>坚持写作给我带来了什么（长期收益、隐形投资、短期回报）</li><li>我的技术成长之路（学习策略、可推荐图书）</li><li>一个优秀的程序员的必备素质？（大佬特质有哪些）？</li></ol><p>前两个问题还好，与自身相关。后两个问题具有普遍意义，需要单独开文回答了。</p><h2 id="写作和收益"><a href="#写作和收益" class="headerlink" title="写作和收益"></a>写作和收益</h2><p>很多事情的发生都需要一个契机，就像是扣动扳机一样。</p><p>朋友在研二实习时面试的是百度，面试官看过他写的博客，感觉很好，加上他自身实力不俗，顺利拿到了 offer。</p><p>这对我来说，是一种触动，想着自己也开通一个账号，整理自己的所学所思所感，万一哪天面试用得到呢。于是，第一篇文章就这样诞生了。当时虽有目的，却动力不足，产出比较低，一年才 20 几篇，甚至在 2018 年停了 1 年。</p><p>每个人写作的目的不一样，但是写作带来的收益有一个是相似的，那就是：思考。无论是谁，什么段位，想要写成一篇文章，必然需要思考，思考前因后果。有时候写的不顺利，可能连续很长一段时间都会反复咀嚼反刍。这就是反复思考的过程，也是反复自省的过程。</p><p>我们做程序猿是比较难的，各种新技术层出不穷，很多时候我们会抱怨学不动了。但是我们做程序猿又是比较容易的，只要有一项技术精通摸透了，触类旁通，其他技术也能够很快上手。如果没有思考，很难做到精通。</p><p>我们在工作中有思考和没有思考会产生截然相反的两种结果，就像是送信的马儿和拉磨的驴子，可能它俩走路的长度一样，但是，马儿看过了世界，驴子看到的只是磨盘下的那个圈。</p><h2 id="两个模型"><a href="#两个模型" class="headerlink" title="两个模型"></a>两个模型</h2><p>分享两个模型：</p><ol><li>德雷福斯模型<br><img src="http://static.howardliu.cn/raving/%E5%BE%B7%E9%9B%B7%E7%A6%8F%E6%96%AF%E6%A8%A1%E5%9E%8B.png" alt="德雷福斯模型"></li><li>艾宾浩斯遗忘曲线<br><img src="http://static.howardliu.cn/raving/20200621182354129.png" alt="艾宾浩斯遗忘曲线"></li></ol><h3 id="德雷福斯模型"><a href="#德雷福斯模型" class="headerlink" title="德雷福斯模型"></a>德雷福斯模型</h3><p>德雷福斯模型定义了我们成长的路径：</p><ol><li>新手 Novice<ol><li>严格遵守规则或计划</li><li>几乎无法感知情境</li><li>无法酌情判断</li></ol></li><li>高级新手 Advanced Beginner<ol><li>依赖基于属性或不同侧面的行动准则</li><li>情境感知依然有限</li><li>对工作的不同方面，分开处理并且给予同等重要性</li></ol></li><li>胜任者 Competent<ol><li>能应对多线程活动或丰富的信息量</li><li>能从长期目标角度（至少部分）审视行动</li><li>有意识、刻意地制定计划</li><li>将流程标准化和常规化</li></ol></li><li>精通者 Proficient<ol><li>从整体把握全局，而不是观察各个方面</li><li>了解情境中最重要的事</li><li>感知情境与正常模式的偏差</li><li>决策越来越轻松</li><li>使用原则（maxims）指导行动，其含义因情况而异</li></ol></li><li>专家 Expert<ol><li>不再依赖规则、行动准则、原则</li><li>基于深刻、潜默的直觉把握情境</li><li>出现新情况或发生问题才使用分析法</li><li>看到未来可能的愿景</li></ol></li></ol><p>以做饭举例：</p><ul><li>新手就是必须照着菜谱做饭，甚至会拿出厨房秤，一丝一毫不能差。如果碰到盐少量、醋少量之类的模糊描述，就完全歇菜。</li><li>高级新手也需要菜谱，但是知道盐少量就是少加点是多少了。</li><li>胜任者基本上不需要菜谱了，菜谱就在脑袋中。但也是照本宣科，没有什么创新。</li><li>精通者在某种菜式中游刃有余，不过，还局限在某种范式中。比如：鲁菜、川菜、杭帮菜等。</li><li>专家没有固定套路，不局限于某种菜式。可以根据食材当时的情况，完全发挥其美味，信手拈来。</li></ul><p>我们也可以列出自己的技术栈和技能，然后每一项后面给自己下一个定义，这样就能够知道我们的差距在哪了。</p><h3 id="艾宾浩斯遗忘曲线"><a href="#艾宾浩斯遗忘曲线" class="headerlink" title="艾宾浩斯遗忘曲线"></a>艾宾浩斯遗忘曲线</h3><p>艾宾浩斯遗忘曲线是可以指导我们学习。</p><p>相信大家都会有一个疑惑，为什么考试之后的知识都遗忘了？就是因为这个遗忘曲线，我们的大脑和电脑不同的是，我们的存储会被清除，随着时间的推移，可能留下的记忆少了。</p><p>之前在读书笔记 <a href="https://www.howardliu.cn/dont-let-irrational-thinking-ruin-your-lift/">别让非理性思维毁了你的人生</a> 中提过，我们的大脑就是一台克鲁机，很多都是拼凑出来了，而且，由于我们的大脑耗能严重，所以奔着能省则省的原则，凡是不影响生死的记忆行为，都被海马体挡在外面了。</p><p>为了骗过海马体这个看门人，我们需要反复学习加深记忆。这也解释了很多同学的一个疑惑，明明很用功的在看书学习，但是偏偏看过一段时间之后，就忘记了。对学习动力造成很大的打击。其实，只是需要隔一段时间在复习一下。</p><p>通常来说，我们的复习节奏是这样，隔 1 天后、再隔 7 天后、再隔 14 天后、再隔 30 天后。也就是说，我们在 1 号学习的知识，需要在 2 号、9 号、23 号、次月 20 号这 4 天复习。这样我们的记忆会保持很久。</p><p>而且，兴趣是最好的记忆催化剂，我们要保持学习的兴趣。很多同学应该有感触，我们感兴趣的东西，哪怕不重复记忆，也可能过目不忘。但是我们感觉无聊的信息，很可能转头就忘。所以，让我们对这个世界保持兴趣，至少对我们要学习的那些东西保持兴趣。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/dont-let-irrational-thinking-ruin-your-lift/">别让非理性思维毁了你的人生</a></li><li><a href="https://www.howardliu.cn/geek-talk-20210523/">Geek 青年说北京沙龙分享</a></li><li><a href="https://www.howardliu.cn/lists-book-recommendations-2021/">程序员进阶书单2021版</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/geek-talk-20210523/">Geek 青年说北京沙龙分享</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/117415953" target="_blank" rel="noopener">Geek 青年说北京沙龙分享</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      5 月 23 号参加了 infoQ 写作平台组织的线下沙龙，瞻仰了很多大佬的英姿。在 Geek 青年说的环节，也壮起胆量上台分享了自己的一些观点。第一次上台，面对台下的大佬们，难免有些紧张。不过思考不易，整理出来，希望能够帮到有相同困惑的同仁们。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊，写作，技术成长" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A%EF%BC%8C%E5%86%99%E4%BD%9C%EF%BC%8C%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>一文掌握 Java8 的 Optional 的 6 种操作</title>
    <link href="https://www.howardliu.cn/java-util-optional/"/>
    <id>https://www.howardliu.cn/java-util-optional/</id>
    <published>2021-05-17T06:17:26.000Z</published>
    <updated>2021-05-17T06:17:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/hamburg-5286863_1920.jpg" alt="一文掌握 Java8 的 Optional 的 6 种操作"></p><p>你好，我是看山。</p><p>Java8 中引入了一个特别有意思类：<code>Optional</code>，一个可以让我们更加轻松的避免 NPE（空指针异常，NullPointException）的工具。</p><p>很久很久以前，为了避免 NPE，我们会写很多类似<code>if (obj != null) {}</code>的代码，有时候忘记写，就可能出现 NPE，造成线上故障。在 Java 技术栈中，如果谁的代码出现了 NPE，有极大的可能会被笑话，这个异常被很多人认为是低级错误。<code>Optional</code>的出现，可以让大家更加轻松的避免因为低级错误被嘲讽的概率。</p><a id="more"></a><h2 id="定义示例数据"><a href="#定义示例数据" class="headerlink" title="定义示例数据"></a>定义示例数据</h2><p>先定义待操作对象，万能的<code>Student</code>类和<code>Clazz</code>类（用到了 lombok 和 guava）：</p><pre><code class="java">@Data@AllArgsConstructor@NoArgsConstructorpublic class Clazz {    private String id;    private String name;}</code></pre><pre><code class="java">@Data@AllArgsConstructor@NoArgsConstructorpublic class Student {    private String id;    private String name;    private Clazz clazz;}</code></pre><p>然后定义一组测试数据：</p><pre><code class="java">final Clazz clazz1 = new Clazz(&quot;1&quot;, &quot;高一一班&quot;);final Student s1 = new Student(&quot;1&quot;, &quot;张三&quot;, clazz1);final Student s2 = new Student(&quot;2&quot;, &quot;李四&quot;, null);final List&lt;Student&gt; students = Lists.newArrayList(s1, s2);final List&lt;Student&gt; emptyStudents = Lists.newArrayList();final List&lt;Student&gt; nullStudents = null;</code></pre><h2 id="创建实例：of、ofNullable"><a href="#创建实例：of、ofNullable" class="headerlink" title="创建实例：of、ofNullable"></a>创建实例：of、ofNullable</h2><p>为了控制生成实例的方式，也是为了收紧空值<code>Optional</code>的定义，<code>Optional</code>将构造函数定义为<code>private</code>。想要创建<code>Optional</code>实例，可以借助<code>of</code>和<code>ofNullable</code>两个方法实现。</p><p>这两个方法的区别在于：<code>of</code>方法传入的参数不能是<code>null</code>的，否则会抛出<code>NullPointerException</code>。所以，对于可能是<code>null</code>的结果，一定使用<code>ofNullable</code>。</p><p>代码如下：</p><pre><code class="java">Optional.of(students);Optional.of(emptyStudents);Optional.ofNullable(nullStudents);</code></pre><p><code>Optional</code>类中还有一个静态方法：<code>empty</code>，这个方法直接返回了内部定义的一个常量<code>Optional&lt;?&gt; EMPTY = new Optional&lt;&gt;()</code>，这个常量的<code>value</code>是<code>null</code>。<code>ofNullable</code>方法也是借助了<code>empty</code>实现<code>null</code>的包装：</p><pre><code class="java">public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) {    return value == null ? empty() : of(value);}</code></pre><p>所以说，对于<code>null</code>的<code>Optional</code>包装类，指向的都是相同的实例对象，<code>Optional.empty() == Optional.ofNullable(null)</code>返回的是<code>true</code>。换句话说，空<code>Optional</code>是单例的。</p><blockquote><p>为了方便描述，下文中对值为<code>null</code>的<code>Optional</code>统称为“<strong>空<code>Optional</code></strong>”。</p></blockquote><h2 id="获取数据：get"><a href="#获取数据：get" class="headerlink" title="获取数据：get"></a>获取数据：get</h2><p><code>Optional</code>的<code>get</code>方法有些坑人，先看下它的源码：</p><pre><code class="java">public T get() {    if (value == null) {        throw new NoSuchElementException(&quot;No value present&quot;);    }    return value;}</code></pre><p>也就是说，<code>Optional</code>值为空时，使用<code>get</code>方法将抛出<code>NoSuchElementException</code>异常。如果不想抛出异常，或者能够 100%确定不是空<code>Optional</code>，或者使用<code>isPresent</code>方法判断。</p><p>如果能 100%确定不是空<code>Optional</code>，那就没有必要使用<code>Optional</code>包装，直接返回即可。如果需要使用<code>isPresent</code>方法，那就和直接判空没有区别了。所以，无论是第一种情况还是第二种情况，都违背了设计这个类的初衷。</p><h2 id="值为空判断：isPresent、ifPresent"><a href="#值为空判断：isPresent、ifPresent" class="headerlink" title="值为空判断：isPresent、ifPresent"></a>值为空判断：isPresent、ifPresent</h2><p><code>isPresent</code>用来判断值是否为空，类似于<code>obj != null</code>，<code>ifPresent</code>可以传入一个<code>Consumer</code>操作，当值不为空的时候，会执行<code>Consumer</code>函数。比如：</p><pre><code class="java">final Optional&lt;List&lt;Student&gt;&gt; nullValue = Optional.ofNullable(nullStudents);if (nullValue.isPresent()) {    System.out.println(&quot;value: &quot; + nullValue.get());}</code></pre><p>上面的方法等价于：</p><pre><code class="java">nullValue.ifPresent(value -&gt; System.out.println(&quot;value: &quot; + value));</code></pre><p><code>isPresent</code>判断的写法上是不是感觉很熟悉，感觉可以直接写为：</p><pre><code class="java">if (nullStudents != null) {    System.out.println(&quot;value: &quot; + nullStudents);}</code></pre><p>对于<code>isPresent</code>，如果是在自己可控的代码范围内，完全没有必要将值封装之后再判空。对于自己不可控的代码，后续的<code>filter</code>或者<code>map</code>方法可能比<code>isPresent</code>更好用一些。</p><p>对于<code>ifPresent</code>，在使用的时候会有一些限制，就是必须是非空<code>Optional</code>的时候，在会执行传入的<code>Consumer</code>函数。</p><h2 id="值处理：map、flatMap"><a href="#值处理：map、flatMap" class="headerlink" title="值处理：map、flatMap"></a>值处理：map、flatMap</h2><p><code>map</code>和<code>flatMap</code>是对<code>Optional</code>的值进行操作的方法，区别在于，<code>map</code>会将结果包装到<code>Optional</code>中返回，<code>flatMap</code>不会。但是两个方法返回值都是<code>Optional</code>类型，这也就要求，<code>flatMap</code>的方法函数返回值需要是<code>Optional</code>类型。</p><p>我们来看看<code>map</code>的实现：</p><pre><code class="java">public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) {    Objects.requireNonNull(mapper);    if (!isPresent())        return empty();    else {        return Optional.ofNullable(mapper.apply(value));    }}</code></pre><p>可以看到，如果<code>Optional</code>的值为空，<code>map</code>直接返回<code>Optional.EMPTY</code>，否则会执行函数结果，并使用<code>Optional.ofNullable</code>包装并返回。也即是说，只要类结构允许，我们可以一直<code>map</code>下去，就像是扒洋葱，一层一层，直到核心。</p><p>比如，我们要获取<code>s2</code>所在班级名称，在定义的时候，我们将<code>s2</code>的<code>clazz</code>属性定义为 null，如果以前需要写为：</p><pre><code class="java">String clazzNameOld;if (s2 != null &amp;&amp; s2.getClazz() != null &amp;&amp; s2.getClazz().getName() != null) {    clazzNameOld = s2.getClazz().getName();} else {    clazzNameOld = &quot;DEFAULT_NAME&quot;;}</code></pre><p>现在借助<code>Optional</code>可以写为：</p><pre><code class="java">final String clazzName = Optional.ofNullable(s2)        .map(Student::getClazz)        .map(Clazz::getName)        .orElse(&quot;DEFAULT_NAME&quot;);</code></pre><p>从代码上似乎没有多大改变，但是如果<code>Clazz</code>内部还有类对象。或者，我们在<code>if</code>判断的时候，少写一层检查呢？而且，<code>map</code>的精巧还在于它的返回值永远是<code>Optional</code>，这样，我们可以重复调用<code>map</code>方法，而不需要中间被打断，增加各种判空逻辑。</p><h2 id="值为空的处理：orElse、orElseGet、orElseThrow"><a href="#值为空的处理：orElse、orElseGet、orElseThrow" class="headerlink" title="值为空的处理：orElse、orElseGet、orElseThrow"></a>值为空的处理：orElse、orElseGet、orElseThrow</h2><p>这几个方法可以与<code>map</code>操作结合，一起完成对象操作。当值为空时，<code>orElse</code>和<code>orElseGet</code>返回默认值，<code>orElseThrow</code>抛出指定的异常。</p><p><code>orElse</code>和<code>orElseGet</code>的区别是，<code>orElse</code>方法传入的参数是明确的默认值，<code>orElseGet</code>方法传入的参数是获取默认值的函数。如果默认值的构造过程比较复杂，需要经过一系列的运算逻辑，那一定要使用<code>orElseGet</code>，因为<code>orElseGet</code>是在值为空的时候，才会执行函数，并返回默认值，如果值不为空，则不会执行函数，相比于<code>orElse</code>而言，减少了一次构造默认值的过程。</p><p>同样以上面的例子：</p><p><code>orElse</code>的写法：</p><pre><code class="java">final String clazzName = Optional.ofNullable(s2)        .map(Student::getClazz)        .map(Clazz::getName)        .orElse(null);</code></pre><p><code>orElseGet</code>的写法：</p><pre><code class="java">final String clazzName = Optional.of(s2)        .map(Student::getClazz)        .map(Clazz::getName)        .orElseGet(() -&gt; null);</code></pre><p>如果<code>clazz</code>属性一定不为空，为空则返回异常，可以使用<code>orElseThrow</code>：</p><pre><code class="java">final String clazzName = Optional.of(s2)        .map(Student::getClazz)        .map(Clazz::getName)        .orElseThrow(() -&gt; new IllegalArgumentException(&quot;clazz属性不合法&quot;));</code></pre><h2 id="条件过滤：filter"><a href="#条件过滤：filter" class="headerlink" title="条件过滤：filter"></a>条件过滤：filter</h2><p><code>filter</code>方法提供的是值验证，如果值验证为 true，返回当前值；否则，返回空<code>Optional</code>。比如，我们要遍历<code>students</code>，找到班级属性为空的，打印学生id：</p><pre><code class="java">for (final Student s : students) {    Optional.of(s)            .filter(x -&gt; x.getClazz() == null)            .ifPresent(x -&gt; System.out.println(x.getId()));}</code></pre><h2 id="其他：equals、hashCode、toString"><a href="#其他：equals、hashCode、toString" class="headerlink" title="其他：equals、hashCode、toString"></a>其他：equals、hashCode、toString</h2><p><code>Optional</code>重写了这三个方法。因为<code>Optional</code>可以认为是包装类，所以还是围绕这被包装的值重写这三个方法。下面给出这三个方法的源码：</p><pre><code class="java">public boolean equals(Object obj) {    // 同一对象判断    if (this == obj) {        return true;    }    // 类型判断    if (!(obj instanceof Optional)) {        return false;    }    Optional&lt;?&gt; other = (Optional&lt;?&gt;) obj;    // 最终还是值的判断    return Objects.equals(value, other.value);}public int hashCode() {    // 直接返回值的hashCode    return Objects.hashCode(value);}public String toString() {    return value != null        ? String.format(&quot;Optional[%s]&quot;, value) // 用到了值的toString结果        : &quot;Optional.empty&quot;;}</code></pre><p><code>equals</code>方法，<code>Optional.of(s1).equals(Optional.of(s2))</code>完全等价于<code>s1.equals(s2)</code>。</p><p><code>hashCode</code>方法，直接返回的是值的hashCode，如果是空<code>Optional</code>，返回的是0。</p><p><code>toString</code>方法，为了能够识别是<code>Optional</code>，将打印数据包装了一下。如果是空<code>Optional</code>，返回的是字符串“Optional.empty”；如果是非空，返回是是“Optional[值的toString]”。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>NPE 之所以讨厌，就是只要出现 NPE，我们就能够解决。但是一旦出现，都已经是事后，可能已经出现线上故障。偏偏在 Java 语言中，NPE 又很容易出现。<code>Optional</code>提供了模板方法，有效且高效的避免 NPE。</p><p>接下来，我们针对上面的使用，总结一下：</p><ol><li><code>Optional</code>是一个包装类，且不可变，不可序列化</li><li>没有公共构造函数，创建需要使用<code>of</code>、<code>ofNullable</code>方法</li><li>空<code>Optional</code>是单例，都是引用<code>Optional.EMPTY</code></li><li>想要获取<code>Optional</code>的值，可以使用<code>get</code>、<code>orElse</code>、<code>orElseGet</code>、<code>orElseThrow</code></li></ol><p>另外，还有一些实践上的建议：</p><ol><li>使用<code>get</code>方法前，必须使用<code>isPresent</code>检查。但是使用<code>isPresent</code>前，先思考下是否可以使用<code>orElse</code>、<code>orElseGet</code>等方法代替实现。</li><li><code>orElse</code>和<code>orElseGet</code>，优先选择<code>orElseGet</code>，这个是惰性计算</li><li><code>Optional</code>不要作为参数或者类属性，可以作为返回值</li><li>尽量将<code>map</code>、<code>filter</code>的函数参数抽出去作为单独方法，这样能够保持链式调用</li></ol><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/java-stream-collectors/">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://www.howardliu.cn/java-util-optional/">一文掌握 Java8 的 Optional 的 6 种操作</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-util-optional/">一文掌握 Java8 的 Optional 的 6 种操作</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/117057756" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      一文掌握 Java8 的 Optional 的 6 种操作
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="jdk8" scheme="https://www.howardliu.cn/tags/jdk8/"/>
    
      <category term="stream" scheme="https://www.howardliu.cn/tags/stream/"/>
    
      <category term="optional" scheme="https://www.howardliu.cn/tags/optional/"/>
    
  </entry>
  
  <entry>
    <title>一文掌握 Java8 Stream 中 Collectors 的 24 个操作</title>
    <link href="https://www.howardliu.cn/java-stream-collectors/"/>
    <id>https://www.howardliu.cn/java-stream-collectors/</id>
    <published>2021-05-12T11:49:59.000Z</published>
    <updated>2021-05-12T11:49:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/stadttheater-5002861_1920.jpg" alt="一文掌握 Java8 Stream 中 Collectors 的 24 个操作"></p><p>你好，我是看山。</p><p>Java8 应该算是业界主版本了，版本中重要性很高的一个更新是<code>Stream</code>流处理。关于流处理内容比较多，本文主要是说一下<code>Stream</code>中的<code>Collectors</code>工具类的使用。</p><a id="more"></a><p><code>Collectors</code>是<code>java.util.stream</code>包下的一个工具类，其中各个方法的返回值可以作为<code>java.util.stream.Stream#collect</code>的入参，实现对队列的各种操作，包括：分组、聚合等。官方文档给出一些例子：</p><blockquote><p>Implementations of {@link Collector} that implement various useful reduction operations, such as accumulating elements into collections, summarizing elements according to various criteria, etc.</p><p>The following are examples of using the predefined collectors to perform common mutable reduction tasks:</p><pre><code class="java">// Accumulate names into a ListList&lt;String&gt; list = people.stream().map(Person::getName).collect(Collectors.toList());// Accumulate names into a TreeSetSet&lt;String&gt; set = people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::new));// Convert elements to strings and concatenate them, separated by commasString joined = things.stream()        .map(Object::toString)        .collect(Collectors.joining(&quot;, &quot;));// Compute sum of salaries of employeeint total = employees.stream()        .collect(Collectors.summingInt(Employee::getSalary)));// Group employees by departmentMap&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream()        .collect(Collectors.groupingBy(Employee::getDepartment));// Compute sum of salaries by departmentMap&lt;Department, Integer&gt; totalByDept = employees.stream()        .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.summingInt(Employee::getSalary)));// Partition students into passing and failingMap&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream()        .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));</code></pre></blockquote><h2 id="定义示例数据"><a href="#定义示例数据" class="headerlink" title="定义示例数据"></a>定义示例数据</h2><p>先定义待操作对象，一个万能的<code>Student</code>类（用到了 lombok）：</p><pre><code class="java">@Data@AllArgsConstructorpublic class Student {    private String id;    private String name;    private LocalDate birthday;    private int age;    private double score;}</code></pre><p>然后定义一组测试数据：</p><pre><code class="java">final List&lt;Student&gt; students = Lists.newArrayList();students.add(new Student(&quot;1&quot;, &quot;张三&quot;, LocalDate.of(2009, Month.JANUARY, 1), 12, 12.123));students.add(new Student(&quot;2&quot;, &quot;李四&quot;, LocalDate.of(2010, Month.FEBRUARY, 2), 11, 22.123));students.add(new Student(&quot;3&quot;, &quot;王五&quot;, LocalDate.of(2011, Month.MARCH, 3), 10, 32.123));</code></pre><h2 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h2><h3 id="元素数量：counting"><a href="#元素数量：counting" class="headerlink" title="元素数量：counting"></a>元素数量：counting</h3><p>这个比较简单，就是统计聚合结果的元素数量：</p><pre><code class="java">// 3students.stream().collect(Collectors.counting())</code></pre><h3 id="平均值：averagingDouble、averagingInt、averagingLong"><a href="#平均值：averagingDouble、averagingInt、averagingLong" class="headerlink" title="平均值：averagingDouble、averagingInt、averagingLong"></a>平均值：averagingDouble、averagingInt、averagingLong</h3><p>这几个方法是计算聚合元素的平均值，区别是输入参数需要是对应的类型。</p><p>比如，求学生的分数平均值，因为分数是<code>double</code>类型，所以在不转类型的情况下，需要使用<code>averagingDouble</code>：</p><pre><code class="java">// 22.123students.stream().collect(Collectors.averagingDouble(Student::getScore))</code></pre><p>如果考虑转换精度，也是可以实现：</p><pre><code class="java">// 22.0students.stream().collect(Collectors.averagingInt(s -&gt; (int)s.getScore()))// 22.0students.stream().collect(Collectors.averagingLong(s -&gt; (long)s.getScore()))</code></pre><p>如果是求学生的平均年龄，因为年龄是<code>int</code>类型，就可以随意使用任何一个函数了：</p><pre><code class="java">// 11.0students.stream().collect(Collectors.averagingInt(Student::getAge))// 11.0students.stream().collect(Collectors.averagingDouble(Student::getAge))// 11.0students.stream().collect(Collectors.averagingLong(Student::getAge))</code></pre><blockquote><p>注意：这三个方法的返回值都是<code>Double</code>类型。</p></blockquote><h3 id="和：summingDouble、summingInt、summingLong"><a href="#和：summingDouble、summingInt、summingLong" class="headerlink" title="和：summingDouble、summingInt、summingLong"></a>和：summingDouble、summingInt、summingLong</h3><p>这三个方法和上面的平均值方法类似，也是需要注意元素的类型，在需要类型转换时，需要强制转换：</p><pre><code class="java">// 66students.stream().collect(Collectors.summingInt(s -&gt; (int)s.getScore()))// 66.369students.stream().collect(Collectors.summingDouble(Student::getScore))// 66students.stream().collect(Collectors.summingLong(s -&gt; (long)s.getScore()))</code></pre><p>但是对于不需要强制转换的类型，可以随意使用任何一个函数：</p><pre><code class="java">// 33students.stream().collect(Collectors.summingInt(Student::getAge))// 33.0students.stream().collect(Collectors.summingDouble(Student::getAge))// 33students.stream().collect(Collectors.summingLong(Student::getAge))</code></pre><blockquote><p>注意：这三个方法返回值和平均值的三个方法不一样，<code>summingDouble</code>返回的是<code>Double</code>类型、<code>summingInt</code>返回的是<code>Integer</code>类型，<code>summingLong</code>返回的是<code>Long</code>类型。</p></blockquote><h3 id="最大值-最小值元素：maxBy、minBy"><a href="#最大值-最小值元素：maxBy、minBy" class="headerlink" title="最大值/最小值元素：maxBy、minBy"></a>最大值/最小值元素：maxBy、minBy</h3><p>顾名思义，这两个函数就是求聚合元素中指定比较器中的最大/最小元素。比如，求年龄最大/最小的<code>Student</code>对象：</p><pre><code class="java">// Optional[Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)]，注意返回类型是Optionalstudents.stream().collect(Collectors.minBy(Comparator.comparing(Student::getAge)))// Optional[Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123)]，注意返回类型是Optionalstudents.stream().collect(Collectors.maxBy(Comparator.comparing(Student::getAge)))</code></pre><p>从源码可以看出来，这两个方法算是作者给的福利，用于完善数据统计的结果。内部都是封装了<code>reducing</code>方法和<code>BinaryOperator</code>工具类，这些下面会讲到。</p><pre><code class="java">public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? super T&gt; comparator) {    return reducing(BinaryOperator.maxBy(comparator));}public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; minBy(Comparator&lt;? super T&gt; comparator) {    return reducing(BinaryOperator.minBy(comparator));}</code></pre><h3 id="统计结果：summarizingDouble、summarizingInt、summarizingLong"><a href="#统计结果：summarizingDouble、summarizingInt、summarizingLong" class="headerlink" title="统计结果：summarizingDouble、summarizingInt、summarizingLong"></a>统计结果：summarizingDouble、summarizingInt、summarizingLong</h3><p>既然是数据操作，基本上逃不出计数、求平局、求和、最大、最小这几个，所以作者也是很贴心的实现了一组聚合的数据统计方法。</p><p>这组方法与求和、求平均的方法类似，都需要注意方法类型。比如，按照分数统计的话，需要进行类型转换：</p><pre><code class="java">// IntSummaryStatistics{count=3, sum=66, min=12, average=22.000000, max=32}students.stream().collect(Collectors.summarizingInt(s -&gt; (int) s.getScore()))// DoubleSummaryStatistics{count=3, sum=66.369000, min=12.123000, average=22.123000, max=32.123000}students.stream().collect(Collectors.summarizingDouble(Student::getScore))// LongSummaryStatistics{count=3, sum=66, min=12, average=22.000000, max=32}students.stream().collect(Collectors.summarizingLong(s -&gt; (long) s.getScore()))</code></pre><p>如果是用年龄统计的话，三个方法通用：</p><pre><code class="java">// IntSummaryStatistics{count=3, sum=33, min=10, average=11.000000, max=12}students.stream().collect(Collectors.summarizingInt(Student::getAge))// DoubleSummaryStatistics{count=3, sum=33.000000, min=10.000000, average=11.000000, max=12.000000}students.stream().collect(Collectors.summarizingDouble(Student::getAge))// LongSummaryStatistics{count=3, sum=33, min=10, average=11.000000, max=12}students.stream().collect(Collectors.summarizingLong(Student::getAge))</code></pre><blockquote><p>注意：这三个方法返回值不一样，<code>summarizingDouble</code>返回<code>DoubleSummaryStatistics</code>类型，<code>summarizingInt</code>返回<code>IntSummaryStatistics</code>类型，<code>summarizingLong</code>返回<code>LongSummaryStatistics</code>类型。</p></blockquote><h2 id="聚合、分组"><a href="#聚合、分组" class="headerlink" title="聚合、分组"></a>聚合、分组</h2><h3 id="聚合元素：toList、toSet、toCollection"><a href="#聚合元素：toList、toSet、toCollection" class="headerlink" title="聚合元素：toList、toSet、toCollection"></a>聚合元素：toList、toSet、toCollection</h3><p>这几个函数比较简单，是将聚合之后的元素，重新封装到队列中，然后返回。比如，得到所有<code>Student</code>的 ID 列表，只需要根据需要的结果类型使用不同的方法即可：</p><pre><code class="java">// List: [1, 2, 3]final List&lt;String&gt; idList = students.stream().map(Student::getId).collect(Collectors.toList());// Set: [1, 2, 3]final Set&lt;String&gt; idSet = students.stream().map(Student::getId).collect(Collectors.toSet());// TreeSet: [1, 2, 3]final Collection&lt;String&gt; idTreeSet = students.stream().map(Student::getId).collect(Collectors.toCollection(TreeSet::new));</code></pre><blockquote><p>注意：<code>toList</code>方法返回的是<code>List</code>子类，<code>toSet</code>返回的是<code>Set</code>子类，<code>toCollection</code>返回的是<code>Collection</code>子类。我们都知道，<code>Collection</code>的子类包括<code>List</code>、<code>Set</code>等众多子类，所以<code>toCollection</code>更加灵活。</p></blockquote><h3 id="聚合元素：toMap、toConcurrentMap"><a href="#聚合元素：toMap、toConcurrentMap" class="headerlink" title="聚合元素：toMap、toConcurrentMap"></a>聚合元素：toMap、toConcurrentMap</h3><p>这两个方法的作用是将聚合元素，重新组装为<code>Map</code>结构，也就是 k-v 结构。两者用法一样，区别是<code>toMap</code>返回的是<code>Map</code>，<code>toConcurrentMap</code>返回<code>ConcurrentMap</code>，也就是说，<code>toConcurrentMap</code>返回的是线程安全的 Map 结构。</p><p>比如，我们需要聚合<code>Student</code>的 id：</p><pre><code class="java">// {1=Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123), 2=Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123), 3=Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)}final Map&lt;String, Student&gt; map11 = students.stream()    .collect(Collectors.toMap(Student::getId, Function.identity()));</code></pre><p>但是，如果 id 有重复的，会抛出<code>java.lang.IllegalStateException: Duplicate key</code>异常，所以，为了保险起见，我们需要借助<code>toMap</code>另一个重载方法：</p><pre><code class="java">// {1=Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123), 2=Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123), 3=Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)}final Map&lt;String, Student&gt; map2 = students.stream()    .collect(Collectors.toMap(Student::getId, Function.identity(), (x, y) -&gt; x));</code></pre><p>可以看到，<code>toMap</code>有不同的重载方法，可以实现比较复杂的逻辑。比如，我们需要得到根据 id 分组的<code>Student</code>的姓名：</p><pre><code class="java">// {1=张三, 2=李四, 3=王五}final Map&lt;String, String&gt; map3 = students.stream()    .collect(Collectors.toMap(Student::getId, Student::getName, (x, y) -&gt; x));</code></pre><p>比如，我们需要得到相同年龄得分最高的<code>Student</code>对象集合：</p><pre><code class="java">// {10=Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123), 11=Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123), 12=Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123)}final Map&lt;Integer, Student&gt; map5 = students.stream()    .collect(Collectors.toMap(Student::getAge, Function.identity(), BinaryOperator.maxBy(Comparator.comparing(Student::getScore))));</code></pre><p>所以，<code>toMap</code>可玩性很高。</p><h3 id="分组：groupingBy、groupingByConcurrent"><a href="#分组：groupingBy、groupingByConcurrent" class="headerlink" title="分组：groupingBy、groupingByConcurrent"></a>分组：groupingBy、groupingByConcurrent</h3><p><code>groupingBy</code>与<code>toMap</code>都是将聚合元素进行分组，区别是，<code>toMap</code>结果是 1:1 的 k-v 结构，<code>groupingBy</code>的结果是 1:n 的 k-v 结构。</p><p>比如，我们对<code>Student</code>的年龄分组：</p><pre><code class="java">// List: {10=[Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)], 11=[Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123)], 12=[Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123)]}final Map&lt;Integer, List&lt;Student&gt;&gt; map1 = students.stream().collect(Collectors.groupingBy(Student::getAge));// Set: {10=[Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)], 11=[Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123)], 12=[Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123)]}final Map&lt;Integer, Set&lt;Student&gt;&gt; map12 = students.stream().collect(Collectors.groupingBy(Student::getAge, Collectors.toSet()));</code></pre><p>既然<code>groupingBy</code>也是分组，是不是也能够实现与<code>toMap</code>类似的功能，比如，根据 id 分组的<code>Student</code>：</p><pre><code class="java">// {1=Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123), 2=Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123), 3=Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)}final Map&lt;String, Student&gt; map3 = students.stream()    .collect(Collectors.groupingBy(Student::getId, Collectors.collectingAndThen(Collectors.toList(), list -&gt; list.get(0))));</code></pre><p>为了对比，把<code>toMap</code>的写法放在这：</p><pre><code class="java">// {1=Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123), 2=Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123), 3=Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)}final Map&lt;String, Student&gt; map2 = students.stream()    .collect(Collectors.toMap(Student::getId, Function.identity(), (x, y) -&gt; x));</code></pre><p>如果想要线程安全的<code>Map</code>，可以使用<code>groupingByConcurrent</code>。</p><h3 id="分组：partitioningBy"><a href="#分组：partitioningBy" class="headerlink" title="分组：partitioningBy"></a>分组：partitioningBy</h3><p><code>partitioningBy</code>与<code>groupingBy</code>的区别在于，<code>partitioningBy</code>借助<code>Predicate</code>断言，可以将集合元素分为<code>true</code>和<code>false</code>两部分。比如，按照年龄是否大于 11 分组：</p><pre><code class="java">// List: {false=[Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123), Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)], true=[Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123)]}final Map&lt;Boolean, List&lt;Student&gt;&gt; map6 = students.stream().collect(Collectors.partitioningBy(s -&gt; s.getAge() &gt; 11));// Set: {false=[Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123), Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123)], true=[Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123)]}final Map&lt;Boolean, Set&lt;Student&gt;&gt; map7 = students.stream().collect(Collectors.partitioningBy(s -&gt; s.getAge() &gt; 11, Collectors.toSet()));</code></pre><h2 id="链接数据：joining"><a href="#链接数据：joining" class="headerlink" title="链接数据：joining"></a>链接数据：joining</h2><p>这个方法对<code>String</code>类型的元素进行聚合，拼接成一个字符串返回，作用与<code>java.lang.String#join</code>类似，提供了 3 个不同重载方法，可以实现不同的需要。比如：</p><pre><code class="java">// javagosqlStream.of(&quot;java&quot;, &quot;go&quot;, &quot;sql&quot;).collect(Collectors.joining());// java, go, sqlStream.of(&quot;java&quot;, &quot;go&quot;, &quot;sql&quot;).collect(Collectors.joining(&quot;, &quot;));// 【java, go, sql】Stream.of(&quot;java&quot;, &quot;go&quot;, &quot;sql&quot;).collect(Collectors.joining(&quot;, &quot;, &quot;【&quot;, &quot;】&quot;));</code></pre><h2 id="操作链：collectingAndThen"><a href="#操作链：collectingAndThen" class="headerlink" title="操作链：collectingAndThen"></a>操作链：collectingAndThen</h2><p>这个方法在<code>groupingBy</code>的例子中出现过，它是先对集合进行一次聚合操作，然后通过<code>Function</code>定义的函数，对聚合后的结果再次处理。</p><p>比如<code>groupingBy</code>中的例子：</p><pre><code class="java">// {1=Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123), 2=Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123), 3=Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)}final Map&lt;String, Student&gt; map3 = students.stream()    .collect(Collectors.groupingBy(Student::getId, Collectors.collectingAndThen(Collectors.toList(), list -&gt; list.get(0))));</code></pre><p>显示将结果聚合成<code>List</code>列表，然后取列表的第 0 个元素返回，通过这种方式，实现 1:1 的 map 结构。</p><p>再来一个复杂一些的，找到聚合元素中年龄数据正确的<code>Student</code>列表：</p><pre><code class="java">// []，结果为空，是因为例子中所有人的年龄都是对的students.stream()        .collect(                Collectors.collectingAndThen(Collectors.toList(), (                        list -&gt; list.stream()                                .filter(s -&gt; (LocalDate.now().getYear() - s.getBirthday().getYear()) != s.getAge())                                .collect(Collectors.toList()))                )        );</code></pre><blockquote><p>这个例子纯粹是为了使用<code>collectingAndThen</code>的用法，其实可以简化为：</p><pre><code class="java">students.stream()        .filter(s -&gt; (LocalDate.now().getYear() - s.getBirthday().getYear()) != s.getAge())        .collect(Collectors.toList());</code></pre></blockquote><h2 id="操作后聚合：mapping"><a href="#操作后聚合：mapping" class="headerlink" title="操作后聚合：mapping"></a>操作后聚合：mapping</h2><p><code>mapping</code>先通过<code>Function</code>函数处理数据，然后通过<code>Collector</code>方法聚合元素。比如，获取获取<code>students</code>的姓名列表：</p><pre><code class="java">// [张三, 李四, 王五]students.stream()        .collect(Collectors.mapping(Student::getName, Collectors.toList()));</code></pre><p>这种计算与<code>java.util.stream.Stream#map</code>方式类似：</p><pre><code class="java">// [张三, 李四, 王五]students.stream()        .map(Student::getName)        .collect(Collectors.toList());</code></pre><p>从这点上看，还是通过<code>java.util.stream.Stream#map</code>更清晰一些。</p><h2 id="聚合后操作：reducing"><a href="#聚合后操作：reducing" class="headerlink" title="聚合后操作：reducing"></a>聚合后操作：reducing</h2><p><code>reducing</code>提供了 3 个重载方法：</p><ul><li><code>public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; reducing(BinaryOperator&lt;T&gt; op)</code>：直接通过<code>BinaryOperator</code>操作，返回值是<code>Optional</code></li><li><code>public static &lt;T&gt; Collector&lt;T, ?, T&gt; reducing(T identity, BinaryOperator&lt;T&gt; op)</code>：预定默认值，然后通过<code>BinaryOperator</code>操作</li><li><code>public static &lt;T, U&gt; Collector&lt;T, ?, U&gt; reducing(U identity, Function&lt;? super T, ? extends U&gt; mapper, BinaryOperator&lt;U&gt; op)</code>：预定默认值，通过<code>Function</code>操作元素，然后通过<code>BinaryOperator</code>操作</li></ul><p>比如，计算所有<code>students</code>的得分总数：</p><pre><code class="java">// Optional[66.369]，注意返回类型是Optionalstudents.stream()        .map(Student::getScore)        .collect(Collectors.reducing(Double::sum));// 66.369students.stream()        .map(Student::getScore)        .collect(Collectors.reducing(0.0, Double::sum));// 66.369students.stream()        .collect(Collectors.reducing(0.0, Student::getScore, Double::sum));</code></pre><p>同<code>mapping</code>，<code>reducing</code>的操作与<code>java.util.stream.Stream#reduce</code>方式类似：</p><pre><code class="java">// Optional[66.369]，注意返回类型是Optionalstudents.stream().map(Student::getScore).reduce(Double::sum);// 66.369students.stream().map(Student::getScore).reduce(0.0, Double::sum);</code></pre><p>在上文说到<code>maxBy</code>和<code>minBy</code>时，提到这两个函数就是通过<code>reducing</code>实现的。</p><blockquote><p>对于<code>mapping</code>和<code>reducing</code>，可以参考函数式编程中 map-reduce 的概念。</p></blockquote><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文主要讲解了 Java8 Stream 中 Collectors 定义的 24 个方法，这种流式计算逻辑，依靠 Fork/Join 框架，性能方面有很大的优势。如果没有掌握这些用法，可能在后续阅读代码时，会很吃力，毕竟，Java8 基本上已经是业界标杆了。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/java-stream-collectors/">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://www.howardliu.cn/java-util-optional/">一文掌握 Java8 的 Optional 的 6 种操作</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-stream-collectors/">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/116762456" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      一文掌握 Java8 Stream 中 Collectors 的 24 个操作。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="stream" scheme="https://www.howardliu.cn/tags/stream/"/>
    
      <category term="JDK8" scheme="https://www.howardliu.cn/tags/JDK8/"/>
    
      <category term="collectors" scheme="https://www.howardliu.cn/tags/collectors/"/>
    
  </entry>
  
  <entry>
    <title>面试真题：无重复字符的最长子串</title>
    <link href="https://www.howardliu.cn/longest-substring-without-repeating-character/"/>
    <id>https://www.howardliu.cn/longest-substring-without-repeating-character/</id>
    <published>2021-05-08T02:46:53.000Z</published>
    <updated>2021-05-08T02:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/altorithm/surfing-5628803_1920.jpg" alt="面试真题：无重复字符的最长子串"></p><p>你好，我是看山。</p><p>来一个算法题，面试之后查了一下，是 LeetCode 的第三题，难度中等。居然在面试过程中碰到 LeetCode 真题，事后总结一波。加深印象。</p><a id="more"></a><p>先看一下题目描述：</p><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p><p>输入：s = “abcabcbb”<br>输出：3<br>解释：因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><p>输入：s = “pwwkew”<br>输出：3<br>解释：因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p><p>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p></blockquote><p>看过题目之后，我最先想到的是一道数学题：一个线段上有 10 个点，求总共有多少的线段？如果是小朋友解题的话，一般就是，左手固定，右手向右移动，每移动一个点就加一个数，右手移动到末尾后，左手向右移动一个点，以此类推，知道最后一个点。这样就能够数出所有的线段数量，而且还不会乱。</p><p>其实上面这个算法题和我说的这个数学题的解法类似，采用小学生解法，只不过需要在数数的时候加一些判断，比如，线段中的点，有没有相同的。</p><p>来个图例：</p><p><img src="http://static.howardliu.cn/altorithm/WX20210508-115432.png" alt="无重复字符的最长子串"></p><p>根据图例写代码：</p><pre><code class="java">import java.util.HashSet;import java.util.Set;class Solution {    public static int lengthOfLongestSubstring(String s) {        if (s == null || s.isEmpty()) {            return 0;        }        final int len = s.length();        final Set&lt;Character&gt; sets = new HashSet&lt;&gt;();        int i = 0, j = 0, result = 0;        Character tmp ;        while (i &lt; len &amp;&amp; j &lt; len) {            tmp = s.charAt(j);            if (sets.contains(tmp)) {                sets.remove(s.charAt(i++));            } else {                sets.add(tmp);                result = Math.max(result, j++ - i + 1);            }        }        return result;    }}</code></pre><p>如果是面试，这个时候就可以交差了。既然是总结，就得再想一下这个解法有没有通用性。我们所采用的办法是，通过两个变量 i 和 j 指向计算元素，然后与 i 与 j 之间的元素进行判断，这种方式江湖称之为“双指针”。贴心的 LeetCode 也给过定义：</p><blockquote><p>双指针从广义上来说，是指用两个变量在线性结构上遍历而解决的问题。狭义上说，</p><ul><li>对于数组，指两个变量在数组上相向移动解决的问题；</li><li>对于链表，指两个变量在链表上同向移动解决的问题，也称为「快慢指针」问题。</li></ul><p>双指针算法通常不难，是基于暴力解法的优化，<strong>它们是很好的学习算法的入门问题</strong>。</p></blockquote><p>从 <a href="https://leetcode-cn.com/tag/two-pointers/problemset/" target="_blank" rel="noopener">这里</a> 可以找到所有 LeetCode 中关于双指针解法的题目，可以过足瘾。</p><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/longest-substring-without-repeating-character/">面试真题：无重复字符的最长子串</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/116545038" target="_blank" rel="noopener">面试真题：无重复字符的最长子串</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      找出不含有重复字符的最长子串的长度。
    
    </summary>
    
    
      <category term="算法" scheme="https://www.howardliu.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.howardliu.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="双指针" scheme="https://www.howardliu.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="滑动窗口" scheme="https://www.howardliu.cn/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果</title>
    <link href="https://www.howardliu.cn/spring-request-recorder/"/>
    <id>https://www.howardliu.cn/spring-request-recorder/</id>
    <published>2021-04-29T03:22:51.000Z</published>
    <updated>2021-04-29T03:22:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/spring/kingfisher-6146356_1920.jpg" alt="SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果"></p><p>你好，我是看山。</p><a id="more"></a><p>一个系统上线，肯定会或多或少的存在异常情况。为了更快更好的排雷，记录请求参数和响应结果是非常必要的。所以，Nginx 和 Tomcat 之类的 web 服务器，都提供了访问日志，可以帮助我们记录一些请求信息。</p><p>本文是在我们的应用中，定义一个<code>Filter</code>来实现记录请求参数和响应结果的功能。</p><p>有一定经验的都知道，如果我们在<code>Filter</code>中读取了<code>HttpServletRequest</code>或者<code>HttpServletResponse</code>的流，就没有办法再次读取了，这样就会造成请求异常。所以，我们需要借助 Spring 提供的<code>ContentCachingRequestWrapper</code>和<code>ContentCachingRequestWrapper</code>实现数据流的重复读取。</p><h2 id="定义-Filter"><a href="#定义-Filter" class="headerlink" title="定义 Filter"></a>定义 Filter</h2><p>通常来说，我们自定义的<code>Filter</code>是实现<code>Filter</code>接口，然后写一些逻辑，但是既然是在 Spring 中，那就借助 Spring 的一些特性。在我们的实现中，要继承<code>OncePerRequestFilter</code>实现我们的自定义实现。</p><p>从类名上推断，<code>OncePerRequestFilter</code>是每次请求只执行一次，但是，难道<code>Filter</code>在一次请求中还会执行多次吗？Spring 官方也是给出定义这个类的原因：</p><blockquote><p>Filter base class that aims to guarantee a single execution per request dispatch, on any servlet container. It provides a doFilterInternal(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, javax.servlet.FilterChain) method with HttpServletRequest and HttpServletResponse arguments.</p><p>As of Servlet 3.0, a filter may be invoked as part of a REQUEST or ASYNC dispatches that occur in separate threads. A filter can be configured in web.xml whether it should be involved in async dispatches. However, in some cases servlet containers assume different default configuration. Therefore sub-classes can override the method shouldNotFilterAsyncDispatch() to declare statically if they should indeed be invoked, once, during both types of dispatches in order to provide thread initialization, logging, security, and so on. This mechanism complements and does not replace the need to configure a filter in web.xml with dispatcher types.</p><p>Subclasses may use isAsyncDispatch(HttpServletRequest) to determine when a filter is invoked as part of an async dispatch, and use isAsyncStarted(HttpServletRequest) to determine when the request has been placed in async mode and therefore the current dispatch won’t be the last one for the given request.</p><p>Yet another dispatch type that also occurs in its own thread is ERROR. Subclasses can override shouldNotFilterErrorDispatch() if they wish to declare statically if they should be invoked once during error dispatches.</p></blockquote><p>也就是说，Spring 是为了兼容不同的 Web 容器，所以定义了只会执行一次的<code>OncePerRequestFilter</code>。</p><p>接下来开始定义我们的<code>Filter</code>类：</p><pre><code class="java">public class AccessLogFilter extends OncePerRequestFilter {    //... 这里有一些必要的属性    @Override    protected void doFilterInternal(final HttpServletRequest request,                                    final HttpServletResponse response,                                    final FilterChain filterChain)            throws ServletException, IOException {        // 如果是被排除的 uri，不记录 access_log        if (matchExclude(request.getRequestURI())) {            filterChain.doFilter(request, response);            return;        }        final String requestMethod = request.getMethod();        final boolean shouldWrapMethod = StringUtils.equalsIgnoreCase(requestMethod, HttpMethod.PUT.name())                || StringUtils.equalsIgnoreCase(requestMethod, HttpMethod.POST.name());        final boolean isFirstRequest = !isAsyncDispatch(request);        final boolean shouldWrapRequest = isFirstRequest &amp;&amp; !(request instanceof ContentCachingRequestWrapper) &amp;&amp; shouldWrapMethod;        final HttpServletRequest requestToUse = shouldWrapRequest ? new ContentCachingRequestWrapper(request) : request;        final boolean shouldWrapResponse = !(response instanceof ContentCachingResponseWrapper) &amp;&amp; shouldWrapMethod;        final HttpServletResponse responseToUse = shouldWrapResponse ? new ContentCachingResponseWrapper(response) : response;        final long startTime = System.currentTimeMillis();        Throwable t = null;        try {            filterChain.doFilter(requestToUse, responseToUse);        } catch (Exception e) {            t = e;            throw e;        } finally {            doSaveAccessLog(requestToUse, responseToUse, System.currentTimeMillis() - startTime, t);        }    }    // ... 这里是一些必要的方法</code></pre><blockquote><p>这段代码就是整个逻辑的核心所在，其他的内容从源码中找到。</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个代码中，整体的逻辑没有特别复杂的地方，只需要注意几个关键点就可以了。</p><ol><li>默认的<code>HttpServletRequest</code>和<code>HttpServletResponse</code>中的流被读取一次之后，再次读取会失败，所以要使用<code>ContentCachingRequestWrapper</code>和<code>ContentCachingResponseWrapper</code>进行包装，实现重复读取。</li><li>既然我们可以自定义<code>Filter</code>，那我们依赖的组件中也可能会自定义<code>Filter</code>，更有可能已经对请求和响应对象进行过封装，所以，一定要先进行一步判断。也就是<code>request instanceof ContentCachingRequestWrapper</code>和<code>response instanceof ContentCachingResponseWrapper</code>。</li></ol><p>只要注意了这两点，剩下的都是这个逻辑的细化实现。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>接下来我们就运行一遍，看看结果。先定义几种不同的请求：普通 get 请求、普通 post 请求、上传文件、下载文件，这四个接口几乎可以覆盖绝大部分场景。（因为都是比较简单的写法，源码就不赘述了，可以从文末的源码中找到）</p><p>先启动项目，然后借助 IDEA 的 http 请求工具：</p><pre><code class="script">###普通 get 请求GET http://localhost:8080/index/get?name=howard###普通 post 请求POST http://localhost:8080/index/postContent-Type: application/json{&quot;name&quot;:&quot;howard&quot;}###上传文件POST http://localhost:8080/index/uploadContent-Type: multipart/form-data; boundary=WebAppBoundary--WebAppBoundaryContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;history.txt&quot;Content-Type: multipart/form-data&lt;/Users/liuxh/history.txt--WebAppBoundary--###下载文件GET http://localhost:8080/index/download</code></pre><p>再看看打印的日志：</p><pre><code class="log">2021-04-29 19:44:57.495  INFO 83448 --- [nio-8080-exec-1] c.h.d.s.filter.AccessLogFilter           : time=44ms,ip=127.0.0.1,uri=/index/get,headers=[host:localhost:8080,connection:Keep-Alive,user-agent:Apache-HttpClient/4.5.12 (Java/11.0.7),accept-encoding:gzip,deflate],status=200,requestContentType=null,responseContentType=text/plain;charset=UTF-8,params=name=howard,request=,response=2021-04-29 19:44:57.551  INFO 83448 --- [nio-8080-exec-2] c.h.d.s.filter.AccessLogFilter           : time=36ms,ip=127.0.0.1,uri=/index/post,headers=[content-type:application/json,content-length:17,host:localhost:8080,connection:Keep-Alive,user-agent:Apache-HttpClient/4.5.12 (Java/11.0.7),accept-encoding:gzip,deflate],status=200,requestContentType=application/json,responseContentType=application/json,params=,request={&quot;name&quot;:&quot;howard&quot;},response={&quot;name&quot;:&quot;howard&quot;,&quot;timestamp&quot;:&quot;1619696697540&quot;}2021-04-29 19:44:57.585  INFO 83448 --- [nio-8080-exec-3] c.h.d.s.filter.AccessLogFilter           : time=20ms,ip=127.0.0.1,uri=/index/upload,headers=[content-type:multipart/form-data; boundary=WebAppBoundary,content-length:232,host:localhost:8080,connection:Keep-Alive,user-agent:Apache-HttpClient/4.5.12 (Java/11.0.7),accept-encoding:gzip,deflate],status=200,requestContentType=multipart/form-data; boundary=WebAppBoundary,responseContentType=application/json,params=,request=,response={&quot;contentLength&quot;:&quot;0&quot;,&quot;contentType&quot;:&quot;multipart/form-data&quot;}2021-04-29 19:44:57.626  INFO 83448 --- [nio-8080-exec-4] c.h.d.s.filter.AccessLogFilter           : time=27ms,ip=127.0.0.1,uri=/index/download,headers=[host:localhost:8080,connection:Keep-Alive,user-agent:Apache-HttpClient/4.5.12 (Java/11.0.7),accept-encoding:gzip,deflate],status=200,requestContentType=null,responseContentType=application/octet-stream;charset=utf-8,params=,request=,response=</code></pre><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>自定义<code>Filter</code>是比较简单的，只要能够注意几个关键点就可以了。不过后续还有扩展的空间，比如：</p><ol><li>定义排除的请求 uri，可以借助<code>AntPathMatcher</code>实现 ant 风格的定义</li><li>将请求日志单独存放，可以借助 logback 或者 log4j2 等框架的的日志配置实现，这样能更加方便的查找日志</li><li>与调用链技术结合，在请求日志中增加调用链的 TraceId 等，可以快速定位待查询的请求日志</li></ol><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>附上源码：<a href="https://github.com/howardliu-cn/effective-spring/tree/main/spring-filter" target="_blank" rel="noopener">https://github.com/howardliu-cn/effective-spring/tree/main/spring-filter</a></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response/">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response-exception/">SpringBoot 实战：如何优雅的处理异常</a></li><li><a href="https://www.howardliu.cn/spring-beanpostprocessor/">SpringBoot 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://www.howardliu.cn/spring-request-recorder/">SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li><li><a href="https://www.howardliu.cn/spring-enum-params/">SpringBoot 实战：优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-enum-params-principle/">SpringBoot 实战：优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</a></li><li><a href="https://www.howardliu.cn/springboot-action-enum-params-in-requestbody-principle/">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</a></li><li><a href="https://www.howardliu.cn/springboot-action-junit5-mockmvc-mockito/">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/spring-request-recorder/">SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/116276032" target="_blank" rel="noopener">SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文是在我们的应用中，定义一个 Filter 来实现记录请求参数和响应结果的功能。
    
    </summary>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/categories/spring/"/>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/tags/spring/"/>
    
      <category term="filter" scheme="https://www.howardliu.cn/tags/filter/"/>
    
  </entry>
  
</feed>
