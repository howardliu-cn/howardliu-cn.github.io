<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沉潜飞动</title>
  
  <subtitle>君子藏器于身，待时而动。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.howardliu.cn/"/>
  <updated>2022-05-14T02:37:39.000Z</updated>
  <id>https://www.howardliu.cn/</id>
  
  <author>
    <name>Howard Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java17 的新特性</title>
    <link href="https://www.howardliu.cn/java-17-features/"/>
    <id>https://www.howardliu.cn/java-17-features/</id>
    <published>2022-05-14T02:37:39.000Z</published>
    <updated>2022-05-14T02:37:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/black-redstart-g4e4e89b2d_1920.jpeg" alt="Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java17 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java17 是在 2021 年 9 月发布的一个 LTS 版本（长期支持版本），上一个长期支持版是 Java11，于 2018 年 9 月发布。从目前来看，Java11 在市场占有率已经过半，如果错过了升级 Java11，我们可不要错过这次的升级。接下来我们看看 Java17 为我们带来了哪些新增特性：</p><ul><li>JEP 306：恢复严格的浮点语义</li><li>JEP 356：增强型伪随机数生成器</li><li>JEP 382：新的 macOS 渲染管道</li><li>JEP 391：macOS/AArch64 端口</li><li>JEP 398：弃用 Applet API</li><li>JEP 403：强封装 JDK 内部 API</li><li>JEP 406：Switch 的模式匹配（预览）</li><li>JEP 407：删除 RMI 激活机制</li><li>JEP 409：密封类</li><li>JEP 410：删除实验性的 AOT 和 JIT 编译器</li><li>JEP 411：弃用安全管理器</li><li>JEP 412：外部函数和内存 API（孵化）</li><li>JEP 414：Vector API（第二版孵化）</li><li>JEP 415：上下文特定的反序列化过滤器</li></ul><p>接下来我们一起看看这些特性。</p><h2 id="恢复严格的浮点语义（JEP-306）"><a href="#恢复严格的浮点语义（JEP-306）" class="headerlink" title="恢复严格的浮点语义（JEP 306）"></a>恢复严格的浮点语义（JEP 306）</h2><p>这个特性是利好科学计算中的浮点运算，保证浮点运算中的 strict 或 strictfp 在每个平台上都能够得到相同的结果，也就是可以把 strictfp 扔了。</p><p>在 Java1.2 之前，精确浮点计算是通过迂回的方式实现的。大约从 2001 年开始，奔腾 4 和更高版本的处理器中提供了 SSE2 扩展（数据流单指令多数据扩展指令集 2），可以直接支持严格的 JVM 浮点运算，不需要额外的开销。那个时候 Intel 和 AMD 还不支持这种扩展，于是 Java1.2 的浮点运算就分叉了。</p><p>到后来 Intel 和 AMD 也开始支持 SSE2 和更高版本的扩展指令集，Java 语言就可以恢复到严格的浮点运算了。连 Java 之父 James Gosling 在 Twitter 也发文庆祝：</p><p><img src="https://static.howardliu.cn/java/jep306-jamesgosling-twitter.png" alt="恢复严格的浮点语义（JEP 306）"></p><h2 id="增强伪随机数生成器（JEP-356）"><a href="#增强伪随机数生成器（JEP-356）" class="headerlink" title="增强伪随机数生成器（JEP 356）"></a>增强伪随机数生成器（JEP 356）</h2><p>这个特性是为伪随机数生成器 RPNG（Pseudo-Random Number Generators）增加了新的接口类型和实现，可以更容易地互换使用不同的算法，而且它还为基于流的编程方式提供了更好的支持。这个特性的目标有四个：</p><ul><li>在应用程序中更容易地交替使用各种 PRNG 算法；</li><li>改进了对基于流的编程的支持，提供了 PRNG 对象流；</li><li>消除现有 PRNG 类中的重复代码；</li><li>保留<code>java.util.Random</code>类的现有行为，做好向下兼容。</li></ul><p>新增了<code>java.util.random.RandomGenerator</code>接口，作为所有 PRNG 算法的统一 API，提供了工厂类<code>java.util.random.RandomGeneratorFactory</code>，借助<code>java.util.ServiceLoader.load()</code>的能力加载各种 PRNG 算法实现，可以构造<code>RandomGenerator</code>实例。</p><p>我们遍历一下看看有哪些 PRNG 算法：</p><pre><code class="java">RandomGeneratorFactory.all().forEach(factory -&gt; {    System.out.println(factory.group() + &quot;:&quot; + factory.name());});</code></pre><p>结果是：</p><pre><code class="log">LXM:L32X64MixRandomLXM:L128X128MixRandomLXM:L64X128MixRandomLegacy:SecureRandomLXM:L128X1024MixRandomLXM:L64X128StarStarRandomXoshiro:Xoshiro256PlusPlusLXM:L64X256MixRandomLegacy:RandomXoroshiro:Xoroshiro128PlusPlusLXM:L128X256MixRandomLegacy:SplittableRandomLXM:L64X1024MixRandom</code></pre><p><code>Legacy:Random</code>就是我们常用的<code>java.util.Random</code>，我们来试试看：</p><pre><code class="java">RandomGenerator randomGenerator = RandomGeneratorFactory.of(&quot;Random&quot;)        .create(System.currentTimeMillis());System.out.println(randomGenerator.getClass());System.out.println(randomGenerator.nextInt(10));</code></pre><p>结果是：</p><pre><code class="log">class java.util.Random6 （这个值随不同的运行结果不同）</code></pre><p>我们还可以使用流式编程方式批量获取随机数：</p><pre><code class="java">final IntStream ints = RandomGeneratorFactory.of(&quot;L128X128MixRandom&quot;)        .create()        .ints(10, 0, 100);System.out.println(Arrays.toString(ints.toArray()));</code></pre><p>结果会得到 10 个随机数字数组（每次运行结果不同）：</p><pre><code class="log">[50, 16, 73, 4, 79, 32, 55, 34, 40, 53]</code></pre><h2 id="新的-MacOS-渲染库（JEP-382）"><a href="#新的-MacOS-渲染库（JEP-382）" class="headerlink" title="新的 MacOS 渲染库（JEP 382）"></a>新的 MacOS 渲染库（JEP 382）</h2><p>MacOS 为了提升图形渲染性能，在 2018 年 9 月放弃之前的 OpenGL 渲染库，选用了 Apple Metal。从 Java17 开始，Swing API 内部用于渲染 Java 2D 的 API 开始使用新的 Apple Metal 加速渲染 API。</p><p>默认情况下，这个功能不启用，需要主动开启：</p><pre><code class="sh">-Dsun.java2d.metal=true</code></pre><p>这个特性改动是属于 API 内部实现，使用上没有任何差别。而且对 MacOS 的系统版本有要求，需要在 MacOS10.14 版本或以上，否则还是会使用 OpenGL 渲染图形。</p><h2 id="MacOS-AArch64-端口（JEP-391）"><a href="#MacOS-AArch64-端口（JEP-391）" class="headerlink" title="MacOS/AArch64 端口（JEP 391）"></a>MacOS/AArch64 端口（JEP 391）</h2><p>苹果在 2020 年 6 月的 WWDC 的演讲中宣布，将开启长期将 Macintosh 系列从 x64 过渡到 AArch64 的计划，该特性主要是为了适应这种改变。</p><p>Linux 的 AArch64 支持是在 Java9 提供的（参见 <a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a>），Windows 的 AArch64 支持是在 Java16 提供的（参见 <a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a>）。</p><p>在 Java12 的时候对 AArch64 的支持库进行了统一，只保留了一套维护代码（参见 <a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a>）。</p><h2 id="强封装-JDK-内部-API（JEP-403）"><a href="#强封装-JDK-内部-API（JEP-403）" class="headerlink" title="强封装 JDK 内部 API（JEP 403）"></a>强封装 JDK 内部 API（JEP 403）</h2><p>在 Java16 中为了改进 JDK 的安全性和可维护性，对内部 API 进行了封装，但是也留了后门，可以使用启动参数<code>--illegal-access</code>控制内部 API 的封装程度。（参见 <a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a>）</p><p>到了 Java17 中，除了<code>sun.misc.Unsafe</code>可以使用，其他的内部 API 都变成了强封装模式，而且<code>--illegal-access</code>命令也被移除，如果还在命令中添加该参数，会直接报错：</p><pre><code class="log">~ $ java -versionopenjdk version &quot;17.0.1&quot; 2021-10-19OpenJDK Runtime Environment (build 17.0.1+12-39)OpenJDK 64-Bit Server VM (build 17.0.1+12-39, mixed mode, sharing)~ $ java --illegal-accessUnrecognized option: --illegal-accessError: Could not create the Java Virtual Machine.Error: A fatal exception has occurred. Program will exit.</code></pre><h2 id="密封类（JEP-409）"><a href="#密封类（JEP-409）" class="headerlink" title="密封类（JEP 409）"></a>密封类（JEP 409）</h2><p>密封类特性是在 Java15 提供预览版，Java16 提供第二版预览，终于在 Java17 中成为正式功能。该特性限制哪些其他类或接口可以扩展或实现密封组件。</p><p>JEP 409 并没有对密封类有新的特性，可以参考 <a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a>、<a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a>，这里不再重复。</p><h2 id="上下文特定的反序列化过滤器（JEP-415）"><a href="#上下文特定的反序列化过滤器（JEP-415）" class="headerlink" title="上下文特定的反序列化过滤器（JEP 415）"></a>上下文特定的反序列化过滤器（JEP 415）</h2><p>Java 对象序列化是一个非常重要的功能，可以透明化远程处理，也促进了 JavaEE 的成功。序列化过程没有问题，但是反序列化过程可能存在危险：</p><ul><li>许多情况下传入的数据流内容是通过未知或未经身份验证的客户端获取的；</li><li>序列化数据流中可能携带带有攻击者精心构造的恶意代码。</li></ul><p>终于在 Java17 中增加了反序列化过滤器，允许应用程序使用 JVM 范围的过滤器工厂，配置特定于上下文和动态选择的反序列化过滤器，该工厂用于为每个反序列化操作选择一个过滤器。</p><p>简单点说，就是提前说好可以反序列化哪些类，如果序列化数据流中包含不被允许的类对象，就直接报错。</p><h2 id="预览功能"><a href="#预览功能" class="headerlink" title="预览功能"></a>预览功能</h2><h3 id="Switch-的模式匹配（JEP-406）"><a href="#Switch-的模式匹配（JEP-406）" class="headerlink" title="Switch 的模式匹配（JEP 406）"></a>Switch 的模式匹配（JEP 406）</h3><p>这个特性功能很赞，在 Java14 中正式提供 Switch 表达式特性（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a>），本次提供的是 Switch 模式匹配与 instanceof 模式匹配有些类似，是能够在 Switch 表达式实现类型自动转换。</p><p>比如：</p><pre><code class="java">static String formatterPatternSwitch(Object o) {    return switch (o) {        case null -&gt; &quot;null&quot;;        case Integer i -&gt; String.format(&quot;int %d&quot;, i);        case Long l -&gt; String.format(&quot;long %d&quot;, l);        case Double d -&gt; String.format(&quot;double %f&quot;, d);        case String s -&gt; String.format(&quot;String %s&quot;, s);        default -&gt; o.getClass().getSimpleName() + &quot; &quot; + o;    };}public static void main(String[] args) {    System.out.println(formatterPatternSwitch(null));    System.out.println(formatterPatternSwitch(&quot;1&quot;));    System.out.println(formatterPatternSwitch(2));    System.out.println(formatterPatternSwitch(3L));    System.out.println(formatterPatternSwitch(4.0));    System.out.println(formatterPatternSwitch(new AtomicLong(5)));}</code></pre><p>结果是：</p><pre><code class="log">nullString 1int 2long 3double 4.000000AtomicLong 5</code></pre><p>可以看到，不只是类型自动转换，还可以直接判断是否是<code>null</code>，省了前置判断对象是否是<code>null</code>了。</p><p>期待这个功能早日转正。</p><h2 id="孵化功能"><a href="#孵化功能" class="headerlink" title="孵化功能"></a>孵化功能</h2><h3 id="外部函数和内存-API（JEP-412）"><a href="#外部函数和内存-API（JEP-412）" class="headerlink" title="外部函数和内存 API（JEP 412）"></a>外部函数和内存 API（JEP 412）</h3><p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据互操作。通过有效地调用外部函数（即 JVM 外部的代码），并通过安全地访问外部内存（即不由 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会有 JNI 的脆弱性和危险。</p><p>通过更加优雅的方式访问外部函数是从 Java14 开始的，经历了多个孵化版本：</p><ul><li>Java14 的 JEP 370：外部存储器访问 API（孵化）</li><li>Java15 的 JEP 383：外部存储器访问 API（第二版孵化功能）</li><li>Java16 的 JEP 389：外部链接器 API（孵化功能）</li><li>Java16 的 JEP 393：外部存储器访问 API（第三版孵化功能）</li><li>Java17 的 JEP 412：外部函数和内存 API</li></ul><p>可以看出来，虽然一直在孵化，但是功能越来越强大，这一旦孵出来，岂不是超级神兽了。</p><p>这一系列的功能都是为了能够在 Java 类中调用 C 语言类库：</p><pre><code class="java">private static final SymbolLookup libLookup;static {    // loads a particular C library    var path = JEP412.class.getResource(&quot;/print_name.so&quot;).getPath();    System.load(path);    libLookup = SymbolLookup.loaderLookup();}</code></pre><p>第一步，需要加载我们希望通过 API 调用的目标库。<br>第二步，我们需要指定目标方法的签名，并最终调用它：</p><pre><code class="java">public String getPrintNameFormat(String name) {    var printMethod = libLookup.lookup(&quot;printName&quot;);    if (printMethod.isPresent()) {        var methodReference = CLinker.getInstance()            .downcallHandle(                printMethod.get(),                MethodType.methodType(MemoryAddress.class, MemoryAddress.class),                FunctionDescriptor.of(CLinker.C_POINTER, CLinker.C_POINTER)            );        try {            var nativeString = CLinker.toCString(name, newImplicitScope());            var invokeReturn = methodReference.invoke(nativeString.address());            var memoryAddress = (MemoryAddress) invokeReturn;            return CLinker.toJavaString(memoryAddress);        } catch (Throwable throwable) {            throw new RuntimeException(throwable);        }    }    throw new RuntimeException(&quot;printName function not found.&quot;);}</code></pre><blockquote><p>上面这段代码摘自<a href="https://www.baeldung.com/java-17-new-features" target="_blank" rel="noopener">https://www.baeldung.com/java-17-new-features</a>。</p></blockquote><h3 id="Vector-API（JEP-414，第二版孵化）"><a href="#Vector-API（JEP-414，第二版孵化）" class="headerlink" title="Vector API（JEP 414，第二版孵化）"></a>Vector API（JEP 414，第二版孵化）</h3><p>Vector 向量计算 API 是为了处理 SIMD（Single Instruction Multiple Data，单指令多数据）类型的操作，即并行执行的各种指令集。它利用支持向量指令的专用 CPU 硬件，并允许以管道的形式执行此类指令。这种运算方式可以让开发人员实现更高效的代码，充分利用底层硬件的潜力。日常使用包括科学代数线性应用程序、图像处理、字符处理、繁重的算术应用程序，以及任何需要对多个独立操作数应用一个运算的应用程序。</p><p>Vector 向量计算 API 是在 Java16 引入（参见 <a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a>），可以在运行时借助 CPU 向量运算指令，实现更优的计算能力。在 Java17 中，针对性能和实现进行了改进，包括字节向量与布尔数组之间进行转换。</p><p>原来的向量运算我们需要这样写：</p><pre><code class="java">for (var i = 0; i &lt; a.length; i++) {    c[i] = a[i] * b[i];}</code></pre><p>现在我们可以这样写：</p><pre><code class="java">final VectorSpecies&lt;Float&gt; SPECIES = FloatVector.SPECIES_PREFERRED;for (var i = 0; i &lt; a.length; i += SPECIES.length()) {    var m = SPECIES.indexInRange(i, a.length);    var va = FloatVector.fromArray(SPECIES, a, i, m);    var vb = FloatVector.fromArray(SPECIES, b, i, m);    var vc = va.mul(vb);    vc.intoArray(c, i, m);}</code></pre><h2 id="弃用和删除"><a href="#弃用和删除" class="headerlink" title="弃用和删除"></a>弃用和删除</h2><h3 id="启用-Applet-API（JEP-398）"><a href="#启用-Applet-API（JEP-398）" class="headerlink" title="启用 Applet API（JEP 398）"></a>启用 Applet API（JEP 398）</h3><p>Applet 是用 Java 编写可以嵌入到网页中的小应用，属于已经过时的技术，很多浏览器已经取消支持。Applet API 在 Java9 的时候标记了过期，在 Java17 标记为删除（<code>@Deprecated(since = &quot;9&quot;, forRemoval = true)</code>）。</p><p>记得我上学的时候，课本上还有这部分内容。</p><h3 id="删除-RMI-激活机制（JEP-407）"><a href="#删除-RMI-激活机制（JEP-407）" class="headerlink" title="删除 RMI 激活机制（JEP 407）"></a>删除 RMI 激活机制（JEP 407）</h3><p>RMI 激活机制在 Java15 标记了过期（参见 <a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a>），到 Java17 正式删除。这里只是删除了 RMI 激活机制，对于其他 RMI 功能不受影响。</p><h3 id="删除实验性的-AOT-和-JIT-编译器（JEP-410）"><a href="#删除实验性的-AOT-和-JIT-编译器（JEP-410）" class="headerlink" title="删除实验性的 AOT 和 JIT 编译器（JEP 410）"></a>删除实验性的 AOT 和 JIT 编译器（JEP 410）</h3><p>在 Java9 的 JEP 295 中，引入了实验性的提前编译 jaotc 工具，但是这个特性自从引入依赖用处都不太大，而且需要大量的维护工作，所以在 Java17 中决定删除这个特性。</p><p>但是保留了实验性的 Java 级 JVM 编译器接口（JVMCI），这样开发人员也可以继续使用外部构建的编译器版本，并使用 Graal 编译器（GraalVM）进行 JIT 编译。</p><h3 id="弃用安全管理器（JEP-411）"><a href="#弃用安全管理器（JEP-411）" class="headerlink" title="弃用安全管理器（JEP 411）"></a>弃用安全管理器（JEP 411）</h3><p>Security Manager 在 JDK1.0 时就已经引入，但是它一直都不是保护服务端以及客户端 Java 代码的主要手段，对于如此鸡肋的功能，最终决定标记为删除（<code>@Deprecated(since=&quot;17&quot;, forRemoval=true)</code>）。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java17 新增的特性，完整的特性清单可以从 <a href="https://openjdk.java.net/projects/jdk/17/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/17/</a> 查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>Java17 是 LTS（长期支持版），上个 LTS 版本是 Java11，很多团队已经在生产上切换，相信接下来会有一些团队在测试环境尝鲜。</p><p>有人认为 Java8 是神，有人则喜欢不断地尝鲜，你是哪种呢？欢迎在留言说下你在用哪个版本？</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-17-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java17 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/124830768" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java17 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Java17 是在 2021 年 9 月发布的一个 LTS 版本（长期支持版本），上一个长期支持版是 Java11，于 2018 年 9 月发布。从目前来看，Java11 在市场占有率已进过半，如果错过了升级 Java11，我们可不要错过这次的升级。接下来我们看看 Java17 为我们带来了哪些新增特性：JEP 306：恢复严格的浮点语义；JEP 356：增强型伪随机数生成器；JEP 382：新的 macOS 渲染管道；JEP 391：macOS/AArch64 端口；JEP 398：弃用 Applet API；JEP 403：强封装 JDK 内部 API；JEP 406：Switch 的模式匹配（预览）；JEP 407：删除 RMI 激活机制；JEP 409：密封类；JEP 410：删除实验性的 AOT 和 JIT 编译器；JEP 411：弃用安全管理器；JEP 412：外部函数和内存 API（孵化）；JEP 414：Vector API（第二版孵化）；JEP 415：上下文特定的反序列化过滤器；接下来我们一起看看这些特性。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java17" scheme="https://www.howardliu.cn/tags/Java17/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java16 的新特性</title>
    <link href="https://www.howardliu.cn/java-16-features/"/>
    <id>https://www.howardliu.cn/java-16-features/</id>
    <published>2022-04-18T23:48:47.000Z</published>
    <updated>2022-04-18T23:48:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/yellow-5219524_1920.jpeg" alt="Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java16 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java16 是在 2021 年 3 月发布的一个短期版本，新增特性如下：</p><ul><li>JEP 338：向量 API（孵化功能）</li><li>JEP 347：启用 C++ 14 语言特性</li><li>JEP 357：从 Mercurial 迁移到 Git</li><li>JEP 369：迁移到 GitGitHub</li><li>JEP 376：ZGC 的并发线程堆栈处理</li><li>JEP 380：支持 Unix 套接字</li><li>JEP 386：Alpine Linux 移植</li><li>JEP 387：弹性元空间</li><li>JEP 388：Windows/AArch64 移植</li><li>JEP 389：外部链接器 API（孵化功能）</li><li>JEP 390：对基于值的类设置“弃用移除”警告</li><li>JEP 392：打包工具</li><li>JEP 393：外部存储器访问 API（第三版孵化功能）</li><li>JEP 394：instanceof 模式匹配</li><li>JEP 395：Record 类型</li><li>JEP 396：默认强封装 JDK 内部元素</li><li>JEP 397：密封类（第二版预览功能）</li></ul><p>接下来我们一起看看这些特性。</p><h2 id="启用-C-14-语言特性（JEP-347）"><a href="#启用-C-14-语言特性（JEP-347）" class="headerlink" title="启用 C++ 14 语言特性（JEP 347）"></a>启用 C++ 14 语言特性（JEP 347）</h2><p>在 JDK15 之前，JDK 中使用的 C++语言限制在 C++98/03 版本，没有办法使用更高级的特性，从 JDK16 开始，可以支持 C++14 的语言特性。</p><p>这一点更新对应用开发者可能关系不大，但是对于底层组件的开发者意义重大。Java 的版本更新迅速，C++的特性也是飞速更新，如果 JDK 还是限制在 C++98/03 版本，没有办法使用 C++11/14 中的高级特性，也是一种损失。</p><h2 id="从-Mercurial-迁移到-Git（JEP-357、JEP-369）"><a href="#从-Mercurial-迁移到-Git（JEP-357、JEP-369）" class="headerlink" title="从 Mercurial 迁移到 Git（JEP 357、JEP 369）"></a>从 Mercurial 迁移到 Git（JEP 357、JEP 369）</h2><p>这是两个提案，JEP 357 是将 OpenJDK 社区的源代码版本控制工具，从 Mercurial（hg）迁移到 Git，JEP 369 是将 OpenJDK 项目定向到 GitHub 中的仓库，我们可以看到从 OpenJDK 的 JIRA 工具中，代码提交和 Issue 预览的都是在 <a href="https://github.com/openjdk" target="_blank" rel="noopener">https://github.com/openjdk</a> 中，有一部分是从 <a href="https://git.openjdk.java.net" target="_blank" rel="noopener">https://git.openjdk.java.net</a> 重定向到 GitHub。</p><p>Mercurial（hg）是一个 Python 编写的跨平台的分布式版本控制软件，与 Git 是同一时代开始的工具，功能也是很强大，只是在发展过程中，有些方面稍弱于 Git，比如元数据的占用、与现代工具链的集成。所以 OpenJDK 转而投向了 Git 的怀抱。</p><h2 id="ZGC-的并发线程堆栈处理（JEP-376）"><a href="#ZGC-的并发线程堆栈处理（JEP-376）" class="headerlink" title="ZGC 的并发线程堆栈处理（JEP 376）"></a>ZGC 的并发线程堆栈处理（JEP 376）</h2><p>ZGC 是在 Java11 引入的（参见 <a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 新特性</a>），在 Java15 中正式特性（参见 <a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 新特性</a>），可以用命令<code>-XX:+UseZGC</code>启用 ZGC。</p><p>ZGC 是一个并发的垃圾回收器，可以极大地提升 GC 的性能，支持任意堆大小而保持稳定的低延迟。在 128G 堆大小的测试中，ZGC 优势明显，找了一张网上的图片：</p><p><img src="https://static.howardliu.cn/java/java-11-1.png" alt="ZGC：可伸缩低延迟垃圾收集器"></p><p>ZGC 的目标是实现垃圾回收与程序同时运行，将 STW 降低为 0，即不存在中断。目前在标记、重定位、参考处理、类卸载和跟处理阶段删除安全点处理。目前 ZGC 中仍然依靠安全点执行的包括部分的根处理和有时间限制的标记终止操作。这些根处理中有一项就是 Java 线程堆栈处理。随着线程数量增加，停顿时间增长。所以，我们需要实现并发的堆栈处理。目标包括：</p><ul><li>ZGC 的安全点不再包含线程堆栈处理。</li><li>使堆栈处理变得惰性、协作、并发和增量。</li><li>从 ZGC 安全点中删除所有其他线程根处理。</li><li>提供一种机制，其他 HotSpot 子系统（如 Loom 和 JFR）可以通过该机制惰性地处理堆栈。</li></ul><h2 id="支持-Unix-套接字（JEP-380）"><a href="#支持-Unix-套接字（JEP-380）" class="headerlink" title="支持 Unix 套接字（JEP 380）"></a>支持 Unix 套接字（JEP 380）</h2><p>对于本地进程间通信，Unix 套接字比 TCP/IP 更加安全高效。Unix 套接字一直是大多数 Unix 平台的一个特性，现在在 Windows 10 和 Windows Server 2019 也提供了支持。</p><p>所以在 Java16 中为<code>java.nio.channels</code>包的<code>SocketChannel</code>和<code>ServerSocketChannel</code>添加了 Unix（AF_UNIX）套接字支持。Unix 套接字用于同一主机上的进程间通信（IPC）, 在很大程度上类似于 TCP/IP，区别在于套接字是通过文件系统路径名而不是 Internet 协议（IP）地址和端口号寻址的。对于本地进程间通信，Unix 套接字比 TCP/IP 环回连接更安全、更有效。</p><h2 id="Alpine-Linux-移植、Windows-AArch64-移植（JEP-386、JEP-388）"><a href="#Alpine-Linux-移植、Windows-AArch64-移植（JEP-386、JEP-388）" class="headerlink" title="Alpine Linux 移植、Windows/AArch64 移植（JEP 386、JEP 388）"></a>Alpine Linux 移植、Windows/AArch64 移植（JEP 386、JEP 388）</h2><p>这些移植的价值不在于移植本身，而在于支持平台的多样性。Java 的口号是一次编写到处运行。既然要到处运行，就得支持各种平台。而且，针对不同的操作系统支持，还能给我们提供更多的选择。</p><p>Alpine Linux 是一个独立非商业的 Linux 发行版，体系非常小，一个容器需要不超过 8MB 的空间，磁盘最小仅需 130MB 存储。如果我们通过 jlink 生产 JDK，Docket 镜像可以减小到 38MB，这样在微服务部署过程中，可以减少很多磁盘占用，也能减少镜像传输、部署时间。</p><h2 id="弹性元空间（JEP-387）"><a href="#弹性元空间（JEP-387）" class="headerlink" title="弹性元空间（JEP 387）"></a>弹性元空间（JEP 387）</h2><p>这是在 HotSpot 中的空间分配上的优化，将未使用的元空间（metaspace，也叫类的元空间）中的内容存返回给操作系统。</p><p>应用程序如果存在大量类加载和类卸载的动作时，会占用大量的元空间内存，这部分内存得不到释放，造成内存利用率低。现在的应用系统为了应对高并发的流量，动辄部署数十上百台实例，这将造成极大的资源浪费。</p><p>元空间的内存方式使用的是基于区域的内存管理方式（Region-based memory management），也就是每个分配的对象都被分配到一个区域中。这里的区域有不同的叫法：zone（区域）、arena（竞技场）、memory context（内存上下文）等。</p><p>当类被回收后，其元空间区域中的内存块会返回自由列表中，以便以后重新使用。当然，可能很长使用不会被重新使用。这样就会造成元空间中很多的内存碎片，这些都是被标记为占用的内存。如果没有碎片的内存空间，是可以返回给操作系统的。</p><p>在 JEP 387 特性中，提出使用基于伙伴的内存分配算法（Buddy memory allocation）改善元空间的内存使用，这种方式是一种在 Linux 内核中经过验证的成熟算法。这种算法是在很小的块（chunk）中分配内存，这会降低类加载器的开销。</p><p>同时，JEP 387 增加了内存延迟提交给内存区域的特性，这样就会减少那种申请了内存却不使用的情况。</p><p>最后，JEP 387 将元空间的内存区域设计为不同大小，可以满足不同大小需求的内存申请。</p><p>这些操作与 Java13 中对 ZGC 的增强特性很类似（参见 <a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a>）。他山之石可以攻玉，我们不妨学习一下这些方式，对我们在以后的开发中提供思路。</p><h2 id="对基于值的类设置“弃用移除”警告（JEP-390）"><a href="#对基于值的类设置“弃用移除”警告（JEP-390）" class="headerlink" title="对基于值的类设置“弃用移除”警告（JEP 390）"></a>对基于值的类设置“弃用移除”警告（JEP 390）</h2><p>将基于值的类的公共构造函数设置启用移除警告。</p><p>比如<code>Interger</code>的构造函数上设置了<code>@Deprecated(since=&quot;9&quot;, forRemoval = true)</code>。如果某个类使用了<code>Integer integer = new Integer(1);</code>这种写法，通过<code>javac</code>命令编译时，会收到<code>警告：[removal] Integer 中的 Integer(int) 已过时，且标记为待删除</code>这种警告信息。</p><p>基于值的类在类定义上都会有<code>@jdk.internal.ValueBased</code>注解，比如<code>java.lang.Integer</code>、<code>java.lang.Double</code>等。这样的改动是为 Valhalla 项目做准备。</p><h2 id="打包工具（JEP-392）"><a href="#打包工具（JEP-392）" class="headerlink" title="打包工具（JEP 392）"></a>打包工具（JEP 392）</h2><p>打包工具是在 Java14 中引入的孵化功能（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a>），可以打包成自包含的 Java 应用程序，比如 Windows 的 exe 和 msi、Mac 的 pkg 和 dmg、Linux 的 deb 和 rpm 等。</p><p>我们可以使用<code>jlink</code>创建一个最小可运行的模块包，然后使用<code>jpackage</code>将其构建成安装包：</p><pre><code class="shell">jpackage --name myapp --input lib --main-jar main.jar</code></pre><p>这里需要注意一点，因为已经成为正式功能，模块名从<code>jdk.incubator.jpackage</code>改为<code>jdk.jpackage</code>。</p><h2 id="instanceof-模式匹配（JEP-394）"><a href="#instanceof-模式匹配（JEP-394）" class="headerlink" title="instanceof 模式匹配（JEP 394）"></a>instanceof 模式匹配（JEP 394）</h2><p>instanceof 模式匹配首先在 Java14 中提供预览功能（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 特性</a>），可以提供<code>instanceof</code>更加简洁高效的实现，在 Java15 中进行了第二次预览，用于收集反馈，终于是多年的媳妇熬成婆，在 Java16 中成为正式功能。</p><p>我们再简单复习一下<code>instanceof</code>模式匹配的功能（详细使用可以移步 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 特性</a>）：</p><pre><code class="java">@Testvoid test1() {    final Object obj1 = &quot;Hello, World!&quot;;    int result = 0;    if (obj1 instanceof String str) {        result = str.length();    } else if (obj1 instanceof Number num) {        result = num.intValue();    }    Assertions.assertEquals(13, result);}</code></pre><h2 id="Record-类型（JEP-395）"><a href="#Record-类型（JEP-395）" class="headerlink" title="Record 类型（JEP 395）"></a>Record 类型（JEP 395）</h2><p>Record 类型用来增强 Java 语言特性，充当不可变数据载体。与 instanceof 模式匹配一样，Record 类型也是在 Java14 中提供预览功能（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 新特性</a>），在 Java15 中进行了第二次预览，用于收集反馈。</p><p>我们再简单复习一下 Record 类型的功能，比如，我们定义一个<code>Person</code>类：</p><pre><code class="java">public record Person(String name, String address) {}</code></pre><p>我们转换为之前的定义会是一坨下面这种代码：</p><pre><code class="java">public final class PersonBefore14 {    private final String name;    private final String address;    public PersonBefore14(String name, String address) {        this.name = name;        this.address = address;    }    public String name() {        return name;    }    public String address() {        return address;    }    @Override    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        PersonBefore14 that = (PersonBefore14) o;        return Objects.equals(name, that.name) &amp;&amp; Objects.equals(address, that.address);    }    @Override    public int hashCode() {        return Objects.hash(name, address);    }    @Override    public String toString() {        return &quot;PersonBefore14{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +                &#39;}&#39;;    }}</code></pre><p>Record 类型特性有四个特性：</p><ol><li>设计一个面向对象的结构，表达简单的信息聚合；</li><li>帮助开发人员专注于建模不可变数据，而不是可扩展的行为；</li><li>自动实现数据驱动的方法，比如<code>equals</code>、<code>getter</code>、<code>setter</code>等方法；</li><li>保留长期存在的 Java 规范，比如迁移兼容性。</li></ol><p>我们不能将 Record 类型简单的理解为去除“样板化”代码的功能，它不是解决 JavaBean 命名约定的中很多模板化方法的冗余繁杂问题，它的目标不是类似 Lombok 等工具自动生成代码的功能，是从开发人员专注模型的角度出发的。</p><h2 id="默认强封装-JDK-内部元素（JEP-396）"><a href="#默认强封装-JDK-内部元素（JEP-396）" class="headerlink" title="默认强封装 JDK 内部元素（JEP 396）"></a>默认强封装 JDK 内部元素（JEP 396）</h2><p>这个功能特性是为了改进 JDK 的安全性和可维护性，是 Jigsaw 项目的主要目标之一。所以在 Java16 中，默认强封装 JDK 的绝大部分内部 API，有些关键性的 API，比如<code>sun.misc.Unsafe</code>暂时可以放心使用。</p><p>我们可以使用启动参数<code>--illegal-access</code>控制内部 API 的封装程度：</p><ul><li><code>--illegal-access=permit</code>：JDK 8 中存在的每个包对未命名模块中的代码开放。也就是放心大胆地使用。Java9 中默认就是这个等级；</li><li><code>--illegal-access=warn</code>：与许可相同，不同之处在于每次非法反射访问操作都会发出警告消息；</li><li><code>--illegal-access=debug</code>：与 warn 相同，不同的是，每个非法反射访问操作都会发出警告消息和堆栈跟踪；</li><li><code>--illegal-access=deny</code>：禁用所有非法访问操作，但由其他命令行选项（例如<code>--add-opens</code>）启用的操作除外。</li></ul><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><h3 id="密封类-预览第二版（JEP-397）"><a href="#密封类-预览第二版（JEP-397）" class="headerlink" title="密封类-预览第二版（JEP 397）"></a>密封类-预览第二版（JEP 397）</h3><p>密封类首次在 Java15 中预览（参见 <a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 新特性</a>），在 Java16 中进行第二次预览，我们在复习一下功能：</p><pre><code class="java">public sealed interface JungleAnimal permits Monkey, Snake  {}public final class Monkey implements JungleAnimal {}public non-sealed class Snake implements JungleAnimal {}</code></pre><p><code>sealed</code>关键字与<code>permits</code>关键字结合使用，以确定允许哪些类实现此接口。在我们的例子中，是<code>Monkey</code>和<code>Snake</code>。</p><ul><li><code>sealed</code>：必须使用<code>permits</code>关键字定义允许继承的子类；</li><li><code>final</code>：最终类，不再有子类；</li><li><code>non-sealed</code>：普通类，任何类都可以继承它。</li></ul><h2 id="孵化"><a href="#孵化" class="headerlink" title="孵化"></a>孵化</h2><h3 id="向量-API（JEP-338）"><a href="#向量-API（JEP-338）" class="headerlink" title="向量 API（JEP 338）"></a>向量 API（JEP 338）</h3><p>这是为向量计算专门定义的 API，可以在运行时可靠地编译为支持的 CPU 架构上的最佳向量硬件指令，从而获得优于同等标量计算的性能，充分利用单指令多数据（SIMD）技术（大多数现代 CPU 上都可以使用的一种指令）。该 API 将使开发人员能够轻松地用 Java 编写可移植的高性能向量算法。</p><p>尽管 HotSpot 支持自动向量化，但是可转换的标量操作集有限且易受代码更改的影响。</p><pre><code class="java">final int[] a = {1, 2, 3, 4};final int[] b = {5, 6, 7, 8};final int[] c = new int[3];IntVector vectorA = IntVector.fromArray(IntVector.SPECIES_128, a, 0);IntVector vectorB = IntVector.fromArray(IntVector.SPECIES_128, b, 0);IntVector vectorC = vectorA.mul(vectorB);vectorC.intoArray(c, 0);</code></pre><p>这个功能在 Java17 中进行了第二次孵化，基于使用安全的考虑，我们在短时间内用不上这个特性了。</p><h3 id="外部链接器-API（JEP-389）"><a href="#外部链接器-API（JEP-389）" class="headerlink" title="外部链接器 API（JEP 389）"></a>外部链接器 API（JEP 389）</h3><p>这个特性提供了静态类型、纯 Java 访问原生代码的 API，大大简化绑定原生库的原本复杂且容易出错的过程。从 Java1.1 开始，我们可以通过原生接口（JNI）调用原生方法，但是并不好用，现在提供了外部链接器 API，可以不再使用 JNI 粘合代码了。</p><p>和向量 API 一样，暂时用不上了，等啥时候转正了，咱们重点说说怎么玩。</p><h3 id="外部存储器访问-API-孵化第三版（JEP-393）"><a href="#外部存储器访问-API-孵化第三版（JEP-393）" class="headerlink" title="外部存储器访问 API-孵化第三版（JEP 393）"></a>外部存储器访问 API-孵化第三版（JEP 393）</h3><p>外部存储器访问 API 在 Java14 开始孵化（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 新特性</a>），在 Java15 中孵化第二版（参见 <a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 新特性</a>），在 Java16 中进行第三版孵化。</p><p>外部存储器访问 API 使 Java 程序能够安全有效地对各种外部存储器（例如本机存储器、持久性存储器、托管堆存储器等）进行操作。外部内存通常是说那些独立 JVM 之外的内存区域，可以不受 JVM 垃圾收集的影响，通常能够处理较大的内存。</p><p>这次带来的特性包括：</p><ul><li><code>MemorySegment</code>和<code>MemoryAddress</code>接口之间更加清晰的职责分离；</li><li>增加了新接口<code>MemoryAccess</code>，提供了常见的静态内存访问器，以便在简单的情况下尽量减少对<code>VarHandle</code> 的需求；</li><li>支持共享 segments，并提供向清理器注册 segments 的能力。</li></ul><p>这些新的 API 虽然不会直接影响多数的应用类开发人员，但是他们可以在内存的第三方库中提供支持，包括分布式缓存、非结构化文档存储、大型字节缓冲区、内存映射文件等。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java16 新增的特性，完整的特性清单可以从 <a href="https://openjdk.java.net/projects/jdk/16/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/16/</a> 查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-16-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java16 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/124264210" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java16 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Java16 是在 2021 年 3 月发布的一个短期版本，新增特性如下：JEP 338：向量 API（孵化功能）、JEP 347：启用 C++ 14 语言特性、JEP 357：从 Mercurial 迁移到 Git、JEP 369：迁移到 GitGitHub、JEP 376：ZGC 的并发线程堆栈处理、JEP 380：支持 Unix 套接字、JEP 386：Alpine Linux 移植、JEP 387：弹性元空间、JEP 388：Windows/AArch64 移植、JEP 389：外部链接器 API（孵化功能）、JEP 390：对基于值的类设置“弃用移除”警告、JEP 392：打包工具、JEP 393：外部存储器访问 API（第三版孵化功能）、JEP 394：instanceof 模式匹配、JEP 395：Record 类型、JEP 396：默认强封装 JDK 内部元素、JEP 397：密封类（第二版预览功能），接下来我们一起看看这些特性。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java16" scheme="https://www.howardliu.cn/tags/Java16/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java15 的新特性</title>
    <link href="https://www.howardliu.cn/java-15-features/"/>
    <id>https://www.howardliu.cn/java-15-features/</id>
    <published>2022-03-07T14:04:28.000Z</published>
    <updated>2022-03-07T14:04:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/eyes-5248678_1920.jpeg" alt="Java15 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java15 是在 2020 年 9 月发布的一个短期版本，新增特性如下：</p><ul><li>JEP 339：Edwards-Curve 数字签名算法</li><li>JEP 360：密封的类和接口（预览功能）</li><li>JEP 371：隐藏类</li><li>JEP 372：移除 Nashorn JavaScript 引擎</li><li>JEP 373：重新实现 DatagramSocket 接口</li><li>JEP 374：禁用偏向锁</li><li>JEP 375：instanceof 匹配模式（第二版预览功能）</li><li>JEP 377：ZGC：可伸缩低延迟垃圾收集器</li><li>JEP 378：文本块</li><li>JEP 379：Shenandoah：低暂停时间垃圾收集器</li><li>JEP 381：移除 Solaris 和 SPARC 端口 API</li><li>JEP 383：外部存储器访问 API（第二版孵化功能）</li><li>JEP 384：Record 类型（第二版预览功能）</li><li>JEP 385：废除 RMI Activation</li></ul><p>接下来我们一起看看这些特性。</p><h2 id="Edwards-Curve-数字签名算法（JEP-339）"><a href="#Edwards-Curve-数字签名算法（JEP-339）" class="headerlink" title="Edwards-Curve 数字签名算法（JEP 339）"></a>Edwards-Curve 数字签名算法（JEP 339）</h2><p>Edwards-Curve 数字签名算法（EdDSA），一种根据 RFC 8032 规范所描述的 Edwards-Curve 数字签名算法（EdDSA）实现加密签名。</p><p>EdDSA 是一种现代的椭圆曲线方案，与 JDK 中的现有签名方案相比，EdDSA 具有更高的安全性和性能，因此备受关注。它已经在 OpenSSL 和 BoringSSL 等加密库中得到支持，目前在区块链领域用的比较多。</p><p>我们看下官方给的例子：</p><pre><code class="java">byte[] msg = &quot;Hello, World!&quot;.getBytes(StandardCharsets.UTF_8);// example: generate a key pair and signKeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;Ed25519&quot;);KeyPair kp = kpg.generateKeyPair();// algorithm is pure Ed25519Signature sig = Signature.getInstance(&quot;Ed25519&quot;);sig.initSign(kp.getPrivate());sig.update(msg);System.out.println(Hex.encodeHexString(sig.sign()));// example: use KeyFactory to contruct a public keyKeyFactory kf = KeyFactory.getInstance(&quot;EdDSA&quot;);NamedParameterSpec paramSpec = new NamedParameterSpec(&quot;Ed25519&quot;);EdECPublicKeySpec pubSpec = new EdECPublicKeySpec(paramSpec, new EdECPoint(true, new BigInteger(&quot;1&quot;)));PublicKey pubKey = kf.generatePublic(pubSpec);System.out.println(pubKey.getAlgorithm());System.out.println(Hex.encodeHexString(pubKey.getEncoded()));System.out.println(pubKey.getFormat());</code></pre><p>例子中 Ed25519 是使用 SHA-512（SHA-2）和 Curve25519 的 EdDSA 签名方案。旨在提供与高质量 128 位对称密码相当的抗攻击能力，公钥长度为 256 位，签名长度为 512 位。</p><h2 id="隐藏类（JEP-371）"><a href="#隐藏类（JEP-371）" class="headerlink" title="隐藏类（JEP 371）"></a>隐藏类（JEP 371）</h2><p>Java15 引入了一个新的特性：隐藏类（Hidden Classes），一个专为框架而设计的特性。大多数开发人员不会直接使用这个特性，一般是通过动态字节码或 JVM 语言来使用隐藏类。</p><p>隐藏类有下面三个特点：</p><ol><li>不可发现：在运行时生成内部类对象；</li><li>访问控制：只能通过反射访问，不能直接被其他字节码访问；</li><li>较短的生命周期：可独立于其他类加载、卸载，且效率很高，能够减少框架的内存占用。</li></ol><p>隐藏类的功能特性还是比较有意思的，会涉及类加载、卸载、不可见、反射等很多内容，后续会开文单独聊，文章会放在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 专栏中。</p><h2 id="重新实现-DatagramSocket-接口（JEP-373）"><a href="#重新实现-DatagramSocket-接口（JEP-373）" class="headerlink" title="重新实现 DatagramSocket 接口（JEP 373）"></a>重新实现 DatagramSocket 接口（JEP 373）</h2><p>老的 DatagramSocket API 在 Java15 中被重写，是继 Java14 重写 Socket API 的后续不走。这个特性是 Loom 项目的先决条件。</p><p>目前，<code>DatagramSocket</code>和<code>MulticastSocket</code>将所有的套接字委托为<code>java.net.DatagramSocketImpl</code>的实现，根据不同的平台，Unix 平台使用<code>PlainDatagramSocketImpl</code>，Windows 平台使用<code>TwoStackPlainDatagramSocketImpl</code>和<code>DualPlainDatagramSocketImpl</code>。抽象类<code>DatagramSocketImpl</code>是 Java1.1 提供的，功能很少且有一些过时方法，阻碍了 NOI 的实现。</p><p>类似于 Java14 中对 Socket API 的重写（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 新特性</a>），会在<code>DatagramSocket</code>内部封装一个<code>DatagramSocket</code>实例，将所有调用直接委托给该实例。包装实例或者使用 NIO 的<code>DatagramChannel::socket</code>创建套接字，或者是使用原始<code>DatagramSocket</code>类的实现<code>DatagramSocketImpl</code>实现功能（用于实现向后兼容）。</p><p>我们可以看下新的依赖图：</p><p><img src="https://static.howardliu.cn/java/ReimplementDS.png" alt="DatagramSocket"></p><h2 id="禁用偏向锁（JEP-374）"><a href="#禁用偏向锁（JEP-374）" class="headerlink" title="禁用偏向锁（JEP 374）"></a>禁用偏向锁（JEP 374）</h2><p>在 Java15 中，默认禁用偏向锁，弃用了所有相关命令行选项。</p><p>偏向锁是 HotSpot 中一种用于减少非竞争锁定开销的优化技术，不过在如今的应用程序中，优化增益不太明显了。</p><p>根据官方说法，使用偏向锁增益最多的是大量使用早期同步组件（比如<code>Hashtable</code>、<code>Vector</code>等），随着新的 API 实现和针对多线程场景引入的支持并发的数据结构，偏向锁的锁定及撤销，会带来性能的开销，从而是优化收益降低。</p><p>而且随着越来越多的功能特性引入，偏向锁在同步子系统中引入的大量代码，侵入 HotSpot 其他组件，带来代码的复杂性和维护成本，成为代码优化的阻碍。所以官方要将其移除。</p><p>不过，有些应用在禁用偏向锁后会出现性能下降，可以使用<code>-XX:+UseBiasedLocking</code>手动开启。</p><h2 id="ZGC：可伸缩低延迟垃圾收集器（JEP-377）"><a href="#ZGC：可伸缩低延迟垃圾收集器（JEP-377）" class="headerlink" title="ZGC：可伸缩低延迟垃圾收集器（JEP 377）"></a>ZGC：可伸缩低延迟垃圾收集器（JEP 377）</h2><p>ZGC 是在 Java11 引入的（参见 <a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 新特性</a>），一直处于试验阶段，想要体验，需要在参数中使用<code>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code>组合启用，在 Java15 中，ZGC 成为正式特性，想要使用可以直接用命令<code>-XX:+UseZGC</code>就行。</p><p>ZGC 是一个重新设计的并发的垃圾回收器，可以极大的提升 GC 的性能，支持任意堆大小而保持稳定的低延迟。从 <a href="https://openjdk.java.net/jeps/333" target="_blank" rel="noopener">https://openjdk.java.net/jeps/333</a> 给出的数据可以看出来，在 128G 堆大小的测试中，ZGC 优势明显，找了一张网上的图片：</p><p><img src="https://static.howardliu.cn/java/java-11-1.png" alt="ZGC：可伸缩低延迟垃圾收集器"></p><p>虽然 ZGC 愿景很好，但是还有很长的路要走，所以默认的垃圾收集器还是 G1。</p><h2 id="Shenandoah：低暂停时间垃圾收集器（JEP-379）"><a href="#Shenandoah：低暂停时间垃圾收集器（JEP-379）" class="headerlink" title="Shenandoah：低暂停时间垃圾收集器（JEP 379）"></a>Shenandoah：低暂停时间垃圾收集器（JEP 379）</h2><p>Shenandoah 是在 Java12 引入的（参见）<a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a>，本次和 ZGC 一起转正。同样的，想要使用 Shenandoah，不再需要参数<code>-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC</code>组合，只使用<code>-XX:+UseShenandoahGC</code>即可。需要注意的是，Shenandoah 只在 OpenJDK 中提供，OracleJDK 中并不包含。</p><h2 id="文本块（JEP-378）"><a href="#文本块（JEP-378）" class="headerlink" title="文本块（JEP 378）"></a>文本块（JEP 378）</h2><p>文本块是千呼万唤终于转正，在 Java13 中首次引入（参见 <a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a>），在 Java14 中又增加了预览特性（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a>），终于在 Java15 确定下来，可以放心使用了。</p><p>我们再复习一下：</p><pre><code class="java">@Testvoid testTextBlock() {    final String singleLine = &quot;你好，我是看山，公众号「看山的小屋」。这行没有换行，而且我的后面多了一个空格 \n 这次换行了&quot;;    final String textBlockSingleLine = &quot;&quot;&quot;            你好，我是看山，公众号「看山的小屋」。\            这行没有换行，而且我的后面多了一个空格、s            这次换行了&quot;&quot;&quot;;    Assertions.assertEquals(singleLine, textBlockSingleLine);}</code></pre><p>这个功能特性是代码可读性的优化。</p><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><h3 id="密封类和接口（JEP-360）"><a href="#密封类和接口（JEP-360）" class="headerlink" title="密封类和接口（JEP 360）"></a>密封类和接口（JEP 360）</h3><p>目前，Java 没有提供对继承的细粒度控制，只有 public、protected、private、包内控制四种非常粗粒度的控制方式。</p><p>为此，密封类的目标是允许单个类声明哪些类型可以用作其子类型。这也适用于接口，并确定哪些类型可以实现它们。该功能特性新增了<code>sealed</code>和<code>non-sealed</code>修饰符和<code>permits</code>关键字。</p><p>我们可以做如下定义：</p><pre><code class="java">public sealed class Person permits Student, Worker, Teacher {}public sealed class Student extends Person        permits Pupil, JuniorSchoolStudent, HighSchoolStudent, CollegeStudent, GraduateStudent {}public final class Pupil extends Student {}public non-sealed class Worker extends Person {}public class OtherClass extends Worker {}public final class Teacher extends Person {}</code></pre><p>我们可以先定义一个<code>sealed</code>修饰的类<code>Person</code>，使用<code>permits</code>指定被继承的子类，这些子类必须是使用<code>final</code>或<code>sealed</code>或<code>non-sealed</code>修饰的类。其中<code>Student</code>是使用<code>sealed</code>修饰，所以也需要使用<code>permits</code>指定被继承的子类。<code>Worker</code>类使用<code>non-sealed</code>修饰，成为普通类，其他类都可以继承它。<code>Teacher</code>使用<code>final</code>修饰，不可再被继承。</p><p>从类图上看没有太多区别：</p><p><img src="https://static.howardliu.cn/java/sealed-class.png" alt="密封类和接口"></p><p>但是从功能特性上，起到了很好的约束作用，我们可以放心大胆的定义可以公开使用，但又不想被非特定类继承的类了。</p><h3 id="instanceof-模式匹配-预览第二版（JEP-375）"><a href="#instanceof-模式匹配-预览第二版（JEP-375）" class="headerlink" title="instanceof 模式匹配-预览第二版（JEP 375）"></a>instanceof 模式匹配-预览第二版（JEP 375）</h3><p>instanceof 模式匹配首先在 Java14 中提供预览功能（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 特性</a>），可以提供<code>instanceof</code>更加简洁高效的实现，在 Java15 中没有新增特性，主要是为了再次收集反馈，根据结果看，大家还是很期待这个功能，在 Java16 中正式提供。</p><p>我们再简单看下<code>instanceof</code>的改进：</p><pre><code class="java">@Testvoid test1() {    final Object obj1 = &quot;Hello, World!&quot;;    int result = 0;    if (obj1 instanceof String str) {        result = str.length();    } else if (obj1 instanceof Number num) {        result = num.intValue();    }    Assertions.assertEquals(13, result);}</code></pre><h3 id="Record-类型-预览第二版（JEP-384）"><a href="#Record-类型-预览第二版（JEP-384）" class="headerlink" title="Record 类型-预览第二版（JEP 384）"></a>Record 类型-预览第二版（JEP 384）</h3><p>Record 类型用来增强 Java 语言特性，充当不可变数据载体。在 Java14 中提供预览功能（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 新特性</a>），在 Java15 中提供第二次预览，这次预览的目标是收集用户反馈。</p><p>比如，我们定义一个<code>Person</code>类：</p><pre><code class="java">public record Person(String name, String address) {}</code></pre><p>我们转换为之前的定义会是一坨下面这种代码：</p><pre><code class="java">public final class PersonBefore14 {    private final String name;    private final String address;    public PersonBefore14(String name, String address) {        this.name = name;        this.address = address;    }    public String name() {        return name;    }    public String address() {        return address;    }    @Override    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        PersonBefore14 that = (PersonBefore14) o;        return Objects.equals(name, that.name) &amp;&amp; Objects.equals(address, that.address);    }    @Override    public int hashCode() {        return Objects.hash(name, address);    }    @Override    public String toString() {        return &quot;PersonBefore14{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +                &#39;}&#39;;    }}</code></pre><p>Record 类型特性有四个特性：</p><ol><li>设计一个面向对象的结构，表达简单的信息聚合；</li><li>帮助开发人员专注于建模不可变数据，而不是可扩展的行为；</li><li>自动实现数据驱动的方法，比如<code>equals</code>、<code>getter</code>、<code>setter</code>等方法；</li><li>保留长期存在的 Java 规范，比如迁移兼容性。</li></ol><p>我们不能将 Record 类型简单的理解为去除“样板化”代码的功能，它不是解决 JavaBean 命名约定的中很多模板化方法的冗余繁杂问题，它的目标不是类似 Lombok 等工具自动生成代码的功能，是从开发人员专注模型的角度出发的。</p><h2 id="孵化"><a href="#孵化" class="headerlink" title="孵化"></a>孵化</h2><h3 id="外部存储器访问-API-孵化第二版（JEP-383）"><a href="#外部存储器访问-API-孵化第二版（JEP-383）" class="headerlink" title="外部存储器访问 API-孵化第二版（JEP 383）"></a>外部存储器访问 API-孵化第二版（JEP 383）</h3><p>外部存储器访问 API 在 Java14 开始孵化（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 新特性</a>），在 Java15 中继续孵化状态，这个版本中增加了几个特性：</p><ul><li>新的<code>VarHandle</code>API，用于定制内存访问句柄；</li><li>支持<code>Spliterator</code>接口实现并行处理内存段；</li><li>增强了对映射内存段的支持；</li><li>能够像本机调用一样操作或间接操作内存地址。</li></ul><p>外部内存通常是说那些独立 JVM 之外的内存区域，可以不受 JVM 垃圾收集的影响，通常能够处理较大的内存。</p><p>这些新的 API 虽然不会直接影响多数的应用类开发人员，但是他们可以在内存的第三方库中提供支持，包括分布式缓存、非结构化文档存储、大型字节缓冲区、内存映射文件等。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="移除-Nashorn-JavaScript-引擎（JEP-372）"><a href="#移除-Nashorn-JavaScript-引擎（JEP-372）" class="headerlink" title="移除 Nashorn JavaScript 引擎（JEP 372）"></a>移除 Nashorn JavaScript 引擎（JEP 372）</h3><p>Nashorn JavaScript 引擎最初在 Java8 中引入（参见 <a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 新特性</a>），在 Java11 被标记为过期，在 Java15 中被删除，包括 Nashorn JavaScript 引擎、API、jjs 工具等内容。</p><p>Nashorn JavaScript 引擎是一个 JavaScript 脚本引擎，用来取代 Rhino 脚本引擎，对 ECMAScript-262 5.1 有完整的支持，增强了 Java 和 JavaScript 的兼容性，而且有很强的性能。</p><p>随着 GraalVM 和其他虚拟机技术最近的引入，Nashorn 引擎不再在 JDK 生态系统中占有一席之地。而且，ECMAScript 脚本语言结构、API 改变速度太快，Nashorn JavaScript 引擎维护成本太高，所以，直接删了。</p><h3 id="移除-Solaris-和-SPARC-端口-API（JEP-381）"><a href="#移除-Solaris-和-SPARC-端口-API（JEP-381）" class="headerlink" title="移除 Solaris 和 SPARC 端口 API（JEP 381）"></a>移除 Solaris 和 SPARC 端口 API（JEP 381）</h3><p>Solaris 和 SPARC 都已被 Linux 操作系统和英特尔处理器取代。放弃对 Solaris 和 SPARC 端口的支持将使 OpenJDK 社区的贡献者能够加速开发新功能，从而推动平台向前发展。</p><p>Solaris 和 SPARC 端口 API 在 Java14 中标记过时，在 Java15 中彻底移除。仅仅半年就痛下杀手，可见社区对于维护这些 API 深受折磨。</p><h3 id="废除-RMI-Activation（JEP-385）"><a href="#废除-RMI-Activation（JEP-385）" class="headerlink" title="废除 RMI Activation（JEP 385）"></a>废除 RMI Activation（JEP 385）</h3><p>RMI Activation 在 Java15 中标记为废除，会在未来版本删除。之所以被删除，是因为在现代的 web 应用中，已经不需要这种激活机制，继续维护，增加了 Java 开发人员的维护负担。在 Java8 的时候，已经将其设置为非必选项。</p><p>从开发系统的角度看，虽然 RMI Activation 是一个还不错的设计，但是已经有其他替代方案，继续维护开发下去，成本收益完全不匹配，及早舍弃，可以选择更加优秀的方案。有些类似于零边际成本的思想。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java15 新增的特性，完整的特性清单可以从 <a href="https://openjdk.java.net/projects/jdk/15/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/15/</a> 查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-15-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java15 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/123541149" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java15 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Java15 是在 2020 年 9 月发布的一个短期版本，新增特性如下：Edwards-Curve 数字签名算法；密封的类和接口（预览功能）；隐藏类；移除 Nashorn JavaScript 引擎；重新实现 DatagramSocket 接口；禁用偏向锁；instanceof 匹配模式（第二版预览功能）；ZGC：可伸缩低延迟垃圾收集器；文本块；Shenandoah：低暂停时间垃圾收集器；移除 Solaris 和 SPARC 端口 API；外部存储器访问 API（第二版孵化功能）；Record 类型（第二版预览功能）；废除 RMI Activation；接下来我们一起看看这些特性。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java15" scheme="https://www.howardliu.cn/tags/Java15/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java14 的新特性</title>
    <link href="https://www.howardliu.cn/java-14-features/"/>
    <id>https://www.howardliu.cn/java-14-features/</id>
    <published>2022-03-05T03:37:11.000Z</published>
    <updated>2022-03-05T03:37:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/tree-blossoms-7022041_1920.jpeg" alt="Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java14 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文讲解一下 Java14 的特性，这个版本带来了不少新特性、功能实用性的增强、GC 的尝试、性能优化等：</p><ul><li>JEP 305：instanceof 模式匹配 （预览版）</li><li>JEP 343：打包工具 （孵化）</li><li>JEP 345：G1 的可识别 NUMA 系统的内存分配</li><li>JEP 349：JFR 事件流</li><li>JEP 352：非原子性的字节缓冲区映射</li><li>JEP 358：NullPointerException 的友好提示信息</li><li>JEP 359：Record 声明 （预览版）</li><li>JEP 361：Switch 表达式转正 （第二版预览）</li><li>JEP 362：弃用 Solaris 和 SPARC 端口</li><li>JEP 363：删除 CMS 垃圾回收器</li><li>JEP 364：ZGC 支持 MacOS</li><li>JEP 365：ZGC 支持 Windows</li><li>JEP 366：弃用 ParallelScavenge 和 SerialOld GC 的组合</li><li>JEP 367：移除 Pack200 Tools 和 API</li><li>JEP 368：文本块 （第二版预览）</li><li>JEP 370：外部存储器访问 API（孵化）</li></ul><p>接下来我们一起看看这些特性。</p><h2 id="Switch-表达式转正（JEP-361）"><a href="#Switch-表达式转正（JEP-361）" class="headerlink" title="Switch 表达式转正（JEP 361）"></a>Switch 表达式转正（JEP 361）</h2><p>Switch 表达式在 Java12 和 Java13 都处于功能预览阶段，到 Java14 终于转正了，从另一个角度，我们可以在生产环境中使用这个功能了。</p><p>我们以“判断是否工作日”的例子展示一下，在 Java14 之前：</p><pre><code class="java">@Testvoid testSwitch() {    final DayOfWeek day = DayOfWeek.from(LocalDate.now());    String typeOfDay = &quot;&quot;;    switch (day) {        case MONDAY:        case TUESDAY:        case WEDNESDAY:        case THURSDAY:        case FRIDAY:            typeOfDay = &quot;Working Day&quot;;            break;        case SATURDAY:        case SUNDAY:            typeOfDay = &quot;Rest Day&quot;;            break;    }    Assertions.assertFalse(typeOfDay.isEmpty());}</code></pre><p>在 Java14 中：</p><pre><code class="java">@Testvoid testSwitchExpression() {    final DayOfWeek day = DayOfWeek.SATURDAY;    final String typeOfDay = switch (day) {        case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; {            System.out.println(&quot;Working Day: &quot; + day);            yield &quot;Working Day&quot;;        }        case SATURDAY, SUNDAY -&gt; &quot;Day Off&quot;;    };    Assertions.assertEquals(&quot;Day Off&quot;, typeOfDay);}</code></pre><p>注意看，例子中我们使用了两种写法，一种是通过<code>yield</code>关键字表示返回结果，一种是在<code>-&gt;</code>之后直接返回。</p><h2 id="预览功能"><a href="#预览功能" class="headerlink" title="预览功能"></a>预览功能</h2><p>和前面的版本一样，Java14 中也提供了一些预览功能，我们可以在预览环境中试用一下。</p><p>这次的预览功能包括文本块（第二版预览）、instanceof 模式匹配、Record 声明，接下来我们分别说一下。</p><h3 id="文本块（第二版预览，JEP-368）"><a href="#文本块（第二版预览，JEP-368）" class="headerlink" title="文本块（第二版预览，JEP 368）"></a>文本块（第二版预览，JEP 368）</h3><p>文本块在 Java13 中首次出现（参见 <a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13</a>），本次又提供了两个扩展：</p><ul><li><code>\</code>：表示当前语句未换行，与 shell 脚本中的习惯一致；</li><li><code>\s</code>：表示单个空格。</li></ul><p>我们看个例子：</p><pre><code class="java">@Testvoid testTextBlock() {    final String singleLine = &quot;你好，我是看山，公众号「看山的小屋」。不没有换行，而且我的后面多了一个空格 &quot;;    final String textBlockSingleLine = &quot;&quot;&quot;            你好，我是看山，公众号「看山的小屋」。\            不没有换行，而且我的后面多了一个空格、s&quot;&quot;&quot;;    Assertions.assertEquals(singleLine, textBlockSingleLine);}</code></pre><p>个人感觉、是比较实用的，这个功能在 Java15 中转正，值得期待。</p><h3 id="instanceof-模式匹配（JEP-305）"><a href="#instanceof-模式匹配（JEP-305）" class="headerlink" title="instanceof 模式匹配（JEP 305）"></a>instanceof 模式匹配（JEP 305）</h3><p><code>instanceof</code>主要用来检查对象类型，作为类型强转前的安全检查。</p><p>比如：</p><pre><code class="java">@Testvoid test() {    final Object obj1 = &quot;Hello, World!&quot;;    int result = 0;    if (obj1 instanceof String) {        String str = (String) obj1;        result = str.length();    } else if (obj1 instanceof Number) {        Number num = (Number) obj1;        result = num.intValue();    }    Assertions.assertEquals(13, result);}</code></pre><p>可以看到，我们每次判断类型之后，需要声明一个判断类型的变量，然后将判断参数强制转换类型，赋值给新声明的变量。这种写法显得繁琐且多余。</p><p>于是在 Java14 中对<code>instanceof</code>进行了改进：</p><pre><code class="java">@Testvoid test1() {    final Object obj1 = &quot;Hello, World!&quot;;    int result = 0;    if (obj1 instanceof String str) {        result = str.length();    } else if (obj1 instanceof Number num) {        result = num.intValue();    }    Assertions.assertEquals(13, result);}</code></pre><p>不仅如此，<code>instanceof</code>模式匹配的作用域还可以扩展。在<code>if</code>条件判断中，我们都知道<code>&amp;&amp;</code>与判断是会执行所有的表达式，所以使用<code>instanceof</code>模式匹配定义的局部变量继续判断。</p><p>比如：</p><pre><code class="java">if (obj1 instanceof String str &amp;&amp; str.length() &gt; 20) {    result = str.length();}</code></pre><p>与原来的写法对比，Java14 提供的写法代码更加简洁、可读性更高，能够提出很多冗余繁琐的代码，非常实用的一个特性，这个功能会在 Java16 中转正。</p><h3 id="Record-声明（JEP-359）"><a href="#Record-声明（JEP-359）" class="headerlink" title="Record 声明（JEP 359）"></a>Record 声明（JEP 359）</h3><p>在 Java14 预览功能中新增了一个关键字<code>record</code>，它是定义不可变数据类型封装类的关键字，主要用在特定领域类上。这个关键字最终会在 Java16 中正式提供。</p><p>我们都知道，在 Java 开发中，我们需要定义 POJO 作为数据存储对象，根据规范，POJO 中除了属性是个性化的，其他的比如<code>getter</code>、<code>setter</code>、<code>equals</code>、<code>hashCode</code>、<code>toString</code>都是模板化的写法，所以为了简便，很多类似 Lombok 的组件提供 Java 类编译时增强，通过在类上定义<code>@Data</code>注解自动添加这些模板化方法。在 Java14 中，我们可以直接使用<code>record</code>解决这个问题。</p><p>比如，我们定义一个<code>Person</code>类：</p><pre><code class="java">public record Person(String name, String address) {}</code></pre><p>我们转换为之前的定义会是一坨下面这种代码：</p><pre><code class="java">public final class PersonBefore14 {    private final String name;    private final String address;    public PersonBefore14(String name, String address) {        this.name = name;        this.address = address;    }    public String name() {        return name;    }    public String address() {        return address;    }    @Override    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        PersonBefore14 that = (PersonBefore14) o;        return Objects.equals(name, that.name) &amp;&amp; Objects.equals(address, that.address);    }    @Override    public int hashCode() {        return Objects.hash(name, address);    }    @Override    public String toString() {        return &quot;PersonBefore14{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +                &#39;}&#39;;    }}</code></pre><p>我们可以发现 Record 类有如下特征：</p><ol><li>一个构造方法</li><li>getter 方法名与属性名相同</li><li>有<code>equals()</code>、<code>hashCode()</code>方法</li><li>有<code>toString()</code>方法</li><li>类对象和属性被<code>final</code>修饰，所以构造函数是包含所有属性的，而且没有 setter 方法</li></ol><p>在<code>Class</code>类中也新增了对应的处理方法：</p><ul><li><code>getRecordComponents()</code>：返回一组<code>java.lang.reflect.RecordComponent</code>对象组成的数组，该数组的元素与<code>Record</code>类中的组件相对应，其顺序与在记录声明中出现的顺序相同，可以从该数组中的每个<code>RecordComponent</code>中提取到组件信息，包括其名称、类型、泛型类型、注释及其访问方法。</li><li><code>isRecord()</code>：返回所在类是否是 Record 类型，如果是，则返回 true。</li></ul><p>看起来，Record 类和 Enum 很像，都是一定的模板类，通过语法糖定义，在 Java 编译过程中，将其编译成特定的格式，功能很好，但如果没有习惯使用，可能会觉得限制太多。</p><h2 id="NullPointerException-的友好提示信息（JEP-358）"><a href="#NullPointerException-的友好提示信息（JEP-358）" class="headerlink" title="NullPointerException 的友好提示信息（JEP 358）"></a>NullPointerException 的友好提示信息（JEP 358）</h2><p>在没有考虑完全场景的情况下，很容易碰到空指针异常（NullPointerException，简称 NPE）。一般碰到这个异常，根据异常栈信息我们很容易定位到发生异常的代码行，比如：</p><pre><code class="java">@Testvoid test1() {    Student s = null;    Assertions.assertThrows(NullPointerException.class, ()-&gt; s.getName())            .fillInStackTrace()            .printStackTrace();}</code></pre><p>如果是在 Java14 之前，这个时候打印出来的异常信息是：</p><pre><code class="log">Exception in thread &quot;main&quot; java.lang.NullPointerException    at cn.howardliu.tutorials.java14.NpeTest.test1(NpeTest.java:20)</code></pre><p>对于上面例子，我们可以直接定位到<code>s</code>是<code>null</code>，但是下面这个例子呢：</p><pre><code class="java">@Testvoid test2() {    Student s = new Student();    s.setName(&quot;看山&quot;);    Assertions.assertThrows(NullPointerException.class, ()-&gt; s.getClazz().getNo())            .fillInStackTrace()            .printStackTrace();}</code></pre><p>我们很难判断<code>s</code>或者<code>s</code>中的<code>clazz</code>是<code>null</code>，需要查看上下文代码，或者复杂情况还需要添加日志辅助定位问题。</p><p>在 Java14 中，对 NullPointerException 异常栈信息做了增强，通过分析程序的字节码信息，能够做到准确地定位到出现 NullPointerException 的变量，并且根据实际源代码打印出详细异常信息。此时，上面例子的异常信息是：</p><pre><code class="log">java.lang.NullPointerException: Cannot invoke &quot;cn.howardliu.tutorials.java14.NpeTest$Clazz.getNo()&quot; because the return value of &quot;cn.howardliu.tutorials.java14.NpeTest$Student.getClazz()&quot; is null    at cn.howardliu.tutorials.java14.NpeTest.test2(NpeTest.java:30)</code></pre><p>这样一目了然。</p><h2 id="孵化功能"><a href="#孵化功能" class="headerlink" title="孵化功能"></a>孵化功能</h2><p>孵化功能是 Java 开发团队让我们提前尝鲜、公测的功能，在 Java9 模块化之后，孵化功能会放在<code>jdk.incubator.</code>中。</p><h3 id="外部存储器访问-API（JEP-370）"><a href="#外部存储器访问-API（JEP-370）" class="headerlink" title="外部存储器访问 API（JEP 370）"></a>外部存储器访问 API（JEP 370）</h3><p>Java 对象是驻留在堆上，但是有时候因为其算法或者内存结构的原因，使用效率低下、性能低下、受垃圾收集器 GC 算法影响。所以很多时候我们会使用本机内存或者称为直接内存。</p><p>在 Java14 之前，使用直接内存我们会用到<code>ByteBuffer</code>或者<code>Unsafe</code>，但是这两个都存在一些问题。</p><ul><li><code>ByteBuffer</code>管理内存最大不能够超过 2G；</li><li><code>ByteBuffer</code>管理的这部分内存需要使用垃圾收集器回收内存，使用不当可能造成内存泄漏；</li><li><code>Unsafe</code>是非标准的 Java API，可能会因为不合法的内存使用致使系统崩溃。</li></ul><p>“天下苦秦久矣”，于是在 Java14 中提供了新的 API：</p><ul><li><code>MemorySegment</code>：用来申请内存区域，可以是堆内存，也可以是对外内存；</li><li><code>MemoryAddress</code>：从<code>MemorySegment</code>实例获取已申请内存的内存地址用于执行操作，例如从底层内存段的内存中检索数据；</li><li><code>MemoryLayout</code>：用来描述内存段的内容，它允许我们定义如何将内存分解为元素，并提供每个元素的大小。</li></ul><p>这部分功能截止到 Java17 还是孵化功能，而且内容比较多，后续会单独开一篇介绍。</p><h3 id="打包工具（JEP-343）"><a href="#打包工具（JEP-343）" class="headerlink" title="打包工具（JEP 343）"></a>打包工具（JEP 343）</h3><p>一般来说，Java 程序会以一个 Jar 的形式提供，web 服务可能是 war 或者 ear 包，但是有时候我们的 Java 程序可能是在自己的 PC 机（比如 Windows 或者 MacOS）上运行，期望可以通过双击打开的方式。</p><p>于是 Java14 引入了<code>引入了 jdk.incubator.jpackage.jmod</code>，基于 JavaFX javapackager tool，其目的就是创建一个打包工具，可以将 jar 包构建成 exe、pkg、dmg、deb、rpm 格式的安装文件。</p><p>我们可以使用<code>jlink</code>创建一个最小可运行的模块包，然后使用<code>jpackage</code>将其构建成安装包：</p><pre><code class="shell">jpackage --name myapp --input lib --main-jar main.jar</code></pre><h2 id="JVM-功能"><a href="#JVM-功能" class="headerlink" title="JVM 功能"></a>JVM 功能</h2><h3 id="ZGC-支持-MacOS-和-Windows-系统（JEP-364、JEP-365）"><a href="#ZGC-支持-MacOS-和-Windows-系统（JEP-364、JEP-365）" class="headerlink" title="ZGC 支持 MacOS 和 Windows 系统（JEP 364、JEP 365）"></a>ZGC 支持 MacOS 和 Windows 系统（JEP 364、JEP 365）</h3><p>ZGC 最初是在 Java11 中引入（参见 <a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a>），在后续版本中，不断升级优化，实现可伸缩、低延迟的目标，使用了内存读屏障、染色指针、内存多重映射等技术。在之前，ZGC 只支持 Linux/x64 平台，在 Java14 之后，支持了 macOS/x64 和 Windows/x64 系统中。</p><p>开启参数：</p><pre><code class="shell">-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code></pre><h3 id="G1-的可识别-NUMA-系统的内存分配（JEP-345）"><a href="#G1-的可识别-NUMA-系统的内存分配（JEP-345）" class="headerlink" title="G1 的可识别 NUMA 系统的内存分配（JEP 345）"></a>G1 的可识别 NUMA 系统的内存分配（JEP 345）</h3><p>Java14 改进了非一致性内存访问（Non-uniform Memory Access，NUMA）系统上的 G1 垃圾收集器的整体性能，主要是对年轻代的内存分配做出优化，从而提升 CPU 计算过程中内存访问速度。</p><p>NUMA 主要是指在多插槽物理计算机体系中，处理器一般是多核，且越来越多具备 NUMA 访问体系结构，即内存与每个插槽或内核之间的距离不等。套接字之间的内存访问有不同的性能特征，更远的套接字访问会有更多的时间消耗。这样的结果是，每个核对于某一区域的内存访问速度会随核与物理内存的位置远近有所差异。</p><p>Java 分配内存时，G1 会申请一块 region，作为对象存放区域。如果能够感知 NUMA，就可以优先在当前线程绑定的 NUMA 节点空闲内存执行申请内存操作，用于提升访问速度。</p><p>启用参数是<code>-XX:+UseNUMA</code>。</p><h3 id="JFR-事件流（JEP-349）"><a href="#JFR-事件流（JEP-349）" class="headerlink" title="JFR 事件流（JEP 349）"></a>JFR 事件流（JEP 349）</h3><p>飞行记录器（Flight Recorder）是在 Java11 中引入（参见 <a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a>）。</p><p>本次增强可以实现 JFR 数据的公开访问，可以通过使用<code>jdk.jfr.consumer</code>中的方法持续读取或流式传输读取记录，用于持续监控。这样的话，我们可以与现有监控系统集成，实现 JFR 数据的持续监听，不用非得等着收集完成后再解析分析。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h2 id="非原子性的字节缓冲区映射（JEP-352）"><a href="#非原子性的字节缓冲区映射（JEP-352）" class="headerlink" title="非原子性的字节缓冲区映射（JEP 352）"></a>非原子性的字节缓冲区映射（JEP 352）</h2><p>对<code>FileChannel</code>进行扩展，定义了<code>jdk.nio.mapmode.ExtendedMapMode</code>，用来创建<code>MappedByteBuffer</code>实例，可以对非原子性的字节缓冲区映射（Non-Volatile Mapped Byte Buffers，NVM）实现持久化。</p><h3 id="删除-CMS-垃圾回收器（JEP-363）"><a href="#删除-CMS-垃圾回收器（JEP-363）" class="headerlink" title="删除 CMS 垃圾回收器（JEP 363）"></a>删除 CMS 垃圾回收器（JEP 363）</h3><p>CMS 是老年代垃圾回收算法，通过标记-清除的方式进行内存回收，在内存回收过程中能够与用户线程并行执行。在 G1 之前，CMS 几乎占据了 GC 的全部江山。在使用过程中，一般是 CMS 与 Parallel New 搭配使用。</p><p>CMS 由于其算法特性，会产生内存碎片和浮动垃圾，随着时间推移，可能出现的情况是，虽然老年代还有空间，但是没有办法分配足够内存给大对象。</p><p>所以在 Java9 中开始放弃使用 CMS，在 Java14 中彻底删除，并删除与 CMS 有关的参数。从 Java14 开始，CMS 成为了历史。</p><h3 id="弃用-ParallelScavenge-和-SerialOld-GC-的组合（JEP-366）"><a href="#弃用-ParallelScavenge-和-SerialOld-GC-的组合（JEP-366）" class="headerlink" title="弃用 ParallelScavenge 和 SerialOld GC 的组合（JEP 366）"></a>弃用 ParallelScavenge 和 SerialOld GC 的组合（JEP 366）</h3><p>Parallel Scavenge 是并行收集算法，SerialOld 提供老年代串行收集，这种年轻代使用并行算法、老年代使用串行算法的混搭的方式，使用场景少且有风险。但是却需要大量工作量维护，所以在 Java14 中，删除了这两种 GC 组合。</p><p>删除组合的方式是通过启用组合参数<code>-XX:+UseParallelGC -XX:-UseParallelOldGC</code>，并在单独使用<code>-XX:-UseParallelOldGC</code>时会收到警告信息。</p><h3 id="移除-Pack200-Tools-和-API（JEP-367）"><a href="#移除-Pack200-Tools-和-API（JEP-367）" class="headerlink" title="移除 Pack200 Tools 和 API（JEP 367）"></a>移除 Pack200 Tools 和 API（JEP 367）</h3><p>these were deprecated for removal in Java 11, and now removed</p><p>删除<code>java.util.jar</code>包中的<code>pack200</code>和<code>unpack200</code>工具以及 Pack200 API。这些工具和 API 已在 Java11 时标记弃用，删除也是意料之中。</p><h3 id="弃用-Solaris-和-SPARC-端口（JEP-362）"><a href="#弃用-Solaris-和-SPARC-端口（JEP-362）" class="headerlink" title="弃用 Solaris 和 SPARC 端口（JEP 362）"></a>弃用 Solaris 和 SPARC 端口（JEP 362）</h3><p>Solaris 和 SPARC 都已被 Linux 操作系统和英特尔处理器取代。放弃对 Solaris 和 SPARC 端口的支持将使 OpenJDK 社区的贡献者能够加速开发新功能，从而推动平台向前发展。</p><p>这些 API 在 Java14 中标记弃用，在 Java15 中彻底删除。这样做，也是为了让很多正在进行的项目尽早适应新的架构。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java14 新增的特性，完整的特性清单可以从 <a href="https://openjdk.java.net/projects/jdk/14/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/14/</a> 查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-14-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java14 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/123340900" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java14 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文讲解一下 Java14 的特性，这个版本带来了不少新特性、功能实用性的增强、GC 的尝试、性能优化等：JEP 305：instanceof 模式匹配 （预览版）；JEP 343：打包工具 （孵化）；JEP 345：G1 的可识别 NUMA 系统的内存分配；JEP 349：JFR 事件流；JEP 352：非原子性的字节缓冲区映射；JEP 358：NullPointerException 的友好提示信息；JEP 359：Record 声明 （预览版）；JEP 361：Switch 表达式转正 （第二版预览）；JEP 362：弃用 Solaris 和 SPARC 端口；JEP 363：删除 CMS 垃圾回收器；JEP 364：ZGC 支持 MacOS；JEP 365：ZGC 支持 Windows；JEP 366：弃用 ParallelScavenge 和 SerialOld GC 的组合；JEP 367：移除 Pack200 Tools 和 API；JEP 368：文本块 （第二版预览）；JEP 370：外部存储器访问 API（孵化）。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java14" scheme="https://www.howardliu.cn/tags/Java14/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java13 的新特性</title>
    <link href="https://www.howardliu.cn/java-13-features/"/>
    <id>https://www.howardliu.cn/java-13-features/</id>
    <published>2022-02-14T13:41:37.000Z</published>
    <updated>2022-02-14T13:41:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/bird-6965228_1920.jpeg" alt="Java13 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文讲解一下 Java13 的特性，这个版本在语法特性上增加不多，值得关注的是两个预览功能：Switch 表达式和文本块，另外可以关乎的是性能优化方面的：动态类数据共享（CDS）存档、ZGC 动态释放未使用内存、Socket API 重构。这些方面可以看出，Java 的升级方向有两个，一是增加功能，增加新的语法特性；二是增强功能，提升已有功能性能。</p><h2 id="预览功能"><a href="#预览功能" class="headerlink" title="预览功能"></a>预览功能</h2><p>Java13 引入了两个新的语法特性：Switch 表达式和文本块。这些预览功能是为了让开发者尝鲜的同时，可以快速调整，反馈好就留下，不好就移除。目前来看，这些特性还是挺香的。</p><p><img src="https://static.howardliu.cn/Illustration/zhenxiangdinglv.jpeg" alt="真香定律"></p><h3 id="Switch-表达式"><a href="#Switch-表达式" class="headerlink" title="Switch 表达式"></a>Switch 表达式</h3><p>在 Java12 中 Switch 表达式首次以预览版的身份出现，在 Java13 中又做了增强，在 Java14 正式提供。Java13 添加了<code>yield</code>关键字，用来返回值。</p><p><code>yield</code>与<code>return</code>的区别在于，<code>yield</code>只会跳出<code>switch</code>块，<code>return</code>是跳出当前方法或循环。</p><p>比如下面的例子，在 Java12 之前，要判断日期可以这样写：</p><pre><code class="java">@Testvoid testSwitch() {    final DayOfWeek day = DayOfWeek.from(LocalDate.now());    String typeOfDay = &quot;&quot;;    switch (day) {        case MONDAY:        case TUESDAY:        case WEDNESDAY:        case THURSDAY:        case FRIDAY:            typeOfDay = &quot;Working Day&quot;;            break;        case SATURDAY:        case SUNDAY:            typeOfDay = &quot;Rest Day&quot;;            break;    }    Assertions.assertFalse(typeOfDay.isEmpty());}</code></pre><p>在 Java12 提供的 Switch 表达式预览功能，我们可以简化一下：</p><pre><code class="java">@Testvoid testSwitchExpression() {    final DayOfWeek day = DayOfWeek.SATURDAY;    final String typeOfDay = switch (day) {        case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; &quot;Working Day&quot;;        case SATURDAY, SUNDAY -&gt; &quot;Day Off&quot;;    };    Assertions.assertEquals(&quot;Day Off&quot;, typeOfDay);}</code></pre><p>这样可以实现判断，但是没有办法在表达式中实现其他逻辑了。于是 Java13 补齐了这个功能：</p><pre><code class="java">@Testvoid testSwitchExpression13() {    final DayOfWeek day = DayOfWeek.SATURDAY;    final String typeOfDay = switch (day) {        case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; {            System.out.println(&quot;Working Day: &quot; + day);            yield &quot;Working Day&quot;;        }        case SATURDAY, SUNDAY -&gt; {            System.out.println(&quot;Day Off: &quot; + day);            yield &quot;Day Off&quot;;        }    };    Assertions.assertEquals(&quot;Day Off&quot;, typeOfDay);}</code></pre><p>这里需要说明一下，既然是预览功能，会与正式提供功能有些出入。上面的代码是在 Java14 环境中编写，与 Java13 发布的功能描述有些差异，这点不必深究，已经废弃的约束就是不存在。</p><h3 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h3><p>一直以来，Java 中的字符串定义都是以双引号括起来的形式，不支持多行书写，所以在需要多行字符串中，需要使用转义符表示，既不好看、还不好读，更不好维护。</p><p>千呼万唤始出来，终于有了文本块功能。</p><p>比如，我们想要写一段 Json 格式的数据，Java13 之前需要写成：</p><pre><code class="java">String json = &quot;{\n&quot;        + &quot;  \&quot;wechat\&quot;: \&quot;hellokanshan\&quot;,\n&quot;        + &quot;  \&quot;wechatName\&quot;: \&quot;看山、&quot;,\n&quot;        + &quot;  \&quot;mp\&quot;: \&quot;kanshanshuo\&quot;,\n&quot;        + &quot;  \&quot;mpName\&quot;: \&quot;看山的小屋、&quot;\n&quot;        + &quot;}\n&quot;;</code></pre><p>但是在 Java13 预览版中可以写作：</p><pre><code class="java">String json2 = &quot;&quot;&quot;        {          &quot;wechat&quot;: &quot;hellokanshan&quot;,          &quot;wechatName&quot;: &quot;看山&quot;,          &quot;mp&quot;: &quot;kanshanshuo&quot;,          &quot;mpName&quot;: &quot;看山的小屋&quot;        }        &quot;&quot;&quot;;</code></pre><p>少了很多的+、换行、转移等字符，看着更加直观。</p><p>这个功能在 Java15 中正式提供。</p><h2 id="动态类数据共享（CDS）存档"><a href="#动态类数据共享（CDS）存档" class="headerlink" title="动态类数据共享（CDS）存档"></a>动态类数据共享（CDS）存档</h2><p>CDS 是 Java5 引入的一种类预处理方式，可以将一组类共享到一个归档文件中，借助内存映射加载类数据，减少启动时间，并可实现在多 JVM 之间共享的功能。在 Java10 对其进行扩展，增大了 CDS 使用范围，即 AppCDS（参见 <a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 新特性</a>）。到了 Java12，将 CDS 归档文件作为了默认功能开放出来（参见 <a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 新特性</a>）。</p><p>但是这个功能在使用的时候还是有些麻烦。为了生成归档文件，开发人员必须先对应用程序进行试运行，创建一个类列表，然后将其转储到归档文件中。然后，这个归档才可以用来在 JVM 之间共享元数据。</p><p>Java13 简化了这个过程：允许 Java 应用在运行结束后动态归档，即将已被加载但不属于 CDS 的类（包括自定义类和引用库的类）动态添加到 CDS 归档文件中。不用再提供归档类的列表，通过更加简洁的方式创建包含应用程序的归档。</p><p>我们可以使用<code>-XX:ArchiveClassesAtExit</code>参数控制应用程序退出时创建 CDS 归档文件：</p><pre><code class="shell">java -XX:ArchiveClassesAtExit=&lt;archive filename&gt; -cp &lt;app jar&gt; AppName</code></pre><p>也可以使用<code>-XX:SharedArchiveFile</code>来使用动态存档功能：</p><pre><code class="shell">java -XX:SharedArchiveFile=&lt;archive filename&gt; -cp &lt;app jar&gt; AppName</code></pre><h2 id="ZGC-增强：释放未使用内存"><a href="#ZGC-增强：释放未使用内存" class="headerlink" title="ZGC 增强：释放未使用内存"></a>ZGC 增强：释放未使用内存</h2><p>ZGC 是 Java11 中引入的一个可伸缩、低延迟的垃圾收集器，主要目标包括：GC 停顿时间不超过 10ms；可以处理从几百 MB 的小堆，到几个 TB 的大堆；应用吞吐能力不会下降超过 15%等（参见 <a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a>）。</p><p>但是 ZGC 并没有像 Hotspot 中的 G1 和 Shenandoah 那样，可以主动释放未使用的内存，对于多数应用程序来说，CPU 和内存都是稀缺资源，尤其是现在云上环境和虚拟化技术，如果应用程序占用的内存长期处于空闲状态，还紧握住不释放，就是极大的浪费。</p><p>在 Java13 中对其进行改进，包括：</p><ul><li>可释放空闲内存</li><li>支持的最大堆大小从 4TB 扩大到 16TB</li></ul><p>我们来看下 ZGC 的内部逻辑。</p><p>ZGC 堆由一组称为 ZPages 的堆区域组成，每个 ZPage 都与提交的堆内存的可变数量相关联。当 ZGC 压缩堆时，ZPages 被释放并插入到页面缓存 ZPageCache 中，页面缓存中的 ZPages 可以重新使用，以满足新的堆分配。</p><p>ZPageCache 中的 ZPages 集合代表堆中未使用的部分，这部分可以释放回操作系统。ZPageCache 中的 ZPages 根据 LRU（最近最少使用）排序，并按照大中小进行分组。这样的话就可以根据算法按顺序释放未使用的内存。</p><p>Java13 还提供了<code>-XX:ZUncommitDelay=&lt;seconds&gt;</code>命令，用于指定释放多长时间（默认是 5 分钟）未使用的内存，这个参数类似于 Shenandoah 中的<code>-XX:ShenandoahUncommitDelay=&lt;milliseconds&gt;</code>。</p><p>在 Java13 中，ZGC 内存释放功能默认开启，可通过参数<code>-XX:-ZUncommit</code>关闭该功能。由于 ZGC 释放内存时，不会低于最小堆内存，即当最小堆内存（-Xms）与最大堆内存（-Xmx）一样时，不会自动释放。</p><h2 id="Socket-API-重构"><a href="#Socket-API-重构" class="headerlink" title="Socket API 重构"></a>Socket API 重构</h2><p>Java 中的 Socket 是从 Java1.0 开始就有的，是 Java 中不可或缺的网络 API，算起来已经服役 20 多年了。在这段时间内，信息技术已经发生了很多变化，这些上古 API 有一定的局限性，而且不容易维护和调试。</p><p>Java 的 Socket API 主要包括<code>java.net.ServerSocket</code>和<code>java.net.Socket</code>，<code>ServerSocket</code>用来监听连接请求的端口，连接成功后返回的是<code>Socket</code>对象，可以通过操作<code>Socket</code>对象实现数据发送和读取。Java 是通过<code>SocketImpl</code>实现这些功能。</p><p>在 Java13 之前，通过<code>SocketImpl</code>的子类<code>PlainSocketImpl</code>实现。在 Java13 中，引入<code>NioSocketImpl</code>实现，该实现以 NIO 为基础，与高速缓冲机制集成，实现非阻塞式网络。</p><p>如果想用回<code>PlainSocketImpl</code>，可以设置启动参数<code>-Djdk.net.usePlainSocketImpl=true</code>即可。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java13 新增的特性，完整的特性清单可以从<a href="https://openjdk.java.net/projects/jdk/13/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/13/</a>查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-13-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java13 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122932951" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java13 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文讲解一下 Java13 的特性，这个版本在语法特性上增加不多，值得关注的是两个预览功能：Switch 表达式和文本块，另外可以关乎的是性能优化方面的：动态类数据共享（CDS）存档、ZGC 动态释放未使用内存、Socket API 重构。这些方面可以看出，Java 的升级方向有两个，一是增加功能，增加新的语法特性；二是增强功能，提升已有功能性能。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java13" scheme="https://www.howardliu.cn/tags/Java13/"/>
    
  </entry>
  
  <entry>
    <title>从春运迁徙图看到的一些东西</title>
    <link href="https://www.howardliu.cn/2022-spring-festival/"/>
    <id>https://www.howardliu.cn/2022-spring-festival/</id>
    <published>2022-01-29T11:51:31.000Z</published>
    <updated>2022-01-29T11:51:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/bird-g81ab0101d_1920_20220129150731.jpeg" alt="从春运迁徙图看到的一些东西"></p><p>你好，我是看山。</p><p>腊月二十七宰鸡赶大集，响应国家号召，就地过年。</p><p>难免思乡，于是翻了翻百度地图提供的迁徙数据。我们从迁出地和迁徙趋势看一看这几年的春运变化。</p><a id="more"></a><p>我们先来看看从 2020 年到现在（2022 年）的春运迁徙图：</p><p><img src="https://static.howardliu.cn/raving/2020-spring-festival-travel-rush.png" alt="2020 年春运迁徙图"></p><p><img src="https://static.howardliu.cn/raving/2021-spring-festival-travel-rush.png" alt="2021 年春运迁徙图"></p><p><img src="https://static.howardliu.cn/raving/2022-spring-festival-travel-rush.png" alt="2022 年春运迁徙图"></p><p>从三张图中，我们不难看出一些规律，待我慢慢道来。</p><h2 id="春运热门迁出地"><a href="#春运热门迁出地" class="headerlink" title="春运热门迁出地"></a>春运热门迁出地</h2><p>这几年中，比较热门的迁出地有北京、上海、广州、深圳，稍微热门的是杭州、武汉、重庆、长沙、西安等。不难看出，热门迁出地对应着一线、新一线城市。这些城市的外来务工人员比较多，在春节选择回家过年。</p><p><img src="https://static.howardliu.cn/raving/bsgs.jpg" alt="北上广深"></p><p>其中，北上广深是一线城市，很多人或为生活、或为梦想，选择了一线城市打拼。辛苦一年，趁着年关回到家，无论家乡是好是孬，总归是一个平静的港湾。至于年后，是选择以梦为马潇洒天涯，还是选择背起行囊漂泊他乡，都是年后的事情。</p><p><img src="https://static.howardliu.cn/raving/2020city.jpg" alt="2020 年城市购买排行"></p><p>当人们在寻找工作和生活的平衡点时，很多城市也是快速发展，成为了新一线城市，成为了中国发展的新兴动力城市，也给了我们更多的选择。人们不在单纯的考虑收入，会更多的考虑感受、家人，更多的考虑幸福。</p><p>无论我们在哪，做什么，都是为了追求幸福，幸福才是我们心底最期望的东西。</p><p><img src="https://static.howardliu.cn/raving/happy.jpg" alt="幸福"></p><h2 id="疫情对迁徙的影响在减弱"><a href="#疫情对迁徙的影响在减弱" class="headerlink" title="疫情对迁徙的影响在减弱"></a>疫情对迁徙的影响在减弱</h2><p><img src="https://static.howardliu.cn/raving/2019-spring-festival-line-chart.png" alt="2019 年春运迁徙趋势图"></p><p>疫情发生前（2019 年），我们可以看到，年前迁移流量持续增长，大年初一稍微少了一点，到初六假期结束，迁移量达到峰值。我们以此为参照，看下疫情的影响。</p><p><img src="https://static.howardliu.cn/raving/2020-spring-festival-line-chart.png" alt="2020 年春运迁徙趋势图"></p><p>2020 年疫情爆发，武汉封城，春节期间全国人民上下齐心，共抗疫情。这个时候，春运流动基本上停止。作为普通民众，我们能够做到，就是待在家里，不给国家添麻烦。</p><p><img src="https://static.howardliu.cn/raving/2021-spring-festival-line-chart.png" alt="2021 年春运迁徙趋势图"></p><p>2021 年是疫情第二年，咱们国家提出的“清零”政策取得了好成绩，生活工作基本上恢复正常，也有了十一小长假出行旅游复苏的场景。外国友人们躲在家里看我们堵在路上，心里一定是各种羡慕。而且，在年底开始全员接种疫苗，给我们增加一层保障。</p><p>不过由于冬天天气转冷，病毒的存活能力增强，为了保住来之不易的战果。各地倡导就地过年。所以能够看到，春运的流量比 2019 年减少了将近一半。</p><p><img src="https://static.howardliu.cn/raving/2022-spring-festival-line-chart.png" alt="2022 年春运迁徙趋势图"></p><p>今年的春运刚刚开始，我们只能够根据趋势推测一下，到今天为止，迁徙流量的发展基本上和 2019 年相似。这不得不说在抗疫方面，2021 年取得了好成绩。全民接种加强针疫苗，各地的清零政策也是严格执行。虽然年底有些地方出现了本土疫情，但是都是在控制范围内，没有爆发的征兆。有了 2021 年春运、五一、十一等各种假期迁徙的经验，各地采取“有温度的严格控制”，让远在他乡想在春节回家的游子们，一解乡愁。</p><p>可以预见，等到了 2023 年春运的时候，我们可能就不再纠结能不能回、让不让回，只需要带着必要的证明，正常计划归乡日期就好。</p><p>按照习俗，给大家拜个早年，愿大家新年胜旧年，欢愉且胜意，万事尽可期。</p><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/2022-spring-festival/">从春运迁徙图看到的一些东西</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">从春运迁徙图看到的一些东西</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      腊月二十七宰鸡赶大集，响应国家号召，就地过年。难免思乡，于是翻了翻百度地图提供的迁徙数据。我们从迁出地和迁徙趋势看一看这几年的春运变化。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="春运" scheme="https://www.howardliu.cn/tags/%E6%98%A5%E8%BF%90/"/>
    
      <category term="迁徙" scheme="https://www.howardliu.cn/tags/%E8%BF%81%E5%BE%99/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java12 的新特性</title>
    <link href="https://www.howardliu.cn/java-12-features/"/>
    <id>https://www.howardliu.cn/java-12-features/</id>
    <published>2022-01-15T05:10:35.000Z</published>
    <updated>2022-01-15T05:10:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/lily-gf02d5baa4_1920.jpg" alt="Java12 的新特性"></p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>你好，我是看山。</p><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文讲解一下 Java12 的特性，作为第一个长期支持版 Java11 之后的第一个版本，增加的功能也不少，除了一些小幅度的 API 增强，增加了另一个试验阶段的垃圾收集器 Shenandoah、对 G1 做了优化、增加微基准套件等。</p><h2 id="语法特性"><a href="#语法特性" class="headerlink" title="语法特性"></a>语法特性</h2><p>Java12 提供了很多的语法特性，既有小而美的增强 API，又有特别方便的工具扩展。本节我们跟着代码看看比较好玩的功能。</p><h3 id="String-的增强方法：indent-和-transform"><a href="#String-的增强方法：indent-和-transform" class="headerlink" title="String 的增强方法：indent 和 transform"></a>String 的增强方法：indent 和 transform</h3><p>在 Java12 中，String 又增强了两个方法。之所以说又，是因为在 Java11 中已经增加过小而美的方法，想要详细了解的可以查看 <a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 新特性</a>。</p><p>这次增加的方法是<code>indent</code>（缩进）和<code>transform</code>（转换）。</p><p>顾名思义，<code>indent</code>方法是对字符串每行（使用<code>\r</code>或<code>\n</code>分隔）数据缩进指定空白字符，参数是 int 类型。</p><p>如果参数大于 0，就缩进指定数量的空格；如果参数小于 0，就将左侧的空字符删除指定数量，即右移。</p><p>我们看下源码：</p><pre><code class="java">public String indent(int n) {    if (isEmpty()) {        return &quot;&quot;;    }    Stream&lt;String&gt; stream = lines();    if (n &gt; 0) {        final String spaces = &quot; &quot;.repeat(n);        stream = stream.map(s -&gt; spaces + s);    } else if (n == Integer.MIN_VALUE) {        stream = stream.map(s -&gt; s.stripLeading());    } else if (n &lt; 0) {        stream = stream.map(s -&gt; s.substring(Math.min(-n, s.indexOfNonWhitespace())));    }    return stream.collect(Collectors.joining(&quot;\n&quot;, &quot;&quot;, &quot;\n&quot;));}</code></pre><p>这里会使用到 Java11 增加的<code>lines</code>、<code>repeat</code>、<code>stripLeading</code>等方法。<code>indent</code>最后会将多行数据通过<code>Collectors.joining(&quot;\n&quot;, &quot;&quot;, &quot;\n&quot;)</code>方法拼接，结果会有两点需要注意：</p><ul><li><code>\r</code>会被替换成<code>\n</code>；</li><li>如果原字符串是多行数据，最后一行的结尾没有<code>\n</code>，最后会补上一个<code>\n</code>，即多了一个空行。</li></ul><p>我们看下测试代码：</p><pre><code class="java">@Testvoid testIndent() {    final String text = &quot;\t\t\t 你好，我是看山。\n \u0020\u2005Java12 的 新特性。\r 欢迎三连+关注哟&quot;;    assertEquals(&quot;    \t\t\t 你好，我是看山。\n     \u0020\u2005Java12 的 新特性。\n    欢迎三连+关注哟、n&quot;, text.indent(4));    assertEquals(&quot;\t 你好，我是看山。\n\u2005Java12 的 新特性。\n 欢迎三连+关注哟、n&quot;, text.indent(-2));    final String text2 = &quot;山水有相逢&quot;;    assertEquals(&quot;山水有相逢&quot;, text2);}</code></pre><p>我们再来看看<code>transform</code>方法，源码一目了然：</p><pre><code class="java">public &lt;R&gt; R transform(Function&lt;? super String, ? extends R&gt; f) {    return f.apply(this);}</code></pre><p>通过传入的<code>Function</code>对当前字符串进行转换，转换结果由<code>Function</code>决定。比如，我们要对字符串反转：</p><pre><code class="java">@Testvoid testTransform() {    final String text = &quot;看山是山&quot;;    final String reverseText = text.transform(s -&gt; new StringBuilder(s).reverse().toString());    assertEquals(&quot;山是山看&quot;, reverseText);}</code></pre><p>其实这个方法在 Java8 中提供的<code>Optional</code>实现类似的功能（完整的 Optional 功能可以查看 <a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">Optional 的 6 种操作</a>）：</p><pre><code class="java">@Testvoid testTransform() {    final String text = &quot;看山是山&quot;;    final String reverseText2 = Optional.of(text)            .map(s -&gt; new StringBuilder(s).reverse().toString())            .orElse(&quot;&quot;);    assertEquals(&quot;山是山看&quot;, reverseText2);}</code></pre><h3 id="Files-的增强方法：mismatch"><a href="#Files-的增强方法：mismatch" class="headerlink" title="Files 的增强方法：mismatch"></a>Files 的增强方法：mismatch</h3><p>在 Java12 中，<code>Files</code>增加了<code>mismatch</code>方法，用于对比两个文件中的不相同字符的位置，如果内容相同，返回<code>-1L</code>，是<code>long</code>类型的。</p><p>我们来简单看下怎么用：</p><pre><code class="java">@Testvoid testMismatch() throws IOException {    final Path pathA = Files.createFile(Paths.get(&quot;a.txt&quot;));    final Path pathB = Files.createFile(Paths.get(&quot;b.txt&quot;));    // 写入相同内容    Files.write(pathA, &quot;看山&quot;.getBytes(), StandardOpenOption.WRITE);    Files.write(pathB, &quot;看山&quot;.getBytes(), StandardOpenOption.WRITE);    final long mismatch1 = Files.mismatch(pathA, pathB);    Assertions.assertEquals(-1L, mismatch1);    // 追加不同内容    Files.write(pathA, &quot;是山&quot;.getBytes(), StandardOpenOption.APPEND);    Files.write(pathB, &quot;不是山&quot;.getBytes(), StandardOpenOption.APPEND);    final long mismatch2 = Files.mismatch(pathA, pathB);    Assertions.assertEquals(6L, mismatch2);    Files.deleteIfExists(pathA);    Files.deleteIfExists(pathB);}</code></pre><p>我们可以看到，当第一次在两个文件中写入相同内容，执行<code>mismatch</code>方法返回的是<code>-1L</code>。当第二次追加进去不同的内容后，返回的是<code>6L</code>。之所以是 6，是因为测试代码中使用的字符集是<code>UTF-8</code>，大部分汉子是占用 3 个字符，前两个字相同，从第三个字开始不同，下标从 0 开始，所以开始位置是 6。</p><h3 id="Collectors-的增强方法：teeing"><a href="#Collectors-的增强方法：teeing" class="headerlink" title="Collectors 的增强方法：teeing"></a>Collectors 的增强方法：teeing</h3><p>我们看下<code>teeing</code>的定义：</p><pre><code class="java">public static &lt;T, R1, R2, R&gt; Collector&lt;T, ?, R&gt; teeing(    Collector&lt;? super T, ?, R1&gt; downstream1,    Collector&lt;? super T, ?, R2&gt; downstream2,    BiFunction&lt;? super R1, ? super R2, R&gt; merger)</code></pre><p>这个方法有三个参数，前两个是<code>Collector</code>对象，用于对输入数据进行预处理，第三个参数是<code>BiFunction</code>，用于将前两个处理后的结果作为参数传入<code>BiFunction</code>中，运算得到结果。</p><p>我们来看下例子：</p><pre><code class="java">@Testvoid testTeeing() {    var result = Stream.of(&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;)            .collect(Collectors.teeing(                    Collectors.filtering(n -&gt; n.contains(&quot;u&quot;), Collectors.toList()),                    Collectors.filtering(n -&gt; n.contains(&quot;n&quot;), Collectors.toList()),                    (list1, list2) -&gt; List.of(list1, list2)            ));    assertEquals(2, result.size());    assertTrue(isEqualCollection(List.of(&quot;Sunday&quot;, &quot;Tuesday&quot;), result.get(0)));    assertTrue(isEqualCollection(List.of(&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Wednesday&quot;), result.get(1)));}</code></pre><p>我们对输入的几个字符串进行过滤，然后将过滤结果组成一个新的队列。</p><h3 id="新工具：CompactNumberFormat"><a href="#新工具：CompactNumberFormat" class="headerlink" title="新工具：CompactNumberFormat"></a>新工具：CompactNumberFormat</h3><p>这个工具比较好玩，可以对数字进行按需格式化。提供了<code>public static NumberFormat getCompactNumberInstance(Locale locale, NumberFormat.Style formatStyle)</code>方法用于初始化：</p><ul><li>第一个参数是指定区域，不同区域展示的结果不同，比如中国展示汉字、美国展示英文；</li><li>第二个参数是指定展示结果的模式，分为<code>SHORT</code>和<code>LONG</code>，不过对于中文展示，似乎没啥区别。</li></ul><p>我们一起看下例子：</p><pre><code class="java">@Testvoid testFormat() {    final NumberFormat zhShort = NumberFormat.getCompactNumberInstance(Locale.CHINA, Style.SHORT);    assertEquals(&quot;1 万&quot;, zhShort.format(10_000));    assertEquals(&quot;1 兆&quot;, zhShort.format(1L &lt;&lt; 40));    final NumberFormat zhLong = NumberFormat.getCompactNumberInstance(Locale.CHINA, Style.LONG);    assertEquals(&quot;1 万&quot;, zhLong.format(10_000));    assertEquals(&quot;1 兆&quot;, zhLong.format(1L &lt;&lt; 40));    final NumberFormat usShort = NumberFormat.getCompactNumberInstance(Locale.US, Style.SHORT);    usShort.setMaximumFractionDigits(2);    assertEquals(&quot;10K&quot;, usShort.format(10_000));    assertEquals(&quot;1.1T&quot;, usShort.format(1L &lt;&lt; 40));    final NumberFormat usLong = NumberFormat.getCompactNumberInstance(Locale.US, Style.LONG);    usLong.setMaximumFractionDigits(2);    assertEquals(&quot;10 thousand&quot;, usLong.format(10_000));    assertEquals(&quot;1.1 trillion&quot;, usLong.format(1L &lt;&lt; 40));}</code></pre><p>我们也可以继续使用<code>NumberFormat</code>中的方法定义，比如示例中保留小数点后 2 位。</p><h2 id="Shenandoah：一个低停顿垃圾收集器"><a href="#Shenandoah：一个低停顿垃圾收集器" class="headerlink" title="Shenandoah：一个低停顿垃圾收集器"></a>Shenandoah：一个低停顿垃圾收集器</h2><p>Java12 引入了一个实验阶段的垃圾收集器：Shenandoah，作为一个低停顿的垃圾收集器。</p><p>Shenandoah 垃圾收集器是 RedHat 在 2014 年宣布进行的垃圾收集器研究项目，其工作原理是通过与 Java 应用执行线程同时运行来降低停顿时间。简单的说就是，Shenandoah 工作时与应用程序线程并发，通过交换 CPU 并发周期和空间以改善停顿时间，使得垃圾回收器执行线程能够在 Java 线程运行时进行堆压缩，并且标记和整理能够同时进行，因此避免了在大多数 JVM 垃圾收集器中所遇到的问题。</p><p><img src="https://static.howardliu.cn/java/shenandoah-gc-cycle.png" alt="Shenandoah GC"></p><p>Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200MB 还是 200GB，都将拥有一致的系统暂停时间，不过实际使用性能将取决于实际工作堆的大小和工作负载。</p><p>Java12 中 Shenandoah 处于实验阶段，想要使用需要编译时添加<code>--with-jvm-features=shenandoahgc</code>，然后启动时使用<code>-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC</code>以开启。</p><p>后续会补充 Java 中各种垃圾收集器的文章，其中会有介绍 Shenandoah 的，敬请关注公众号「看山的小屋」。如果想要提前了解，欢迎访问<a href="https://wiki.openjdk.java.net/display/shenandoah" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/shenandoah</a>。</p><h2 id="增加一套基准测试套件"><a href="#增加一套基准测试套件" class="headerlink" title="增加一套基准测试套件"></a>增加一套基准测试套件</h2><p>Java12 中添加一套基准测试套件，该基准测试套件基于 JMH（Java Microbenchmark Harness），使开发人员可以轻松运行现有的基准测试并创建新的基准测试，其目标是提供一个稳定且优化的基准。</p><p>在这套基准测试套件中包括将近 100 个基准测试的初始集合，并且能够轻松添加新基准、更新基准测试和提高查找已有基准测试的便利性。</p><p>微基准套件与 JDK 源代码位于同一个目录中，并且在构建后将生成单个 Jar 文件。它是一个单独的项目，在支持构建期间不会执行，以方便开发人员和其他对构建微基准套件不感兴趣的人在构建时花费比较少的构建时间。</p><h2 id="Switch-表达式扩展（预览版）"><a href="#Switch-表达式扩展（预览版）" class="headerlink" title="Switch 表达式扩展（预览版）"></a>Switch 表达式扩展（预览版）</h2><p>Switch 语句出现的姿势是条件判断、流程控制组件，与现在很流行的新语言对比，其写法显得非常笨拙，所以 Java 推出了 Switch 表达式语法，可以让我们写出更加简化的代码。这个扩展在 Java12 中作为预览版首次引入，需要在编译时增加<code>-enable-preview</code>开启，在 Java14 中正式提供，功能编号是 <a href="https://openjdk.java.net/jeps/361" target="_blank" rel="noopener">JEP 361</a>。</p><p>比如，我们通过 switch 语法简单计算工作日、休息日，在 Java12 之前需要这样写：</p><pre><code class="java">@Testvoid testSwitch() {    final DayOfWeek day = DayOfWeek.from(LocalDate.now());    String typeOfDay = &quot;&quot;;    switch (day) {        case MONDAY:        case TUESDAY:        case WEDNESDAY:        case THURSDAY:        case FRIDAY:            typeOfDay = &quot;Working Day&quot;;            break;        case SATURDAY:        case SUNDAY:            typeOfDay = &quot;Rest Day&quot;;            break;    }    Assertions.assertFalse(typeOfDay.isEmpty());}</code></pre><p>在 Java12 中的 Switch 表达式中，我们可以直接简化：</p><pre><code class="java">@Testvoid testSwitchExpression() {    final DayOfWeek day = DayOfWeek.SATURDAY;    final String typeOfDay = switch (day) {        case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; &quot;Working Day&quot;;        case SATURDAY, SUNDAY -&gt; &quot;Day Off&quot;;    };    Assertions.assertEquals(&quot;Day Off&quot;, typeOfDay);}</code></pre><p>是不是很清爽。文末提供的源码中，<code>pom.xml</code>定义的<code>maven.compiler</code>版本写的是<code>14</code>，这是因为 Switch 表达式是 Java14 正式提供，我没有重新编译 Java，所以只能指定 Java14 来实现这个功能代码的演示。</p><h2 id="引入-JVM-常量-API"><a href="#引入-JVM-常量-API" class="headerlink" title="引入 JVM 常量 API"></a>引入 JVM 常量 API</h2><p>Java12 中引入 JVM 常量 API，用来更容易地对关键类文件和运行时构件的描述信息进行建模，特别是对那些从常量池加载的常量，这是一项非常技术性的变化，能够以更简单、标准的方式处理可加载常量。</p><p>具体来说就是<code>java.base</code>模块新增了<code>java.lang.constant</code>包，引入了<code>ConstantDesc</code>接口以及<code>Constable</code>接口。<code>ConstantDesc</code>的子接口包括：</p><ul><li><code>ClassDesc</code>：Class 的可加载常量标称描述符；</li><li><code>MethodTypeDesc</code>：方法类型常量标称描述符；</li><li><code>MethodHandleDesc</code>：方法句柄常量标称描述符；</li><li><code>DynamicConstantDesc</code>：动态常量标称描述符。</li></ul><p>继续挖坑，这部分内容会在进阶篇再详细介绍，敬请关注公众号「看山的小屋」。</p><h2 id="改进-AArch64-实现"><a href="#改进-AArch64-实现" class="headerlink" title="改进 AArch64 实现"></a>改进 AArch64 实现</h2><p>Java12 中将只保留一套 AArch64 实现，之前版本中，有两个关于 aarch64 的实现，分别是<code>ope/src/hotspot/cpu/arm</code>以及<code>open/src/hotspot/cpu/aarch64</code>，它们的实现重复了。为了集中精力更好地实现 aarch64，删除了<code>open/src/hotspot/cpu/arm</code>中与 arm64（64-bit Arm platform）实现相关的代码，只保留 32 位 ARM 端口和 64 位 aarch64 的端口。</p><p>这样做，可以让开发人员将目标集中在剩下的这个 64 位 ARM 实现上，消除维护两套端口所需的重复工作。</p><p>目标聚焦，力量集中。</p><h2 id="默认使用类数据共享（CDS）存档"><a href="#默认使用类数据共享（CDS）存档" class="headerlink" title="默认使用类数据共享（CDS）存档"></a>默认使用类数据共享（CDS）存档</h2><p>在 <a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a> 中我们介绍过类数据共享（CDS，Class Data Sharing），其作用是通过构建时生成默认类列表，在运行时使用内存映射，减少 Java 的启动时间和减少动态内存占用量，也能在多个 Java 虚拟机之间共享相同的归档文件，减少运行时的资源占用。</p><p>在 Java12 之前，想要使用需要三步走手动开启，到了 Java12，将默认开启 CDS 功能，想要关闭，需要使用参数<code>-Xshare:off</code>。</p><h2 id="改善-G1-垃圾收集器"><a href="#改善-G1-垃圾收集器" class="headerlink" title="改善 G1 垃圾收集器"></a>改善 G1 垃圾收集器</h2><h3 id="能够中止收集"><a href="#能够中止收集" class="headerlink" title="能够中止收集"></a>能够中止收集</h3><p>G1 垃圾收集器可以在大内存多处理器的工作场景中提升回收效率，能够满足用户预期降低 STW 停顿时间。</p><p>其内部是采用一个高级分析引擎来选择在收集期间要处理的工作量，此选择过程的结果是一组称为 GC 回收集（collection set，CSet）的区域。一旦收集器确定了 GC 回收集 并且 GC 回收、整理工作已经开始，则 G1 收集器必须完成收集集合集的所有区域中的所有活动对象之后才能停止；但是如果收集器选择过大的 GC 回收集，可能会导致 G1 回收器停顿时间超过预期时间。</p><p>在 Java12 中，GC 回收集拆分为必需和可选两部分，使 G1 垃圾回收器能中止垃圾回收过程。其中必需处理的部分包括 G1 垃圾收集器不能递增处理的 GC 回收集的部分，同时也可以包含老年代以提高处理效率。在 G1 垃圾回收器完成收集需要必需回收的部分之后，G1 垃圾回收器可以根据剩余时间决定是否停止收集。</p><h3 id="向操作系统自动返回未用堆内存"><a href="#向操作系统自动返回未用堆内存" class="headerlink" title="向操作系统自动返回未用堆内存"></a>向操作系统自动返回未用堆内存</h3><p>在 Java11 中，G1 仅在进行 Full GC 或并发处理周期时才能向操作系统返还堆内存，但是这两种场景都是 G1 极力避免的，所以如果我们使用 G1 收集器，基本上很难返还 Java 堆内存，这样对于那种周期性执行大量占用内存的应用，会造成比较多的内存浪费。</p><p>Java12 中，G1 垃圾收集器将在应用程序不活动期间定期生成或持续循环检查整体 Java 堆使用情况，以便 G1 垃圾收集器能够更及时的将 Java 堆中不使用内存部分返还给操作系统。对于长时间处于空闲状态的应用程序，此项改进将使 JVM 的内存利用率更加高效。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java12 新增的特性，完整的特性清单可以从<a href="https://openjdk.java.net/projects/jdk/12/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/12/</a>查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-12-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java12 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122530460" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java12 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文讲解一下 Java12 的特性，作为第一个长期支持版 Java11 之后的第一个版本，增加的功能也不少，除了一些小幅度的 API 增强，增加了另一个试验阶段的垃圾收集器 Shenandoah、对 G1 做了优化、增加微基准套件等。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java12" scheme="https://www.howardliu.cn/tags/Java12/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java11 的新特性</title>
    <link href="https://www.howardliu.cn/java-11-features/"/>
    <id>https://www.howardliu.cn/java-11-features/</id>
    <published>2022-01-09T14:09:15.000Z</published>
    <updated>2022-01-09T14:09:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/animal-gb69e2a049_1920.jpg" alt="Java11 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java11 是 2018 年 9 月发布的，是自 Java8 之后第一个长期支持版（long-term support，LTS）。相比于其他版本 6 个月维护期，长期支持版的维护期是 3 年。</p><p>长期支持版的更新会比较多，而且都是相对稳定的更新。今天我们就一起看看 Java11 都有哪些喜人的变化：增强的 API、全新的 HTTP 客户端、<a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">基于嵌套关系的访问控制优化</a>、低开销的堆性能采用工具、ZGC、Epsilon 垃圾收集器、飞行记录器等。</p><h2 id="增强-String"><a href="#增强-String" class="headerlink" title="增强 String"></a>增强 String</h2><p>首先说下<code>String</code>中新增的方法：<code>repeat</code>、<code>strip</code>、<code>stripLeading</code>、<code>stripTrailing</code>、<code>isBlank</code>、<code>lines</code>。这些方法还是挺有用的，以前我们可能需要借助第三方类库（比如 Apache 出品的 commons-lang）中的工具类，现在可以直接使用嫡亲方法了。</p><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><p><code>repeat</code>是实例方法，顾名思义，这个方法是返回给定字符串的重复值的，参数是<code>int</code>类型，传参的时候需要注意：</p><ul><li>如果重复次数小于 0 会抛出<code>IllegalArgumentException</code>异常；</li><li>如果重复次数为 0 或者字符串本身是空字符串，将返回空字符串；</li><li>如果重复次数为 1 直接返回本身；</li><li>如果字符串重复指定次数后，长度超过<code>Integer.MAX_VALUE</code>，会抛出<code>OutOfMemoryError</code>错误。</li></ul><p>用法很简单：</p><pre><code class="java">@Testvoid testRepeat() {    String output = &quot;foo &quot;.repeat(2) + &quot;bar&quot;;    assertEquals(&quot;foo foo bar&quot;, output);}</code></pre><p>小而美的一个工具方法。</p><h3 id="strip、stripLeading、stripTrailing"><a href="#strip、stripLeading、stripTrailing" class="headerlink" title="strip、stripLeading、stripTrailing"></a>strip、stripLeading、stripTrailing</h3><p><code>strip</code>方法算是<code>trim</code>方法的增强版，<code>trim</code>方法可以删除字符串两侧的空白字符（空格、tab 键、换行符），但是对于<code>Unicode</code>的空白字符无能为力，<code>strip</code>补足这一短板。</p><p>用起来是这样的：</p><pre><code class="java">@Testvoid testTrip() {    final String output = &quot;\n\t  hello   \u2005&quot;.strip();    assertEquals(&quot;hello&quot;, output);    final String trimOutput = &quot;\n\t  hello   \u2005&quot;.trim();    assertEquals(&quot;hello   \u2005&quot;, trimOutput);}</code></pre><p>对比一下可以看到，<code>trim</code>方法的清理功能稍弱。</p><p><code>stripLeading</code>和<code>stripTrailing</code>与<code>strip</code>类似，区别是一个清理头，一个清理尾。用法如下：</p><pre><code class="java">@Testvoid testTripLeading() {    final String output = &quot;\n\t  hello   \u2005&quot;.stripLeading();    assertEquals(&quot;hello   \u2005&quot;, output);}@Testvoid testTripTrailing() {    final String output = &quot;\n\t  hello   \u2005&quot;.stripTrailing();    assertEquals(&quot;\n\t  hello&quot;, output);}</code></pre><h3 id="isBlank"><a href="#isBlank" class="headerlink" title="isBlank"></a>isBlank</h3><p>这个方法是用于判断字符串是否都是空白字符，除了空格、tab 键、换行符，也包括<code>Unicode</code>的空白字符。</p><p>用法很简单：</p><pre><code class="java">@Testvoid testIsBlank() {    assertTrue(&quot;\n\t\u2005&quot;.isBlank());}</code></pre><h3 id="lines"><a href="#lines" class="headerlink" title="lines"></a>lines</h3><p>最后这个方法是将字符串转化为字符串<code>Stream</code>类型，字符串分隔依据是换行符：<code>\n</code>、<code>\r</code>、<code>\r\n</code>，用法如下：</p><pre><code class="java">@Testvoid testLines() {    final String multiline = &quot;This is\n \na multiline\nstring.&quot;;    final String output = multiline.lines()            .filter(Predicate.not(String::isBlank))            .collect(Collectors.joining(&quot; &quot;));    assertEquals(&quot;This is a multiline string.&quot;, output);}</code></pre><h2 id="增强文件读写"><a href="#增强文件读写" class="headerlink" title="增强文件读写"></a>增强文件读写</h2><p>本次更新在<code>Files</code>中增加了两个方法：<code>readString</code>和<code>writeString</code>。<code>writeString</code>作用是将指定字符串写入文件，<code>readString</code>作用是从文件中读出内容到字符串。是一个对<code>Files</code>工具类的增强，封装了对输出流、字节等内容的操作。</p><p>用法比较简单：</p><pre><code class="java">@Testvoid testReadWriteString() throws IOException {    final Path tmpPath = Path.of(&quot;./&quot;);    final Path tempFile = Files.createTempFile(tmpPath, &quot;demo&quot;, &quot;.txt&quot;);    final Path filePath = Files.writeString(tempFile, &quot;看山 howardliu.cn\n 公众号：看山的小屋&quot;);    assertEquals(tempFile, filePath);    final String fileContent = Files.readString(filePath);    assertEquals(&quot;看山 howardliu.cn\n 公众号：看山的小屋&quot;, fileContent);    Files.deleteIfExists(filePath);}</code></pre><p><code>readString</code>和<code>writeString</code>还可以指定字符集，不指定默认使用<code>StandardCharsets.UTF_8</code>字符集，可以应对大部分场景了。</p><h2 id="增强集合的数组操作"><a href="#增强集合的数组操作" class="headerlink" title="增强集合的数组操作"></a>增强集合的数组操作</h2><p><code>java.util.Collection</code>提供了集合转数组的方法有两个：</p><ul><li><code>Object[] toArray()</code>：可以直接转数组，但是转换后是<code>Object</code>类型，后续使用的时候，需要强转，太不优雅了；</li><li><code>&lt;T&gt; T[] toArray(T[] a)</code>：传入一个指定类型的数组，一般会有另种实现：<ul><li>一是，如果传入数组长度小于列表长度，会借助<code>Arrays.copyOf</code>创建列表长度的数组，这个数组与传入数组参数没有关系</li><li>二是，如果传入数组长度大于等于列表长度，会借助<code>System.arraycopy</code>将列表写入数组，超过长度的数组元素置为<code>null</code>。</li></ul></li></ul><p>我们一般这样用：</p><pre><code class="java">@Testvoid testArray() {    final List&lt;String&gt; vars = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);    final Object[] objArray = vars.toArray();    final String[] strArray = vars.toArray(new String[0]);    Assertions.assertTrue(Arrays.asList(strArray).contains(&quot;1&quot;));    Assertions.assertTrue(Arrays.asList(strArray).contains(&quot;2&quot;));    Assertions.assertTrue(Arrays.asList(strArray).contains(&quot;3&quot;));}</code></pre><p>在 Java11 中，又新增了一种实现，相当于对<code>&lt;T&gt; T[] toArray(T[] a)</code>做了增强，其源码是：</p><pre><code class="java">default &lt;T&gt; T[] toArray(IntFunction&lt;T[]&gt; generator) {    return toArray(generator.apply(0));}</code></pre><p>可以看到，是通过传入一个<code>IntFunction</code>类型的函数，然后调用<code>&lt;T&gt; T[] toArray(T[] a)</code>创建数组，其实是采用了我们常用的给<code>toArray</code>传入空数组的方式，用法如下：</p><pre><code class="java">@Testvoid testArray() {    final List&lt;String&gt; vars = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);    final String[] strArray2 = vars.toArray(String[]::new);    Assertions.assertTrue(Arrays.asList(strArray2).contains(&quot;1&quot;));    Assertions.assertTrue(Arrays.asList(strArray2).contains(&quot;2&quot;));    Assertions.assertTrue(Arrays.asList(strArray2).contains(&quot;3&quot;));}</code></pre><p>从使用上，似乎没有太多的提升，但是写法上，使用了函数式编程，是不是很优雅。</p><p><img src="https://static.howardliu.cn/Illustration/smile_1.jpg" alt="优雅的假笑"></p><h2 id="增强函数-Predicate"><a href="#增强函数-Predicate" class="headerlink" title="增强函数 Predicate"></a>增强函数 Predicate</h2><p>这个也是方法增强，在以前，我们在<code>Stream</code>中的<code>filter</code>方法判断否的时候，一般需要<code>!</code>运算，比如我们想要找到字符串列表中的数字，可以这样写：</p><pre><code class="java">final List&lt;String&gt; list = Arrays.asList(&quot;1&quot;, &quot;a&quot;);final List&lt;String&gt; nums = list.stream()        .filter(NumberUtils::isDigits)        .collect(Collectors.toList());Assertions.assertEquals(1, nums.size());Assertions.assertTrue(nums.contains(&quot;1&quot;));</code></pre><p>想要找到非数字的，<code>filter</code>方法写的就会用到<code>!</code>非操作：</p><pre><code class="java">final List&lt;String&gt; notNums = list.stream()        .filter(x -&gt; !NumberUtils.isDigits(x))        .collect(Collectors.toList());Assertions.assertEquals(1, notNums.size());Assertions.assertTrue(notNums.contains(&quot;a&quot;));</code></pre><p>Java11 中为<code>Predicate</code>增加<code>not</code>方法，可以更加简单的实现非操作：</p><pre><code class="java">final List&lt;String&gt; notNums2 = list.stream()        .filter(Predicate.not(NumberUtils::isDigits))        .collect(Collectors.toList());Assertions.assertEquals(1, notNums2.size());Assertions.assertTrue(notNums2.contains(&quot;a&quot;));</code></pre><p>有些教程还会推崇静态引入，比如在头部使用<code>import static java.util.function.Predicate.not</code>，这样在函数式编程时，可以写更少的代码，语义更强，比如：</p><pre><code class="java">final List&lt;String&gt; notNums2 = list.stream()        .filter(not(NumberUtils::isDigits))        .collect(toList());</code></pre><p>喜好随人，没有优劣。</p><h2 id="Lambda-中的局部变量"><a href="#Lambda-中的局部变量" class="headerlink" title="Lambda 中的局部变量"></a>Lambda 中的局部变量</h2><p>局部变量是 Java10 中增加的特性，具体可以查看 <a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a> 中的介绍，但是不支持在 Lambda 中使用局部变量。</p><p>在 Lambda 中，我们可以这样操作：</p><pre><code class="java">(String s1, String s2) -&gt; s1 + s2</code></pre><p>也可以这样：</p><pre><code class="java">(s1, s2) -&gt; s1 + s2</code></pre><p>到 Java11 之后，我们还能这样：</p><pre><code class="java">(var s1, var s2) -&gt; s1 + s2</code></pre><p>单纯从语法上，似乎没啥特点，但是如果再加上一些别的用法，比如：</p><pre><code class="java">(@Nonnull var s1, @Nullable var s2) -&gt; s1 + s2</code></pre><p>是不是就能看出差别了，我们可以有如下的操作：</p><pre><code class="java">@Testvoid testLocalVariable() {    final List&lt;String&gt; sampleList = Arrays.asList(&quot;Hello&quot;, &quot;World&quot;);    final String resultString = sampleList.stream()            .map((@NotNull var x) -&gt; x.toUpperCase())            .collect(Collectors.joining(&quot;, &quot;));    Assertions.assertEquals(&quot;HELLO, WORLD&quot;, resultString);}</code></pre><p>不过，这里还是有一些限制，比如：</p><p>如果是多个参数，不能有的使用<code>var</code>修饰，有的不指定类型：</p><pre><code class="java">// 错误写法(var s1, s2) -&gt; s1 + s2</code></pre><p>或者，不能混合使用，一个使用<code>var</code>修饰，一个使用明确的类型：</p><pre><code class="java">// 错误写法(var s1, String s2) -&gt; s1 + s2</code></pre><p>如果是单个参数，如果是单行操作，我们可以不写<code>{}</code>，但是使用<code>var</code>修饰的时候，就不能省略<code>{}</code>了：</p><pre><code class="java">// 错误写法var s1 -&gt; s1.toUpperCase()</code></pre><p>还是有一些限制的，我们在便利的同时，需要符合一定的约束。自由和规范不冲突。</p><h2 id="转正的-HTTP-客户端"><a href="#转正的-HTTP-客户端" class="headerlink" title="转正的 HTTP 客户端"></a>转正的 HTTP 客户端</h2><p>在 <a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a> 中说过，Java 中有一个全新的 HTTP 客户端，当时还在孵化模块中，到 Java11 可以正式使用了。</p><p>新客户端用法简单、性能可靠，而且支持功能也多。我们先简单看下使用：</p><pre><code class="java">@Testvoid testHttpClient() throws IOException, InterruptedException {    final HttpClient httpClient = HttpClient.newBuilder()            .version(HttpClient.Version.HTTP_2)            .connectTimeout(Duration.ofSeconds(20))            .build();    final HttpRequest httpRequest = HttpRequest.newBuilder()            .GET()            .uri(URI.create(&quot;https://www.howardliu.cn/robots.txt&quot;))            .build();    final HttpResponse&lt;String&gt; httpResponse = httpClient.send(httpRequest, BodyHandlers.ofString());    final String responseBody = httpResponse.body();    assertTrue(responseBody.contains(&quot;Allow&quot;));}</code></pre><h2 id="基于嵌套关系的访问控制优化"><a href="#基于嵌套关系的访问控制优化" class="headerlink" title="基于嵌套关系的访问控制优化"></a>基于嵌套关系的访问控制优化</h2><p>这部分是遗留的技术债务，从 Java1.1 开始，到 Java11 修复，属于 Valhalla 项目的一部分，我们在 <a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a> 一文中有详细解释，这里就不再赘述了。</p><h2 id="增强-java-命令"><a href="#增强-java-命令" class="headerlink" title="增强 java 命令"></a>增强 java 命令</h2><p>在 Java11 之前，想要运行源文件，需要先通过<code>javac</code>命令编译，然后使用<code>java</code>命令运行，先可以直接使用<code>java</code>运行了：</p><pre><code class="java">$ java HelloWorld.javaHello Java 11!</code></pre><h2 id="动态类文件常量"><a href="#动态类文件常量" class="headerlink" title="动态类文件常量"></a>动态类文件常量</h2><p>为了使 JVM 对动态语言更具吸引力，Java 指令集引入了 invokedynamic。</p><p>不过 Java 开发人员通常不会注意到此功能，因为它隐藏在 Java 字节代码中。通过使用 invokedynamic，可以延迟方法调用的绑定。例如，Java 语言使用该技术来实现 Lambda 表达式，这些表达式仅在首次使用时才显示出来。这样做，invokedynamic 已经演变成一种必不可少的语言功能。</p><p>Java 11 引入了类似的机制，扩展了 Java 文件格式，以支持新的常量池：CONSTANT_Dynamic，它在初始化的时候，像 invokedynamic 指令生成代理方法一样，委托给 bootstrap 方法进行初始化创建，对上层软件没有很大的影响，降低开发新形式的可实现类文件约束带来的成本和干扰。</p><p>此功能可提高性能，并面向语言设计人员和编译器实现人员。</p><h2 id="低开销的堆性能采用工具"><a href="#低开销的堆性能采用工具" class="headerlink" title="低开销的堆性能采用工具"></a>低开销的堆性能采用工具</h2><p>Java 11 中提供一种低开销的 Java 堆分配采样方法，能够得到堆分配的 Java 对象信息，并且能够通过 JVMTI 访问堆信息。</p><p>引入这个低开销内存分析工具是为了达到如下目的：</p><ul><li>足够低的开销，可以默认且一直开启；</li><li>能通过定义好的程序接口访问；</li><li>能够对所有堆分配区域进行采样；</li><li>能给出正在和未被使用的 Java 对象信息。</li></ul><p>对用户来说，了解堆中内存分布是非常重要的，特别是遇到生产环境中出现的高 CPU、高内存占用率的情况。目前有一些已经开源的工具，允许用户分析应用程序中的堆使用情况，比如：Java Flight Recorder、jmap、YourKit 以及 VisualVM tools.。但是这些工具都有一个明显的不足之处：无法得到对象的分配位置，headp dump 以及 heap histogram 中都没有包含对象分配的具体信息，但是这些信息对于调试内存问题至关重要，因为它能够告诉开发人员他们的代码中发生的高内存分配的确切位置，并根据实际源码来分析具体问题，这也是 Java 11 中引入这种低开销堆分配采样方法的原因。</p><h2 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h2><p>ZGC 是一个可伸缩、低延迟的垃圾收集器，性能由于 G1 收集器，从 Java11 开始可以在 Linux/x64 平台体验，全平台支持是从 Java17 开始。详细介绍可以从<a href="https://wiki.openjdk.java.net/display/zgc/Main" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/zgc/Main</a>查看。</p><p>在 Java11 中尚处于试验阶段，没有包含在 JDK 构建中，想要启用，需要在 JDK 编译时添加参数<code>--with-jvm-features=zgc</code>。显式启用了 ZGC 之后，我们可以使用构建好的 JDK 启动，需要添加参数<code>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code>。</p><p>ZGC 有下面几个目标：</p><ul><li>GC 停顿时间不超过 10ms</li><li>可以处理从几百 MB 的小堆，到几个 TB 的大堆</li><li>与 G1 回收算法相比，应用吞吐能力不会下降超过 15%</li><li>为未来的 GC 特性和优化有色指针和负载屏障奠定基础</li></ul><p>从<a href="https://openjdk.java.net/jeps/333" target="_blank" rel="noopener">https://openjdk.java.net/jeps/333</a>给出的数据可以看出来，在 128G 堆大小的测试中，ZGC 优势明显，找了一张网上的图片：</p><p><img src="https://static.howardliu.cn/java/java-11-1.png" alt="SPECjbb 2015 的基准测试"></p><p>这里预告一下，Java12 中也增加了一个实现阶段的垃圾收集器 Shenandoah，到时候咱们看一下。</p><h2 id="改进-Aarch64-指令集"><a href="#改进-Aarch64-指令集" class="headerlink" title="改进 Aarch64 指令集"></a>改进 Aarch64 指令集</h2><p>Java 11 优化了 ARM64 或 Arch64 处理器上现有的字符串和数组内部函数。还为<code>java.lang.Math</code>的<code>sin</code>、<code>cos</code>和<code>log</code>方法实现了新的内部函数。</p><p>我们像其他函数一样使用内在函数，但是，编译器会以特殊的方式处理内部函数，将使用 CPU 体系结构特定的汇编代码来提高性能。可以关注一下<code>HotSpotIntrinsicCandidate</code>这个注解。</p><h2 id="Epsilon-垃圾收集器"><a href="#Epsilon-垃圾收集器" class="headerlink" title="Epsilon 垃圾收集器"></a>Epsilon 垃圾收集器</h2><p>Java11 引入了一个新的实验性垃圾收集器：Epsilon。Epsilon 垃圾收集器提供一个完全消极的 GC 实现，分配有限的内存资源，最大限度的降低内存占用和内存吞吐延迟时间，适用于模拟内存不足错误的场景。</p><p>Epsilon 垃圾收集器有几个使用场景：</p><ul><li>性能测试：无操作的垃圾收集器可以过滤因为收集器自身原因造成的性能损失；</li><li>内存压力测试：可以用于验证分配内存的阈值；</li><li>VM 接口测试：以 VM 开发视角，有一个简单的 GC 实现，有助于理解 VM-GC 的最小接口实现。它也用于证明 VM-GC 接口的健全性；</li><li>存活极短的任务：这种生命周期极短的任务，需要实现快速启动、快速释放资源的特性。开发者知道这种任务的内存阈值是多少，很大概率上，任务存活周期内，不会触发垃圾回收，就需要一个什么也不干的收集器站着位置就行。</li></ul><p>可以通过<code>-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC</code>参数开启。</p><h2 id="飞行记录器（Flight-Recorder）"><a href="#飞行记录器（Flight-Recorder）" class="headerlink" title="飞行记录器（Flight Recorder）"></a>飞行记录器（Flight Recorder）</h2><p>飞行记录器（Flight Recorder）可是个好东西，之前是 Oracle JDK 中的一个商用产品，现已在 Open JDK 中开源。这是一种低开销的事件信息收集框架，主要用于对应用程序和 JVM 进行故障检查、分析。</p><p>飞行记录器记录的主要数据源于应用程序、JVM 和操作系统，这些事件信息保存在单独的事件记录文件中，故障发生后，能够从事件记录文件中提取出有用信息对故障进行分析。有些类似于飞机上的黑匣子。</p><p><img src="https://static.howardliu.cn/Illustration/800.jpeg" alt="飞机上的黑匣子"></p><p>比如，我们可以使用以下参数开启一个时长为 120 秒的记录：</p><pre><code class="shell">-XX:StartFlightRecording=duration=120s,settings=profile,filename=recording.jfr</code></pre><p>生成的文件可以使用 JMC 工具可视化查看，也可以自己写代码通过<code>RecordedEvent</code>解析。不过嘛，有可视化的，干嘛还要自己敲代码呢？</p><p>我们也可以在运行时通过<code>jcmd</code>命令启动记录：</p><pre><code class="shell">$ jcmd &lt;pid&gt; JFR.start$ jcmd &lt;pid&gt; JFR.dump filename=recording.jfr$ jcmd &lt;pid&gt; JFR.stop</code></pre><p>收到监控，想推广一下之前写的开源监控组件 Cynomys，源码在<a href="https://github.com/howardliu-cn/cynomys" target="_blank" rel="noopener">https://github.com/howardliu-cn/cynomys</a>，里面包含通过 Netty 实现的 RPC 框架、javaagent 实现的探针、使用 javassist 操作字节码、JMX 实现 JVM 内部监控等，可以对操作系统、网络、JVM、请求、SQL 等内容进行监控。</p><h2 id="移除或过期组件"><a href="#移除或过期组件" class="headerlink" title="移除或过期组件"></a>移除或过期组件</h2><p>社会在发展，技术在进步。又有一些功能或组件不合时宜，要么移除、要么标记过期。标记过期的最好不要再用了，不知道哪天就会被移除，想要升级依赖反而麻烦。</p><ul><li>JavaEE 和 CORBA：单独的 JavaEE 版本可以从第三方站点获取，所以在 JavaSEO 中不再包含。从 Java9 开始，JavaEE 和 CORBA 模块已经标记为过期，到 Java11 就完全移除。</li><li>JMC 从 JDK 中移除，可以单独下载。</li><li>JavaFX 也是这样，从 JDK 模块从中移除，需要单独引入。</li><li>Nashorn JavaScript 引擎标记为废弃</li><li>Jar 包的 Pack200 压缩方案标记为废弃</li></ul><h2 id="其他小改动"><a href="#其他小改动" class="headerlink" title="其他小改动"></a>其他小改动</h2><ul><li>实现了新的 ChaCha20 和 ChaCha20-Poly1305 加密算法，取代不安全的 RC4。</li><li>使用 Curve25519 和 Curve448 支持加密密钥协议，以取代现有的 ECDH 方案</li><li>升级 TLS 版本到 1.3，提升了安全性和性能</li><li>支持 Unicode 10， 带来了更多的字符、符号和表情符号</li></ul><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java11 新增的特性，完整的特性清单可以从<a href="https://openjdk.java.net/projects/jdk/11/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/11/</a>查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-11-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java11 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122401213" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java11 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      今天我们就一起看看 Java11 都有哪些喜人的变化：增强的 API、全新的 HTTP 客户端、[基于嵌套关系的访问控制优化](https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA)、低开销的堆性能采用工具、ZGC、Epsilon 垃圾收集器、飞行记录器等。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java11" scheme="https://www.howardliu.cn/tags/Java11/"/>
    
  </entry>
  
  <entry>
    <title>Java11 中基于嵌套关系的访问控制优化</title>
    <link href="https://www.howardliu.cn/java-11-jep181-nestmate/"/>
    <id>https://www.howardliu.cn/java-11-jep181-nestmate/</id>
    <published>2022-01-05T14:57:16.000Z</published>
    <updated>2022-01-05T14:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/rowan-2098486_1920.jpg" alt="Java11 中基于嵌套的权限控制"></p><p>你好，我是看山。</p><p>Java 语言很强大，但是，有人的地方就有江湖，有猿的地方就有 bug，Java 的核心代码并非十全十美。比如在 <a href="https://mp.weixin.qq.com/s/4jVPnaOr-rve3GQdukDFmA" target="_blank" rel="noopener">JDK 中居然也有反模式接口常量</a> 中介绍的反模式实现，以及本文说到的这个技术债务：嵌套关系（NestMate）调用方式。</p><a id="more"></a><p>在 Java 语言中，类和接口可以相互嵌套，这种组合之间可以不受限制的彼此访问，包括访问彼此的构造函数、字段、方法等。即使是<code>private</code>私有的，也可以彼此访问。比如下面这样定义：</p><pre><code class="java">public class Outer {    private int i;    public void print1() {        print11();        print12();    }    private void print11() {        System.out.println(i);    }    private void print12() {        System.out.println(i);    }    public void callInnerMethod() {        final Inner inner = new Inner();        inner.print4();        inner.print5();        System.out.println(inner.j);    }    public class Inner {        private int j;        public void print3() {            System.out.println(i);            print1();        }        public void print4() {            System.out.println(i);            print11();            print12();        }        private void print5() {            System.out.println(i);            print11();            print12();        }    }}</code></pre><p>上例中，<code>Outer</code>类中的字段<code>i</code>、方法<code>print11</code>和<code>print12</code>都是私有的，但是可以在<code>Inner</code>类中直接访问，<code>Inner</code>类的字段<code>j</code>、方法<code>print5</code>是私有的，也可以在<code>Outer</code>类中使用。这种设计是为了更好的封装，在用户看来，这几个彼此嵌套的类/接口是一体的，分开定义是为了更好的封装自己，隔离不同特性，但是有因为彼此是一体，所以私有元素也应该是共有的。</p><h2 id="Java11-之前的实现方式"><a href="#Java11-之前的实现方式" class="headerlink" title="Java11 之前的实现方式"></a>Java11 之前的实现方式</h2><p>我们使用 Java8 编译，然后借助<code>javap -c</code>命令分别查看<code>Outer</code>和<code>Inner</code>的结果。</p><pre><code class="shell">$ javap -c Outer.class      Compiled from &quot;Outer.java&quot;public class cn.howardliu.tutorials.java8.nest.Outer {  public cn.howardliu.tutorials.java8.nest.Outer();    Code:       0: aload_0       1: invokespecial #4                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V       4: return  public void print1();    Code:       0: aload_0       1: invokespecial #2                  // Method print11:()V       4: aload_0       5: invokespecial #1                  // Method print12:()V       8: return  public void callInnerMethod();    Code:       0: new           #7                  // class cn/howardliu/tutorials/java8/nest/Outer$Inner       3: dup       4: aload_0       5: invokespecial #8                  // Method cn/howardliu/tutorials/java8/nest/Outer$Inner.&quot;&lt;init&gt;&quot;:(Lcn/howardliu/tutorials/java8/nest/Outer;)V       8: astore_1       9: aload_1      10: invokevirtual #9                  // Method cn/howardliu/tutorials/java8/nest/Outer$Inner.print4:()V      13: aload_1      14: invokestatic  #10                 // Method cn/howardliu/tutorials/java8/nest/Outer$Inner.access$000:(Lcn/howardliu/tutorials/java8/nest/Outer$Inner;)V      17: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;      20: aload_1      21: invokestatic  #11                 // Method cn/howardliu/tutorials/java8/nest/Outer$Inner.access$100:(Lcn/howardliu/tutorials/java8/nest/Outer$Inner;)I      24: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V      27: return  static int access$200(cn.howardliu.tutorials.java8.nest.Outer);    Code:       0: aload_0       1: getfield      #3                  // Field i:I       4: ireturn  static void access$300(cn.howardliu.tutorials.java8.nest.Outer);    Code:       0: aload_0       1: invokespecial #2                  // Method print11:()V       4: return  static void access$400(cn.howardliu.tutorials.java8.nest.Outer);    Code:       0: aload_0       1: invokespecial #1                  // Method print12:()V       4: return}</code></pre><p>再来看看<code>Inner</code>的编译结果，这里需要注意的是，内部类会使用特殊的命名方式定义<code>Inner</code>类，最终会将编译结果存储在两个文件中：</p><pre><code class="shell">$ javap -c Outer\$Inner.classCompiled from &quot;Outer.java&quot;public class cn.howardliu.tutorials.java8.nest.Outer$Inner {  final cn.howardliu.tutorials.java8.nest.Outer this$0;  public cn.howardliu.tutorials.java8.nest.Outer$Inner(cn.howardliu.tutorials.java8.nest.Outer);    Code:       0: aload_0       1: aload_1       2: putfield      #3                  // Field this$0:Lcn/howardliu/tutorials/java8/nest/Outer;       5: aload_0       6: invokespecial #4                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V       9: return  public void print3();    Code:       0: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;       3: aload_0       4: getfield      #3                  // Field this$0:Lcn/howardliu/tutorials/java8/nest/Outer;       7: invokestatic  #6                  // Method cn/howardliu/tutorials/java8/nest/Outer.access$200:(Lcn/howardliu/tutorials/java8/nest/Outer;)I      10: invokevirtual #7                  // Method java/io/PrintStream.println:(I)V      13: aload_0      14: getfield      #3                  // Field this$0:Lcn/howardliu/tutorials/java8/nest/Outer;      17: invokevirtual #8                  // Method cn/howardliu/tutorials/java8/nest/Outer.print1:()V      20: return  public void print4();    Code:       0: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;       3: aload_0       4: getfield      #3                  // Field this$0:Lcn/howardliu/tutorials/java8/nest/Outer;       7: invokestatic  #6                  // Method cn/howardliu/tutorials/java8/nest/Outer.access$200:(Lcn/howardliu/tutorials/java8/nest/Outer;)I      10: invokevirtual #7                  // Method java/io/PrintStream.println:(I)V      13: aload_0      14: getfield      #3                  // Field this$0:Lcn/howardliu/tutorials/java8/nest/Outer;      17: invokestatic  #9                  // Method cn/howardliu/tutorials/java8/nest/Outer.access$300:(Lcn/howardliu/tutorials/java8/nest/Outer;)V      20: aload_0      21: getfield      #3                  // Field this$0:Lcn/howardliu/tutorials/java8/nest/Outer;      24: invokestatic  #10                 // Method cn/howardliu/tutorials/java8/nest/Outer.access$400:(Lcn/howardliu/tutorials/java8/nest/Outer;)V      27: return  static void access$000(cn.howardliu.tutorials.java8.nest.Outer$Inner);    Code:       0: aload_0       1: invokespecial #2                  // Method print5:()V       4: return  static int access$100(cn.howardliu.tutorials.java8.nest.Outer$Inner);    Code:       0: aload_0       1: getfield      #1                  // Field j:I       4: ireturn}</code></pre><p>我们可以看到，<code>Outer</code>和<code>Inner</code>中多出了几个方法，方法名格式是<code>access$*00</code>。</p><p><code>Outer</code>中的<code>access$200</code>方法返回了属性<code>i</code>，<code>access$300</code>和<code>access$400</code>分别调用了<code>print11</code>和<code>print12</code>方法。这些新增的方法都是静态方法，作用域是默认作用域，即包内可用。这些方法最终被<code>Inner</code>类中的<code>print3</code>和<code>print4</code>调用，相当于间接调用<code>Outer</code>中的私有属性或方法。</p><p>我们称这些生成的方法为“桥”方法（Bridge Method），是一种实现嵌套关系内部互相访问的方式。</p><p>在编译的时候，Java 为了保持类的单一特性，会将嵌套类编译到多个 class 文件中，同时为了保证嵌套类能够彼此访问，自动创建了调用私有方法的“桥”方法，这样，在保持原有定义不变的情况下，又实现了嵌套语法。</p><h2 id="技术债务"><a href="#技术债务" class="headerlink" title="技术债务"></a>技术债务</h2><p>“桥”方法的实现是比较巧妙的，但是这会造成源码与编译结果访问控制权限不一致，比如，我们可以在<code>Inner</code>中调用<code>Outer</code>中的私有方法，按照道理来说，我们可以在<code>Inner</code>中通过反射调用<code>Outer</code>的方法，但实际上不行，会抛出<code>IllegalAccessException</code>异常。我们验证一下：</p><pre><code class="java">public class Outer {    // 省略其他方法    public void callInnerReflectionMethod()            throws InvocationTargetException, NoSuchMethodException, IllegalAccessException {        final Inner inner = new Inner();        inner.callOuterPrivateMethod(this);    }    public class Inner {        // 省略其他方法        public void callOuterPrivateMethod(Outer outer)                throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {            final Method method = outer.getClass().getDeclaredMethod(&quot;print12&quot;);            method.invoke(outer);        }    }}</code></pre><p>定义测试用例：</p><pre><code class="java">@Testvoid gotAnExceptionInJava8() {    final Outer outer = new Outer();    final Exception e = assertThrows(IllegalAccessException.class, outer::callInnerReflectionMethod);    e.printStackTrace();    assertDoesNotThrow(outer::callInnerMethod);}</code></pre><p>打印的异常信息是：</p><pre><code class="log">java.lang.IllegalAccessException: class cn.howardliu.tutorials.java8.nest.Outer$Inner cannot access a member of class cn.howardliu.tutorials.java8.nest.Outer with modifiers &quot;private&quot;    at java.base/jdk.internal.reflect.Reflection.newIllegalAccessException(Reflection.java:361)    at java.base/java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:591)    at java.base/java.lang.reflect.Method.invoke(Method.java:558)    at cn.howardliu.tutorials.java8.nest.Outer$Inner.callOuterPrivateMethod(Outer.java:62)    at cn.howardliu.tutorials.java8.nest.Outer.callInnerReflectionMethod(Outer.java:36)</code></pre><p>通过反射直接调用私有方法会失败，但是可以直接的或者通过反射访问这些“桥”方法，这样就比较奇怪了。所以提出 <a href="http://openjdk.java.net/jeps/181" target="_blank" rel="noopener">JEP181 改进</a>，修复这个技术债务的同时，为后续的改进铺路。</p><h2 id="Java11-中的实现"><a href="#Java11-中的实现" class="headerlink" title="Java11 中的实现"></a>Java11 中的实现</h2><p>我们再来看看 Java11 编译之后的结果：</p><pre><code class="shell">$ javap -c Outer.class      Compiled from &quot;Outer.java&quot;public class cn.howardliu.tutorials.java11.nest.Outer {  public cn.howardliu.tutorials.java11.nest.Outer();    Code:       0: aload_0       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V       4: return  public void print1();    Code:       0: aload_0       1: invokevirtual #2                  // Method print11:()V       4: aload_0       5: invokevirtual #3                  // Method print12:()V       8: return  public void callInnerMethod();    Code:       0: new           #7                  // class cn/howardliu/tutorials/java11/nest/Outer$Inner       3: dup       4: aload_0       5: invokespecial #8                  // Method cn/howardliu/tutorials/java11/nest/Outer$Inner.&quot;&lt;init&gt;&quot;:(Lcn/howardliu/tutorials/java11/nest/Outer;)V       8: astore_1       9: aload_1      10: invokevirtual #9                  // Method cn/howardliu/tutorials/java11/nest/Outer$Inner.print4:()V      13: aload_1      14: invokevirtual #10                 // Method cn/howardliu/tutorials/java11/nest/Outer$Inner.print5:()V      17: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;      20: aload_1      21: getfield      #11                 // Field cn/howardliu/tutorials/java11/nest/Outer$Inner.j:I      24: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V      27: return}</code></pre><p>是不是很干净，与<code>Outer</code>类的源码结构是一致的。我们再看看<code>Inner</code>有没有什么变化：</p><pre><code class="shell">$ javap -c Outer\$Inner.classCompiled from &quot;Outer.java&quot;public class cn.howardliu.tutorials.java11.nest.Outer$Inner {  final cn.howardliu.tutorials.java11.nest.Outer this$0;  public cn.howardliu.tutorials.java11.nest.Outer$Inner(cn.howardliu.tutorials.java11.nest.Outer);    Code:       0: aload_0       1: aload_1       2: putfield      #1                  // Field this$0:Lcn/howardliu/tutorials/java11/nest/Outer;       5: aload_0       6: invokespecial #2                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V       9: return  public void print3();    Code:       0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;       3: aload_0       4: getfield      #1                  // Field this$0:Lcn/howardliu/tutorials/java11/nest/Outer;       7: getfield      #4                  // Field cn/howardliu/tutorials/java11/nest/Outer.i:I      10: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V      13: aload_0      14: getfield      #1                  // Field this$0:Lcn/howardliu/tutorials/java11/nest/Outer;      17: invokevirtual #6                  // Method cn/howardliu/tutorials/java11/nest/Outer.print1:()V      20: return  public void print4();    Code:       0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;       3: aload_0       4: getfield      #1                  // Field this$0:Lcn/howardliu/tutorials/java11/nest/Outer;       7: getfield      #4                  // Field cn/howardliu/tutorials/java11/nest/Outer.i:I      10: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V      13: aload_0      14: getfield      #1                  // Field this$0:Lcn/howardliu/tutorials/java11/nest/Outer;      17: invokevirtual #7                  // Method cn/howardliu/tutorials/java11/nest/Outer.print11:()V      20: aload_0      21: getfield      #1                  // Field this$0:Lcn/howardliu/tutorials/java11/nest/Outer;      24: invokevirtual #8                  // Method cn/howardliu/tutorials/java11/nest/Outer.print12:()V      27: return}</code></pre><p>同样干净。</p><p>我们在通过测试用例验证一下反射调用：</p><pre><code class="java">@Testvoid doesNotGotAnExceptionInJava11() {    final Outer outer = new Outer();    assertDoesNotThrow(outer::callInnerReflectionMethod);    assertDoesNotThrow(outer::callInnerMethod);}</code></pre><p>结果是正常运行。</p><p>这就是 JEP181 期望的结果，源码和编译结果一致，访问控制一致。</p><h2 id="Nestmate-新增的-API"><a href="#Nestmate-新增的-API" class="headerlink" title="Nestmate 新增的 API"></a>Nestmate 新增的 API</h2><p>在 Java11 中还新增了几个 API，用于嵌套关系的验证：</p><h3 id="getNestHost"><a href="#getNestHost" class="headerlink" title="getNestHost"></a>getNestHost</h3><p>这个方法是返回嵌套主机（NestHost），转成普通话就是找到嵌套类的外层类。对于非嵌套类，直接返回自身（其实也算是返回外层类）。</p><p>我们看下用法：</p><pre><code class="java">@Testvoid checkNestHostName() {    final String outerNestHostName = Outer.class.getNestHost().getName();    assertEquals(&quot;cn.howardliu.tutorials.java11.nest.Outer&quot;, outerNestHostName);    final String innerNestHostName = Inner.class.getNestHost().getName();    assertEquals(&quot;cn.howardliu.tutorials.java11.nest.Outer&quot;, innerNestHostName);    assertEquals(outerNestHostName, innerNestHostName);    final String notNestClass = NotNestClass.class.getNestHost().getName();    assertEquals(&quot;cn.howardliu.tutorials.java11.nest.NotNestClass&quot;, notNestClass);}</code></pre><p>对于<code>Outer</code>和<code>Inner</code>都是返回了<code>cn.howardliu.tutorials.java11.nest.Outer</code>。</p><h3 id="getNestMembers"><a href="#getNestMembers" class="headerlink" title="getNestMembers"></a>getNestMembers</h3><p>这个方法是返回嵌套类的嵌套成员数组，下标是 0 的元素确定是 NestHost 对应的类，其他元素顺序没有给出排序规则。我们看下使用：</p><pre><code class="java">@Testvoid getNestMembers() {    final List&lt;String&gt; outerNestMembers = Arrays.stream(Outer.class.getNestMembers())            .map(Class::getName)            .collect(Collectors.toList());    assertEquals(2, outerNestMembers.size());    assertTrue(outerNestMembers.contains(&quot;cn.howardliu.tutorials.java11.nest.Outer&quot;));    assertTrue(outerNestMembers.contains(&quot;cn.howardliu.tutorials.java11.nest.Outer$Inner&quot;));    final List&lt;String&gt; innerNestMembers = Arrays.stream(Inner.class.getNestMembers())            .map(Class::getName)            .collect(Collectors.toList());    assertEquals(2, innerNestMembers.size());    assertTrue(innerNestMembers.contains(&quot;cn.howardliu.tutorials.java11.nest.Outer&quot;));    assertTrue(innerNestMembers.contains(&quot;cn.howardliu.tutorials.java11.nest.Outer$Inner&quot;));}</code></pre><h3 id="isNestmateOf"><a href="#isNestmateOf" class="headerlink" title="isNestmateOf"></a>isNestmateOf</h3><p>这个方法是用于判断两个类是否是彼此的 NestMate，彼此形成嵌套关系。判断依据还是嵌套主机，只要相同，两个就是 NestMate。我们看下使用：</p><pre><code class="java">@Testvoid checkIsNestmateOf() {    assertTrue(Inner.class.isNestmateOf(Outer.class));    assertTrue(Outer.class.isNestmateOf(Inner.class));}</code></pre><h2 id="后续的改进"><a href="#后续的改进" class="headerlink" title="后续的改进"></a>后续的改进</h2><p>嵌套关系是作为 Valhalla 项目的一部分，这个项目的主要目标之一是改进 JAVA 中的值类型和泛型。后续会有更多的改进：</p><ul><li>在泛型特化（generic specialization）中，每个特化类型（specialized type）可被创建为泛型的一个 Nestmate。</li><li>支持对<code>Unsafe.defineAnonymousClass()</code> API 的安全替换，实现将新类创建为已有类的 Nestmate。</li><li>可能会影响“密封类”（sealed classes），仅允许 Nestmate 的子类作为密封类。</li><li>可能会影响私有嵌套类型。私有嵌套类型当前定义为包内可访问（package-access）。</li></ul><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文阐述了基于嵌套关系的访问控制优化，其中涉及<code>NestMate</code>、<code>NestHost</code>、<code>NestMember</code>等概念。这次优化是 Valhalla 项目中一部分，主要改进 Java 中的值类型和泛型等。文中涉及源码都上传在 GitHub 上，关注公号「看山的小屋」回复“java”获取源码。</p><p>青山不改，绿水长流，咱们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-11-jep181-nestmate/">Java11 中基于嵌套关系的访问控制优化</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122334212" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Java 语言很强大，但是，有人的地方就有江湖，有猿的地方就有 bug，Java 的核心代码并非十全十美。比如在JDK 中居然也有反模式接口常量中介绍的反模式实现，以及本文说到的这个技术债务：嵌套关系（NestMate）调用方式。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java11" scheme="https://www.howardliu.cn/tags/Java11/"/>
    
  </entry>
  
  <entry>
    <title>这一年很幸运，平平淡淡的|2021 年度总结</title>
    <link href="https://www.howardliu.cn/2021-summary/"/>
    <id>https://www.howardliu.cn/2021-summary/</id>
    <published>2022-01-03T09:10:33.000Z</published>
    <updated>2022-01-03T09:10:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/wine-6688901_1920.jpg" alt="这一年很幸运，平平淡淡的|2021 年度总结"></p><p>你好，我是看山。</p><p>一晃又是一年，果然岁数越大，时间越快。有些内容在 <a href="https://mp.weixin.qq.com/s/_I8NtBk7NvGQt18jlxkW6Q" target="_blank" rel="noopener">原来还能这么干</a> 一文中聊了一些，今天再聊点别的。让我们一起总结过去，把握现在，展望未来。</p><p>总结下来，2021 年还算幸运，平平淡淡过一年。工作上按部就班，生活上一如既往。</p><a id="more"></a><p>如果说有什么可以出牛的，就是开始好好写文了。幸运的是在 2021 年最后一天，得到了 InfoQ 官方认可，成为签约作者。</p><h2 id="按部就班的工作"><a href="#按部就班的工作" class="headerlink" title="按部就班的工作"></a>按部就班的工作</h2><p>2021 年换了一份工作，感谢前司领导同事的帮助，知道了什么是好好工作，怎样做可以做好工作：</p><ol><li>一切用数字说话：if you cannot measure it, you cannot manage it;</li><li>做之前多想想怎么形成闭环：如果在想法上都没有闭环，那结果就经不起推敲；</li><li>方法论很重要：在没有绝对的有效处理事情的能力前，就学习一些方法论，指导工作；</li><li>坦诚待人：做到绝对坦诚不容易，可以先在工作上做到这点；</li><li>结果导向：一个人、一个团队、一个公司，都是为了一个目标在做事，如果没有结果，谈其他的都没有意义。</li></ol><p>到了现司之后，也有了一些感悟：孤胆英雄是没有办法生存的，团队才是能够好好工作的最小单位。</p><p>上面这些，每一条都可以描述很多，既然是年终总结，就先一笔带过，看官可以先自行体会一下。如果有必要，再开文详细聊聊。</p><h2 id="一如既往的生活"><a href="#一如既往的生活" class="headerlink" title="一如既往的生活"></a>一如既往的生活</h2><p>2021 年要好好感谢我媳妇，如果有哪位朋友恰好看到这篇文章，记得给小猪转发一下，我猜她一定忽略了我的这份心意。</p><p><img src="https://static.howardliu.cn/about/zhuzhu-qiqi.jpg" alt="朱朱和七七"></p><p>生活方面没有太多要说的，只有满心的感动和感激。</p><h2 id="其他方面的小确幸"><a href="#其他方面的小确幸" class="headerlink" title="其他方面的小确幸"></a>其他方面的小确幸</h2><p>在 <a href="https://mp.weixin.qq.com/s/IlgvUH79DEuCmUmTmqsqKg" target="_blank" rel="noopener">Geek 青年说北京沙龙分享</a> 中聊过，我是 2013 年开始写博客，2018 年停更一年，从 2021 年开始坚持周更。这个过程中，认识了很多志同道合的朋友，见到了很多优秀的博主。</p><p>一个人可以走的很快，一群人可以走的很远。</p><p>写博客是为了实现自己定的目标，不必太在意结果。不过，正如前面所说，一切用数字说话。下面就晒一下 2021 年的一些成绩（这些成绩和大佬没法比，只能小小的自嗨一下）：</p><p>C 站粉丝达到 17000，访问量有 870000：</p><p><img src="https://static.howardliu.cn/about/csdn-20220103.png" alt="2022 年 1 月 3 日，看山 CSDN 的详细资料"></p><p>C 站 1024 活动时，收货博客专家勋章：</p><p><img src="https://static.howardliu.cn/about/csdn-2021-october-24th.jpg" alt="CSDN1024 活动-博客专家勋章"></p><p>参加知乎海盐计划，直接升级到 4 级；</p><p>参加掘金 11 月更文活动，两次后端模块的周榜前 10；</p><p>参加 InfoQ 写作平台签约作者第二季，成功入选。评选结果是在 12 月 31 号公布的，算是给 2021 年的写作之旅画上一个不错的句号。</p><p><img src="https://static.howardliu.cn/about/InfoQ-xie-kanshan-1.jpg" alt="InfoQ 签约作者第二季"></p><p>除了写博客，今年也开始健身了。一开始是维嘉带着练，后来维嘉回了学校是跟着斌哥练，终于看到了 75 公斤的影子。</p><h2 id="2022-年的计划"><a href="#2022-年的计划" class="headerlink" title="2022 年的计划"></a>2022 年的计划</h2><p>新的一年，为了对自己负责，对家人负责，对朋友负责，我们总要做出新一年的计划。我 2022 年的计划就是搞定 2021 年那些原定于 2020 年未完成的安排，只为兑现 2019 年时要完成 2018 年许下的诺言，曾说 2017 年之后一定不要像 2016 年那样只会跟着 2015 年去做 2014 年没给 2013 年完成的那个目标。</p><p>哈哈哈，上面的文案摘自某音的段子，比较写实。</p><p>我真实的计划就不放出来了，心理学上有个研究结果，当多次向别人描述自己的计划，就会产生一种错觉，以为自己已经完成了计划。计划不广而告之，但是一定要有。</p><p>没有计划的人生不值得过。</p><p>青山不改，绿水长流，咱们下次见。</p><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/2021-summary/">这一年很幸运，平平淡淡的|2021 年度总结</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122334052" target="_blank" rel="noopener">这一年很幸运，平平淡淡的|2021 年度总结</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      一晃又是一年，果然岁数越大，时间越快。总结下来，2021 年还算幸运，平平淡淡过一年。工作上按部就班，生活上一如既往。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="年度总结" scheme="https://www.howardliu.cn/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>原来还能这么干——罗胖2022年《时间的朋友》观后感</title>
    <link href="https://www.howardliu.cn/2022-friends-of-time/"/>
    <id>https://www.howardliu.cn/2022-friends-of-time/</id>
    <published>2022-01-01T16:48:14.000Z</published>
    <updated>2022-01-01T16:48:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/nature-6891549_1920.jpg" alt="原来还能这么干——罗胖2022年《时间的朋友》观后感"></p><p>你好，我是看山。</p><p>就这样 2022 年了，年纪越大，时间越快，又到了罗胖《时间的朋友》直播的时候，看完后想写点什么，奈何腹中墨水太少，索性不难为自己，随便写写。由于疫情原因，罗胖今年的跨年演讲现场的观众全部都是熊猫娃娃，评论区有整场直播的视频回访和文字稿，有些事情，还是要自己亲自感受一下。</p><a id="more"></a><h2 id="打破思维的墙"><a href="#打破思维的墙" class="headerlink" title="打破思维的墙"></a>打破思维的墙</h2><p>整场演讲的主题是“原来还能这么干”，用我能够理解的话，就是打破思维的墙。</p><p>每个人都有自己的思维模式，这是我们赖以生存的根本，也是我们能够更快速、更高效处理普通事务的根本。之前在 <a href="https://mp.weixin.qq.com/s/JbFoEynzykrGBhOgu4Ne4w" target="_blank" rel="noopener">别让非理性思维毁了你的人生</a> 中聊过，我们的大脑为了节省能量，会经常处于自动驾驶模式，这让我们可以更有机会省出能量做其他事情。比如，我看看到知道冒白气的水是热的，不会直接喝；我们知道冷了要穿衣服，否则会生病……但是有些时候，我们用常规的办法解决不了问题，怎么办？</p><p>想要打破思维的墙，我们需要绝对的理性分析限制我们思维的问题是什么？真正要解决的问题有哪些？就不列举罗胖演讲中的例子了，我们考虑一下网约车出来之前那种打车难的问题。</p><p>很多人可能没有经历过打车难的时期，那个时候，我们没有办法知道哪里有出租车，只能就近在路边招手，出租车师傅同样不知道哪有顾客，只能满城转悠，或者在上客概率到的地方等着，比如 CBD、高铁站、机场等。平时还好，等会就等会，如果恰好有急事、或者带着老人小孩、亦或是刮风下雨的时候，就会比较难受。怎么办？</p><p>如果我们可以提前和司机师傅约好，在约定地点上车，是不是就可以了。想法有了，接下来就是实现，于是有了一系列的网约车 APP。现在大家打车记录不需要路边拦车了，直接网上下单，指定地点上车即可，方便快捷。</p><p>这几年，很多互联网公司的崛起，改变了我们的生活方式，比如：外卖、拼团、移动支付……他们的成功，是走了以前没有人走过的路。</p><p>《功勋》中屠呦呦关于常山碱的判断中，认为已经经过反复论证走不通的路，就该果断放弃，立马淘汰，找到更可靠的方式，于是有了后面的青蒿素的发现。</p><p>碰到问题，我们要投入百分之百的努力克服困难，但是如果已经不行了，就该考虑换个方式再上。</p><p>“行就行，不行再想想办法。”</p><h2 id="一切都在变"><a href="#一切都在变" class="headerlink" title="一切都在变"></a>一切都在变</h2><p>唯一不变的就是变化。没有什么是永恒不变的，我们能够应对变化的手段，只有提前预知变化，做好准备，当变化来临时，坦然面对。</p><p>很多 2020 年风生水起的教培行业，在国家出台双减政策后，一夜之间，大厦轰然倒塌。很多教培行业的老师、研发人员，只能重新考虑未来的发展。其实国家一直有这个信号，我在 <a href="https://mp.weixin.qq.com/s/EuNjfAmgQ3G491g6G4PAew" target="_blank" rel="noopener">想躺平不是错</a> 中也谈过相关的问题。很多人抱怨国家手段强硬，但他们真正抱怨的是，国家没有提前告诉他们要行霹雳手段，改变这个畸形发展的行业。</p><p>我们很多人相信风水、星座、命运，其实只是想从中探寻一些未来的可能。罗胖给出了一个观点是，我们没有办法一直追寻改变，只要找到未来的不变，试着靠近他，当未来来临时，我们就已经赶在了潮流的前列。</p><p>那怎么找到未来一定发生的事情？个人愚见是翻翻国家政策，比如“十四五”规划，看看规划的未来目标。跟着国家政策走，绝对不会有太大偏差。找到目标了怎么实现呢？有能力上，没能力提升能力也要上，如果还是上不去，就“打破思维的墙”，再想想别的办法。</p><h2 id="35-岁怎么了？一切刚刚好"><a href="#35-岁怎么了？一切刚刚好" class="headerlink" title="35 岁怎么了？一切刚刚好"></a>35 岁怎么了？一切刚刚好</h2><p>35 岁焦虑是每个程序员都有的？各种营销号中一直鼓吹一个观点，到了 35 岁，就会一下子变成了没有任何价值的抹布。而且给出很多的理由：</p><ol><li>家庭拖累，上有老下有小，会分心；</li><li>体力精力跟不上，没有办法跟刚毕业的小年轻比较；</li><li>变成了老油条，工作中很容易偷懒；</li><li>……</li></ol><p>似乎都有道理，但是总感觉哪里不对。罗胖的观点是，年龄大了之后，除了工作能力之外，我们拼的还有软技能。</p><p>以编程开发为例，简单的 CRUD，刚毕业的小伙子和 35 岁的人开发结果差不多，但是复杂逻辑呢？但凡有些经验的开发人员，会把场景考虑更加完善，会在开发时考虑更多的设计模式，这些经验，会让程序更加健壮，能够应对更多的变化。而且，经历了社会的毒打之后，我们会比较平和的接受一些职场上的不公平，这不是怂，而是一种心态的转变，“世间事，除了生死，哪一件事不是闲事。”</p><p>心态平和了，为人处世才会简单，能够更好的处理人际关系。这就是我们的软技能，如果我们可以在开发之外再有一些亮眼的特点，比如：架构设计、逻辑分析、产品设计、汇报总结等等。</p><p>之前看过一篇文章，里面说到，被辞退的员工，不会被告知被辞退的真正原因，只会说是公司效益不好、发展不畅。其实，很多时候是软技能太弱。</p><p>既然我们没有办法和 20 多岁的年轻人拼精力，那我们以一个更有生活阅历的年轻人身份在职场中打拼。</p><h2 id="此生不悔入华夏"><a href="#此生不悔入华夏" class="headerlink" title="此生不悔入华夏"></a>此生不悔入华夏</h2><p>不知道从什么时候开始，这种情绪就渗进了我们骨子里面。</p><p>写这段内容的时候，写了改，改了删。我企图找到一些证据，证明我的这个想法是对的，我企图找到一个事件，能够代表这种情绪的起点。最后还是删了，这是潜移默化的一个结果。填饱肚子的不是最后一个包子，而是前面 9 个包子的铺垫。</p><p>我只表达这种情绪，其他的交给时间。</p><h2 id="可以常常回味的话"><a href="#可以常常回味的话" class="headerlink" title="可以常常回味的话"></a>可以常常回味的话</h2><p>『1』给重要时刻：</p><p>“行万里路，读万遍经。笨鸭早飞，笨牛勤耕。让小的敬老的，拿次的留好的。宁欺官，不欺贤，宁欺贤，不欺天。人多的地方不去，没人的地方不留。赞美成功的人，安慰失败的人。犯病的东西不吃，犯法的事情不做。不要穿金戴银，只要好好做人。墙倒众人推，我不推；枪打出头鸟，我不打。种瓜得瓜瓜儿大，种豆得豆豆儿多。”————《王鼎钧回忆录》</p><p>『2』给理性乐观派：</p><p>“我的乐观并不需要这些头头是道的逻辑支撑，它就是一种朴素的信念：相信中国会更好。这种信念不是源于学术训练，而是源于司马迁、杜甫、苏轼，源于‘一条大河波浪宽’，源于对中国人勤奋实干的钦佩。它影响了我看待问题的角度和处理信息的方式，我接受这种局限性，没有改变的打算。”————兰小欢</p><p>『3』给犹豫不决的人：</p><p>“什么是事件？事件就是某种超出了原因的结果。”————齐泽克</p><p>『4』给准备出发的人：</p><p>“设计是一个不断生成目标和备选方案的过程。”————赫伯特·西蒙</p><p>『5』给正在路上的人：</p><p>“非常理想，特别现实。”————李希贵</p><p>『6』给正在拓荒的人：</p><p>“提前一个版本遵守法律”————王永治</p><p>『7』给知易行难的人：</p><p>“要改变一个成年人的行为，认知、能力、提醒，三者同样重要”————王建硕</p><p>『8』给身处困境的人：</p><p>“地球上最后一个人独自坐在房间里，这时忽然响起了敲门声……”————弗里蒂克·布朗</p><p>『9』给 2022 年的我们：</p><p>“让我们泰然自若，与自己的时代狭路相逢”————莎士比亚</p><h2 id="我们都要好好的"><a href="#我们都要好好的" class="headerlink" title="我们都要好好的"></a>我们都要好好的</h2><p>生活很难，有时候就需要一种正能量激励我们，哪怕只是轻轻的推一把，齿轮就会转动起来，然后就沿着这种惯性继续下去。</p><p>愿大家 2022 年“各从其欲，皆得所愿”。</p><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/2022-friends-of-time/">原来还能这么干——罗胖2022年《时间的朋友》观后感</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122273004" target="_blank" rel="noopener">原来还能这么干——罗胖2022年《时间的朋友》观后感</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      就这样 2022 年了，年纪越大，时间越快，又到了罗胖《时间的朋友》直播的时候，看完后想写点什么，奈何腹中墨水太少，索性不难为自己，随便写写。由于疫情原因，罗胖今年的跨年演讲现场的观众全部都是熊猫娃娃，评论区有整场直播的视频回访和文字稿，有些事情，还是要自己亲自感受一下。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊，时间的朋友" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A%EF%BC%8C%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java10 的新特性</title>
    <link href="https://www.howardliu.cn/java-10-features/"/>
    <id>https://www.howardliu.cn/java-10-features/</id>
    <published>2021-12-29T14:01:57.000Z</published>
    <updated>2021-12-29T14:01:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/christmas-5740350.png?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="Java10 新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><a id="more"></a><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>从 Java10 开始，Java 版本正式进入每半年一个版本的更新节奏，更新频率加快，小步快跑。</p><p>接下来我们瞅瞅 Java10 都更新了哪些比较有意思的功能。</p><h2 id="局部变量类型推断"><a href="#局部变量类型推断" class="headerlink" title="局部变量类型推断"></a>局部变量类型推断</h2><p>我们都知道 Java 是强类型语言，有着严格的类型限制。想要定义一个变量，必须明确指明变量类型，用<code>Object</code>抬杠的可以离开了。但是从 Java10 开始，我们可以在定义局部变量时使用<code>var</code>限定变量类型，Java 编译器会根据变量的值推断具体的类型。</p><p>比如，我们定义一个<code>Map</code>对象：</p><pre><code class="java">Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</code></pre><p>现在我们可以写做：</p><pre><code class="java">var idToNameMap = new HashMap&lt;Integer, String&gt;();</code></pre><p>这个功能算是 Java 的一次尝鲜，给 Java 语言增加了更多的可能，让我们的代码更加简洁，更加专注于可读性。</p><p>需要注意的是，新增的<code>var</code>不会把 Java 变成动态语言，在编译时，编译器会自动推断类型，将其转换为确定的类型，不会在运行时动态变化。</p><p>目前<code>var</code>只能用于局部变量，而且等号右侧必须是确定类型的定义，包括：初始化的实例、方法的调用、匿名内部类。</p><p>我们再回到刚才的例子：</p><pre><code class="java">// 以前的写法Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();// 现在可以这么写var idToNameMap = new HashMap&lt;Integer, String&gt;();</code></pre><p>对于参数的名字，我们可以不在关注类型，可以更多的关注参数的意义，这也是编写可读代码的要求。</p><p>这也为我们提出了一些要求，如果是特别长的 Lambda 表达式，还是老老实实的使用明确的类型吧，否则写着写着就迷糊了。</p><p>再就是推断类型时没有那么智能，都是基于最明确的推断，比如：</p><pre><code class="java">var emptyList = new ArrayList&lt;&gt;();</code></pre><p>这个时候推断<code>emptyList</code>的结果是<code>ArrayList&lt;Object&gt;</code>，绝对不会按照我们常用写法推断成<code>List&lt;Object&gt;</code>。</p><p>如果是匿名内部类，比如：</p><pre><code class="java">var obj = new Object() {};</code></pre><p>这个时候<code>obj.getClass()</code>可就不是<code>Object.class</code>了，而且匿名内部类的类型了。</p><p>所以，小刀虽好，但也要好好用，胡乱用容易误伤。</p><h2 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h2><p>从 Java9 开始提供不可变集合的实现，Java10 继续扩展。集合是一个容器，作为一个参数传入方法中，我们并不知道方法是否会对容器中的元素进行修改，有了不可变集合，我们就能够在一定程度上进行控制（毕竟对容器中对象的数据进行修改，我们的控制力就没有那么强了）。</p><p>针对不可变集合，我们摘取<code>java.util.List</code>的描述（其他的描述都是类似的）：</p><blockquote><h2 id="Unmodifiable-Lists"><a href="#Unmodifiable-Lists" class="headerlink" title="Unmodifiable Lists"></a>Unmodifiable Lists</h2><p>The List.of and List.copyOf static factory methods provide a convenient way to create unmodifiable lists. The List instances created by these methods have the following characteristics:</p><ul><li>They are unmodifiable. Elements cannot be added, removed, or replaced. Calling any mutator method on the List will always cause UnsupportedOperationException to be thrown. However, if the contained elements are themselves mutable, this may cause the List’s contents to appear to change.</li><li>They disallow null elements. Attempts to create them with null elements result in NullPointerException.</li><li>They are serializable if all elements are serializable.</li><li>The order of elements in the list is the same as the order of the provided arguments, or of the elements in the provided array.</li><li>They are value-based. Callers should make no assumptions about the identity of the returned instances. Factories are free to create new instances or reuse existing ones. Therefore, identity-sensitive operations on these instances (reference equality (==), identity hash code, and synchronization) are unreliable and should be avoided.</li><li>They are serialized as specified on the Serialized Form page.</li></ul></blockquote><p>简单翻译一下：</p><ul><li>这些集合都不可变，元素不能增、减、替换，调用修改方法都会返回<code>UnsupportedOperationException</code>异常。但是，but，如果集合中的元素是可变的，那就控不住了。比如，元素是<code>AtomInteger</code>就没法控制其中的值，集合只是元素不变；如果是<code>String</code>，那集合是整体不变的。</li><li>不允许<code>null</code>，会抛出<code>NullPointerException</code></li><li>如果集合中的元素是可序列化的，那集合就能够序列化</li><li>集合中元素的顺序是加入的顺序</li><li><code>copyOf</code>和<code>of</code>这些方法中返回的结果可能使用提前定义好的对象，比如空集合、原集合等。换句话说，在不同调用位置返回了相同对象。所以不要相信<code>==</code>、<code>hashCode</code>，也不要对其加锁。</li></ul><h3 id="copyOf"><a href="#copyOf" class="headerlink" title="copyOf"></a>copyOf</h3><p>在<code>java.util.List</code>、<code>java.util.Map</code>、<code>java.util.Set</code>这几个接口中都各自添加了一个<code>copyOf</code>静态方法，用来创建不可变集合，最终都会是<code>ImmutableCollections</code>中定义的几个集合实现，与 Java9 中定义的<code>of</code>方法类似。</p><p>对于<code>java.util.Map</code>、<code>java.util.Set</code>，这里有一个优化，如果传入的本身就是不可变的集合，将直接返回传入的参数，代码如下：</p><pre><code class="java">static &lt;E&gt; Set&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) {    if (coll instanceof ImmutableCollections.AbstractImmutableSet) {        return (Set&lt;E&gt;)coll;    } else {        return (Set&lt;E&gt;)Set.of(new HashSet&lt;&gt;(coll).toArray());    }}</code></pre><h3 id="toUnmodifiableList、toUnmodifiableSet、toUnmodifiableMap"><a href="#toUnmodifiableList、toUnmodifiableSet、toUnmodifiableMap" class="headerlink" title="toUnmodifiableList、toUnmodifiableSet、toUnmodifiableMap"></a>toUnmodifiableList、toUnmodifiableSet、toUnmodifiableMap</h3><p>Java10 很贴心的提供了<code>Stream</code>中的操作，我们直接创建不可变集合了。比如：</p><pre><code class="java">Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;)    .map(x -&gt; &quot;id: &quot; + x)    .collect(Collectors.toUnmodifiableList());</code></pre><p><code>toUnmodifiableList</code>、<code>toUnmodifiableSet</code>、<code>toUnmodifiableMap</code>的用法与<code>toList</code>、<code>toSet</code>、<code>toMap</code>没有太多区别，差别在于返回的是不可变集合。</p><h2 id="Optional-族增加-orElseThrow-方法"><a href="#Optional-族增加-orElseThrow-方法" class="headerlink" title="Optional 族增加 orElseThrow 方法"></a>Optional 族增加 orElseThrow 方法</h2><p>这里说的 Optional 族包括<code>Optional</code>、<code>OptionalInt</code>、<code>OptionalLong</code>、<code>OptionalDouble</code>几个实现。以前有一个<code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code>方法，用于获取不到数据时，抛出<code>exceptionSupplier</code>中定义的异常。</p><p>我们会写成：</p><pre><code class="java">Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;)    .map(x -&gt; &quot;id: &quot; + x)    .findAny()    .orElseThrow(() -&gt; new NoSuchElementException(&quot;No value present&quot;));</code></pre><p>优点是我们可以自定义自己的异常以及异常信息。有时候，我们不关心具体的异常和异常信息，这个时候 Java10 中的新增的<code>orElseThrow</code>方法就派上用场了：</p><pre><code class="java">Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;)    .map(x -&gt; &quot;id: &quot; + x)    .findAny()    .orElseThrow();</code></pre><p>此时如果元素为空，将抛出<code>NoSuchElementException</code>异常。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>Java 当年在性能方面一直被诟病，中间隔着一层虚拟机，实现跨平台运行的功能同时，也致使其执行性能不如 C 语言。所以，Java 一直在性能方面投入大量精力。</p><p>我们看看 Java10 中都有哪些优化点。</p><h3 id="G1-实现并行-Full-GC-算法"><a href="#G1-实现并行-Full-GC-算法" class="headerlink" title="G1 实现并行 Full GC 算法"></a>G1 实现并行 Full GC 算法</h3><p>从 Java9 开始，G1 已经转正，成为默认的垃圾收集器。不过在 Full GC 时，G1 还是采用的单线程串行标记压缩算法，这样 STW 时间会比较长。到 Java10，Full GC 实现了并行标记压缩算法，明显缩短 STW 时间。</p><h3 id="应用程序类数据共享（AppCDS）"><a href="#应用程序类数据共享（AppCDS）" class="headerlink" title="应用程序类数据共享（AppCDS）"></a>应用程序类数据共享（AppCDS）</h3><p>CDS（Class-Data Sharing，类数据共享）是在 Java5 引入的一种类预处理方式，可以将一组类共享到一个归档文件中，在运行时通过内存映射加载类，这样做可以减少启动时间。同时在多个 JVM 之间实现同享同一个归档文件，减少动态内存占用。</p><p>但是 CDS 有一个限制，就是只能是 Bootstrap ClassLoader 使用，这样就将功能限制了类的范围。在 Java10 中，将这个功能扩展到了系统类加载器（System ClassLoader，或者成为应用类加载器，Application ClassLoader）、内置的平台类加载器（Platform ClassLoader），或者是自定义的类加载器。这样就将功能扩展到了应用类。</p><p>想要使用这个功能的话，总共分三步：</p><p><img src="https://static.howardliu.cn/Illustration/BE710605-5206-4D37-8D8C-86E515A6D386.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="总共分三步"></p><ol><li>打包<br>我们把<code>hello.jar</code>中的<code>HelloWorld</code>类使用的类添加到<code>hello.lst</code>中：</li></ol><pre><code class="shell">$ java -Xshare:off -XX:+UseAppCDS -XX:DumpLoadedClassList=hello.lst \    -cp hello.jar HelloWorld</code></pre><ol start="2"><li>创建 AppCDS 归档<br>接下来使用<code>hello.lst</code>中的内容创建 AppCDS 文件<code>hello.jsa</code>：</li></ol><pre><code class="shell">$ java -Xshare:dump -XX:+UseAppCDS -XX:SharedClassListFile=hello.lst \   -XX:SharedArchiveFile=hello.jsa -cp hello.jar</code></pre><ol start="3"><li>使用 AppCDS 归档<br>最后是使用<code>hello.jsa</code>启动<code>HelloWorld</code>：</li></ol><pre><code class="shell">$ java -Xshare:on -XX:+UseAppCDS -XX:SharedArchiveFile=hello.jsa \   -cp hello.jar HelloWorld</code></pre><h3 id="基于-Java-的-JIT-编译器-Graal"><a href="#基于-Java-的-JIT-编译器-Graal" class="headerlink" title="基于 Java 的 JIT 编译器 Graal"></a>基于 Java 的 JIT 编译器 Graal</h3><p><a href="https://github.com/oracle/graal/" target="_blank" rel="noopener">Graal</a> 是使用 Java 编写的与 HotSpot JVM 集成的动态编译器，专注于高性能和可扩展性。是从 JDK9 引入的实验性 AOT 编译器的基础。</p><p>在 JDK10 中，我们可以在 Linux/x64 平台将 Graal 作为 JIT 编译器使用。开启命令如下：</p><pre><code class="shell">-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler</code></pre><p>需要注意的是，这是实验特性，相当于公测阶段，可能在某些场景下，性能不如现有的 JIT 编译器。</p><h2 id="支持容器"><a href="#支持容器" class="headerlink" title="支持容器"></a>支持容器</h2><p>容器化是目前的趋势，在之前，由于 JVM 不能够感知容器，在同一个主机上部署多个虚拟机时，会造成内存占用、CPU 抢占等问题，这点也成为了很多大会上抨击 Java 语言不适合容器时代的一个点。</p><p>现在好了，JVM 可以感知容器了。只是暂时还只支持 Linux 系统（so what，其他平台也还没有用过）。这个功能默认开启，不想使用可以手动关闭：</p><pre><code class="shell">-XX:-UseContainerSupport</code></pre><p>我们还可以手动指定 CPU 核数：</p><pre><code class="shell">-XX:ActiveProcessorCount=1</code></pre><p>还有三个可以控制内存的使用量：</p><pre><code class="shell">-XX:InitialRAMPercentage-XX:MaxRAMPercentage-XX:MinRAMPercentage</code></pre><p>就目前来看，这部分还可以继续完善，相信只是时间问题。</p><h2 id="根证书认证"><a href="#根证书认证" class="headerlink" title="根证书认证"></a>根证书认证</h2><p>自 Java9 起在 keytool 中加入参数 -cacerts，可以查看当前 JDK 管理的根证书。而 Java9 中 cacerts 目录为空，这样就会给开发者带来很多不便。从 Java10 开始，将会在 JDK 中提供一套默认的 CA 根证书。</p><p>作为 JDK 一部分的 cacerts 密钥库旨在包含一组能够用于在各种安全协议的证书链中建立信任的根证书。在 Java10 之前，cacerts 密钥库是空的，默认情况下，关键安全组件（如 TLS）是不起作用的，开发人员需要手动添加一组根证书来使用这些验证。</p><p>Java10 中，Oracle 开放了根证书源码，可以让 OpenJDK 构建对开发人员更有吸引力，并减少这些构建与 Oracle JDK 构建之间的差异。</p><h2 id="启用和删除的功能"><a href="#启用和删除的功能" class="headerlink" title="启用和删除的功能"></a>启用和删除的功能</h2><p>有增有减，这样才能够保证 Java 的与时共进。</p><h3 id="命令行工具和某些参数"><a href="#命令行工具和某些参数" class="headerlink" title="命令行工具和某些参数"></a>命令行工具和某些参数</h3><ul><li>移除<code>javah</code>命令，这个命令用于创建 native 方法所需的 C 的头文件和资源文件的，使用<code>javac -h</code>替代。</li><li>移除<code>policytool</code>工具，这个工具用于创建和管理策略文件。可以直接还使用文本编辑器代替。</li><li>删除<code>java -Xprof</code>参数，这个参数本来是用于评测正在运行的程序，并将评测数据发送到标准输出。可以使用<code>jmap</code>代替。</li></ul><h3 id="某些-API"><a href="#某些-API" class="headerlink" title="某些 API"></a>某些 API</h3><p><code>java.security.acl</code>包标记为过期，标记参数<code>forRemoval</code>是<code>true</code>，将在未来版本中删除。目前，这个包内的功能已经被<code>java.security.Policy</code>取代。<code>java.security</code>包中的<code>Certificate</code>、<code>Identity</code>、<code>IdentityScope</code>、<code>Signer</code>的标记参数<code>forRemoval</code>也是<code>true</code>。这些都将在后续版本中删除。</p><h2 id="基于时间的版本发布模式"><a href="#基于时间的版本发布模式" class="headerlink" title="基于时间的版本发布模式"></a>基于时间的版本发布模式</h2><p>从 Java10 开始，Java 正式进入每半年一个版本的更新节奏，主要改动如下：</p><ol><li>每 6 个月发布一组新特性；</li><li>长期支持版（LTS）将支持 3 年，其他版本支持 6 个月；</li><li>Java11、Java17 是长期支持版；</li><li>采用<code>$FEATURE.$INTERIM.$UPDATE.$PATCH</code>命名机制：<code>$FEATURE</code>，每次版本发布加 1，不考虑具体的版本内容；<code>$INTERIM</code>，中间版本号，在大版本中间发布的，包含问题修复和增强的版本，不会引入非兼容性修改；<code>$PATCH</code>用于快速打补丁的。</li></ol><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java10 新增的特性，完整的特性清单可以从<a href="https://openjdk.java.net/projects/jdk/10/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/10/</a>查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-10-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java10 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122225794" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java10 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      从 Java10 开始，Java 版本正式进入每半年一个版本的更新节奏，更新频率加快，小步快跑。在 Java10 中增加了局部变量类型推断、不可变集合、Optional增强、G1 实现并行 Full GC 算法、支持容器、根证书认证等特性。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java10" scheme="https://www.howardliu.cn/tags/Java10/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis-Plus 版本冲突触发“Could not convert argument value of type [java.lang.String] to required type [java.lang.Class]”的 java.lang.NoClassDefFoundError 异常</title>
    <link href="https://www.howardliu.cn/mybatis-plus-conflict-noclassdeffounderror/"/>
    <id>https://www.howardliu.cn/mybatis-plus-conflict-noclassdeffounderror/</id>
    <published>2021-12-25T03:51:38.000Z</published>
    <updated>2021-12-25T03:51:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/dog-2963062_1920.jpg" alt="Mybatis-Plus 版本冲突触发“Could not convert argument value of type [java.lang.String] to required type [java.lang.Class]”的 java.lang.NoClassDefFoundError 异常"></p><p>你好，我是看山。</p><p>今天项目依赖了一个基础组件之后，启动失败，排查过程走了一些弯路，最终确认是因为依赖组件版本冲突造成了<code>java.lang.NoClassDefFoundError</code>异常。下面是排查过程，希望可以给你提供一些思路。</p><a id="more"></a><h2 id="观察异常栈"><a href="#观察异常栈" class="headerlink" title="观察异常栈"></a>观察异常栈</h2><p>下面是打印的异常栈信息，从其中提炼可能的关键信息，能够找到“Could not convert argument value of type [java.lang.String] to required type [java.lang.Class]”，还有“Unresolvable class definition for class [cn.howardliu.demo.AddressMapper]”。继续从异常栈中找一下发生的时机，可以发现是调用<code>AbstractAutowireCapableBeanFactory.createBeanInstance</code>时，这个方法是创建 Bean 实例。</p><pre><code class="log">这块是异常信息（getMessage 的内容，横向太长，手动换行了）：org.springframework.beans.factory.UnsatisfiedDependencyException:    Error creating bean with name &#39;methodValidationPostProcessor&#39; defined in class path resource [org/springframework/boot/autoconfigure/validation/ValidationAutoConfiguration.class]:    Unsatisfied dependency expressed through method &#39;methodValidationPostProcessor&#39; parameter 0;    nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException:    Error creating bean with name &#39;addressMapper&#39; defined in file [/Users/liuxinghao/Documents/work/code/cn.howardliu/effective-spring/target/classes/cn/howardliu/demo/AddressMapper.class]:    Unsatisfied dependency expressed through constructor parameter 0:    Could not convert argument value of type [java.lang.String] to required type [java.lang.Class]:    Failed to convert value of type &#39;java.lang.String&#39; to required type &#39;java.lang.Class&#39;;    nested exception is java.lang.IllegalArgumentException:     Unresolvable class definition for class [cn.howardliu.demo.AddressMapper]下面是异常栈：    at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:799) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:540) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1341) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1181) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:556) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:516) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:324) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:322) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:207) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]其他异常栈信息可以忽略了</code></pre><p>我们可以根据目前有效的信息进行排查，首先看下我们的<code>cn.howardliu.demo.AddressMapper</code>定义是否有问题，再看看依赖它的 Service 有没有问题，什么问题也没有发现。下一个检查点是配置，比如<code>@MapperScan</code>是否正确、Mapper 类上有没有加上<code>@Mapper</code>注解，发现也没有问题。</p><p>从异常信息找不到思路了，只能从代码入手了。</p><blockquote><p>这里需要说一下，打印异常信息至关重要，直接影响我们排错的思路。如果打印的信息没有办法准确定位，我们将会花费大量的时间查找真正的错误，这就需要走查代码，有时候还需要一些经验。</p></blockquote><h2 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h2><p>我们由异常栈<code>ConstructorResolver.createArgumentArray(ConstructorResolver.java:799)</code>入手，跟着断点往下追，最终会追到<code>org.springframework.util.ClassUtils#forName</code>方法，其中会抛出异常的代码是下面这块：</p><pre><code class="java">try {    return Class.forName(name, false, clToUse);}catch (ClassNotFoundException ex) {    int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);    if (lastDotIndex != -1) {        String innerClassName =                name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);        try {            return Class.forName(innerClassName, false, clToUse);        }        catch (ClassNotFoundException ex2) {            // Swallow - let original exception get through        }    }    throw ex;}</code></pre><p>出现错误的是<code>Class.forName(name, false, clToUse)</code>这句，<code>name</code>传的是”cn.howardliu.demo.AddressMapper”字符串，抛出的异常是<code>java.lang.NoClassDefFoundError</code>，由于不是<code>ClassNotFoundException</code>异常，不会进入<code>catch</code>逻辑，会直接向上抛出。</p><p>找到错误我们就好定位问题了。</p><p>一般来说，<code>java.lang.NoClassDefFoundError</code>错误是需要加载的类能够找到，但是加载时出现了异常，简单说就是，类的定义有问题。我们借助 JD-GUI 反编译一下运行 jar 包，结果如下：</p><pre><code class="java">import com.baomidou.mybatisplus.core.mapper.BaseMapper;import cn.howardliu.demo.Address;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface AddressMapper extends BaseMapper&lt;Address&gt; {}</code></pre><p>观察仔细的话，我们可以看到<code>import com.baomidou.mybatisplus.core.mapper.BaseMapper;</code>这行没有下划线，也就是说，在反编译工具中追溯不到这个接口，推断出来就是在运行环境中，找不到<code>BaseMapper</code>这个类定义。</p><p>所以，当<code>Class.forName</code>加载类的时候抛出了<code>java.lang.NoClassDefFoundError</code>异常。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>如果有一定经验，就会立刻想到，大概率出现了依赖 jar 的版本冲突。</p><p>我们可以借助 maven 命令行找到版本冲突的依赖：</p><pre><code class="shell">mvn dependency:tree -Dverbose | grep conflict</code></pre><p>打印结果为：</p><pre><code class="log">[INFO] |  +- (com.baomidou:mybatis-plus:jar:3.1.2:compile - omitted for conflict with 2.1.6)</code></pre><p>我们也可以借助 IDEA 的可视化工具，在 pom.xml 上打开依赖图：</p><p><img src="https://static.howardliu.cn/java/EF543BDC-9C35-43CF-A181_20211225114104.png" alt="依赖图"></p><p>我们可以看到 mybatis-plus 的红线指示出冲突信息：</p><p><img src="https://static.howardliu.cn/java/F0C16C09-7C27-4D34-99F9-B73B665EF0A3_20211225114132.png" alt="冲突信息"></p><p>结论就是 Mybatis-Plus 版本冲突了，项目中依赖了 mybatis-plus 的 2.1.6 和 3.1.2 两个版本，由于 2.1.6 路径更短，最终被选中。</p><p>此时只需要将低版本的依赖去掉即可。</p><h2 id="复盘问题"><a href="#复盘问题" class="headerlink" title="复盘问题"></a>复盘问题</h2><h3 id="mybatis-plus-的版本问题"><a href="#mybatis-plus-的版本问题" class="headerlink" title="mybatis-plus 的版本问题"></a>mybatis-plus 的版本问题</h3><p>为什么低版本的 mybatis-plus 会造成类加载失败呢？是因为 mybatis-plus 跨版本更新时，把<code>BaseMapper</code>的包路径改了：</p><pre><code class="java">// 3.1.2 版本import com.baomidou.mybatisplus.core.mapper.BaseMapper;// 2.1.6 版本import com.baomidou.mybatisplus.mapper.BaseMapper;</code></pre><p>而且还不止这一个，<code>IService</code>、<code>ServiceImpl</code>、<code>TableName</code>、<code>TableField</code>、<code>Model</code>、<code>TableField</code>等等，很多常用的类都改了位置。所以会造成找不到依赖的类。编译是 3.1.2 依赖还在运行环境中，就会出现编译没有问题，执行时出现加载类异常。</p><p>想要工程化的解决这个问题，我们可以创建基础的依赖 bom 配置，定义好基础依赖包，在项目中不在指定版本。这样做到统一版本，可以有效地避免这类问题。</p><p>我们还可以在 CI/CD 中加入冲突依赖检查，如果发现冲突依赖，就终止流水线。</p><h3 id="真实异常被隐藏问题"><a href="#真实异常被隐藏问题" class="headerlink" title="真实异常被隐藏问题"></a>真实异常被隐藏问题</h3><p>接下来我们看下为什么明明是<code>java.lang.NoClassDefFoundError</code>异常，结果异常栈中打印的是一堆不相干的错误。继续跟着刚才的断点 Debug：</p><p><code>org.springframework.util.ClassUtils#resolveClassName</code>会捕捉<code>LinkageError</code>错误，然后包装成<code>IllegalArgumentException</code>异常，这个时候真是异常还是继续上抛。</p><p>然后在<code>org.springframework.beans.TypeConverterSupport#convertIfNecessary</code>方法会包装成<code>TypeMismatchException</code>异常，此时，真实异常还在异常<code>cause</code>参数中，并没有丢失。</p><p>等回到<code>org.springframework.beans.factory.support.ConstructorResolver#createArgumentArray</code>方法后，捕捉异常的方法是：</p><pre><code class="java">try {    convertedValue = converter.convertIfNecessary(originalValue, paramType, methodParam);}catch (TypeMismatchException ex) {    throw new UnsatisfiedDependencyException(            mbd.getResourceDescription(), beanName, new InjectionPoint(methodParam),            &quot;Could not convert argument value of type [&quot; +                    ObjectUtils.nullSafeClassName(valueHolder.getValue()) +                    &quot;] to required type [&quot; + paramType.getName() + &quot;]: &quot; + ex.getMessage());}</code></pre><p>此时我们可以注意到，在包装成<code>UnsatisfiedDependencyException</code>异常的时候，只是把捕捉到的<code>TypeMismatchException</code>通过<code>getMessage</code>方法追加在异常描述后面，此时经过前面几轮的包装再包装，真实的异常的异常信息仅剩<code>Unresolvable class definition for class [cn.howardliu.demo.AddressMapper]</code>这段经过处理的信息，完全没有<code>java.lang.NoClassDefFoundError</code>的影子了。</p><p>至此，真实异常消失无踪。</p><p>这也给我们一个提醒，我们要保证异常的时候，一定要保留有效信息，否则，排错会非常麻烦。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文是抓虫文，从问题出发，到解决问题，给出完整的思路。<code>java.lang.NoClassDefFoundError</code>一般都是出现在版本冲突的时候，这种异常是编译打包没有问题，在运行时加载类失败。在本文中之所以排查时走了一些弯路，是因为<code>Spring</code>隐藏了真实异常，给我们排错造成了一些阻碍。所以，我们在日常开发时也要重视异常的明确信息，可以给我们排错提供准确的目标。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/mybatis-plus-conflict-noclassdeffounderror/">Mybatis-Plus 版本冲突触发“Could not convert argument value of type [java.lang.String] to required type [java.lang.Class]”的 java.lang.NoClassDefFoundError 异常</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122203746" target="_blank" rel="noopener">Mybatis-Plus 版本冲突触发“Could not convert argument value of type [java.lang.String] to required type [java.lang.Class]”的 java.lang.NoClassDefFoundError 异常</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      今天项目依赖了一个基础组件之后，启动失败，排查过程走了一些弯路，最终确认是因为依赖组件版本冲突造成了`java.lang.NoClassDefFoundError`异常。下面是排查过程，希望可以给你提供一些思路。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="NoClassDefFoundError" scheme="https://www.howardliu.cn/tags/NoClassDefFoundError/"/>
    
      <category term="Mybatis-Plus" scheme="https://www.howardliu.cn/tags/Mybatis-Plus/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java9 的新特性</title>
    <link href="https://www.howardliu.cn/java-9-features/"/>
    <id>https://www.howardliu.cn/java-9-features/</id>
    <published>2021-12-19T02:09:20.000Z</published>
    <updated>2021-12-19T02:09:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/train-g9ee00db77_1920.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java9 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>相较于 <a href="https://mp.weixin.qq.com/s/f0bgOBy1_Hz-HHRD32HSXw" target="_blank" rel="noopener">Java8</a>，Java9 没有新增语法糖，但是其增加的特性也都是非常实用的，比如 Jigsaw 模块化、JShell、发布-订阅框架、GC 等。本文将快速、高层次的介绍一些新特性，完整的特性可以参加<a href="https://openjdk.java.net/projects/jdk9/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk9/</a>。</p><blockquote><p>这里需要说明一下，由于 Java9 并不是长期支持版，当前也是从现在看过去，所以笔者偷个懒，文章的示例代码都是在 Java11 下写的，可能会与 Java9 中的定义有些出入，不过，这也没啥，毕竟我们真正使用的时候还是优先考虑长期支持版。</p></blockquote><h2 id="Jigsaw-模块化"><a href="#Jigsaw-模块化" class="headerlink" title="Jigsaw 模块化"></a>Jigsaw 模块化</h2><p>模块化是一个比较大的更新，这让以前 All-in-One 的 Java 包拆分成几个模块。这种模块化系统提供了类似 OSGi 框架系统的功能，比如多个模块可以独立开发，按需引用、按需集成，最终组装成一个完整功能。</p><p>模块具有依赖的概念，可以导出功能 API，可以隐藏实现细节。</p><p>还有一个好处是可以实现 JVM 的按需使用，能够减小 Java 运行包的体积，让 JVM 在内存更小的设备上运行。JVM 当时的初衷就是做硬件，也算是不忘初心了。</p><p>另外，JVM 中<code>com.sun.*</code>的之类的内部 API，做了更强的封闭，不在允许调用，提升了内核安全。</p><p>在使用的时候，我们需要在 java 代码的顶层目录中定义一个<code>module-info.java</code>文件，用于描述模块信息：</p><pre><code class="java">module cn.howardliu.java9.modules.car {    requires cn.howardliu.java9.modules.engines;    exports cn.howardliu.java9.modules.car.handling;}</code></pre><p>上面描述的信息是：模块<code>cn.howardliu.java9.modules.car</code>需要依赖模块<code>cn.howardliu.java9.modules.engines</code>，并导出模块<code>cn.howardliu.java9.modules.car.handling</code>。</p><p>更多的信息可以查看 OpenJDK 的指引 <a href="https://openjdk.java.net/projects/jigsaw/quick-start，后续会单独介绍" target="_blank" rel="noopener">https://openjdk.java.net/projects/jigsaw/quick-start，后续会单独介绍</a> Jigsaw 模块的使用，内容会贴到评论区。</p><h2 id="全新的-HTTP-客户端"><a href="#全新的-HTTP-客户端" class="headerlink" title="全新的 HTTP 客户端"></a>全新的 HTTP 客户端</h2><p>这是一个千呼万唤始出来的功能，终于有官方 API 可以替换老旧难用的<code>HttpURLConnection</code>。只不过，在 Java9 中，新版 HTTP 客户端是放在孵化模块中（具体信息可以查看 <a href="https://openjdk.java.net/jeps/110）。" target="_blank" rel="noopener">https://openjdk.java.net/jeps/110）。</a></p><p>老版 HTTP 客户端存在很多问题，大家开发的时候基本上都是使用第三方 HTTP 库，比如 Apache HttpClient、Netty、Jetty 等。</p><p>新版 HTTP 客户端的目标很多，毕竟这么多珠玉在前，如果还是做成一坨，指定是要被笑死的。所以新版 HTTP 客户端列出了 16 个目标，包括简单易用、打印关键信息、WebSocket、HTTP/2、HTTPS/TLS、良好的性能、非阻塞 API 等等。</p><p>我们先简单的瞅瞅：</p><pre><code class="java">final String url = &quot;https://postman-echo.com/get&quot;;final HttpRequest request = HttpRequest.newBuilder()        .uri(new URI(url))        .GET()        .build();final HttpResponse&lt;String&gt; response = HttpClient.newHttpClient()        .send(request, HttpResponse.BodyHandlers.ofString());final HttpHeaders headers = response.headers();headers.map().forEach((k, v) -&gt; System.out.println(k + &quot;:&quot; + v));System.out.println(response.statusCode());System.out.println(response.body());</code></pre><blockquote><p>新版 HTTP 客户端可以在 Java11 中正常使用了，上面的代码也是在 Java11 中写的，API 是在<code>java.net.http</code>包中。</p></blockquote><h2 id="改进的进程-API"><a href="#改进的进程-API" class="headerlink" title="改进的进程 API"></a>改进的进程 API</h2><p>在 Java9 中提供的进程 API，可以控制和管理操作系统进程。也就是说，可以在代码中管理当前进程，甚至可以销毁当前进程。</p><h3 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h3><p>这个功能是由<code>java.lang.ProcessHandle</code>提供的，我们来瞅瞅怎么用：</p><pre><code class="java">final ProcessHandle self = ProcessHandle.current();final long pid = self.pid();System.out.println(&quot;PID: &quot; + pid);final ProcessHandle.Info procInfo = self.info();procInfo.arguments().ifPresent(x -&gt; {    for (String s : x) {        System.out.println(s);    }});procInfo.commandLine().ifPresent(System.out::println);procInfo.startInstant().ifPresent(System.out::println);procInfo.totalCpuDuration().ifPresent(System.out::println);</code></pre><p><code>java.lang.ProcessHandle.Info</code>中提供了丰富的进程信息</p><h3 id="销毁进程"><a href="#销毁进程" class="headerlink" title="销毁进程"></a>销毁进程</h3><p>我们还可以使用<code>java.lang.ProcessHandle#destroy</code>方法销毁进程，我们演示一下销毁子进程：</p><pre><code class="java">ProcessHandle.current().children()        .forEach(procHandle -&gt; {            System.out.println(procHandle.pid());            System.out.println(procHandle.destroy());        });</code></pre><blockquote><p>从 Java8 之后，我们会发现 Java 提供的 API 使用了<code>Optional</code>、<code>Stream</code>等功能，*<em>Eating your own dog food *</em>也是比较值得学习的。</p></blockquote><h2 id="其他小改动"><a href="#其他小改动" class="headerlink" title="其他小改动"></a>其他小改动</h2><p>Java9 中还对做了对已有功能做了点改动，我们来瞅瞅都有哪些。</p><h3 id="改进-try-with-resources"><a href="#改进-try-with-resources" class="headerlink" title="改进 try-with-resources"></a>改进 try-with-resources</h3><p>从 Java7 开始，我们可以使用<code>try-with-resources</code>语法自动关闭资源，所有实现了<code>java.lang.AutoCloseable</code>接口，可以作为资源。但是这里会有一个限制，就是每个资源需要声明一个新变量。</p><p>也就是这样：</p><pre><code class="java">public static void tryWithResources() throws IOException {    try (FileInputStream in2 = new FileInputStream(&quot;./&quot;)) {        // do something    }}</code></pre><p>对于这种直接使用的还算方便，但如果是需要经过一些列方法定义的呢？就得写成下面这个样子：</p><pre><code class="java">final Reader inputString = new StringReader(&quot;www.howardliu.cn 看山&quot;);final BufferedReader br = new BufferedReader(inputString);// 其他一些逻辑try (BufferedReader br1 = br) {    System.out.println(br1.lines());}</code></pre><p>在 Java9 中，如果资源是<code>final</code>定义的或者等同于<code>final</code>变量，就不用声明新的变量名，可以直接在<code>try-with-resources</code>中使用：</p><pre><code class="java">final Reader inputString = new StringReader(&quot;www.howardliu.cn 看山&quot;);final BufferedReader br = new BufferedReader(inputString);// 其他一些逻辑try (br) {    System.out.println(br.lines());}</code></pre><h3 id="改进钻石操作符-Diamond-Operator"><a href="#改进钻石操作符-Diamond-Operator" class="headerlink" title="改进钻石操作符 (Diamond Operator)"></a>改进钻石操作符 (Diamond Operator)</h3><p>钻石操作符（也就是<code>&lt;&gt;</code>）是 Java7 引入的，可以简化泛型的书写，比如：</p><pre><code class="java">Map&lt;String, List&lt;String&gt;&gt; strsMap = new TreeMap&lt;String, List&lt;String&gt;&gt;();</code></pre><p>右侧的<code>TreeMap</code>类型可以根据左侧的泛型定义推断出来，借助钻石操作符可以简化为：</p><pre><code class="java">Map&lt;String, List&lt;String&gt;&gt; strsMap = new TreeMap&lt;&gt;();</code></pre><p>看山会简洁很多，<code>&lt;&gt;</code>的写法就是钻石操作符 (Diamond Operator)。</p><p>但是这种写法不适用于匿名内部类。比如有个抽象类：</p><pre><code class="java">abstract static class Consumer&lt;T&gt; {    private T content;    public Consumer(T content) {        this.content = content;    }    abstract void accept();    public T getContent() {        return content;    }}</code></pre><p>在 Java9 之前，想要实现匿名内部类，就需要写成：</p><pre><code class="java">final Consumer&lt;Integer&gt; intConsumer = new Consumer&lt;Integer&gt;(1) {    @Override    void accept() {        System.out.println(getContent());    }};intConsumer.accept();final Consumer&lt;? extends Number&gt; numConsumer = new Consumer&lt;Number&gt;(BigDecimal.TEN) {    @Override    void accept() {        System.out.println(getContent());    }};numConsumer.accept();final Consumer&lt;?&gt; objConsumer = new Consumer&lt;Object&gt;(&quot;看山&quot;) {    @Override    void accept() {        System.out.println(getContent());    }};objConsumer.accept();</code></pre><p>在 Java9 之后就可以使用钻石操作符了：</p><pre><code class="java">final Consumer&lt;Integer&gt; intConsumer = new Consumer&lt;&gt;(1) {    @Override    void accept() {        System.out.println(getContent());    }};intConsumer.accept();final Consumer&lt;? extends Number&gt; numConsumer = new Consumer&lt;&gt;(BigDecimal.TEN) {    @Override    void accept() {        System.out.println(getContent());    }};numConsumer.accept();final Consumer&lt;?&gt; objConsumer = new Consumer&lt;&gt;(&quot;看山&quot;) {    @Override    void accept() {        System.out.println(getContent());    }};objConsumer.accept();</code></pre><h3 id="私有接口方法"><a href="#私有接口方法" class="headerlink" title="私有接口方法"></a>私有接口方法</h3><p>如果说钻石操作符是代码的简洁可读，那接口的私有方法就是比较实用的一个扩展了。</p><p>在 Java8 之前，接口只能有常量和抽象方法，想要有具体的实现，就只能借助抽象类，但是 Java 是单继承，有很多场景会受到限制。</p><p>在 Java8 之后，接口中可以定义默认方法和静态方法，提供了很多扩展。但这些方法都是<code>public</code>方法，是完全对外暴露的。如果有一个方法，只想在接口中使用，不想将其暴露出来，就没有办法了。这个问题在 Java9 中得到了解决。我们可以使用<code>private</code>修饰，限制其作用域。</p><p>比如：</p><pre><code class="java">public interface Metric {    // 常量    String NAME = &quot;METRIC&quot;;    // 抽象方法    void info();    // 私有方法    private void append(String tag, String info) {        buildMetricInfo();        System.out.println(NAME + &quot;[&quot; + tag + &quot;]:&quot; + info);        clearMetricInfo();    }    // 默认方法    default void appendGlobal(String message) {        append(&quot;GLOBAL&quot;, message);    }    // 默认方法    default void appendDetail(String message) {        append(&quot;DETAIL&quot;, message);    }    // 私有静态方法    private static void buildMetricInfo() {        System.out.println(&quot;build base metric&quot;);    }    // 私有静态方法    private static void clearMetricInfo() {        System.out.println(&quot;clear base metric&quot;);    }}</code></pre><h2 id="JShell"><a href="#JShell" class="headerlink" title="JShell"></a>JShell</h2><p>JShell 就是 Java 语言提供的 REPL(Read Eval Print Loop，交互式的编程环境）环境。在 Python、Node 之类的语言，很早就带有这种环境，可以很方便的执行 Java 语句，快速验证一些语法、功能等。</p><pre><code class="shell">$ jshell|  欢迎使用 JShell -- 版本 13.0.9|  要大致了解该版本，请键入：/help intro</code></pre><p>我们可以直接使用<code>/help</code>查看命令</p><pre><code class="shell">jshell&gt; /help|  键入 Java 语言表达式，语句或声明。|  或者键入以下命令之一：|  /list [&lt;名称或 id&gt;|-all|-start]|      列出您键入的源|  /edit &lt;名称或 id&gt;。很多的内容，鉴于篇幅，先隐藏</code></pre><p>我们看下一些简单的操作：</p><pre><code class="shell">jshell&gt; &quot;This is a test.&quot;.substring(5, 10);$2 ==&gt; &quot;is a &quot;jshell&gt; 3+1$3 ==&gt; 4</code></pre><p>也可以创建方法：</p><pre><code class="shell">jshell&gt; int mulitiTen(int i) { return i*10;}|  已创建 方法 mulitiTen(int)jshell&gt; mulitiTen(3)$6 ==&gt; 30</code></pre><p>想要退出 JShell 直接输入：</p><pre><code class="shell">jshell&gt; /exit|  再见</code></pre><h2 id="JCMD-新增子命令"><a href="#JCMD-新增子命令" class="headerlink" title="JCMD 新增子命令"></a>JCMD 新增子命令</h2><p><code>jcmd</code>是用于向本地 jvm 进程发送诊断命令，这个命令是从 JDK7 提供的命令行工具，常用于快速定位线上环境故障。</p><p>在 JDK9 之后，提供了一些新的子命令，查看 JVM 中加载的所有类及其继承结构的列表。比如：</p><pre><code class="shell">$ jcmd 22922 VM.class_hierarchy -i -s java.net.Socket22922:java.lang.Object/null|--java.net.Socket/null|  implements java.io.Closeable/null (declared intf)|  implements java.lang.AutoCloseable/null (inherited intf)|  |--sun.nio.ch.SocketAdaptor/null|  |  implements java.lang.AutoCloseable/null (inherited intf)|  |  implements java.io.Closeable/null (inherited intf)</code></pre><p>第一个参数是进程 ID，都是针对这个进程执行诊断。我们还可以使用<code>set_vmflag</code>参数在线修改 JVM 参数，这种操作无需重启 JVM 进程。</p><p>有时候还需要查看当前进程的虚拟机参数选项和当前值：<code>jcmd 22922 VM.flags -all</code>。</p><h2 id="多分辨率图像-API"><a href="#多分辨率图像-API" class="headerlink" title="多分辨率图像 API"></a>多分辨率图像 API</h2><p>在 Java9 中定义了多分辨率图像 API，我们可以很容易的操作和展示不同分辨率的图像了。<code>java.awt.image.MultiResolutionImage</code>将一组具有不同分辨率的图像封装到单个对象中。<code>java.awt.Graphics</code>类根据当前显示 DPI 度量和任何应用的转换从多分辨率图像中获取变量。</p><p>以下是多分辨率图像的主要操作方法：</p><ul><li><code>Image getResolutionVariant(double destImageWidth, double destImageHeight)</code>：获取特定分辨率的图像变体-表示一张已知分辨率单位为 DPI 的特定尺寸大小的逻辑图像，并且这张图像是最佳的变体。</li><li><code>List&lt;Image&gt; getResolutionVariants()</code>：返回可读的分辨率的图像变体列表。</li></ul><p>我们来看下应用：</p><pre><code class="java">final List&lt;Image&gt; images = List.of(        ImageIO.read(new URL(&quot;https://static.howardliu.cn/about/kanshanshuo_2.png&quot;)),        ImageIO.read(new URL(&quot;https://static.howardliu.cn/about/hellokanshan.png&quot;)),        ImageIO.read(new URL(&quot;https://static.howardliu.cn/about/evil%20coder.jpg&quot;)));// 读取所有图片final MultiResolutionImage multiResolutionImage = new BaseMultiResolutionImage(images.toArray(new Image[0]));// 获取图片的所有分辨率final List&lt;Image&gt; variants = multiResolutionImage.getResolutionVariants();System.out.println(&quot;Total number of images: &quot; + variants.size());for (Image img : variants) {    System.out.println(img);}// 根据不同尺寸获取对应的图像分辨率Image variant1 = multiResolutionImage.getResolutionVariant(100, 100);System.out.printf(&quot;\nImage for destination[%d,%d]: [%d,%d]&quot;,        100, 100, variant1.getWidth(null), variant1.getHeight(null));Image variant2 = multiResolutionImage.getResolutionVariant(200, 200);System.out.printf(&quot;\nImage for destination[%d,%d]: [%d,%d]&quot;,        200, 200, variant2.getWidth(null), variant2.getHeight(null));Image variant3 = multiResolutionImage.getResolutionVariant(300, 300);System.out.printf(&quot;\nImage for destination[%d,%d]: [%d,%d]&quot;,        300, 300, variant3.getWidth(null), variant3.getHeight(null));Image variant4 = multiResolutionImage.getResolutionVariant(400, 400);System.out.printf(&quot;\nImage for destination[%d,%d]: [%d,%d]&quot;,        400, 400, variant4.getWidth(null), variant4.getHeight(null));Image variant5 = multiResolutionImage.getResolutionVariant(500, 500);System.out.printf(&quot;\nImage for destination[%d,%d]: [%d,%d]&quot;,        500, 500, variant5.getWidth(null), variant5.getHeight(null));</code></pre><h2 id="变量句柄（Variable-Handles）"><a href="#变量句柄（Variable-Handles）" class="headerlink" title="变量句柄（Variable Handles）"></a>变量句柄（Variable Handles）</h2><p>变量句柄（Variable Handles）的 API 主要是用来替代<code>java.util.concurrent.atomic</code>包和<code>sun.misc.Unsafe</code>类的部分功能，并且提供了一系列标准的内存屏障操作，用来更加细粒度的控制内存排序。一个变量句柄是一个变量（任何字段、数组元素、静态表里等）的类型引用，支持在不同访问模型下对这些类型变量的访问，包括简单的 read/write 访问，volatile 类型的 read/write 访问，和 CAS(compare-and-swap) 等。</p><blockquote><p>这部分内容涉及反射、内联、并发等内容，后续会单独介绍，文章最终会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 中，敬请关注。</p></blockquote><h2 id="发布-订阅框架"><a href="#发布-订阅框架" class="headerlink" title="发布-订阅框架"></a>发布-订阅框架</h2><p>在 Java9 中增加的<code>java.util.concurrent.Flow</code>支持响应式 API 的发布-订阅框架，他们提供在 JVM 上运行的许多异步系统之间的互操作性。我们可以借助<code>SubmissionPublisher</code>定制组件。</p><blockquote><p>关于响应式 API 的内容可以先查看 <a href="http://www.reactive-streams.org/的内容，后续单独介绍，文章最终会发布在" target="_blank" rel="noopener">http://www.reactive-streams.org/的内容，后续单独介绍，文章最终会发布在</a> <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 中，敬请关注。怎么感觉给自己刨了这么多坑，得抓紧时间填坑了。</p></blockquote><h2 id="统一-JVM-日志记录"><a href="#统一-JVM-日志记录" class="headerlink" title="统一 JVM 日志记录"></a>统一 JVM 日志记录</h2><p>在这个版本中，为 JVM 的所有组件引入了一个通用的日志系统。它提供了日志记录的基础。这个功能是通过<code>-Xlog</code>启动参数指定，并且定义很多标签用来定义不同类型日志，比如：gc（垃圾收集）、compiler（编译）、threads（线程）等等。比如，我们定义<code>debug</code>等级的 gc 日志，日志存储在<code>gc.log</code>文件中：</p><pre><code class="shell">java -Xlog:gc=debug:file=gc.log:none</code></pre><p>因为参数比较多，我们可以通过<code>java -Xlog:help</code>查看具体定义参数。而且日志配置可以通过<code>jcmd</code>命令动态修改，比如，我们将日志输出文件修改为<code>gc_other.log</code>：</p><pre><code class="shell">jcmd ${PID} VM.log output=gc_other.log what=gc</code></pre><h2 id="新的-API"><a href="#新的-API" class="headerlink" title="新的 API"></a>新的 API</h2><h3 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h3><p>在 Java9 中增加的<code>java.util.List.of()</code>、<code>java.util.Set.of()</code>、<code>java.util.Map.of()</code>系列方法，可以一行代码创建不可变集合。在 Java9 之前，我们想要初始化一个有指定值的集合，需要执行一堆<code>add</code>或<code>put</code>方法，或者依赖<code>guava</code>框架。</p><p>而且，这些集合对象是可变的，假设我们将值传入某个方法，我们就没有办法控制这些集合的值不会被修改。在 Java9 之后，我们可以借助<code>ImmutableCollections</code>中的定义实现初始化一个不可变的、有初始值的集合了。如果对这些对象进行修改（新增元素、删除元素），就会抛出<code>UnsupportedOperationException</code>异常。</p><p>这里不得不提的是，Java 开发者们也是考虑了性能，针对不同数量的集合，提供了不同的实现类：</p><ul><li><code>List12</code>、<code>Set12</code>、<code>Map1</code>专门用于少量（List 和 Set 是 2 个，对于 Map 是 1 对）元素数量的场景</li><li><code>ListN</code>、<code>SetN</code>、<code>MapN</code>用于数据量多（List 和 Set 是超过 2 个，对于 Map 是多余 1 对）的场景</li></ul><h3 id="改进的-Optional-类"><a href="#改进的-Optional-类" class="headerlink" title="改进的 Optional 类"></a>改进的 Optional 类</h3><p>Java9 中为<code>Optional</code>添加了三个实用方法：<code>stream</code>、<code>ifPresentOrElse</code>、<code>or</code>。</p><p><code>stream</code>是将<code>Optional</code>转为一个<code>Stream</code>，如果该<code>Optional</code>中包含值，那么就返回包含这个值的<code>Stream</code>，否则返回<code>Stream.empty()</code>。比如，我们有一个集合，需要过滤非空数据，在 Java9 之前，写法如下：</p><pre><code class="java">final List&lt;Optional&lt;String&gt;&gt; list = Arrays.asList(        Optional.empty(),        Optional.of(&quot;看山&quot;),        Optional.empty(),        Optional.of(&quot;看山的小屋&quot;));final List&lt;String&gt; filteredList = list.stream()        .flatMap(o -&gt; o.isPresent() ? Stream.of(o.get()) : Stream.empty())        .collect(Collectors.toList());</code></pre><p>在 Java9 之后，我们可以借助<code>stream</code>方法：</p><pre><code class="java">final List&lt;String&gt; filteredListJava9 = list.stream()        .flatMap(Optional::stream)        .collect(Collectors.toList());</code></pre><p><code>ifPresentOrElse</code>：如果一个<code>Optional</code>包含值，则对其包含的值调用函数<code>action</code>，即<code>action.accept(value)</code>，这与<code>ifPresent</code>方法一致；如果<code>Optional</code>不包含值，那会调用<code>emptyAction</code>，即<code>emptyAction.run()</code>。效果如下：</p><pre><code class="java">Optional&lt;Integer&gt; optional = Optional.of(1);optional.ifPresentOrElse(x -&gt; System.out.println(&quot;Value: &quot; + x), () -&gt; System.out.println(&quot;Not Present.&quot;));optional = Optional.empty();optional.ifPresentOrElse(x -&gt; System.out.println(&quot;Value: &quot; + x), () -&gt; System.out.println(&quot;Not Present.&quot;));// 输出结果为：// 作者：看山// 佚名</code></pre><p><code>or</code>：如果值存在，返回<code>Optional</code>指定的值，否则返回一个预设的值。效果如下：</p><pre><code class="java">Optional&lt;String&gt; optional1 = Optional.of(&quot;看山&quot;);Supplier&lt;Optional&lt;String&gt;&gt; supplierString = () -&gt; Optional.of(&quot;佚名&quot;);optional1 = optional1.or(supplierString);optional1.ifPresent(x -&gt; System.out.println(&quot;作者：&quot; + x));optional1 = Optional.empty();optional1 = optional1.or(supplierString);optional1.ifPresent(x -&gt; System.out.println(&quot;作者：&quot; + x));// 输出结果为：// 作者：看山// 作者：佚名</code></pre><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java9 新增的特性，完整的特性清单可以从<a href="https://openjdk.java.net/projects/jdk9/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk9/</a>查看。文中也给自己刨了几个坑，碍于篇幅，没有办法展开，所有这些需要展开的功能细述，都会在 Java8 到 Java17 的新特性系列完成后补充，博文会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-9-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java9 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java9 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Java9 的新特性。Java9 发布于 2017 年 9 月 22 日，带来了很多新特性，其中包括Jigsaw模块化、新的HTTP客户端（Java9中处于孵化中，到Java11可以正式使用）、进程API、JShell、JCMD新增子命令、多分辨率图像API、变量句柄、发布-订阅框架、统一JVM日志等等，还有很多小功能。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java9" scheme="https://www.howardliu.cn/tags/Java9/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构的陷阱：从单体到分布式单体</title>
    <link href="https://www.howardliu.cn/avoid-the-distributed-monolith/"/>
    <id>https://www.howardliu.cn/avoid-the-distributed-monolith/</id>
    <published>2021-12-12T14:32:20.000Z</published>
    <updated>2021-12-12T14:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/squirrel-6846096_1920.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="微服务架构的陷阱：从单体到分布式单体"></p><p>你好，我是看山。</p><p>前面咱们聊了架构的演进过程，提到单体架构、SOA 架构、微服务架构、无服务架构。整个过程如下图：</p><p><img src="https://static.howardliu.cn/microservice/architect-gogogo.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="架构演进过程：单体架构、早期服务化、SOA 架构、微服务架构"></p><p>目前无服务架构还未成熟，只能满足一些简单场景。所以大家在设计软件架构时，首选还是微服务架构。然后我们又聊了聊如何把单体架构改造为微服务架构，推荐采用绞杀模式，一步一步的实现系统微服务化。</p><p>在这个过程中，我们会碰到微服务架构的一个大坑：分布式错觉，即将分布式当成了微服务的全部（充要条件）。</p><a id="more"></a><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>出现分布式单体的主要原因在于，只是用进程间的远程调用替换进程内的方法调用。</p><p><img src="https://static.howardliu.cn/microservice/monolitic-microservice-call.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="模块 A 与模块 B 之间的通信方式"></p><p>从上图可以看出，单体架构在模块 A 与模块 B 之间的请求是通过进程内通信（通常是方法调用）实现的；在微服务架构中，两者之间是通过 REST 或 RPC 调用。抛开进程和消息通知机制的差异，两种架构中模块 A 与模块 B 之间的通信形式完全一致：</p><p><img src="https://static.howardliu.cn/microservice/monolitic-microservice-call2.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="单体/微服务架构中模块间通信方式"></p><p>在这种情况下，模块 A 与模块 B 耦合在一起，任何一方变更请求契约（方法签名或接口参数），另外一个都必须同步修改。更糟糕的是，由于微服务架构服务之间是通过网络通信，由于其不可靠性和不稳定性，大大增加了出错的概率，使模块之间的调用关系更加脆弱。</p><p>模块 A 与模块 B 之间的网络请求是同步调用，请求过程中会占用一个网络连接和至少一个线程，如果模块 A 与模块 B 所在的服务的承压能力不同，很有可能模块 B 所在服务被打满，后续模块 A 的请求会阻塞等待，直到请求超时。</p><p>那又是什么原因让大家没有意识到这种方式不妥呢？原因有两个：</p><ol><li>想要在微服务架构中实现单体架构中模块间的关系；</li><li>想要在分布式应用中实现数据的强一致性。</li></ol><p>针对于微服务架构中的数据一致性问题，可以参考 <a href="https://mp.weixin.qq.com/s?__biz=MzI4OTU5NTA1Ng==&mid=2247484752&idx=1&sn=38e19e269e6609ab14b69d68d5e77529" target="_blank" rel="noopener">关于微服务系统中数据一致性的总结</a>。</p><p>下面我们重点说说如果解决第一个问题。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>对于模块之间的关系，主要在于通信模式，对于查询请求，由于数据依赖，模块之间的耦合是天然的，我们这里要解耦的是数据变更（增、删、改）时的模块调用。</p><p>类比一下现实，我们如果想要通知某些人一个消息，会怎么处理？一般来说，有两种方式：</p><ol><li>点对点主动通知，直接找到这个人，给这个人打电话，不通继续打，保证对方能够收到消息；</li><li>点对面广播通知，比如，群里发给公告、公司的告示栏等，这种方式需要消息接受者主动查看公告信息。</li></ol><p>这两种方式对应了我们系统设计中消息传递的两个模式：指令（Command）、事件（Event）。</p><h3 id="指令（Command）和事件（Event）"><a href="#指令（Command）和事件（Event）" class="headerlink" title="指令（Command）和事件（Event）"></a>指令（Command）和事件（Event）</h3><p><img src="https://static.howardliu.cn/microservice/command_event.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="command 与 event，指令与事件"></p><p>指令（Command）是表示从发起者（source）向执行者（destination）传递（send）一个必须执行某个动作（action）的请求（request）。这个模式有如下特点：</p><ul><li>明确的知道发起者和执行者，发起者依赖执行者；</li><li>请求发送方式一般是点对点同步请求，一般是 RPC 请求；</li><li>动作已发生或即将发生，有可能由于执行者拒绝执行而取消；</li><li>执行者有可能拒绝执行；</li><li>执行者会很明确的告知发起者指令执行情况：拒绝、成功、失败等。</li><li>为了保证指令的有效触达，发起者在网络超时时会重复调用执行者，所以执行者需要实现请求幂等；</li><li>执行者可能会成为下一个指令的发起者。</li></ul><p>事件（event）是表示由生产者（producer）发布（public）一个已经发生的事情，表示行为（action）已经发生，某些状态（status）发生了改变，消费者（consumer）订阅这些事件，然后做出响应。这个模式有如下特点：</p><ul><li>事件有明确的生产者，但是消费者不明确，甚至可能不存在；</li><li>一般借助消息中间件实现事件发送、存储、传递等；</li><li>行为已经发生，不可改变，不可逆，事件是对已经发生事情的客观描述；</li><li>消费者根据消息选择处理方式：执行、抛弃等；</li><li>消费者处理完成后，不需要回复生产者；</li><li>一般消息中间件采用“至少一次”通知机制，所以消费者需要实现消息处理的幂等；</li><li>消费者可能会成为下一个事件的生产者。</li></ul><p><img src="https://static.howardliu.cn/microservice/command-and-event.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="指令与事件之间的区别"></p><p>由于请求模式的不同，在依赖关系上就会发生改变：</p><p>在指令模式中，模块 A 调用模块 B，属于直接调用，模块 A 需要依赖模块 B；在事件模式中，模块 A 把事件发送给消息中间件，其他需要订阅事件的服务，直接从消息中间件获取，这种会产生依赖倒置，模块 B 依赖模块 A。这是解耦模块 A 与模块 B 很好的方式。</p><h3 id="重新定义微服务"><a href="#重新定义微服务" class="headerlink" title="重新定义微服务"></a>重新定义微服务</h3><p>我们再回过头来看看我们的问题：</p><p><img src="https://static.howardliu.cn/microservice/monolitic-microservice-call2.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="单体/微服务架构中模块间通信方式"></p><p>此时我们会比较清晰，由于全系统中使用了指令模式，上次调用者依赖下层，由于是同步请求，依赖会发生传递，这种依赖传递，将整个系统耦合在一起，一处修改，处处变动，也就是我们在抨击单体架构时常说的牵一发而动全身。</p><p>此时，我们就可以借助事件模式，将依赖链条打断。但是需要注意，不要矫枉过正的全部改为事件模式，那将会是另一个火坑。一般我们会将系统改造成下面的样子：</p><p><img src="https://static.howardliu.cn/microservice/refactor-monolitic.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="重新定义微服务"></p><p>根据业务具体情况，我们可以归纳一下改造结果：</p><ol><li>服务 A 接到的请求可能是事件或指令；</li><li>服务 A 会向服务 B 发送指令，也会向消息中间件发送事件；</li><li>服务 B 接到指令后开始执行，执行完毕后，可能会向消息中间件发送事件；</li><li>服务 C 定于事件，从消息中间件接到消息后处理，它可能发送事件或指令。</li></ol><p>需要注意的是，每个服务内部还有有一些操作。抽象一下，整个系统中的指令、事件、操作如下图：</p><p><img src="https://static.howardliu.cn/microservice/command-event-definition.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="指令和事件的定义"></p><ul><li>输入：以一个指令或事件作为输入，开始整个业务执行；</li><li>服务内部操作：服务内部会有执行逻辑，比如操作数据库、访问缓存服务等。可选，0-N 个；</li><li>指令调用：同步调用依赖服务，发送指令，获得结果。可选，0-N 个；</li><li>发布事件：以消息形式发布事件，一般发布到消息中间件，其他发布订阅消息中间件，执行事件需要的行为。可选，事件一般是 0-1 个。</li></ul><p>架构设计的过程不是非此即彼，全部指令会造成耦合，全部事件会致使开发难度提升以及边界不清。我们需要理性的看待两种模式，做到不偏不倚。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文从分布式单体陷阱展开，讲述了分布式错觉带来的问题，然后通过事件、指令两种模式相结合的方式解决问题。微服务是目前比较完善的架构风格，从单体到微服务架构，是要实现架构的升级，所以调用模式不会一成不变。这个陷阱，也是我们在做新系统时需要避免的。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/09ILTzijUr3knHBj13t_kQ" target="_blank" rel="noopener">什么是微服务？</a></li><li><a href="https://mp.weixin.qq.com/s/n1eKTlLP_BbyBkKG4OyLSw" target="_blank" rel="noopener">微服务编程范式</a></li><li><a href="https://mp.weixin.qq.com/s/sRkYdrAwvn8UrGSraAURpA" target="_blank" rel="noopener">微服务的基建工作</a></li><li><a href="https://mp.weixin.qq.com/s/sRX04UhPiFWSDOazTSXuXw" target="_blank" rel="noopener">微服务中服务注册和发现的可行性方案</a></li><li><a href="https://mp.weixin.qq.com/s/NcftJ1jNAd-DHpzBXKk8RA" target="_blank" rel="noopener">从单体架构到微服务架构</a></li><li><a href="https://mp.weixin.qq.com/s/gSWFUsFnaqRKyGXVgdUqew" target="_blank" rel="noopener">除了微服务，我们还有其他选择吗？</a></li><li><a href="https://mp.weixin.qq.com/s/M0sla4LVvp2lEiFpzwyVrA" target="_blank" rel="noopener">如何在微服务团队中高效使用 Git 管理代码？</a></li><li><a href="https://mp.weixin.qq.com/s/apHFXB2cUqDALpJJebNp9A" target="_blank" rel="noopener">关于微服务系统中数据一致性的总结</a></li><li><a href="https://mp.weixin.qq.com/s/AE0n4d_zRZOEeYEQt-rSKw" target="_blank" rel="noopener">实现 DevOps 的三步工作法</a></li><li><a href="https://mp.weixin.qq.com/s/mMjbafRIhia3u9DmXPSfPQ" target="_blank" rel="noopener">系统设计系列之如何设计一个短链服务</a></li><li><a href="https://mp.weixin.qq.com/s/mtt_wsUChGIwnR-Nz5BE4g" target="_blank" rel="noopener">系统设计系列之任务队列</a></li><li><a href="https://mp.weixin.qq.com/s/_PI5jRP99ktPs3lxCbBLSg" target="_blank" rel="noopener">软件架构-缓存技术</a></li><li><a href="https://mp.weixin.qq.com/s/668L2NK7LWo3c8U8ZI_1ng" target="_blank" rel="noopener">软件架构-事件驱动架构</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/avoid-the-distributed-monolith/">微服务架构的陷阱：从单体到分布式单体</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/121944074" target="_blank" rel="noopener">微服务架构的陷阱：从单体到分布式单体</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      目前无服务架构还未成熟，只能满足一些简单场景。所以大家在设计软件架构时，首选还是微服务架构。然后我们又聊了聊如何把单体架构改造为微服务架构，推荐采用绞杀模式，一步一步的实现系统微服务化。在这个过程中，我们会碰到微服务架构的一个大坑：分布式错觉，即将分布式当成了微服务的全部（充要条件）。
    
    </summary>
    
    
      <category term="microservice" scheme="https://www.howardliu.cn/categories/microservice/"/>
    
    
      <category term="微服务" scheme="https://www.howardliu.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="架构" scheme="https://www.howardliu.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>如何实现单体架构到微服务架构的蜕变？</title>
    <link href="https://www.howardliu.cn/from-monolith-to-microservices-2/"/>
    <id>https://www.howardliu.cn/from-monolith-to-microservices-2/</id>
    <published>2021-12-05T14:40:49.000Z</published>
    <updated>2021-12-05T14:40:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/rose-leaf-6831355_1920.jpg" alt="如何实现单体架构到微服务架构的蜕变？" title="如何实现单体架构到微服务架构的蜕变？"></p><p>你好，我是看山。</p><p>前文我们聊了介绍了单体架构、SOA 架构、微服务架构、无服务架构。如果原来是单体架构，想要切换到微服务架构，该怎么解决呢？本文来聊聊这个话题，解决“什么时候（WHEN）、怎样做（HOW）”。</p><a id="more"></a><h2 id="什么时候"><a href="#什么时候" class="headerlink" title="什么时候"></a>什么时候</h2><p>微服务架构是一种架构风格，专注于软件研发效能，主要包括单位时间内实现更多功能，或者软件从想法到上线的整个持续交付的过程。在当前的互联网环境中，业务变化迅速，使用微服务架构，可以让团队迅速反应，快速实施，在方案没有过期之前已经上线运行，经受市场考察和考验。</p><p>目前国内大多数公司正在运行的系统都是单体架构系统，不可否认，这些系统在公司发展过程中，发挥了不可替代的作用，保障了公司正常运行，创造了很多价值。但是，随着系统的日渐膨胀，集成的功能越来越多，开发效率变得越来越低，一个功能从想法到实现，需要花费越来越长的时间。更严重的是，由于代码模块纠结在一起，很多已经老化的架构或者废弃的功能，已经成为新功能的阻碍。</p><p><img src="https://static.howardliu.cn/microservice/737565-20181016193114922-488026211.png" alt="单体架构与微服务架构的成本" title="单体架构与微服务架构的成本"></p><p>上图中，X 轴是业务复杂度，Y 轴是单位效益。绿色线条代表单体架构，蓝色线条代表微服务架构。</p><p>可以看到，在业务发展初期，系统复杂度不高，业务不够成熟，我们主要经历在于业务试错。如果采用单体架构，可以将所有的功能、模块放在一个进程；如果此时采用微服务架构，我们就需要考虑进程间通信、不可靠网络故障等，还需要实现微服务的基础组件。这个时候，单体架构的单位效益是高于微服务架构的。</p><p>随着业务发展，系统承载的功能越来越多，单体架构的劣势凸显，比如：</p><ol><li>硬件能力难以跟上急速发展的业务；</li><li>系统隔离性差，所有功能都在一个进程中，一个功能的异常可能影响其他功能；</li><li>代码复杂度提升，团队合作越来越难，代码冲突的可能性越来越高；</li><li>庞大的代码量，在日常开发、测试时，IDE 难以支持；</li><li>系统构建、部署时间延长；</li><li>技术绑定，没有办法根据系统功能需要灵活使用不同技术；</li><li>……</li></ol><p>总而言之，单体架构随着功能增多，不可避免的是研发效能的降低：研发周期变长、研发资源占用增多。从而引发的情况是：新员工培训时间增多、员工加班时间变长、员工要求涨薪或者跳槽。</p><p>当达到图中的交叉点时，说明单体架构已经不能够满足企业发展需要，这个时候，需要升级架构来提升研发效能，比如微服务架构。</p><p>有人会问，这个时间点不太好把握。我们只需要考虑三个问题即可：</p><ol><li>产品是否已经经过市场考验？</li><li>是否需要超过一个团队来保证产品发布？</li><li>系统是否对可靠性、可伸缩性有较高要求？</li></ol><p>如果都是肯定回答，那就该着手准备将单体架构切换为微服务架构了。</p><h2 id="怎样做"><a href="#怎样做" class="headerlink" title="怎样做"></a>怎样做</h2><p>从单体架构到微服务架构，从一个大一统的系统，拆分成一个一个单独的小服务，我们需要投入精力，做基础的准备：</p><ol><li>先要了解什么是服务、该怎么拆分；</li><li>然后需要搭建基础设施，为拆分出来的服务做好后勤保障；</li><li>最后才是一步一步完成架构切换。</li></ol><h3 id="认识服务"><a href="#认识服务" class="headerlink" title="认识服务"></a>认识服务</h3><p>首先，什么是微服务架构呢？通俗的定义是：“一组围绕业务领域建模的、小而自治的、彼此协同工作的服务。”</p><p>微服务架构中的服务，是根据业务能力抽取的业务模块，独立开发和部署，但是需要彼此配合完成整个业务功能。服务不是单纯的数据存储组件，也不是单纯的逻辑函单元。只有同时包括数据+逻辑，才是真正意义上的服务。</p><p>服务拆解过程中，DDD（领域驱动设计）可以作为微服务架构的指导方针。因为微服务是围绕业务功能定义服务，根据服务定义团队，这与 DDD 将业务域拆解为业务子域、定义限定上下文的方法论如出一辙，于是 DDD 作为微服务的指导方针，快速定义各个服务组件，完成从单体架构到微服务架构的迁移。</p><p><img src="https://static.howardliu.cn/microservice/121148382613129.jpg" alt="领域驱动设计" title="领域驱动设计"></p><p>Alberto Brandolini 提出识别服务上下文的方式叫做“Event Storming”。第一步是识别业务域中发生的事件，也就是说，我们的关注点是行为，不是数据结构。这样做的好处是，系统中不同服务之间是松散耦合关系，而且单个服务能够自治。</p><p>定义好了服务边界，还需要定义事务边界。过去，我们的服务在一个进程中，后面挂着一个数据库，事务可以选择强一致性事务，也就是 ACID。当服务增多，彼此配合，这个时候可以使用最终一致性事务，也就是 BASE。不同于 ACID，BASE 更加灵活，只要数据在最终能够保持一致就可以了。这个最终的时间范围，根据不同的业务场景不同，可能是分钟、小时、天，甚至是周或者月。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>微服务架构愿景美好，属于重型武器，优点众多，缺点也很明显。服务增多，运维难度增大，错误调试难度增大。所以需要自动化构建、配置、测试和部署，需要日志收集、指标监控、调用链监控等工具，也就是需要 DevOps 实践。<a href="https://www.howardliu.cn/the-three-ways-principles-underpinning-devops/">实现 DevOps 的三步工作法</a> 中说明了实现 DevOps 文化的三个步骤。</p><p>除了上面提到的基础，还需要在早期确定服务之间如何集成和彼此调用方式，还需要确定数据体系，包括事务一致性和数据可靠性方法。随着服务增多，还需要配置管理、服务发现等众多组件。具体需要的基础组件可以参考 <a href="https://www.howardliu.cn/the-base-of-microservice/">微服务的基建工作</a>。</p><p><img src="https://static.howardliu.cn/microservice/microservice-architecture.png" alt="微服务架构中的基础组件" title="微服务架构中的基础组件"></p><p>这些基础的服务和设计，最好在早期定义，否则，后期需要花费更多的资源才能够完善架构。如果前期缺失，后期也没有补足，造成的后果就是微服务架构迁移失败，最后的系统也只是披着微服务外衣的单体架构。</p><h3 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h3><p>当我们确定开始使用微服务架构时，接下来的问题就是应该怎么做？是逐步进化更新系统、还是破釜沉舟重构整个系统。</p><p>第二种方式很诱人，比较符合大多数技术人的思维，系统不行，推倒重来，名为重构。但是在大多数情况下，这种方式不能被允许，因为市场变化迅速、竞争激烈，大多数公司不会停止业务，去等待重构一个能够运行、只是有些缺点的系统。所以，逐步替换更新系统才是王道，大多数公司也能接受。这种方式又被称为绞杀模式。</p><p>该如何逐步过渡到微服务架构？下面一步步进行展示：</p><p><img src="https://static.howardliu.cn/microservice/from_monolith_to_microservice_0.jpg" alt="实现单体架构到微服务架构：单体架构" title="实现单体架构到微服务架构：单体架构"></p><p>第一步，将视图层与服务层部分逻辑进行分离。业务逻辑委托给服务层，支持页面展示的查询定向到数据库。这个阶段，我们不修改数据库本身。</p><p><img src="https://static.howardliu.cn/microservice/from_monolith_to_microservice_1.jpg" alt="实现单体架构到微服务架构：部分拆分视图和业务逻辑" title="实现单体架构到微服务架构：部分拆分视图和业务逻辑"></p><p>第二步，用户视图层与数据库完全分离，依赖于服务层操作数据库。</p><p><img src="https://static.howardliu.cn/microservice/from_monolith_to_microservice_2.jpg" alt="实现单体架构到微服务架构：完全拆分视图和业务逻辑" title="实现单体架构到微服务架构：完全拆分视图和业务逻辑"></p><p>第三步，将用户视图层与服务层拆分为不同服务，并在服务层创建一个 API 层，用于视图层与服务层之间通信。</p><p><img src="https://static.howardliu.cn/microservice/from_monolith_to_microservice_3.jpg" alt="实现单体架构到微服务架构：物理拆分视图和业务逻辑" title="实现单体架构到微服务架构：物理拆分视图和业务逻辑"></p><p>第四步，拆分数据库，将不同业务数据拆分到不同的数据库中，同时对应业务服务层拆分到不同的服务。用户视图层通过 API 网关与不同业务服务层的 API 组件通信。这个时候需要注意，如果团队没有微服务开发经验，可以在这一步基础使用绞杀方式，先抽取简单业务域服务，因为业务简单，实现简单，可以练手，积累经验。</p><p><img src="https://static.howardliu.cn/microservice/from_monolith_to_microservice_4.jpg" alt="实现单体架构到微服务架构：业务服务层拆分、垂直拆分数据库" title="实现单体架构到微服务架构：业务服务层拆分、垂直拆分数据库"></p><p>最后一步，拆分用户视图层。</p><p><img src="https://static.howardliu.cn/microservice/from_monolith_to_microservice_5.jpg" alt="实现单体架构到微服务架构：拆分用户视图层" title="实现单体架构到微服务架构：拆分用户视图层"></p><p>绞杀模式的优势就在于，我们可以随着业务变化随时调整方案，不会造成整个业务进化过程的停摆。</p><h2 id="成功标准"><a href="#成功标准" class="headerlink" title="成功标准"></a>成功标准</h2><p><img src="https://static.howardliu.cn/Illustration/measuring-success-with-guavabox.jpg" alt="If you cannot measure it, you cannot manage it!" title="If you cannot measure it, you cannot manage it!"></p><p><strong>If you cannot measure it, you cannot manage it!</strong></p><p>引入微服务的目的首先是改善开发流程，我们可以通过简单的指标来衡量：</p><ul><li>开发周期：从概念到上线持续的时间</li><li>开发效能：单位时间内团队或个人完成的功能或用户故事</li><li>系统可伸缩性：系统的水平、垂直扩展能力</li><li>平均维修时间：查找和排除故障所需时间</li></ul><p>通过对比老架构和新架构的这些特性值，可以评估升级过程取得的效果。我们要时刻关注这些指标，只有一个个小阶段的胜利，才能组成最终完整的胜利。如果再某个阶段失败了，可能达不到我们最终的目的，或者埋下技术债务，后期不得不花更大的代价补偿。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>想要说明微服务架构的好处，可以来一个比喻。我们建了一个空间站，为此，我们需要将人、货物和设备运输到空间站中，这个时候，运载火箭是比较好的选择，尽管运载火箭造价也比较高，但是几个月发射一次，也能够满足需求。随着空间站的扩大，火箭发射的间隔变短，运输成本高的离谱，而且越来越没法满足空间站运转需求。这个时候，可以尝试另外一种方式，比如，太空电梯。当然太空电梯的造价成本高于一次飞行的费用，但是只要建成，以后的成本就降低了很多。</p><p>这个比喻也是说明了微服务带来的美好期望，同时也说明一个问题，实施微服务架构会带来巨大的投资。所以，我们在建造太空电梯之前需要想好，我们真的需要这种投入，否则只能是一种浪费。</p><p>作为攻城狮，我们为能够解决或改善周围世界而自豪，着迷于提供解决方案。同时，我们也要意识到，我们付出的每一份努力，都要有回报。如果不能带来任何回报的重构升级，都是浪费时间。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/09ILTzijUr3knHBj13t_kQ" target="_blank" rel="noopener">什么是微服务？</a></li><li><a href="https://mp.weixin.qq.com/s/n1eKTlLP_BbyBkKG4OyLSw" target="_blank" rel="noopener">微服务编程范式</a></li><li><a href="https://mp.weixin.qq.com/s/sRkYdrAwvn8UrGSraAURpA" target="_blank" rel="noopener">微服务的基建工作</a></li><li><a href="https://mp.weixin.qq.com/s/sRX04UhPiFWSDOazTSXuXw" target="_blank" rel="noopener">微服务中服务注册和发现的可行性方案</a></li><li><a href="https://mp.weixin.qq.com/s/NcftJ1jNAd-DHpzBXKk8RA" target="_blank" rel="noopener">从单体架构到微服务架构</a></li><li><a href="https://mp.weixin.qq.com/s/M0sla4LVvp2lEiFpzwyVrA" target="_blank" rel="noopener">如何在微服务团队中高效使用 Git 管理代码？</a></li><li><a href="https://mp.weixin.qq.com/s/apHFXB2cUqDALpJJebNp9A" target="_blank" rel="noopener">关于微服务系统中数据一致性的总结</a></li><li><a href="https://mp.weixin.qq.com/s/AE0n4d_zRZOEeYEQt-rSKw" target="_blank" rel="noopener">实现DevOps的三步工作法</a></li><li><a href="https://mp.weixin.qq.com/s/mMjbafRIhia3u9DmXPSfPQ" target="_blank" rel="noopener">系统设计系列之如何设计一个短链服务</a></li><li><a href="https://mp.weixin.qq.com/s/mtt_wsUChGIwnR-Nz5BE4g" target="_blank" rel="noopener">系统设计系列之任务队列</a></li><li><a href="https://mp.weixin.qq.com/s/_PI5jRP99ktPs3lxCbBLSg" target="_blank" rel="noopener">软件架构-缓存技术</a></li><li><a href="https://mp.weixin.qq.com/s/668L2NK7LWo3c8U8ZI_1ng" target="_blank" rel="noopener">软件架构-事件驱动架构</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/from-monolith-to-microservices-2/">如何实现单体架构到微服务架构的蜕变？</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">如何实现单体架构到微服务架构的蜕变？</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      如果原来是单体架构，想要切换到微服务架构，该怎么解决呢？本文来聊聊这个话题，解决“什么时候（WHEN）、怎样做（HOW）”。
    
    </summary>
    
    
      <category term="microservice" scheme="https://www.howardliu.cn/categories/microservice/"/>
    
    
      <category term="微服务" scheme="https://www.howardliu.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="单体架构" scheme="https://www.howardliu.cn/tags/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    
      <category term="重构" scheme="https://www.howardliu.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>除了微服务，我们还有其他选择吗？</title>
    <link href="https://www.howardliu.cn/do-we-have-any-other-options-besides-microservices/"/>
    <id>https://www.howardliu.cn/do-we-have-any-other-options-besides-microservices/</id>
    <published>2021-12-05T14:25:56.000Z</published>
    <updated>2021-12-05T14:25:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/bird-6720306_1920.jpg" alt="除了微服务，我们还有其他选择吗？"></p><p>你好，我是看山。</p><p>前面我们聊了微服务的话题，现在微服务已经是业内通识。但凡系统开发、系统设计，必然采用微服务架构，或者宣称是微服务架构。</p><p>但大家有没有想过，微服务架构不是一开始就有的。如果追溯历史，微服务最早在 2005 的云计算博览会，由 Peter Rodgers 博士提出（那时候称为微 Web 服务（Micro-Web-Service））。到了 2014 年，Martin Fowler 与 James Lewis 共同提出微服务（Micron-Service）的概念，算是对概念归纳总结，天下一统。这一年也被称为微服务元年。</p><p><img src="https://static.howardliu.cn/Illustration/1565046133.jpg" alt="看山的小屋"></p><p>那就要问了，在 2014 年之前呢？大家用啥架构？再往前呢？上次互联网大潮的时候，大家又是用啥？我们今天来聊聊这段历史，可能你会对现在习以为常的架构，产生一些新的看法。在架构上，可以有更多的选择。</p><a id="more"></a><h2 id="人人喊打的单体架构"><a href="#人人喊打的单体架构" class="headerlink" title="人人喊打的单体架构"></a>人人喊打的单体架构</h2><blockquote><p>单体架构，人人都说这种架构不好，为什么不好呢？真的不好吗？可能真相并不是你认为的那样简单。</p></blockquote><p>当前来说，如果有人说某个系统是单体架构，一定会有人投来怀疑的眼神，有的会带着些许不可思议，甚至带有一丝鄙夷。但是不得不说，单体架构（又称巨石系统，Monolithic）是整个软件发展过程中，出现时间最早、应用范围最广的一种架构风格。从另一个方面，原来本没有单体架构这个称呼，只是后来有了微服务架构，为了区分，才把所有“自包含”的系统称为单体架构。</p><p><img src="https://static.howardliu.cn/microservice/699473-20171125103303375-138169041.png" alt="人人喊打的单体架构构"></p><p>上面这个图就是单体架构，所谓“自包含”，简单说就是自给自足，所有业务功能靠自己，不依赖其他业务系统。其优点有下面这些：</p><ul><li>不涉及进程间通信，效率可控；</li><li>不依赖网络通讯，可以规避不可靠的网络通讯带来难以预知的故障；</li><li>开发生态良好，目前的 IDE 对单体架构的支持更好；</li><li>编码重构容易，单体架构完全的自控制，只要修改自己即可，不需要上下游支持；</li><li>端到端测试简单，因为没有上下游依赖，测试起来更加方便，部署一套环境，就可以实现当前功能的完全测试；</li><li>部署简单，只要打包成 EAR、WAR、JAR 等需要的运行包，扔进服务器就能跑；</li><li>运维简单，一个进程运行的服务，无论是日志还是运行态，都能够很简单的监控；</li><li>横向扩展容易，前面一个负载均衡器做代理，后面可以无限扩展。</li></ul><p>从这个角度，只要单机优势明显，就不该把单体架构视为地狱。</p><p>所谓“成也萧何败也萧何”，统一“集中”成就了单体架构，难以“隔离”也成为了单体架构最大的弊端。这里将隔离简单分为开发期隔离和运行期隔离。</p><p>单体架构省去了进程间通信、性能损失这些麻烦事，但因为在一个进程中执行，如果内部的某处逻辑异常，可能会造成整个系统的崩溃。最常见的内存溢出，可能仅仅是一个不相干的功能查了全表，整个系统都都会宕掉。</p><p><img src="https://static.howardliu.cn/Illustration/300.jpeg" alt="系统崩溃"></p><p>运行期没有办法隔离，升级的时候也没有办法隔离。想要对某些模块功能升级，只能重启整个服务。还要担心会不会有没有覆盖测试的点，提前做好预案，挂好停机维护页。</p><p>因此，一个成功的单体架构系统隐含了一个要求，需要一个对系统完全了解的大脑（一个人或一组人），大脑可以总控系统的开发、升级、运行，把控这个系统的每个细节，实现系统中的各个组件、模块有很高的品质，从而保障系统可在其生命周期内可以稳定的运行。</p><p>比如，SAP 和 Hyperion，妥妥的单体架构，作为国际化的软件公司，为什么不对它们升级改造？是能力不行，还是技术不行？是没有必要。所以，单体架构也不是一无是处，一切都要在合适的前提下评价。</p><h2 id="开疆拓土的-SOA-架构"><a href="#开疆拓土的-SOA-架构" class="headerlink" title="开疆拓土的 SOA 架构"></a>开疆拓土的 SOA 架构</h2><blockquote><p>都说 SOA 架构太重，但他是开创服务化江山的鼻祖。</p></blockquote><p><img src="https://static.howardliu.cn/microservice/Enterprise-service-bus-architecture.png" alt="开疆拓土的 SOA 架构"></p><p>单体架构对团队的要求较高，随着团队的扩大，必然会有短板或薄弱的环节，或者是组织、或者是个人，这样就会给系统代理风险。于是，很多前辈就开始思考，一个庞然大物难以维护，那就分为治之，拆分成多个规模小一些的单体架构，彼此之间通过某种方式交互。这种方案被称为面向服务架构（SOA，Service-Oriented Architecture）。</p><p>SOA 在 1994 年就被提出，这种架构风格是自然演化来的。只不过当时没有足够的条件支持，一直只能处于理论阶段。后来随着 webservice 等技术的提出，才有了技术支撑。到 2006 年，OSOA 成立，共同制定 SOA 架构相关行业标准，这套架构有了理论、技术、规范等一系列约定，从而真正落地。</p><p>SOA 架构开疆拓土，开创了很多目前也在使用的概念，比如服务注册/发现、服务治理、系统隔离、服务编排等。是不是觉得这些概念很熟悉，是的，在微服务架构中，同样有这些概念的身影。SOA 架构有自己的一套风格，使用下面一些组件实现普适的方法论：</p><ol><li>采用 SOAP 作为远程调用的协议；</li><li>利用 ESB（Enterprise Service Bus，企业服务总线）实现各个子系统之间的通信交互；</li><li>使用 BPM（Business Process Management，业务流程管理系统）实现业务流程编排；</li><li>使用 SDO（Service Data Object，服务数据对象）来访问和表示数据；</li><li>使用 SCA（Service Component Architecture，服务组件架构）来定义服务封装的形式和服务运行的容器；</li><li>……</li></ol><p>SOA 架构是各大软件服务商共同愿景下的产物，总结出了一套自上而下的软件研发方法论，期望能够解决软件开发过程中的所有问题。有些类似于八股文，规定好起承转合，只要按照要求来，系统就不会出现太多问题。</p><p>愿景虽好，但是却忽略了一点，一套大而全的架构体系，不是所有公司都能够支撑起来的。有时候，大而全不如小而美。但是，我们不能否认 SOA 架构对于面向服务理论的贡献，在某些场景下的企业内部，SOA 是能够快速打破信息孤岛的重要手段。</p><h2 id="另立门户的微服务架构"><a href="#另立门户的微服务架构" class="headerlink" title="另立门户的微服务架构"></a>另立门户的微服务架构</h2><blockquote><p>本来是作为 SOA 的一种简化方案，结果直接发动宣武门之变，逼着 SAO 禅让。</p></blockquote><p><img src="https://static.howardliu.cn/microservice/microservice-architecture.png" alt="另立门户的微服务架构"></p><p>如开篇所说，微服务架构是在 2005 年提出，在 2014 年崛起。经历了将近 10 年的时间，之所以没有得到太多重视，是因为 2014 年之前，微服务只是在作为 SOA 架构的简化版出现。直到 2014 年才作为独立的架构风格，与 SOA 架构划清界限。</p><p>Martin Fowler 与 James Lewis 在合写的 <a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">《Microservices》</a> 对微服务下了定义：“微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。”</p><p>文中还提出了微服务架构的 9 个核心特征：</p><ol><li>通过服务来实现独立自治的组件（Componentization via Services）</li><li>围绕业务能力构建（Organized around Business Capability）</li><li>产品化思维（Products not Projects）</li><li>强终端弱管道（Smart Endpoint and Dumb Pipe）</li><li>分散治理（Decentralized Governance）</li><li>数据去中心化（Decentralized Data Management）</li><li>基础设施自动化（Infrastructure Automation）</li><li>容错性设计（Design for Failure）</li><li>演进式设计（Evolutionary Design）</li></ol><p>由于微服务架构是从 SOA 架构中演化而来，所以很多的表现形式都是一致的。从《Microservices》对微服务架构全面细致阐述之后，也算是将微服务架构与 SOA 架构彻底划清界限。</p><p>在笔者看来，微服务架构与 SOA 架构最大的不同在于对于实现的约束，SOA 架构有一套完整的规约，微服务架构只有建议，追求的是根据实际情况自由变化，简单的理解就是“想怎么玩就怎么玩”。比如通信协议，SOA 架构明确要求使用 SOAP 通信协议；微服务架构只要求使用轻量级的 RPC 协议，这个选择就比较宽泛了，常见的就有 HTTP（一般采用 Restful 风格）、gRPC、Dubbo、Thrift、Motan2 等等。</p><p>自由意味着可以根据实际情况变化，需要什么引入什么，哪种技术能更好的解决问题就使用哪种技术。在 Java 栈中，也出现了 SpringCloud Netflix 和 SpringCloud Alibaba 之类的全家桶组件，作为开发者，只需要在需要的时候添加依赖即可。</p><p>从架构师的角度，自由带来的是约束力的下降，同时也缺少了规约的指导性。我们需要更加了解系统本身，也要更加了解各种技术的优缺点，才能够在架构设计时，更好的权衡利弊，做好取舍。加油，少年。</p><p><img src="https://static.howardliu.cn/Illustration/jiayou.jpg" alt="架构师养成计划"></p><p>我们来看下微服务中的基础组件：弹性伸缩、服务发现、配置中心、服务网关、负载均衡、服务安全、跟踪监控、降级熔断等等，其实从本质来说，这些组件都是业务无关的。实现软件开发过程中，可以将这些与业务隔离开，也就是所谓的“透明化”。</p><p>比如服务发现，可选的方案包括 Nginx、HAProxy、DNS、Eureka、Nacos、KubeDNS，但是我们真的关心吗？不需要，只需要知道我们要进行网络调用，有一个目标即可，至于这个目标是通过哪种方式发现、传输、寻址，都与我们要实现的功能无关。那就将服务发现与业务剥离，通过承载服务的运行环境处理。这就是所谓的边车模型。</p><p><img src="https://static.howardliu.cn/microservice/service-mesh-with-side-car.png" alt="边车模型"></p><p>微服务之所以应用普及，不仅仅在于其独特优势，还与容器化技术的普及有密切关系。微服务与 Docker 虚拟化的高效结合，相当于给了微服务二次加速的动力，资源调度 Kubernetes 的成功，可以认为是直接实现了曲速推进。先进的理念还需要先进的技术实现。</p><h2 id="有待成熟的无服务架构"><a href="#有待成熟的无服务架构" class="headerlink" title="有待成熟的无服务架构"></a>有待成熟的无服务架构</h2><blockquote><p>又想要快，还想要简单。那就不要服务了，随便写个函数跑跑得了。</p></blockquote><p><img src="https://static.howardliu.cn/microservice/Serverless_Architecture.png" alt="有待成熟的无服务架构"></p><p>就目前而言，绝大部分的系统开发都是为了解决业务问题。在这个过程中，我们需要选择一些业务无关的技术组件。有时候，我们受限于研发环境，需要的某种技术组件不存在时，需要采购部署，或者使用替代方案。这就会分散我们的注意力。</p><p>于是，很多云服务商提出了无服务架构。无服务架构将系统开发涉及的资源分为两部分：后端设施（Backend）、函数（Function），对应的就是 BaaS（Backend as a Service，后端即服务）和 FaaS（Function as a Service，函数即服务）。</p><p>这种不能算是架构风格，只能算是一种系统开发过程中的美好愿景。让开发者只需要关注业务，需要的基础设施全部由云服务提供，不需要考虑运行容器、基础设施的部署、服务器运行能力等。只要将开发好的代码上传，就可以拥有一个可运行的系统。</p><p>但是愿景虽好，但是与自己掌控部署的区别仅在于对于基础设施的管控程度上。除非出现重大变革，否则这种架构很难像微服务架构一样普适。但是对于小程序、小型 web 网站、咨询平台等模板化的小型系统，采用这种架构还是有很大优势的。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文从架构演进的角度分析了单体架构、SOA 架构、微服务架构、无服务架构的适用场景，作为架构师，我们在选择架构师，不应该一味追求主流，也不能盲从大厂的思路。我们要根据自身情况权衡利弊，找到适合的架构风格。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/09ILTzijUr3knHBj13t_kQ" target="_blank" rel="noopener">什么是微服务？</a></li><li><a href="https://mp.weixin.qq.com/s/n1eKTlLP_BbyBkKG4OyLSw" target="_blank" rel="noopener">微服务编程范式</a></li><li><a href="https://mp.weixin.qq.com/s/sRkYdrAwvn8UrGSraAURpA" target="_blank" rel="noopener">微服务的基建工作</a></li><li><a href="https://mp.weixin.qq.com/s/sRX04UhPiFWSDOazTSXuXw" target="_blank" rel="noopener">微服务中服务注册和发现的可行性方案</a></li><li><a href="https://mp.weixin.qq.com/s/NcftJ1jNAd-DHpzBXKk8RA" target="_blank" rel="noopener">从单体架构到微服务架构</a></li><li><a href="https://mp.weixin.qq.com/s/M0sla4LVvp2lEiFpzwyVrA" target="_blank" rel="noopener">如何在微服务团队中高效使用 Git 管理代码？</a></li><li><a href="https://mp.weixin.qq.com/s/apHFXB2cUqDALpJJebNp9A" target="_blank" rel="noopener">关于微服务系统中数据一致性的总结</a></li><li><a href="https://mp.weixin.qq.com/s/AE0n4d_zRZOEeYEQt-rSKw" target="_blank" rel="noopener">实现DevOps的三步工作法</a></li><li><a href="https://mp.weixin.qq.com/s/mMjbafRIhia3u9DmXPSfPQ" target="_blank" rel="noopener">系统设计系列之如何设计一个短链服务</a></li><li><a href="https://mp.weixin.qq.com/s/mtt_wsUChGIwnR-Nz5BE4g" target="_blank" rel="noopener">系统设计系列之任务队列</a></li><li><a href="https://mp.weixin.qq.com/s/_PI5jRP99ktPs3lxCbBLSg" target="_blank" rel="noopener">软件架构-缓存技术</a></li><li><a href="https://mp.weixin.qq.com/s/668L2NK7LWo3c8U8ZI_1ng" target="_blank" rel="noopener">软件架构-事件驱动架构</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/do-we-have-any-other-options-besides-microservices/">除了微服务，我们还有其他选择吗？</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/121760358" target="_blank" rel="noopener">除了微服务，我们还有其他选择吗？</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      从单体架构、SOA架构，到微服务架构，再到容器化、无服务架构，我们的选择很多，没有必要非在一棵树上吊死。
    
    </summary>
    
    
      <category term="microservice" scheme="https://www.howardliu.cn/categories/microservice/"/>
    
    
      <category term="微服务" scheme="https://www.howardliu.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="架构" scheme="https://www.howardliu.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java8 的新特性</title>
    <link href="https://www.howardliu.cn/java-8-features/"/>
    <id>https://www.howardliu.cn/java-8-features/</id>
    <published>2021-11-24T23:53:04.000Z</published>
    <updated>2021-11-24T23:53:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/fruits-6786607_1920.jpg" alt="Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java8 的新特性"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/visionpics-4638469/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6786607" target="_blank" rel="noopener">Alexandr Podvalny</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6786607" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《Java 进阶》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中仍有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述从 Java8 开始各个版本的新特性。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Java8 从 2014 年问世，到现在已是数个年头。这个版本新增了 Stream API、Lambda 表达式、新时间 API 等各种新特性，相比很多新兴语言也不遑多让。今天就来聊聊 Java8 中好玩好使的特性功能（完整特性请参见 <a href="https://openjdk.java.net/projects/Java8/features" target="_blank" rel="noopener">这里</a>）。</p><h2 id="接口方法"><a href="#接口方法" class="headerlink" title="接口方法"></a>接口方法</h2><p>在 Java8 之前，接口只能够定义<code>public abstract</code>方法，默认可以不写修饰符。当在接口中新增方法定义，该接口的所有实现类都需要新增这个方法的实现，这样对于升级扩展很不友好。</p><p>从 Java8 开始，我们可以在接口中定义静态方法和默认方法了，也就是我们可以在接口中定义具有具体操作行为的方法定义，这样接口的实现类可以有选择的实现接口方法。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>Java8 之前，静态方法是类的专属技能，这样会引起概念上的一些歧义。比如，我们定义一个生产者<code>Producer</code>接口，所有生产者都继承该接口，这个时候，我们需要一个静态方法提供<code>Producer</code>的名字。这个时候，在单独定义一个类提供一个静态方法提供名字，可以实现功能，但是略显复杂。</p><p>现在我们直接在<code>Producer</code>生产者接口中定义静态方法即可：</p><pre><code class="java">static String producer() {    return &quot;target: &quot; + System.currentTimeMillis();}</code></pre><p>沿用约定的限定范围，我们不需要在方法前面加<code>public</code>。这个静态方法只能通过接口调用，或者在接口内部直接引用。比如：</p><pre><code class="java">final String target = Producer.producer();</code></pre><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>接口的默认方法定义需要使用<code>default</code>关键字，接口中定义的默认方法可以在实现类中重写。</p><p>比如，我们的生产者<code>Producer</code>需要生产东西，我们可以在接口中定义一个默认方法：</p><pre><code class="java">default String produce() {    return &quot;NULL&quot;;}</code></pre><p>我们可以定义<code>Producer</code>的实现类是<code>Hamburger</code>，可以选择重写接口的默认方法，也可以不用重写。比如：</p><pre><code class="java">public class Hamburger implements Producer {}</code></pre><p>使用的时候直接调用：</p><pre><code class="java">final Producer producer = new Hamburger();System.out.println(producer.produce());</code></pre><p>这个时候会打印“NULL”。我们还可以在<code>Hamburger</code>中重写<code>produce</code>方法：</p><pre><code class="java">@Overridepublic String produce() {    return &quot;HAMBURGER&quot;;}</code></pre><p>这个时候会打印“HAMBURGER”。</p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>我们在使用 Lambda 表达式时，可以使用方法引用，使表达式更短、更易读。方法引用有四种表达形式：</p><ul><li>静态方法引用</li><li>实例方法引用</li><li>特定类型的实例方法引用</li><li>构造方法引用</li></ul><p>下面我们分别说一下。</p><h3 id="静态方法引用"><a href="#静态方法引用" class="headerlink" title="静态方法引用"></a>静态方法引用</h3><p>静态方法引用语法是：<code>类名：: 方法名</code>。假设我们需要判断一个<code>List&lt;String&gt;</code>队列中所有元素是否为空，通过 Stream API 我们可以这样判断：</p><pre><code class="java">final List&lt;String&gt; list = Lists.newArrayList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, null, &quot;4&quot;);final boolean hasNullElement = list.stream()        .anyMatch(x -&gt; Objects.isNull(x));System.out.println(hasNullElement);</code></pre><p>可以看到，<code>anyMath</code>方法中只调用了<code>Objects.isNull</code>方法，而且方法的入参直接是列表中的元素，此时，我们可以直接使用静态方法引用，将代码改写一下：</p><pre><code class="java">final boolean hasNullElementAlso = list.stream().anyMatch(Objects::isNull);</code></pre><p>这样看起来清爽多了。</p><h3 id="实例方法引用"><a href="#实例方法引用" class="headerlink" title="实例方法引用"></a>实例方法引用</h3><p>实例方法引用语法是：<code>实例：: 方法名</code>。比如，我们有一个列表中全是<code>LocalDate</code>类型数据，现在需要对其进行格式化，返回一个字符串列表。我们可以这样使用：</p><pre><code class="java">final DateTimeFormatter fmt = DateTimeFormatter.ISO_LOCAL_DATE;final List&lt;LocalDate&gt; dates = Lists.newArrayList(        LocalDate.MIN,        LocalDate.now(),        LocalDate.MAX);final List&lt;String&gt; dateStrs = dates.stream()        .map(d -&gt; fmt.format(d))        .collect(Collectors.toList());</code></pre><p><code>map</code>方法中通过<code>DateTimeFormatter</code>的实例对象调用了<code>format</code>方法，入参也是 Lambda 表达式中的元素，这样就可以使用实例方法引用，代码可以改写为：</p><pre><code class="java">final List&lt;String&gt; dateStrList = dates.stream()        .map(fmt::format)        .collect(Collectors.toList());</code></pre><p>这样写起来顺手多了。</p><h3 id="特定类型的实例方法引用"><a href="#特定类型的实例方法引用" class="headerlink" title="特定类型的实例方法引用"></a>特定类型的实例方法引用</h3><p>这种方法引用有一个前提条件，就是必须是 Lambda 表达式元素类型对应的方法。语法是：<code>特定类型：: 方法名</code>。比如，我们需要判断一个全都不为<code>null</code>的字符串列表中，空字符的数量，我们可以这样写：</p><pre><code class="java">final List&lt;String&gt; nonNullList = Lists.newArrayList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;&quot;, &quot;4&quot;, &quot;&quot;);final long emptyCount = nonNullList.stream()        .filter(x -&gt; x.isEmpty())        .count();</code></pre><p>我们可以看到，<code>filter</code>方法中引用的函数是利用 Lambda 表达式元素对象的方法，这个时候我们可以将代码改写为：</p><pre><code class="java">final long emptyElementCount = nonNullList.stream()        .filter(String::isEmpty)        .count();</code></pre><p>这样能够清晰的看出是哪个类的方法了。</p><h3 id="构造方法引用"><a href="#构造方法引用" class="headerlink" title="构造方法引用"></a>构造方法引用</h3><p>构造方法引用的语法是：<code>类名：:new</code>。在 Java 中，构造方法是一种特殊的方法，所以构造方法的引用与上面几种方法类似。比如，想要将字符串列表中的元素全部转换为<code>Integer</code>格式：</p><pre><code class="java">final List&lt;String&gt; allIntList = Lists.newArrayList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;);final List&lt;Integer&gt; ints = allIntList.stream()        .map(x -&gt; new Integer(x))        .collect(Collectors.toList());</code></pre><p>我们可以改写为：</p><pre><code class="java">final List&lt;Integer&gt; intList = allIntList.stream()        .map(Integer::new)        .collect(Collectors.toList());</code></pre><h2 id="Optional-神器"><a href="#Optional-神器" class="headerlink" title="Optional 神器"></a>Optional 神器</h2><p>空指针异常（NullPointException，NPE）是特别低级但又很难避免的异常，说他低级是因为只要看到这个异常，就能够很容易的修复，但是我们很难百分之百的避免这个异常的存在。在 Java8 之前，我们只能通过类似<code>obj != null</code>这种模板式方法判断。在 Java8 新增的神器<code>Optional</code>可以更加优雅的解决这个问题。</p><h3 id="创建-Optional"><a href="#创建-Optional" class="headerlink" title="创建 Optional"></a>创建 Optional</h3><p><code>Optional</code>的构造方法是使用<code>private</code>修饰的，其提供了三个静态方法，用于创建<code>Optional</code>实例，分别是<code>empty</code>、<code>of</code>、<code>ofNullable</code>，创建之后，<code>Optional</code>是不可变的。</p><p>我们可以使用<code>empty</code>定义一个具有空值的<code>Optional</code>对象：</p><pre><code class="java">final Optional&lt;String&gt; optional = Optional.empty();</code></pre><p>使用<code>of</code>定义一个不为空的对象：</p><pre><code class="java">final String str = &quot;value&quot;;final Optional&lt;String&gt; optional = Optional.of(str);</code></pre><p>这里需要注意一下，<code>of</code>方法赋值时，使用<code>Objects.requireNonNull</code>验证参数是否为空，为空就会抛出<code>NullPointerException</code>异常。</p><p>如果不太确定是否为空，可以使用<code>ofNullable</code>创建对象：</p><pre><code class="java">final String str = getSomeStr();final Optional&lt;String&gt; optional = Optional.ofNullable(str);</code></pre><h3 id="使用-Optional"><a href="#使用-Optional" class="headerlink" title="使用 Optional"></a>使用 Optional</h3><p>比如，我们需要返回一个字符串列表<code>List&lt;String&gt;</code>，当结果是<code>null</code>的时候，我们返回返回<code>new ArrayList&lt;&gt;()</code>。如果是在 Java8 之前，我们得这样写：</p><pre><code class="java">List&lt;String&gt; list = getList();List&lt;String&gt; listOpt = list != null ? list : new ArrayList&lt;&gt;();</code></pre><p>现在，我们可以借助<code>Optional</code>的能力：</p><pre><code class="java">List&lt;String&gt; listOpt = Optional.ofNullable(getList())        .orElse(new ArrayList&lt;&gt;());</code></pre><p>小试牛刀，还不错，下面放大招。</p><p><img src="https://static.howardliu.cn/20211124232900.jpeg" alt="前方高能，请注意"></p><p>假设，我们有一个<code>User</code>类，内部有个<code>Address</code>类，在内部有个<code>street</code>属性，我们现在想要获取一个<code>User</code>对象的<code>street</code>值。如果是以前，我们需要各种判断是否是<code>null</code>，代码会写成这样：</p><pre><code class="java">User user = getUser();if (user != null) {    Address address = user.getAddress();    if (address != null) {        String street = address.getStreet();        if (street != null) {            return street;        }    }}return &quot;not specified&quot;;</code></pre><p>是不是似曾相识，或者以前亲手写过。现在有了<code>Optional</code>，我们就不需要这么麻烦了：</p><pre><code class="java">String result = Optional.ofNullable(getUser())        .map(User::getAddress)        .map(Address::getStreet)        .orElse(&quot;not specified&quot;);</code></pre><p>是不是相当的优雅，<code>map</code>方法返回的也是<code>Optional</code>对象，所以我们可以无限处理下去。</p><p>如果<code>User</code>类中的<code>getAddress</code>方法返回的本身就是<code>Optional</code>对象，我们可以使用<code>flatMap</code>替换<code>map</code>。</p><p>还有一种情况是我们需要捕捉 NPE 的情况，但是需要包装为其他自定义异常，这个时候可以使用<code>orElseThrow</code>方法：</p><pre><code class="java">String value = null;Optional&lt;String&gt; valueOpt = Optional.ofNullable(value);String result = valueOpt.orElseThrow(CustomException::new).toUpperCase();</code></pre><p>这里只是简单给出几个例子，更多功能可以参见 <a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">《一文掌握 Java8 的 Optional 的 6 种操作》</a>。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文给出了 Java8 中几个比较有意思的特性，完整的特性清单可以从<a href="https://openjdk.java.net/projects/Java8/features" target="_blank" rel="noopener">https://openjdk.java.net/projects/Java8/features</a>查看。</p><p>本文所有代码都可以通过在公众号「看山的小屋」回复“java”获取。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-8-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java8 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/121529334" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java8 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Java8 从 2014 年问世，到现在已是数个年头。这个版本新增了 Stream API、Lambda 表达式、新时间 API 等各种新特性，相比很多新兴语言也不遑多让。今天就来聊聊 Java8 中好玩好使的特性功能
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java8" scheme="https://www.howardliu.cn/tags/Java8/"/>
    
      <category term="optional" scheme="https://www.howardliu.cn/tags/optional/"/>
    
  </entry>
  
  <entry>
    <title>人人都会设计模式：策略模式</title>
    <link href="https://www.howardliu.cn/strategy-pattern/"/>
    <id>https://www.howardliu.cn/strategy-pattern/</id>
    <published>2021-11-15T15:05:51.000Z</published>
    <updated>2021-11-15T15:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/autumn-6752841_1920.jpg" alt="人人都会设计模式：策略模式"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/daschorsch-1537217/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6752841" target="_blank" rel="noopener">daschorsch</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6752841" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><blockquote><p>本文收录在<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1750195552933199874&scene=126&devicetype=iOS15.0.2&version=18000f2a&lang=zh_CN&nettype=WIFI&ascene=59&session_us=gh_9bcfdc303e2f&fontScale=100&wx_header=1" target="_blank" rel="noopener">《一个架构师的职业素养》</a>专栏，日拱一卒，功不唐捐。</p></blockquote><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>策略模式，英文全称是 Strategy Design Pattern。在 GoF 的《设计模式》一书中，它是这样定义的：</p><blockquote><p>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</p></blockquote><p>翻译成中文就是：定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端。</p><p>这里所说的客户端代指使用算法的代码。</p><p>根据使用场景分类，策略模式是一种行为型模式，用于运行时控制类的行为或算法。</p><p>使用上的直观感受是，策略模式可以减少了 if-else/switch 分支代码。那减少分支代码有什么好处呢？</p><ol><li>解耦代码，策略模式就是解耦不同算法实现；</li><li>减少 bug 产生概率，减少分支，就是减少 bug 发生概率。</li></ol><p>有编程经验的都知道，很多 bug 都是从分支逻辑产生的。我刚开始工作时晚上 12 点开始抓虫，一直抓到凌晨 2 点多，最后发现是有一个 if-else 分支中，在某个 if 前面少写了一个 else。下面是示例，实际代码比这个复杂很多：</p><pre><code class="java">if (a &lt; 1) {} else if (a &lt; 2) {} else if (a &lt; 3) {}</code></pre><p>结果写成了：</p><pre><code class="java">if (a &lt; 1) {} else if (a &lt; 2) {} if (a &lt; 3) {}</code></pre><p>代码编译不会错，但是在执行时，某些 case 会不符合预期。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我们来看看策略模式出现的场景。</p><p>以电商系统的支付功能为例，最早的时候，我们可能为了更快上线，选择一个较多人使用的支付方式，比如微信支付（也有可能是支付宝支付，根据售卖场景不同区分）。这个时候，我们只需要判断用户是从 PC 页面进入还是 H5 进入即可。</p><p>后来，业务发展比较好，涉及人群更多了，于是需要对接支付宝支付。支付宝支付也分为了多种的支付场景，对接接口变多了，但是也在可控范围内。</p><p>再后来，我们需要对接银联支付、对接各银行接口，等等，支付接口变得越来越臃肿。于是，每对接一种支付方式，支付相关接口就会增加一倍。此时，这坨臃肿的代码，无论是修复简单的 bug，还是微调传输参数，都会影响整个支付逻辑，从而增加了在已有正常运行代码中引入错误的风险。</p><p><img src="https://static.howardliu.cn/20211116075137.jpeg" alt="越来越臃肿的系统"></p><p>如果是多人协作开发，我们还会陷入代码合并时应付各种冲突的情况。终于，在某一时刻，我们看着这一坨代码，已经无从下手维护了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>首先，我们来分析一下上面的场景，不变的是系统内部的支付业务逻辑，变化的是支付方式。</p><p>支付方式的可变性在于，可能会与多种支付方式对接，对接参数、协议、地址等都会不同。根据设计模式的整体思想，我们将变化的单独出去，将不变的稳定下来。</p><p>这种处理方式就是策略模式建议的：找出负责用许多不同方式完成特定任务的类，然后将其中的算法抽取到一族被称为策略的独立类中。</p><p>调用这些策略类的是调用上下文，它持有对所有策略类的引用。上下文不执行任务，它是任务的指挥者，将工作委派给已连接的策略对象。关系如下：</p><p><img src="https://static.howardliu.cn/20211116075124.png" alt="策略模式类图"></p><p>很多教程到这里就结束了，如果你能够看到这里，而且还用心看了，你就会发现一丝丝的不一样。</p><p>根据迪米特法则（LOD，Law of Demeter），上下文不需要知道具体策略类的功能，只需要通过特定的接口，用于触发选中策略即可。也就是说，完整的策略模式，应该有具体的策略判断是否由该策略执行，上下文只需要知道有哪些策略就行了。这样改动之后，上下文还能够与工厂模式结合。如果策略是无状态策略，还可以在上下文中引入单例模式。</p><h2 id="适用与不适用"><a href="#适用与不适用" class="headerlink" title="适用与不适用"></a>适用与不适用</h2><p>根据上面的定义，策略模式是围绕可以互换的算法来创建业务的。简单的说就是，分支逻辑隔离。</p><ol><li>当你想使用各种不同算法变体，且能够在运行时切换算法。策略模式可以将对象关联到不同实现方式的不同子任务中，可以间接的修改对象；</li><li>只有在执行时有些许不同的相似算法。可以将不同的行为抽象到独立的类中，在原来的类中调用这些独立的算法；</li><li>算法在业务逻辑中不是特别重要。我们可以通过策略模式将算法、数据、依赖等抽离出来，在运行时调用即可。</li></ol><p>设计模式只是解决问题的优雅实现，并不一定适用所有情况，比如下面这几种，就可以不用非得实现策略模式：</p><ol><li>如果算法极少变化，就没有任何理由引入新的类和接口。</li><li>如果使用了 Java8 之后的版本，可以使用函数式编程，有时候就使用 Lambda 表达式或者匿名内部类的方式实现具体算法即可。</li></ol><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>还是以支付为例，因为都是演示，一切从简。我曾经主导过支付中台，如果想要具体实现，可以具体聊一下。</p><p>首先定义支付策略接口：</p><pre><code class="java">public interface PayStrategy {    String payType();    void callPay(BigDecimal amount);}</code></pre><p><code>payType()</code>是在具体的策略实现中定义策略可执行的支付方式，也可以通过传参数的方式返回<code>boolean</code>类型用于判断是否可执行。</p><p>然后是微信支付和支付宝支付分别实现支付策略接口：</p><pre><code class="java">public class WxpayPayStrategy implements PayStrategy {    @Override    public String payType() {        return &quot;WXPAY&quot;;    }    @Override    public void callPay(BigDecimal amount) {        // 微信支付接口        // 这里只是演示，即使都是微信支付，也会分不同的接口        System.out.println(&quot;调用微信支付接口&quot;);    }}public class AlipayPayStrategy implements PayStrategy {    @Override    public String payType() {        return &quot;ALIPAY&quot;;    }    @Override    public void callPay(BigDecimal amount) {        // 调用支付宝支付接口        // 这里只是演示，即使都是支付宝支付，也会分不同的接口        System.out.println(&quot;调用支付宝支付接口&quot;);    }}</code></pre><p>我们再来看看持有策略算法的上下文：</p><pre><code class="java">public class StrategyContext {    private static final Map&lt;String, PayStrategy&gt; PAY_STRATEGY_MAP = new HashMap&lt;&gt;();    static {        final AlipayPayStrategy alipayPayStrategy = new AlipayPayStrategy();        final WxpayPayStrategy wxpayPayStrategy = new WxpayPayStrategy();        PAY_STRATEGY_MAP.put(alipayPayStrategy.payType(), alipayPayStrategy);        PAY_STRATEGY_MAP.put(wxpayPayStrategy.payType(), wxpayPayStrategy);    }    public void pay(String payType, BigDecimal amount) {        final PayStrategy payStrategy = PAY_STRATEGY_MAP.get(payType);        payStrategy.callPay(amount);    }}</code></pre><p>可以看到，上下文只需要知道策略算法的存在，至于算法是否符合要求，由算法自己判断。</p><p>调用就比较简单了：</p><pre><code class="java">public class Main {    public static void main(String[] args) {        final StrategyContext strategyContext = new StrategyContext();        strategyContext.pay(&quot;ALIPAY&quot;, BigDecimal.TEN);        strategyContext.pay(&quot;WXPAY&quot;, BigDecimal.ONE);    }}</code></pre><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>策略模式可能用来减少分支逻辑，将不同的算法分离开来。如果配合工厂模式、单例模式，可以更加灵活的使用。如果是在 Spring 当中，借助自动注入，上下文甚至可以不知道具体策略实现。</p><p>最近刚看到一句话，“日拱一卒，功不唐捐”。坚持下去，每天学点新东西，给生活加点色彩。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/Bpblou6RkZua4jE4gaZylA" target="_blank" rel="noopener">Java 中的单例模式（完整篇）</a></li><li><a href="https://mp.weixin.qq.com/s/ynajBpu0xJYGzcgqaIDjMg" target="_blank" rel="noopener">设计模式：建造者模式</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/strategy-pattern/">人人都会设计模式：策略模式</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/121347845" target="_blank" rel="noopener">人人都会设计模式：策略模式</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端。
    
    </summary>
    
    
      <category term="design pattern" scheme="https://www.howardliu.cn/categories/design-pattern/"/>
    
    
      <category term="设计模式" scheme="https://www.howardliu.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶：使用 Lambda 表达式实现超强的排序功能</title>
    <link href="https://www.howardliu.cn/java-lambda-powerful-comparation/"/>
    <id>https://www.howardliu.cn/java-lambda-powerful-comparation/</id>
    <published>2021-11-07T12:32:59.000Z</published>
    <updated>2021-11-07T12:32:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cairn-g9fca0fd5f_1920.jpg" alt="Java 进阶：使用 Lambda 表达式实现超强的排序功能"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/mike_68-10359383/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6754295" target="_blank" rel="noopener">Michael Kleinsasser</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6754295" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><blockquote><p>本文被<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378&scene=126&devicetype=iOS15.0.2&version=18000f2a&lang=zh_CN&nettype=WIFI&ascene=59&session_us=gh_9bcfdc303e2f&fontScale=100&wx_header=1" target="_blank" rel="noopener">《Java 进阶》</a>专栏收录，在公众号「看山的小屋」，回复“java”可获取源码。</p></blockquote><p>我们在系统开发过程中，对数据排序是很常见的场景。一般来说，我们可以采用两种方式：</p><a id="more"></a><ol><li>借助存储系统（SQL、NoSQL、NewSQL 都支持）的排序功能，查询的结果即是排好序的结果</li><li>查询结果为无序数据，在内存中排序。</li></ol><p>今天要说的是第二种排序方式，在内存中实现数据排序。</p><p>首先，我们定义一个基础类，后面我们将根据这个基础类演示如何在内存中排序。</p><pre><code class="java">@Data@NoArgsConstructor@AllArgsConstructorpublic class Student {    private String name;    private int age;    @Override    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        Student student = (Student) o;        return age == student.age &amp;&amp; Objects.equals(name, student.name);    }    @Override    public int hashCode() {        return Objects.hash(name, age);    }}</code></pre><h2 id="基于Comparator排序"><a href="#基于Comparator排序" class="headerlink" title="基于Comparator排序"></a>基于<code>Comparator</code>排序</h2><p>在 Java8 之前，我们都是通过实现<code>Comparator</code>接口完成排序，比如：</p><pre><code class="java">new Comparator&lt;Student&gt;() {    @Override    public int compare(Student h1, Student h2) {        return h1.getName().compareTo(h2.getName());    }};</code></pre><p>这里展示的是匿名内部类的定义，如果是通用的对比逻辑，可以直接定义一个实现类。使用起来也比较简单，如下就是应用：</p><pre><code class="java">@Testvoid baseSortedOrigin() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12)    );    Collections.sort(students, new Comparator&lt;Student&gt;() {        @Override        public int compare(Student h1, Student h2) {            return h1.getName().compareTo(h2.getName());        }    });    Assertions.assertEquals(students.get(0), new Student(&quot;Jerry&quot;, 12));}</code></pre><blockquote><p>这里使用了 Junit5 实现单元测试，用来验证逻辑非常适合。</p></blockquote><p>因为定义的<code>Comparator</code>是使用<code>name</code>字段排序，在 Java 中，<code>String</code>类型的排序是通过单字符的 ASCII 码顺序判断的，<code>J</code>排在<code>T</code>的前面，所以<code>Jerry</code>排在第一个。</p><h2 id="使用-Lambda-表达式替换Comparator匿名内部类"><a href="#使用-Lambda-表达式替换Comparator匿名内部类" class="headerlink" title="使用 Lambda 表达式替换Comparator匿名内部类"></a>使用 Lambda 表达式替换<code>Comparator</code>匿名内部类</h2><p>使用过 Java8 的 Lamdba 的应该知道，匿名内部类可以简化为 Lambda 表达式为：</p><pre><code class="java">Collections.sort(students, (Student h1, Student h2) -&gt; h1.getName().compareTo(h2.getName()));</code></pre><p>在 Java8 中，<code>List</code>类中增加了<code>sort</code>方法，所以<code>Collections.sort</code>可以直接替换为：</p><pre><code class="java">students.sort((Student h1, Student h2) -&gt; h1.getName().compareTo(h2.getName()));</code></pre><p>根据 Java8 中 Lambda 的类型推断，我们可以将指定的<code>Student</code>类型简写：</p><pre><code class="java">students.sort((h1, h2) -&gt; h1.getName().compareTo(h2.getName()));</code></pre><p>至此，我们整段排序逻辑可以简化为：</p><pre><code class="java">@Testvoid baseSortedLambdaWithInferring() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12)    );    students.sort((h1, h2) -&gt; h1.getName().compareTo(h2.getName()));    Assertions.assertEquals(students.get(0), new Student(&quot;Jerry&quot;, 12));}</code></pre><h2 id="通过静态方法抽取公共的-Lambda-表达式"><a href="#通过静态方法抽取公共的-Lambda-表达式" class="headerlink" title="通过静态方法抽取公共的 Lambda 表达式"></a>通过静态方法抽取公共的 Lambda 表达式</h2><p>我们可以在<code>Student</code>中定义一个静态方法：</p><pre><code class="java">public static int compareByNameThenAge(Student s1, Student s2) {    if (s1.name.equals(s2.name)) {        return Integer.compare(s1.age, s2.age);    } else {        return s1.name.compareTo(s2.name);    }}</code></pre><p>这个方法需要返回一个<code>int</code>类型参数，在 Java8 中，我们可以在 Lambda 中使用该方法：</p><pre><code class="java">@Testvoid sortedUsingStaticMethod() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12)    );    students.sort(Student::compareByNameThenAge);    Assertions.assertEquals(students.get(0), new Student(&quot;Jerry&quot;, 12));}</code></pre><h2 id="借助Comparator的comparing方法"><a href="#借助Comparator的comparing方法" class="headerlink" title="借助Comparator的comparing方法"></a>借助<code>Comparator</code>的<code>comparing</code>方法</h2><p>在 Java8 中，<code>Comparator</code>类新增了<code>comparing</code>方法，可以将传递的<code>Function</code>参数作为比较元素，比如：</p><pre><code class="java">@Testvoid sortedUsingComparator() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12)    );    students.sort(Comparator.comparing(Student::getName));    Assertions.assertEquals(students.get(0), new Student(&quot;Jerry&quot;, 12));}</code></pre><h2 id="多条件排序"><a href="#多条件排序" class="headerlink" title="多条件排序"></a>多条件排序</h2><p>我们在静态方法一节中展示了多条件排序，还可以在<code>Comparator</code>匿名内部类中实现多条件逻辑：</p><pre><code class="java">@Testvoid sortedMultiCondition() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12),            new Student(&quot;Jerry&quot;, 13)    );    students.sort((s1, s2) -&gt; {        if (s1.getName().equals(s2.getName())) {            return Integer.compare(s1.getAge(), s2.getAge());        } else {            return s1.getName().compareTo(s2.getName());        }    });    Assertions.assertEquals(students.get(0), new Student(&quot;Jerry&quot;, 12));}</code></pre><p>从逻辑来看，多条件排序就是先判断第一级条件，如果相等，再判断第二级条件，依次类推。在 Java8 中可以使用<code>comparing</code>和一系列<code>thenComparing</code>表示多级条件判断，上面的逻辑可以简化为：</p><pre><code class="java">@Testvoid sortedMultiConditionUsingComparator() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12),            new Student(&quot;Jerry&quot;, 13)    );    students.sort(Comparator.comparing(Student::getName).thenComparing(Student::getAge));    Assertions.assertEquals(students.get(0), new Student(&quot;Jerry&quot;, 12));}</code></pre><p>这里的<code>thenComparing</code>方法是可以有多个的，用于表示多级条件判断，这也是函数式编程的方便之处。</p><h2 id="在Stream中进行排序"><a href="#在Stream中进行排序" class="headerlink" title="在Stream中进行排序"></a>在<code>Stream</code>中进行排序</h2><p>Java8 中，不但引入了 Lambda 表达式，还引入了一个全新的流式 API：Stream API，其中也有<code>sorted</code>方法用于流式计算时排序元素，可以传入<code>Comparator</code>实现排序逻辑：</p><pre><code class="java">@Testvoid streamSorted() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12)    );    final Comparator&lt;Student&gt; comparator = (h1, h2) -&gt; h1.getName().compareTo(h2.getName());    final List&lt;Student&gt; sortedStudents = students.stream()            .sorted(comparator)            .collect(Collectors.toList());    Assertions.assertEquals(sortedStudents.get(0), new Student(&quot;Jerry&quot;, 12));}</code></pre><p>同样的，我们可以通过 Lambda 简化书写：</p><pre><code class="java">@Testvoid streamSortedUsingComparator() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12)    );    final Comparator&lt;Student&gt; comparator = Comparator.comparing(Student::getName);    final List&lt;Student&gt; sortedStudents = students.stream()            .sorted(comparator)            .collect(Collectors.toList());    Assertions.assertEquals(sortedStudents.get(0), new Student(&quot;Jerry&quot;, 12));}</code></pre><h2 id="倒序排列"><a href="#倒序排列" class="headerlink" title="倒序排列"></a>倒序排列</h2><h3 id="调转排序判断"><a href="#调转排序判断" class="headerlink" title="调转排序判断"></a>调转排序判断</h3><p>排序就是根据<code>compareTo</code>方法返回的值判断顺序，如果想要倒序排列，只要将返回值取返即可：</p><pre><code class="java">@Testvoid sortedReverseUsingComparator2() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12)    );    final Comparator&lt;Student&gt; comparator = (h1, h2) -&gt; h2.getName().compareTo(h1.getName());    students.sort(comparator);    Assertions.assertEquals(students.get(0), new Student(&quot;Tom&quot;, 10));}</code></pre><p>可以看到，正序排列的时候，我们是<code>h1.getName().compareTo(h2.getName())</code>，这里我们直接倒转过来，使用的是<code>h2.getName().compareTo(h1.getName())</code>，也就达到了取反的效果。在 Java 的<code>Collections</code>中定义了一个<code>java.util.Collections.ReverseComparator</code>内部私有类，就是通过这种方式实现元素反转。</p><h3 id="借助Comparator的reversed方法倒序"><a href="#借助Comparator的reversed方法倒序" class="headerlink" title="借助Comparator的reversed方法倒序"></a>借助<code>Comparator</code>的<code>reversed</code>方法倒序</h3><p>在 Java8 中新增了<code>reversed</code>方法实现倒序排列，用起来也是很简单：</p><pre><code class="java">@Testvoid sortedReverseUsingComparator() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12)    );    final Comparator&lt;Student&gt; comparator = (h1, h2) -&gt; h1.getName().compareTo(h2.getName());    students.sort(comparator.reversed());    Assertions.assertEquals(students.get(0), new Student(&quot;Tom&quot;, 10));}</code></pre><h3 id="在Comparator-comparing中定义排序反转"><a href="#在Comparator-comparing中定义排序反转" class="headerlink" title="在Comparator.comparing中定义排序反转"></a>在<code>Comparator.comparing</code>中定义排序反转</h3><p><code>comparing</code>方法还有一个重载方法，<code>java.util.Comparator#comparing(java.util.function.Function&lt;? super T,? extends U&gt;, java.util.Comparator&lt;? super U&gt;)</code>，第二个参数就可以传入<code>Comparator.reverseOrder()</code>，可以实现倒序：</p><pre><code class="java">@Testvoid sortedUsingComparatorReverse() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12)    );    students.sort(Comparator.comparing(Student::getName, Comparator.reverseOrder()));    Assertions.assertEquals(students.get(0), new Student(&quot;Jerry&quot;, 12));}</code></pre><h3 id="在Stream中定义排序反转"><a href="#在Stream中定义排序反转" class="headerlink" title="在Stream中定义排序反转"></a>在<code>Stream</code>中定义排序反转</h3><p>在<code>Stream</code>中的操作与直接列表排序类似，可以反转<code>Comparator</code>定义，也可以使用<code>Comparator.reverseOrder()</code>反转。实现如下：</p><pre><code class="java">@Testvoid streamReverseSorted() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12)    );    final Comparator&lt;Student&gt; comparator = (h1, h2) -&gt; h2.getName().compareTo(h1.getName());    final List&lt;Student&gt; sortedStudents = students.stream()            .sorted(comparator)            .collect(Collectors.toList());    Assertions.assertEquals(sortedStudents.get(0), new Student(&quot;Tom&quot;, 10));}@Testvoid streamReverseSortedUsingComparator() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(&quot;Tom&quot;, 10),            new Student(&quot;Jerry&quot;, 12)    );    final List&lt;Student&gt; sortedStudents = students.stream()            .sorted(Comparator.comparing(Student::getName, Comparator.reverseOrder()))            .collect(Collectors.toList());    Assertions.assertEquals(sortedStudents.get(0), new Student(&quot;Tom&quot;, 10));}</code></pre><h2 id="null-值的判断"><a href="#null-值的判断" class="headerlink" title="null 值的判断"></a>null 值的判断</h2><p>前面的例子中都是有值元素排序，能够覆盖大部分场景，但有时候我们还是会碰到元素中存在<code>null</code>的情况：</p><ol><li>列表中的元素是 null</li><li>列表中的元素参与排序条件的字段是 null</li></ol><p>如果还是使用前面的那些实现，我们会碰到<code>NullPointException</code>异常，即 NPE，简单演示一下：</p><pre><code class="java">@Testvoid sortedNullGotNPE() {    final List&lt;Student&gt; students = Lists.newArrayList(            null,            new Student(&quot;Snoopy&quot;, 12),            null    );    Assertions.assertThrows(NullPointerException.class,            () -&gt; students.sort(Comparator.comparing(Student::getName)));}</code></pre><p>所以，我们需要考虑这些场景。</p><h3 id="元素是-null-的笨拙实现"><a href="#元素是-null-的笨拙实现" class="headerlink" title="元素是 null 的笨拙实现"></a>元素是 null 的笨拙实现</h3><p>最先想到的就是判空：</p><pre><code class="java">@Testvoid sortedNullNoNPE() {    final List&lt;Student&gt; students = Lists.newArrayList(            null,            new Student(&quot;Snoopy&quot;, 12),            null    );    students.sort((s1, s2) -&gt; {        if (s1 == null) {            return s2 == null ? 0 : 1;        } else if (s2 == null) {            return -1;        }        return s1.getName().compareTo(s2.getName());    });    Assertions.assertNotNull(students.get(0));    Assertions.assertNull(students.get(1));    Assertions.assertNull(students.get(2));}</code></pre><p>我们可以将判空的逻辑抽取出一个<code>Comparator</code>，通过组合方式实现：</p><pre><code class="java">class NullComparator&lt;T&gt; implements Comparator&lt;T&gt; {    private final Comparator&lt;T&gt; real;    NullComparator(Comparator&lt;? super T&gt; real) {        this.real = (Comparator&lt;T&gt;) real;    }    @Override    public int compare(T a, T b) {        if (a == null) {            return (b == null) ? 0 : 1;        } else if (b == null) {            return -1;        } else {            return (real == null) ? 0 : real.compare(a, b);        }    }}</code></pre><p>在 Java8 中已经为我们准备了这个实现。</p><h3 id="使用Comparator-nullsLast和Comparator-nullsFirst"><a href="#使用Comparator-nullsLast和Comparator-nullsFirst" class="headerlink" title="使用Comparator.nullsLast和Comparator.nullsFirst"></a>使用<code>Comparator.nullsLast</code>和<code>Comparator.nullsFirst</code></h3><p>使用<code>Comparator.nullsLast</code>实现<code>null</code>在结尾：</p><pre><code class="java">@Testvoid sortedNullLast() {    final List&lt;Student&gt; students = Lists.newArrayList(            null,            new Student(&quot;Snoopy&quot;, 12),            null    );    students.sort(Comparator.nullsLast(Comparator.comparing(Student::getName)));    Assertions.assertNotNull(students.get(0));    Assertions.assertNull(students.get(1));    Assertions.assertNull(students.get(2));}</code></pre><p>使用<code>Comparator.nullsFirst</code>实现<code>null</code>在开头：</p><pre><code class="java">@Testvoid sortedNullFirst() {    final List&lt;Student&gt; students = Lists.newArrayList(            null,            new Student(&quot;Snoopy&quot;, 12),            null    );    students.sort(Comparator.nullsFirst(Comparator.comparing(Student::getName)));    Assertions.assertNull(students.get(0));    Assertions.assertNull(students.get(1));    Assertions.assertNotNull(students.get(2));}</code></pre><p>是不是很简单，接下来我们看下如何实现排序条件的字段是 null 的逻辑。</p><h3 id="排序条件的字段是-null"><a href="#排序条件的字段是-null" class="headerlink" title="排序条件的字段是 null"></a>排序条件的字段是 null</h3><p>这个就是借助<code>Comparator</code>的组合了，就像是套娃实现了，需要使用两次<code>Comparator.nullsLast</code>，这里列出实现：</p><pre><code class="java">@Testvoid sortedNullFieldLast() {    final List&lt;Student&gt; students = Lists.newArrayList(            new Student(null, 10),            new Student(&quot;Snoopy&quot;, 12),            null    );    final Comparator&lt;Student&gt; nullsLast = Comparator.nullsLast(            Comparator.nullsLast( // 1                    Comparator.comparing(                            Student::getName,                            Comparator.nullsLast( // 2                                    Comparator.naturalOrder() // 3                            )                    )            )    );    students.sort(nullsLast);    Assertions.assertEquals(students.get(0), new Student(&quot;Snoopy&quot;, 12));    Assertions.assertEquals(students.get(1), new Student(null, 10));    Assertions.assertNull(students.get(2));}</code></pre><p>代码逻辑如下：</p><ol><li>代码 1 是第一层 null-safe 逻辑，用于判断元素是否为 null；</li><li>代码 2 是第二层 null-safe 逻辑，用于判断元素的条件字段是否为 null；</li><li>代码 3 是条件<code>Comparator</code>，这里使用了<code>Comparator.naturalOrder()</code>，是因为使用了<code>String</code>排序，也可以写为<code>String::compareTo</code>。如果是复杂判断，可以定义一个更加复杂的<code>Comparator</code>，组合模式就是这么好用，一层不够再套一层。</li></ol><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文演示了使用 Java8 中使用 Lambda 表达式实现各种排序逻辑，新增的语法糖真香。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/4jVPnaOr-rve3GQdukDFmA" target="_blank" rel="noopener">JDK 中居然也有反模式接口常量</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-lambda-powerful-comparation/">Java 进阶：使用 Lambda 表达式实现超强的排序功能</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">Java 进阶：使用 Lambda 表达式实现超强的排序功能</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文演示了使用 Java8 中使用 Lambda 表达式实现各种排序逻辑，新增的语法糖真香。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="JDK8" scheme="https://www.howardliu.cn/tags/JDK8/"/>
    
      <category term="Comparator" scheme="https://www.howardliu.cn/tags/Comparator/"/>
    
  </entry>
  
</feed>
