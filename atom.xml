<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沉潜飞动</title>
  
  <subtitle>君子藏器于身，待时而动。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.howardliu.cn/"/>
  <updated>2021-07-12T16:10:51.000Z</updated>
  <id>https://www.howardliu.cn/</id>
  
  <author>
    <name>Howard Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>好书不是通过价格可以衡量的，比如这本</title>
    <link href="https://www.howardliu.cn/about-the-fenix-project/"/>
    <id>https://www.howardliu.cn/about-the-fenix-project/</id>
    <published>2021-07-12T16:10:51.000Z</published>
    <updated>2021-07-12T16:10:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/bee-6354562_1920.jpg" alt="好书不是通过价格可以衡量的，比如这本"></p><p>你好，我是看山。</p><p>笔者主修Java，所以在<a href="https://www.howardliu.cn/lists-book-recommendations-2021/">《程序员进阶书单2021版》</a>主要推荐了一些Java工程师进阶必读书单。推荐原则是豆瓣的评分，结果，遗漏了一本开源书籍，甚是遗憾，今天补上。</p><a id="more"></a><p>推荐的书籍名为《凤凰架构》，开源地址是<a href="https://icyfenix.cn/" target="_blank" rel="noopener">https://icyfenix.cn/</a>。</p><p>看到凤凰，我们会想到凤凰涅槃、涅槃重生之类的词语。在作者看来，我们的系统不是一成不变的，只要在软件生命周期内，总会因为某些原因出现问题，或者是设计上的，或者是工程师代码问题，甚至最简单的网络问题。就像是凤凰浴火，经历考验，然后重生一般。</p><p>本书探讨的主题就是，如何构建一个可靠的分布式系统。这套方法论，可以让多人协作开发的系统，让一个大型的、分布式的系统，可靠的运行。这不是依赖团队成员个人能力，或者是研发质量管理就能够实现的，这是一个系统性的、架构层面的问题。想要实现这个目标，最终要依赖技术和架构。</p><p>全书主要分为5部分：</p><ul><li>演进中的架构：从历史演进过程，以全局视角，梳理微服务发展过程中出现的大量技术名词、概念。可以让我们了解技术的时代背景和探索过程。这里不得不推荐另外一本书《大型网站技术架构》，大家有时间可以看看。</li><li>架构师的视角：这一部分不是局限在某种架构的通用技巧，而是系统性地讲解做架构设计的时候，架构师都应该思考哪些问题、可以选择哪些主流的解决方案和行业标准做法，以及这些主流方案都有什么优缺点、会给架构设计带来什么影响，等等。这样一来，我们才可以把“架构设计”这样比较抽象的工作具体化、具象化。</li><li>分布式的基石：这一部分聚焦在分布式架构，探讨分布式带来的问题与应对策略。剖析分布式架构中出现的一系列问题，比如服务的注册发现、跟踪治理、负载均衡、故障隔离、认证授权、伸缩扩展、传输通讯、事务处理等，有哪些解决思路、方法和常见工具。</li><li>不可变基础设施：这一部分按照云原生时代“基础设施即代码”的新思路，深入理解基础设施不变性的目的、原理与实现途径，体会用代码和用基础设施，来解决分布式问题的差异，让我们更轻松的理解不可变基础设施的内涵，便于在实际工作中做运维、程序升级和部署等工作。</li><li>技术方法论：这一部分属于归纳总结的部分，前面都是从实践出发，让我们更加清楚如何是设计一个不断升级的系统。这一章讲述一些方法论，在我们有一定实践的基础上，构建可靠的理论体系，理论与实现相结合，相互螺旋上升。</li></ul><p>前面说了这么多，该介绍一下作者了，就是大名鼎鼎的周志明，<a href="https://book.douban.com/subject/34907497/" target="_blank" rel="noopener">《深入理解Java虚拟机》</a>作者。相信Java栈的开发者，即使没有读过这本书，也听过其名。就是这本书让笔者有爱有恨，爱的是提升了笔者对JVM的认识，恨的是提升了大家对JVM的认识。</p><p>再次附上开源地址<a href="https://icyfenix.cn/" target="_blank" rel="noopener">https://icyfenix.cn/</a>。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/lists-book-recommendations-2021/">程序员进阶书单2021版</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/about-the-fenix-project/">好书不是通过价格可以衡量的，比如这本</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/103794938" target="_blank" rel="noopener">好书不是通过价格可以衡量的，比如这本</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://static.howardliu.cn/cover/bee-6354562_1920.jpg&quot; alt=&quot;好书不是通过价格可以衡量的，比如这本&quot;&gt;&lt;/p&gt;
&lt;p&gt;你好，我是看山。&lt;/p&gt;
&lt;p&gt;笔者主修Java，所以在&lt;a href=&quot;https://www.howardliu.cn/lists-book-recommendations-2021/&quot;&gt;《程序员进阶书单2021版》&lt;/a&gt;主要推荐了一些Java工程师进阶必读书单。推荐原则是豆瓣的评分，结果，遗漏了一本开源书籍，甚是遗憾，今天补上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="书单" scheme="https://www.howardliu.cn/tags/%E4%B9%A6%E5%8D%95/"/>
    
      <category term="技术成长" scheme="https://www.howardliu.cn/tags/%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>想躺平不是错</title>
    <link href="https://www.howardliu.cn/relax-and-run/"/>
    <id>https://www.howardliu.cn/relax-and-run/</id>
    <published>2021-07-09T00:16:44.000Z</published>
    <updated>2021-07-09T00:16:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/caterpillar-6387049_1920.jpg" alt="想躺平不是错"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/jggrz-7998824/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6387049" target="_blank" rel="noopener">jggrz</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6387049" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>今天聊聊这段时间比较火的一个网络词：躺平。据说这个词还被某些网站屏蔽了，不知道这篇文章会不会也被屏蔽掉。</p><a id="more"></a><p>维基百科为<code>躺平</code>下了一个比较完善的定义：</p><blockquote><p>躺平或躺平主义是 2021 年开始在中华人民共和国流行的网络词语。指这一时期的年轻人在国内经济下滑、社会问题激化的大背景下，出于对现实环境的失望而做出的“与其跟随社会期望坚持奋斗，不如选择‘躺平’，无欲无求”的处事态度。被视为是对抗社会“内卷化”的一种方式。其具体内涵包括“不买房、不买车、不结婚、不生娃、不消费”及“维持最低生存标准，拒绝成为他人赚钱的机器和被剥削的奴隶”，是“低欲望青年”对于阶级固化的低移动性社会、中产阶级萎缩、在职贫穷、苛刻待遇、劳资关系失谐、以及不合理的社会经济结构等现况的回应。</p></blockquote><p>后面就是个人愚见了。</p><p>不禁有人会问，为什么现在年轻人要躺平呢？以前怎么没有？</p><p>怎么会没有？躺平这个词是新词，但这种想法却不是新的，新瓶装旧酒而已。</p><p>在更早的时候有一个词：三和大神。</p><p>维基百科依然可以找到解释：</p><blockquote><p>三和大神是指栖身在中国广东省深圳市龙华区景乐新村海新信人力资源市场附近的一群打工者，“三和”一词源自该区域最大的人力资源公司名称。他们居无定所，以日结薪资的临时工为生，号称“做一天可以玩三天”。这些打工者有的甚至没有身份证，身负债务，与家人鲜有来往。失去身份证无法购票，甚至无法离开三和地区。三和大神的定义同时有精神方面的因素，往往有着过一天算一天的豁达精神，不畏死，不惧穷、苦、脏。</p></blockquote><p>还有个词是“葛优躺”，2016 年的网络词，比喻自己的“颓废”的现状。</p><p><img src="http://static.howardliu.cn/raving/1f178a82b9014a90168ef327b977ad1ab21bee85.jpeg" alt="葛优躺"></p><p>再往前有个词是“佛系”，2014 年的网络词了，指无欲无求、不悲不喜、云淡风轻而追求内心平和的生活态度。</p><p>再往前，看看唐伯虎，躺的很潇洒。</p><blockquote><p>酒醒只在花前坐，酒醉还须花下眠。<br>花前花后日复日，酒醉酒醒年复年。<br>但愿老死花酒间，不愿鞠躬车马前。</p></blockquote><p>最后追上一句“世人笑我太疯癫，我笑世人看不穿。”简直是我躺平辈的真实心态。</p><p>再往前还有陶渊明，隐居山野间，“种豆南山下，草盛豆苗稀”，任由庄稼被杂草吞噬。</p><p>历史上的名人尚且如此，那些没有被历史记住的躺平青年，何其之多。躺平一词，只是给这种处事方式定了一个新说法而已。</p><p>从某度搜索这个词，结果有 1000 万条，可见热度如何。我天朝上国日益繁荣，怎么今年突然出来这么个词？</p><p>现在社会上工作的大部分人，是 80、90、00 这 30 年之间的人，正在接受生活工作的鞭挞。</p><p>改革开放 40 多年，经济迅速发展，几乎赶上欧美 200 多年的发展历程，甚至在某些领域已遥遥领先。</p><p>社会的发展不可能一蹴而就，必然是问题叠问题，不断解决问题。正在工作中努力拼搏的这批人，赶上了计划生育、90 年代的国企下岗、99 年的大学扩招、08 年的房价上涨、15 年二胎政策，以及今年的三胎政策、中考分流等。（中考分流和这批人没有直接关系，不过会跟这批人的子女有关系。）</p><p>能量守恒是自然规律。想要获得一些东西，必然需要通过等价的事物作为交换。社会发展也要遵循这个规律。</p><p>建国初期，百废待兴，需要发展。农业需要农民、工业需要工人、科研需要科学家、社会需要学者，各行各业都缺人，人多力量大。（不是说人多就有用，但是人多出现有用的人概率更大。）因此，人口数量稳步提升，但是国土面积就那么大，任由发展，就可能演变成“老鼠乌托邦”实验，所以必须刹车制动，于是有了计划生育。</p><p>后来，市场经济调控下，大锅饭不再能够保障大部分人的生活，国企经营能力赶不上社会发展，下岗成为了市场经济下的必然。但是下岗工人需要再就业、再创业。但是人口高速增长的那批正在读高中的学子马上也要毕业，怎么办？大学扩招，让这批即将毕业踏入社会的高中生，可以进入大学再学几年，大学成为分担就业压力的一个池子。</p><p>于是，本来大部分人上不了大学，变成了半数人有机会上大学。这样又造成了课外教培事业的繁荣，原本只有那些 90 分以上的孩子才能上大学。扩招之后，70 分以上都可以，那 60 分的就想往上提一下，70 分的怕被挤下来，也参加课外教培。学习上的内卷开始。也就是说，这批有躺平想法的年轻人，在学校读书的时候就被内卷过了。（这又是另外一个话题了，这里不做展开。）</p><p>等到这批扩招的大学生毕业，普通的流水线工厂肯定是不会去了，必然是要到大城市，进写字楼当白领。于是，当白领的人越来越多，但是资源就那么多，彼此竞争。白领人多了，蓝领就少了，也造成了各种用工荒。</p><p>大城市因其资源、人才、企业相互影响，产生人口聚集。人口多了，竞争压力大，教育资源紧缺，房价上涨，种种这些，压得这批年轻人喘不开气来。这些压力转变到生育上，就造成大家不愿生不敢生。人口增长缓慢，老龄化加剧，于是有了后来的鼓励生育，开放二胎三胎。</p><p>说了这么多，似乎和躺平没什么直接关系。仔细思考下，能够发现其中的必然联系。</p><p>目前 80、90、00 这群人，都是经历过社会高速发展的。到目前，我国经济水平已经赶上国际水平，跻身大国行列。后期就要更加良性的发展，不能以牺牲其他方面为代价的发展。所以，经济发展放缓必然是常态化。加上新冠疫情的出现，让这种常态化更快的到来。</p><p>总结下来，钱更难挣了。想要挣到相同的钱，需要我们的能力更强，付出更多的努力。对于这批人，车贷房贷教育费，赡养老人，抚育子女，各种事情都需要花钱。钱变得难挣，但是花钱并没有减少。</p><p>所以，想要躺会儿放松放松，把可能造成压力的事物都摒弃，让自己压力小一些。放松下来，什么也不管，无欲无求，简单度日即可。</p><p>但是，人毕竟是群居生物，有其社群关联。有父母、有妻儿，我朝亲情至上。所以上要孝敬父母，下要抚育子女，中间要与伴侣互相扶持。一时的放松可以，但是不能一直松下去。一时的放松是劳逸结合，一世的放松就是烂泥扶不上墙了。</p><p>推荐看看周董《稻香》的 MV，可以学学男主人公，当工作累了，可以回乡下老家，体验一下慢生活，给自己充充电。释放了压力，才能轻装前行。</p><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/relax-and-run/">想躺平不是错</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/118686355" target="_blank" rel="noopener">想躺平不是错</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      今天聊聊这段时间比较火的一个网络词：躺平。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="躺平" scheme="https://www.howardliu.cn/tags/%E8%BA%BA%E5%B9%B3/"/>
    
  </entry>
  
  <entry>
    <title>Java8 的时间库（3）：开始使用 Java8 中的时间类</title>
    <link href="https://www.howardliu.cn/java-date-time-migrating-to-jsr310/"/>
    <id>https://www.howardliu.cn/java-date-time-migrating-to-jsr310/</id>
    <published>2021-06-30T15:02:17.000Z</published>
    <updated>2021-06-30T15:02:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/chestnut-heath-6370080_1920.jpg" alt="Java8 的时间库（3）：开始使用 Java8 中的时间类"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/erik_karits-15012370/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6370080" target="_blank" rel="noopener">Erik Karits</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6370080" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>前面聊了聊 Java8 新版时间 API 的类，然后又说了说怎么与旧版时间 API 的转换，今天来聊聊怎样通过新 API 实现老 API 的功能，这样我们就可以逐步替换掉旧版 API，与时俱进。</p><a id="more"></a><p>Java8 之前，我们常用的时间类有<code>java.util.date</code>、<code>java.util.Calendar</code>和<code>java.util.Timezone</code>。还会有一些不那么常用的，<code>java.sql.Date</code>、<code>java.sql.TimeStamp</code>。</p><p>这些类可以实现一些简单的功能，但是要实现复杂的功能，我们只能自己实现很多工具类，或者借助第三方类库，其中比较著名的第三方库是 joda-time，后来 Java8 吸收其设计，直接让 joda-time 转正了。</p><blockquote><p>因为这个系列说的都是时间库，后文没有特殊说明，使用“新版 API”指代<code>JSR 310</code>提供的时间 API，使用“旧版 API”指代 Java 8 之前提供的官方时间 API。</p></blockquote><h2 id="新版-API-的优势"><a href="#新版-API-的优势" class="headerlink" title="新版 API 的优势"></a>新版 API 的优势</h2><p>新版 API 的优势，对应的就是旧版 API 的劣势。</p><h3 id="语义明确"><a href="#语义明确" class="headerlink" title="语义明确"></a>语义明确</h3><p>这点非常重要。</p><p>我们在定义一个实体的时候，能够做到语义明确没有歧义非常重要。</p><p>比如，我们需要定义出生日期，只需要年月日，在以前只能用<code>java.util.Date</code>，但是这个类包含时分秒。</p><p>或者，我们需要定义生日，正常只需要月日就行，连年都不需要，<code>java.util.Date</code>更加做不到。</p><p>在这些场景中，我们只能通过注释或者属性名做一些松散约束，很容易出错。</p><p>经验告诉我们，人是不可靠的，约定是不可靠的，只要有犯错的可能，就一定会犯错。</p><p>新版 API 完美解决这个问题，提供具有不同语义且语义明确的类。如果想表示日期可以用<code>LocalDate</code>，如果想表示生日，可以用<code>MonthDay</code>。这样，我们就能够借助编译器增强约束力。</p><h3 id="符合自然规律"><a href="#符合自然规律" class="headerlink" title="符合自然规律"></a>符合自然规律</h3><p>我们来通过一段代码感受下（测试日期是 2021 年 6 月 28 日），执行结果放在每行结尾处：</p><pre><code class="java">Date date = new Date();System.out.println(date);// Mon Jun 28 21:41:25 CST 2021System.out.println(date.getYear());// 121System.out.println(date.getMonth());// 5System.out.println(date.getDay());// 1Calendar calendar = Calendar.getInstance();calendar.setTime(date);System.out.println(calendar.get(Calendar.YEAR));// 2021System.out.println(calendar.get(Calendar.MONTH));// 5System.out.println(calendar.get(Calendar.DAY_OF_MONTH));// 28LocalDate localDate = LocalDate.now();System.out.println(localDate.getYear());// 2021System.out.println(localDate.getMonth());// JUNESystem.out.println(localDate.getDayOfMonth());// 28</code></pre><p>仅仅一个年月日的获取，旧版 API 已经是存在各种含义。</p><p><code>java.util.Date#getYear</code>表示的是当前年份减去 1900；<code>java.util.Date#getDay</code>返回的是当前是一周中的第几天，下标从 0 开始。当然，这几个 API 在 JDK1.1 的时候已经标记废弃了，但是知道现在也没有删除。相信很多初次使用旧版 API 的同学，都可能踩过坑。</p><p>更甚的是，<code>java.util.Date</code>和<code>java.util.Calendar</code>的返回的月份，都是从 0 开始计数的。但是年和日是从 1 开始计数，实在没有搞懂当时开发人员的脑回路是怎样的。</p><p>再看新版 API，完全符合我们的认知：年是自然年，月使用<code>Month</code>枚举（枚举的 value 值是自然月），日是自然日，一切都是根据我们对自然规律的理解。</p><p>而且，新版 API 很贴心的考虑了夏令时，在使用<code>ZonedDateTime</code>进行不同区域时间转换时，会自动计算。可以说，关于时间的逻辑，新版 API 已经都包含了。</p><h3 id="功能完善"><a href="#功能完善" class="headerlink" title="功能完善"></a>功能完善</h3><p>旧版 API 提供的时间类，只能实现一些简单的逻辑，想要做一些复杂的操作，就需要自己实现。新版 API 提供了灵活的时间功能 API。</p><ul><li><code>Instant</code>：表示时间戳，也就是一个时间点。</li><li><code>LocalDate</code>：表示日期，年、月、日</li><li><code>LocalTime</code>：表示时间，时、分、秒、纳秒</li><li><code>LocalDateTime</code>：表示日期+时间，内部也是通过<code>LocalDate</code>和<code>LocalTime</code>存储数据的</li><li><code>OffsetDateTime</code>：带有时间偏移的<code>LocalDateTime</code></li><li><code>OffsetTime</code>：带有时间偏移的<code>LocalTime</code></li><li><code>ZonedDateTime</code>：比<code>OffsetDateTime</code>多了时区，也就是带有时区、带有时间偏移的<code>LocalDateTime</code></li><li><code>MonthDay</code>：表示月、日，不包含年和时间</li><li><code>YearMonth</code>：表示年、月，不包含日和时间</li><li><code>Duration</code>：表示纳秒、秒的时间量，可以度量天、小时、分、秒、毫秒、纳秒。</li><li><code>Period</code>：表示年、月、日的时间量，可以度量年、月、日、周。</li></ul><p>有了上面这些类，我们可以在操作时间时横着走了。</p><h3 id="不可变（线程安全）"><a href="#不可变（线程安全）" class="headerlink" title="不可变（线程安全）"></a>不可变（线程安全）</h3><p>上面提到的这些类中，都是不可修改的，这些类的成员变量都使用<code>final</code>修饰，所有需要修改数据的方法，都是返回一个新实例。新版 API 通过这种方式实现了时间类的不可变性。</p><p>我们都知道，一个对象是不可变的，那它就是线程安全的。</p><p>旧版 API 的则不是这样，数据可变且对并发敏感。当然，这只能算是设计初衷不同。</p><p>新版 API 表示时间的类是线程安全的，可以对时间格式化的<code>DateTimeFormatter</code>也是时间安全的。</p><p>旧版的<code>SimpleDateFormat</code>也是类似的功能，但却不是线程安全的。这点就不是设计初衷不同了，而是缺少设计。相信很多没有被这个类毒打过的小白，会定义一些工具类，里面是<code>static</code>定义的<code>SimpleDateFormat</code>，然后对时间进行格式化，测试的时候没有一点问题，放在线上就出现各种诡异错误。</p><h2 id="开启征程"><a href="#开启征程" class="headerlink" title="开启征程"></a>开启征程</h2><p>我们通过一些常用场景，展示新旧版本 API 的实现方式。</p><h3 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h3><p>旧版 API：</p><pre><code class="java">Date now = new Date();</code></pre><p>新版 API：</p><pre><code class="java">// 没有偏移、没有时区概念的当前时间LocalDateTime now = LocalDateTime.now();// 有偏移和时区的当前时间ZonedDateTime now2 = ZonedDateTime.now();</code></pre><h3 id="指定日期"><a href="#指定日期" class="headerlink" title="指定日期"></a>指定日期</h3><p>旧版 API：</p><pre><code class="java">Date birthday = new GregorianCalendar(1988, Calendar.AUGUST, 20).getTime();</code></pre><p>新版 API：</p><pre><code class="java">LocalDate birthday = LocalDate.of(1988, Month.AUGUST, 20);LocalDate birthday2 = LocalDate.of(1988, 8, 20);</code></pre><h3 id="获取指定量"><a href="#获取指定量" class="headerlink" title="获取指定量"></a>获取指定量</h3><p>旧版 API：</p><pre><code class="java">int month = new GregorianCalendar().get(Calendar.MONTH);</code></pre><p>新版 API：</p><pre><code class="java">Month month = LocalDateTime.now().getMonth();</code></pre><h3 id="调整时间"><a href="#调整时间" class="headerlink" title="调整时间"></a>调整时间</h3><p>比如，获取当前之间 5 小时前的时间。</p><p>旧版 API：</p><pre><code class="java">GregorianCalendar calendar = new GregorianCalendar();calendar.add(Calendar.HOUR_OF_DAY, -5);Date fiveHoursBefore = calendar.getTime();</code></pre><p>新版 API：</p><pre><code class="java">LocalDateTime fiveHoursBefore = LocalDateTime.now().minusHours(5);</code></pre><h3 id="调整指定时间量"><a href="#调整指定时间量" class="headerlink" title="调整指定时间量"></a>调整指定时间量</h3><p>比如，将时间调整到 6 月。</p><p>旧版 API：</p><pre><code class="java">GregorianCalendar calendar = new GregorianCalendar();calendar.set(Calendar.MONTH, Calendar.JUNE);Date inJune = calendar.getTime();</code></pre><p>新版 API：</p><pre><code class="java">LocalDateTime inJune = LocalDateTime.now().withMonth(Month.JUNE.getValue());</code></pre><h3 id="截断时间量"><a href="#截断时间量" class="headerlink" title="截断时间量"></a>截断时间量</h3><p>我们有时候会将时间对象某个单位后面的所有时间量设置为 0，这个操作形象的称为截断。比如，将分、秒、毫秒设置为零。</p><p>旧版 API：</p><pre><code class="java">Calendar now = Calendar.getInstance();now.set(Calendar.MINUTE, 0);now.set(Calendar.SECOND, 0);now.set(Calendar.MILLISECOND, 0);Date truncated = now.getTime();</code></pre><p>新版 API：</p><pre><code class="java">LocalTime truncated = LocalTime.now().truncatedTo(ChronoUnit.HOURS);</code></pre><h3 id="时区转换"><a href="#时区转换" class="headerlink" title="时区转换"></a>时区转换</h3><p>旧版 API：</p><pre><code class="java">GregorianCalendar calendar = new GregorianCalendar();calendar.setTimeZone(TimeZone.getTimeZone(&quot;CET&quot;));Date centralEastern = calendar.getTime();</code></pre><p>新版 API：</p><pre><code class="java">ZonedDateTime centralEastern = LocalDateTime.now().atZone(ZoneId.of(&quot;CET&quot;));</code></pre><h3 id="计算时间跨度"><a href="#计算时间跨度" class="headerlink" title="计算时间跨度"></a>计算时间跨度</h3><p>旧版 API：</p><pre><code class="java">GregorianCalendar calendar = new GregorianCalendar();Date now = new Date();calendar.add(Calendar.HOUR, 1);Date hourLater = calendar.getTime();long elapsed = hourLater.getTime() - now.getTime();</code></pre><p>新版 API：</p><pre><code class="java">LocalDateTime now = LocalDateTime.now();LocalDateTime hourLater = LocalDateTime.now().plusHours(1);Duration span = Duration.between(now, hourLater);</code></pre><p><code>Duration</code>是跨度较小，可以度量天、小时、分、秒、毫秒、纳秒。如果跨度较大，可以使用<code>Period</code>，可以度量年、月、日、周。</p><h3 id="时间格式化和解析"><a href="#时间格式化和解析" class="headerlink" title="时间格式化和解析"></a>时间格式化和解析</h3><p>新版 API 使用<code>DateTimeFormatter</code>，这个类是线程安全的。而且相较于<code>SimpleDateFormat</code>提供了很多额外的功能。</p><p>旧版 API：</p><pre><code class="java">SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);Date now = new Date();String formattedDate = dateFormat.format(now);Date parsedDate = dateFormat.parse(formattedDate);</code></pre><p>新版 API：</p><pre><code class="java">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);LocalDate now = LocalDate.now();String formattedDate = now.format(formatter);LocalDate parsedDate = LocalDate.parse(formattedDate, formatter);</code></pre><h3 id="其他一些小功能"><a href="#其他一些小功能" class="headerlink" title="其他一些小功能"></a>其他一些小功能</h3><p>比如，计算一个月有几天：</p><p>旧版 API：</p><pre><code class="java">Calendar calendar = new GregorianCalendar(1990, Calendar.FEBRUARY, 20);int daysInMonth = calendar.getActualMaximum(Calendar.DAY_OF_MONTH);</code></pre><p>新版 API：</p><pre><code class="java">int daysInMonth = YearMonth.of(1990, 2).lengthOfMonth();</code></pre><h2 id="新旧版-API-的转换"><a href="#新旧版-API-的转换" class="headerlink" title="新旧版 API 的转换"></a>新旧版 API 的转换</h2><p>新版 API 虽然好用，但是罗马不是一天建成的。旧版 API 不会一夜消失，可能需要共用。Java 8 提供了很多方法，用来在新旧版本 API 之间进行转换。比如：</p><pre><code class="java">// 从 Calendar 转换 InstantInstant instantFromCalendar = GregorianCalendar.getInstance().toInstant();// 从 Calendar 转换 ZonedDateTimeZonedDateTime zonedDateTimeFromCalendar = new GregorianCalendar().toZonedDateTime();// 从 Instant 转换 DateDate dateFromInstant = Date.from(Instant.now());// 从 ZonedDateTime 转换 CalendarGregorianCalendar calendarFromZonedDateTime = GregorianCalendar.from(ZonedDateTime.now());// 从 Date 转换 InstantInstant instantFromDate = new Date().toInstant();// 从 TimeZone 转换 ZoneIdZoneId zoneIdFromTimeZone = TimeZone.getTimeZone(&quot;PST&quot;).toZoneId();</code></pre><p>更多的内容可以看看该系列的另一篇：<a href="https://www.howardliu.cn/java-date-to-localdate-and-localdatetime/">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a>。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>在本文中，我们讲解了旧版 API 的缺点、新版 API 的优点。新版 API 提供了很多友好的方法，而且不同类之间操作几乎一致，所以很多例子虽然只是说了一个类的使用，但是其他类也可以采用相似方式实现。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol><li><a href="https://www.howardliu.cn/java-date-and-time-intro/">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://www.howardliu.cn/java-date-to-localdate-and-localdatetime/">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://www.howardliu.cn/java-date-time-migrating-to-jsr310/">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li>未完待续……</li></ol><hr><p>你好，我是看山，10 年老猿，开源贡献者。游于码界，戏享人生。关注公众号：<a href="http://static.howardliu.cn/about/kanshanshuo.png" target="_blank" rel="noopener">看山的小屋</a>，领取学习资料。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-date-time-migrating-to-jsr310/">Java8 的时间库（3）：开始使用 Java8 中的时间类</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/103794938" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      前面聊了聊 Java8 新版时间 API 的类，然后又说了说怎么与旧版时间 API 的转换，今天来聊聊怎样通过新 API 实现老 API 的功能，这样我们就可以逐步替换掉旧版 API，与时俱进。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="Date" scheme="https://www.howardliu.cn/tags/Date/"/>
    
      <category term="Time" scheme="https://www.howardliu.cn/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>如果非要在多线程中使用 ArrayList 会发生什么？（第二篇）</title>
    <link href="https://www.howardliu.cn/arraylist-is-not-thread-safe-2/"/>
    <id>https://www.howardliu.cn/arraylist-is-not-thread-safe-2/</id>
    <published>2021-06-29T15:18:18.000Z</published>
    <updated>2021-06-29T15:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/home-studios-5249651_1920.jpg" alt="如果非要在多线程中使用 ArrayList 会发生什么？（第二篇）"></p><p>你好，我是看山。</p><p>前面写过一篇文章 <a href="https://howardliu.cn/arraylist-is-not-thread-safe/" target="_blank" rel="noopener">《如果非要在多线程中使用 ArrayList 会发生什么？》</a>，有读者反馈，Java 11 代码已经修复，还会出现 null 元素。</p><p>为了便于理解，当时只是通过代码执行顺序说明了异常原因。其实多线程中还会涉及 Java 内存模型，本文就从这方面说明一下。</p><a id="more"></a><h2 id="对比源码"><a href="#对比源码" class="headerlink" title="对比源码"></a>对比源码</h2><p>我们先来看看 Java 11 中，<code>add</code>方法做了什么调整。</p><p>Java 8 中<code>add</code>方法的实现：</p><pre><code class="java">public boolean add(E e) {    ensureCapacityInternal(size + 1);    elementData[size++] = e;    return true;}</code></pre><p>Java 11 中<code>add</code>方法的实现：</p><pre><code class="java">public boolean add(E e) {    modCount++;    add(e, elementData, size);    return true;}private void add(E e, Object[] elementData, int s) {    if (s == elementData.length)        elementData = grow();    elementData[s] = e;    size = s + 1;}</code></pre><p>两段逻辑的差异在于数组下标是否确定：</p><ul><li><code>elementData[size++] = e;</code>，Java 8 中直接使用<code>size</code>定位并赋值，然后通过<code>size++</code>自增</li><li><code>elementData[s] = e; size = s + 1;</code>，Java 11 借助临时变量<code>s</code>定位并赋值，然后通过<code>size = s + 1</code>给<code>size</code>赋新值</li></ul><p>Java 11 的优点在于，为数组指定元素赋值的时候，下标值是确定的。也就是说，只要进入<code>add(E e, Object[] elementData, int s)</code>方法中，就只会处理指定位置的数组元素。并且，<code>size</code>的值也是根据<code>s</code>增加。按照执行顺序推断，最终的结果可能会丢数，但是不会出现 null。（多个线程向同一个下标赋值，即<code>s</code>相等，那最终<code>size</code>也相等。）</p><h2 id="验证一下"><a href="#验证一下" class="headerlink" title="验证一下"></a>验证一下</h2><p>让我们来验证下。</p><pre><code class="java">package com.kuaishou.is.datamart;import java.util.ArrayList;import java.util.List;import java.util.concurrent.CountDownLatch;public class Main {    public static void main(String[] args) throws InterruptedException {        List&lt;String&gt; list = new ArrayList&lt;&gt;();        CountDownLatch latch = new CountDownLatch(1);        CountDownLatch waiting = new CountDownLatch(3);        Thread t1 = new Thread(() -&gt; {            try {                latch.await();                for (int i = 0; i &lt; 1000; i++) {                    list.add(&quot;1&quot;);                }            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                waiting.countDown();            }        });        Thread t2 = new Thread(() -&gt; {            try {                latch.await();                for (int i = 0; i &lt; 1000; i++) {                    list.add(&quot;2&quot;);                }            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                waiting.countDown();            }        });        Thread t2 = new Thread(() -&gt; {            try {                latch.await();                for (int i = 0; i &lt; 1000; i++) {                    list.add(&quot;2&quot;);                }            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                waiting.countDown();            }        });        t1.start();        t2.start();        latch.countDown();        waiting.await();        System.out.println(list);    }}</code></pre><p>在 Java 8 和 Java 11 中分别执行，果然，出现了<code>ArrayIndexOutOfBoundsException</code>和<code>null</code>的情况。如果没有出现，那就是姿势不对，需要多试几次或者多几个线程。</p><h2 id="换个角度想问题"><a href="#换个角度想问题" class="headerlink" title="换个角度想问题"></a>换个角度想问题</h2><p>上一篇通过代码执行顺序解释了出现问题的原因，这次再看看 JMM 的原因。</p><p><img src="http://static.howardliu.cn/java/jmm.png" alt="jmm"></p><p>从上图我们可以看到，Java 为每个线程创建了一个本地内存区域，也就是说，代码运行过程中使用的数据，是线程本地缓存的数据。这份缓存的数据，会与主内存的数据做交换（更新主内存数据或更新本次缓存中的数据）。</p><p>我们通过一个时序图看下为什么会出现 null（数组越界异常同理）：</p><p><img src="http://static.howardliu.cn/java/arraylist-add.png" alt="多线程场景下 ArrayList#add 方法的时序图"></p><p>从时序图我们可以看出现，在执行过程中，两个线程取的<code>size</code>值和<code>elementData</code>数组地址，大部分是操作自己本地缓存中的，执行一段时间后，会将本地缓存中的数据写回主内存数据，然后还会从主内存中读取最新数据更新本地缓存数据。异常就在这个交换过程中发生了。</p><p>这个时候，可能有读者会想，是不是把<code>size</code>和<code>elementData</code>两个变量加上<code>volatile</code>就可以解决了。如果这样想，那你就想简单。线程安全是整个类设计实现时已经确定了，除了属性需要考虑多线程的影响，方法（主要是会修改属性元素的方法）也需要考虑。</p><p><code>ArrayList</code>的定位是非线程安全的，其中的所有方法都没有考虑多线程下为共享资源加锁。即使<code>size</code>和<code>elementData</code>两个变量都是实时读写主内存，但是<code>add</code>和<code>grow</code>方法还是可能会覆盖另一个线程的数据。</p><p>我们从<code>ArrayList</code>的<code>add</code>方法注释可以得知，方法拆分不是为了实现线程安全，而是为了执行效率和内存占用：</p><blockquote><p>This helper method split out from add(E) to keep method bytecode size under 35 (the -XX:MaxInlineSize default value), which helps when add(E) is called in a C1-compiled loop.</p></blockquote><p>所以说，在多线程场景下使用<code>ArrayList</code>，该出现的异常，一个也不会少。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol><li><a href="https://www.howardliu.cn/arraylist-is-not-thread-safe/">如果非要在多线程中使用 ArrayList 会发生什么？</a></li><li><a href="https://www.howardliu.cn/arraylist-is-not-thread-safe-2/">如果非要在多线程中使用 ArrayList 会发生什么？（第二篇）</a></li></ol><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/arraylist-is-not-thread-safe-2/">如果非要在多线程中使用 ArrayList 会发生什么？（第二篇）</a><br>CSDN 主页：<a href="http://kanshan.csdn.net/" target="_blank" rel="noopener">http://kanshan.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.csdn.net/article/details/118346355" target="_blank" rel="noopener">如果非要在多线程中使用 ArrayList 会发生什么？（第二篇）</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      如果非要在多线程中使用 ArrayList 会发生什么？（第二篇）
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="ArrayList" scheme="https://www.howardliu.cn/tags/ArrayList/"/>
    
      <category term="线程安全" scheme="https://www.howardliu.cn/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</title>
    <link href="https://www.howardliu.cn/java-date-to-localdate-and-localdatetime/"/>
    <id>https://www.howardliu.cn/java-date-to-localdate-and-localdatetime/</id>
    <published>2021-06-22T14:50:46.000Z</published>
    <updated>2021-06-22T14:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/rome-6207755_1920.jpg" alt="Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换"></p><p>你好，我是看山。</p><p>从 Java1 到 Java8 将近 20 年，再加上 Java8 的普及时间、各种历史 API 兼容过渡时间。我们很多时候需要在旧时间 API 与新时间 API 之间切换，并行使用。今天就来说说，<code>java.util.Date</code>与<code>java.time.LocalDate/LocalDateTime</code>如何互相转换。</p><a id="more"></a><h2 id="java-util-Date转为java-time-LocalDate"><a href="#java-util-Date转为java-time-LocalDate" class="headerlink" title="java.util.Date转为java.time.LocalDate"></a><code>java.util.Date</code>转为<code>java.time.LocalDate</code></h2><p>Java8 发行的时候，也考虑到了新旧 API 之间的转换，所以在<code>java.util.Date</code>中增加了<code>toInstance()</code>方法，可以得到一个<code>Instance</code>实例。<code>Instance</code>没有时区概念，所以我们需要通过<code>atZone()</code>指定时区，得到<code>ZonedDateTime</code>实例，然后转换为<code>java.time.LocalDate</code>。如下：</p><pre><code class="java">public LocalDate convertToLocalDateViaInstant(Date dateToConvert) {    return dateToConvert.toInstant()            .atZone(ZoneId.systemDefault())            .toLocalDate();}</code></pre><p>同样的，我们也可以借助<code>Instance</code>的<code>ofEpochMilli()</code>方法创建实例。如下：</p><pre><code class="java">public LocalDate convertToLocalDateViaMilisecond(Date dateToConvert) {    return Instant.ofEpochMilli(dateToConvert.getTime())            .atZone(ZoneId.systemDefault())            .toLocalDate();}</code></pre><p>Java 中，除了<code>java.util.Date</code>，还有一个 Date 对象是<code>java.sql.Date</code>，java8 给这个类增加了一个直接转换为<code>LocalDate</code>的方法<code>toLocalDate()</code>。所以，我们也可以将<code>java.util.Date</code>转换为<code>java.sql.Date</code>，然后借助<code>toLocalDate()</code>方法。如下：</p><pre><code class="java">public LocalDate convertToLocalDateViaSqlDate(Date dateToConvert) {    return new java.sql.Date(dateToConvert.getTime()).toLocalDate();}</code></pre><h2 id="java-util-Date转为java-time-LocalDateTime"><a href="#java-util-Date转为java-time-LocalDateTime" class="headerlink" title="java.util.Date转为java.time.LocalDateTime"></a><code>java.util.Date</code>转为<code>java.time.LocalDateTime</code></h2><p><code>java.util.Date</code>是包含年月日时分秒的，转为<code>java.time.LocalDate</code>是把时分秒去掉，转为<code>java.time.LocalDateTime</code>是精度保留，转换方式完全一样，只不过要用到的是<code>toLocalDateTime()</code>方法。如下：</p><pre><code class="java">public LocalDateTime convertToLocalDateTimeViaInstant(Date dateToConvert) {    return dateToConvert.toInstant()            .atZone(ZoneId.systemDefault())            .toLocalDateTime();}public LocalDateTime convertToLocalDateTimeViaMilisecond(Date dateToConvert) {    return Instant.ofEpochMilli(dateToConvert.getTime())            .atZone(ZoneId.systemDefault())            .toLocalDateTime();}</code></pre><p><code>java.sql.Date</code>精度只有年月日，<code>java.sql.Timestamp</code>精度包含时分秒，所以还可以借助这个类的<code>toLocalDateTime()</code>方法实现转换：</p><pre><code class="java">LocalDateTime convertToLocalDateTimeViaSqlTimestamp(Date dateToConvert) {    return new java.sql.Timestamp(dateToConvert.getTime()).toLocalDateTime();}</code></pre><p>接下来，我们看看怎么从新时间 API 转旧时间 API。</p><h2 id="java-time-LocalDate转为java-util-Date"><a href="#java-time-LocalDate转为java-util-Date" class="headerlink" title="java.time.LocalDate转为java.util.Date"></a><code>java.time.LocalDate</code>转为<code>java.util.Date</code></h2><p>先来一个简单的方法，借助<code>java.sql.Date</code>的<code>valueOf()</code>方法，如下：</p><pre><code class="java">public java.util.Date convertToDateViaSqlDate(LocalDate dateToConvert) {    return java.sql.Date.valueOf(dateToConvert);}</code></pre><p><code>java.sql.Date.valueOf()</code>方法的实现也比较简单，我们也可以自己实现：</p><pre><code class="java">public static Date valueOf(LocalDate date) {    return new Date(date.getYear() - 1900,            date.getMonthValue() - 1,            date.getDayOfMonth());}</code></pre><blockquote><p>题外话：不知为何 Java8 这么偏爱<code>java.sql.Date</code>，提供了各种好用的转换方法。但是按照我的习惯，大部分时间用的都是<code>java.util.Date</code>类，是不是这个习惯得改改了。</p></blockquote><p>还有一种方式，是借助<code>java.util.Date</code>的<code>from(Instant instant)</code>方法，如下：</p><pre><code class="java">public java.util.Date convertToDateViaInstant(LocalDate dateToConvert) {    return java.util.Date.from(dateToConvert.atStartOfDay().atZone(ZoneId.systemDefault())            .toInstant());}</code></pre><h2 id="java-time-LocalDateTime转为java-util-Date"><a href="#java-time-LocalDateTime转为java-util-Date" class="headerlink" title="java.time.LocalDateTime转为java.util.Date"></a><code>java.time.LocalDateTime</code>转为<code>java.util.Date</code></h2><p>介绍两种方式。</p><p>一种是借助<code>java.sql.Timestamp</code>的<code>valueOf()</code>方法，如下：</p><pre><code class="java">public java.util.Date convertToDateViaSqlTimestamp(LocalDateTime dateToConvert) {    return java.sql.Timestamp.valueOf(dateToConvert);}</code></pre><p>另一种方式是：</p><pre><code class="java">public java.util.Date convertToDateViaInstant(LocalDateTime dateToConvert) {    return java.util.Date.from(dateToConvert.atZone(ZoneId.systemDefault())            .toInstant());}</code></pre><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>虽然 Java8 已经是行业底线，但是为了向下兼容，很多类库或者遗留代码依然保留了旧 API，不可能一夜之间替换完毕，所以我们还是会有新旧 API 的转换。本文提供几种转换方式，可供大家使用。当然，条条大路通罗马，这些方法都不是唯一的方式。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/eugenp/tutorials/tree/master/core-java-modules/core-java-8-datetime" target="_blank" rel="noopener">core-java-8-datetime</a></li></ul><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol><li><a href="https://www.howardliu.cn/java-date-and-time-intro/">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://www.howardliu.cn/java-date-to-localdate-and-localdatetime/">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li></ol><hr><p>你好，我是看山，10 年老猿，开源贡献者。游于码界，戏享人生。关注公众号：<a href="http://static.howardliu.cn/about/kanshanshuo.png" target="_blank" rel="noopener">看山的小屋</a>，领取学习资料。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-date-to-localdate-and-localdatetime/">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/118121634" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      从 Java1 到 Java8 将近 20 年，再加上 Java8 的普及时间、各种历史 API 兼容过渡时间。我们很多时候需要在旧时间 API 与新时间 API 之间切换，并行使用。今天就来说说，java.util.Date 与 java.time.LocalDate/LocalDateTime 如何互相转换。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="Date" scheme="https://www.howardliu.cn/tags/Date/"/>
    
      <category term="Time" scheme="https://www.howardliu.cn/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</title>
    <link href="https://www.howardliu.cn/java-date-and-time-intro/"/>
    <id>https://www.howardliu.cn/java-date-and-time-intro/</id>
    <published>2021-06-15T15:03:23.000Z</published>
    <updated>2021-06-15T15:03:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/strawberries-6165597_1920.jpg" alt="Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/onderortel-8618939/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6165597" target="_blank" rel="noopener">Önder Örtel</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6165597" target="_blank" rel="noopener">Pixabay</a>上发布</p></blockquote><p>你好，我是看山。</p><p>年龄大的 Java 程序员都有体会，Java8 之前，Java 提供了一组时间类：<code>java.util.Date</code>、<code>java.util.Calendar</code>及其子类和工具类等。功能比较全面，最大的缺点是难用。所以很多团队直接放弃原生时间类，使用第三方的时间类库。后来，Java8 吸收了 joda-time 的优秀设计，提供了一组新的时间处理 API<code>java.time.</code>。</p><p>本文作为这个系列的第一篇，扒一扒<code>Date</code>和<code>Calendar</code>存在的问题，说说 Java8 提供的时间库是怎么解决这些问题的。后续再说一下 Java8 中<code>java.time.</code>包中的一些核心类，例如<code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>、<code>ZonedDateTime</code>、<code>Period</code>、<code>Duration</code>。</p><a id="more"></a><h2 id="老时间-API-存在的问题"><a href="#老时间-API-存在的问题" class="headerlink" title="老时间 API 存在的问题"></a>老时间 API 存在的问题</h2><ol><li>线程安全性：老的时间 API 是非线程安全的，而我们的代码都是运行在并发环境下，这样就不得不处理难以调试的并发问题，而且还需要额外的代码处理线程安全。一不小心，就会碰到一些比较诡异的错误，本地还不容易复现，比如定义了一个公用的<code>SimpleDateFormt</code>去操作时间，偶尔并发时会出错，只能通过迂回的办法实现（比如借助<code>ThreadLocal</code>）。在 Java8 中引入的新时间 API 是不可变对象，天然保证了线程安全。</li><li>API 设计和可理解性：老的时间 API 在这设计上没有一致的模型，而且日常操作功能不全。而且有一些比较让人诟病的设计，比如<code>Date</code>类的构造方法<code>public Date(int year, int month, int date)</code>，其中<code>month</code>字段取值是<code>0-11</code>，也就是按照计算机的 0 作为第一个数，但是<code>day</code>没有这种情况，取值是<code>1-31</code>，很容易搞错。新 API 以 ISO 为中心，遵循日期、时间、持续时间、时间间隔等一致的域模型，而且为时间 API 增加很多实用的工具方法。</li><li>时区处理：老的时间 API 在处理时区逻辑时比较繁琐，但是在新的 API 中，只需要通过<code>Local*</code>或<code>Zoned*</code>等类处理时区即可。</li></ol><p>下面就开始实际上手 Java8 的时间 API 了。</p><h2 id="LocalDate、LocalTime、LocalDateTime"><a href="#LocalDate、LocalTime、LocalDateTime" class="headerlink" title="LocalDate、LocalTime、LocalDateTime"></a>LocalDate、LocalTime、LocalDateTime</h2><p>这三个是最常用的几个时间类了，根据名字可以知道，这三个类是默认使用当前机器上的时区作为参考系的时间对象。也就是说，在不需要显示指定时区时，我们就可以使用这几个类。</p><h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><p><code>LocalDate</code>是 ISO 格式（yyyy-MM-dd）的日期，没有时分秒的时间数据。我们可以用它表示生日、放假等只关心日期的数据。通过<code>now</code>方法创建当前日期实例：</p><pre><code class="java">LocalDate localDate = LocalDate.now();</code></pre><p>这里是使用机器时间创建的。</p><p>我们还可以使用<code>of</code>方法或<code>parse</code>方法获取指定日期的<code>LocalDate</code>实例，比如，我们想要时间为 2021 年 6 月 11 号：</p><pre><code class="java">LocalDate.of(2021, 6, 11);LocalDate.parse(&quot;2021-06-11&quot;);</code></pre><p><code>LocalDate</code>还提供了各种实用方法来获取时间信息，接下来快速浏览一下这些 API 方法。</p><ol><li>获取明天的日期，即当前日期加一天：</li></ol><pre><code class="java">LocalDate tomorrow = LocalDate.now().plusDays(1);</code></pre><ol start="2"><li>获取上个月的今天，即当前日期并减去一个月（我们可以使用枚举单位操作数据）：</li></ol><pre><code class="java">LocalDate previousMonthSameDay = LocalDate.now().minus(1, ChronoUnit.MONTHS);`</code></pre><ol start="3"><li>解析日期“2021-06-11”，并获取周几（结果<code>DayOfWeek</code>是一个枚举类，设计很周到）：</li></ol><pre><code class="java">DayOfWeek friday = LocalDate.parse(&quot;2021-06-11&quot;).getDayOfWeek();</code></pre><ol start="4"><li>解析日期“2021-06-11”，并获取几号：</li></ol><pre><code class="java">int eleven = LocalDate.parse(&quot;2021-06-11&quot;).getDayOfMonth();</code></pre><ol start="5"><li>检查一个日期的年份是否是闰年：</li></ol><pre><code class="java">boolean leapYear = LocalDate.now().isLeapYear();</code></pre><ol start="6"><li>判断一个日期是否在另外一个日期之前：</li></ol><pre><code class="java">boolean isBefore = LocalDate.parse(&quot;2021-06-11&quot;).isBefore(LocalDate.parse(&quot;2021-06-12&quot;));</code></pre><ol start="7"><li>判断一个日期是否在另外一个日期之后：</li></ol><pre><code class="java">boolean isAfter = LocalDate.parse(&quot;2021-06-12&quot;).isAfter(LocalDate.parse(&quot;2021-06-11&quot;));</code></pre><ol start="8"><li>获取给定日期的当天开始时间，比如给定“2021-06-11”，想要获取“2021-06-11T00:00”（也就是当天的 0 点时间）：</li></ol><pre><code class="java">LocalDateTime beginningOfDay = LocalDate.parse(&quot;2021-06-11&quot;).atStartOfDay();</code></pre><ol start="9"><li>获取给定日期所在月份的的第一天，比如给定“2021-06-11”，想要获取“2021-06-01”：</li></ol><pre><code class="java">LocalDate firstDayOfMonth = LocalDate.parse(&quot;2021-06-11&quot;).with(TemporalAdjusters.firstDayOfMonth());</code></pre><h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p><code>LocalDate</code>是 ISO 格式（yyyy-MM-dd）的日期，没有时分秒的时间数据。我们可以用它表示生日、放假等只关心日期的数据。通过<code>now</code>方法创建当前日期实例：</p><p><code>LocalTime</code>提供的是没有日期数据的时间，只有时分秒数据。这个类很多方法与<code>LocalDate</code>类似，所以我们快速过一下这些 API 方法。</p><ol><li>创建当前时间</li></ol><pre><code class="java">LocalTime now = LocalTime.now();</code></pre><ol start="2"><li>解析给定的字符串时间，可以使用<code>of</code>和<code>parse</code>方法，比如下午 4:30：</li></ol><pre><code class="java">LocalTime sixty30 = LocalTime.parse(&quot;16:30&quot;);LocalTime sixty31 = LocalTime.of(16, 31);</code></pre><ol start="3"><li>解析给定字符串时间，并获取一小时后的时间实例：</li></ol><pre><code class="java">LocalTime seventy30 = LocalTime.parse(&quot;16:30&quot;).plus(1, ChronoUnit.HOURS);</code></pre><ol start="4"><li>获取给定字符串时间的小时数：</li></ol><pre><code class="java">int sixty = LocalTime.parse(&quot;16:30&quot;).getHour();</code></pre><ol start="5"><li>判断一个时间是否在另外一个时间之前：</li></ol><pre><code class="java">boolean isBeforeTime = LocalTime.parse(&quot;16:30&quot;).isBefore(LocalTime.parse(&quot;17:30&quot;));</code></pre><ol start="6"><li>判断一个时间是否在另外一个时间之后：</li></ol><pre><code class="java">boolean isAfterTime = LocalTime.parse(&quot;17:30&quot;).isAfter(LocalTime.parse(&quot;16:30&quot;));</code></pre><ol start="7"><li>常用的时间常量：</li></ol><pre><code class="java">LocalTime.MIN;// 00:00LocalTime.NOON;// 12:00LocalTime.MAX;// 23:59:59.999999999LocalTime.MIDNIGHT;// 00:00</code></pre><h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>顾名思义，<code>LocalDateTime</code>表示日期和时间的组合。有了前两个类做铺垫，这个类也是很类似的操作。</p><ol><li>创建当前时间</li></ol><pre><code class="java">LocalDateTime.now();</code></pre><ol start="2"><li>解析给定的字符串时间，可以使用<code>of</code>和<code>parse</code>方法，比如 2021 年 6 月 11 日 16 点 30 分：</li></ol><pre><code class="java">LocalDateTime.of(2021, Month.JUNE, 11, 16, 30);LocalDateTime.parse(&quot;2021-06-11T16:30:00&quot;);// 注意这个时间格式，这种写法属于 UTC 时间格式，后续再开文说一下时间格式的话题。</code></pre><p>其他与<code>LocalDate</code>和<code>LocalTime</code>类似的 API，比如<code>plusDays</code>、<code>MinsHours</code>、<code>getMonth</code>等。我们可以把<code>LocalDateTime</code>理解为<code>LocalDate</code>和<code>LocalTime</code>的合体。</p><p><code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>处理的都是当前系统所在时区的日期时间数据，有时候我们还需要处理特定时区的日期和时间，Java8 提供了<code>ZonedDateTime</code>，接下来我们说说这个类。</p><h2 id="ZonedDateTime"><a href="#ZonedDateTime" class="headerlink" title="ZonedDateTime"></a>ZonedDateTime</h2><p><code>ZonedDateTime</code>的使用需要配合<code>ZoneId</code>，<code>ZoneId</code>表示不同区域的标识符，在<code>${JAVA_HOME}/lib/tzdb.dat</code>文件中存放了默认的区域标识符，如果没有特别定义，需要是文件中指定的数据才能获取到<code>ZoneId</code>实例。</p><p>我们来创建我天朝的区域：<code>ZoneId zoneId = ZoneId.of(&quot;Asia/Shanghai&quot;);</code>。</p><p>如果不知道有哪些区域，可以通过<code>Set&lt;String&gt; allZoneIds = ZoneId.getAvailableZoneIds();</code>获取，我当前 jdk 版本是 jdk1.8.0_202，一共有 599 个区域标识。</p><p>我们对比我朝与漂亮国的时间，获取当前时间：</p><pre><code class="java">ZonedDateTime.now();// 2021-06-11T17:49:53.400+08:00[Asia/Shanghai]ZonedDateTime.now(ZoneId.systemDefault());// 2021-06-11T17:49:53.400+08:00[Asia/Shanghai]ZonedDateTime.now(ZoneId.of(&quot;America/New_York&quot;));// 2021-06-11T05:49:53.400-04:00[America/New_York]</code></pre><p>可以看到，<code>now</code>方法不传参数与使用当前时区参数结果一致，使用漂亮国时区时，在小时上有区别，但是两个时间，都是指当前时间。我们可以通过指定<code>ZoneId</code>获取不同时区的结果：</p><pre><code class="java">final ZonedDateTime newyorkZonedDateTime = ZonedDateTime.now(ZoneId.of(&quot;America/New_York&quot;));// 2021-06-11T05:57:00.655-04:00[America/New_York]final ZonedDateTime shanghaiZonedDateTime = newyorkZonedDateTime.withZoneSameInstant(ZoneId.of(&quot;Asia/Shanghai&quot;));// 2021-06-11T17:57:00.655+08:00[Asia/Shanghai]final ZonedDateTime shanghaiZonedDateTime2 = ZonedDateTime.now(ZoneId.of(&quot;Asia/Shanghai&quot;));// 2021-06-11T17:58:34.221+08:00[Asia/Shanghai]</code></pre><p>可以看到，我们直接获取北京时间与通过漂亮国时间转换为北京时间，结果是一样的。</p><p>这里有一点需要提醒，这点是我朝程序员容易忽略的。那就是夏令时，我国没有夏令时，但是国外有些国家使用夏令时。所以在处理时间的时候，我们最好不要通过手动加减时区差来计算时间，这样很容易忽略夏令时。</p><h2 id="Period、Duration"><a href="#Period、Duration" class="headerlink" title="Period、Duration"></a>Period、Duration</h2><p>这两个类都是表示时间量，也就是时间段。不过，<code>Period</code>类以年、月、日这种比较大的单位表示时间量，<code>Duration</code>类以秒、纳秒这种相对较小的单位表示时间量。</p><h3 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h3><p><code>Period</code>表示的单位是年或月或日这种相对大一些的单位。我们可以用它来增减时间，或者计算两个时间间的时间差。</p><p>比如，我们以 2021 年 6 月 15 日为基准，计算 5 天后的日期：</p><pre><code class="java">LocalDate initialDate = LocalDate.parse(&quot;2021-06-15&quot;);LocalDate finalDate = initialDate.plus(Period.ofDays(5));// 2021-06-20</code></pre><p><code>Period</code>提供了<code>ofYears</code>、<code>ofMonths</code>、<code>ofWeeks</code>、<code>ofDays</code>、<code>of</code>等方法，可以随情况处理时间。</p><p>除了锚定的特定时间，<code>Period</code>还可以计算两个日期之间的时间差。比如：</p><pre><code class="java">LocalDate initialDate = LocalDate.parse(&quot;2021-06-15&quot;);final LocalDate newDate = initialDate.plus(Period.of(1, 2, 3));final Period period = Period.between(initialDate, newDate);int years = period.getYears();// 1int months = period.getMonths();// 2int days = period.getDays();// 3</code></pre><p>这里需要注意一下，这三个方法是两个单位同单位的差，不会进行换算。我们可以借助<code>ChronoUnit</code>实现单位换算状态下的结果：</p><pre><code class="java">long allYears = ChronoUnit.YEARS.between(initialDate, newDate);// 1long allMonths = ChronoUnit.MONTHS.between(initialDate, newDate);// 14long allDays = ChronoUnit.DAYS.between(initialDate, newDate);// 429</code></pre><p><code>ChronoUnit</code>是借助<code>Duration</code>实现的，所以最细粒度可以到纳秒。</p><h3 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h3><p><code>Duration</code>可以表示的单位是天、小时、分、秒、毫秒、纳秒，其内部结果是通过秒、纳秒进行存储的，其他可表示的单位，都是通过这两个单位组合实现的。比如，一分钟等于 3600 秒，那内部存储就是 3600 秒 0 纳秒；1 毫秒等于 1000000 纳秒，内部存储就是 0 秒 1000000 纳秒。</p><p><code>Duration</code>用法与<code>Period</code>类似。比如，我们给 21 点 03 分 15 秒加 30 秒：</p><pre><code class="java">LocalTime initialTime = LocalTime.parse(&quot;21:02:15&quot;);LocalTime finalTime = initialTime.plus(Duration.ofSeconds(30));// 21:02:45</code></pre><p><code>Duration</code>也可以计算两个时间之间的时间差，只是单位较小一些，比如：</p><pre><code class="java">LocalTime initialTime = LocalTime.parse(&quot;21:02:15&quot;);LocalTime newTime = LocalTime.of(21, 02, 20);Duration duration = Duration.between(initialTime, newTime);long seconds = duration.getSeconds();// 5int nano = duration.getNano();// 0</code></pre><p>同样的，我们可以借助<code>ChronoUnit</code>实现更多单位的时间差，这里不做赘述。</p><h2 id="从老时间-API-创建"><a href="#从老时间-API-创建" class="headerlink" title="从老时间 API 创建"></a>从老时间 API 创建</h2><p>Java8 提供了<code>toInstant()</code>方法，可以将老时间 API 的<code>Date</code>和<code>Calendar</code>转换为新的对象：</p><pre><code class="java">Date date = new Date();LocalDateTime localDateTime = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());Calendar calendar = GregorianCalendar.getInstance();LocalDateTime localDateTime1 = LocalDateTime.ofInstant(calendar.toInstant(), ZoneId.systemDefault());</code></pre><h2 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h2><p>Java8 提供了易于使用的时间格式化 API，这里简单说下。比如：</p><pre><code class="java">LocalDateTime localDateTime = LocalDateTime.of(2021, Month.JUNE, 15, 21, 23);String localDateString = localDateTime.format(DateTimeFormatter.ISO_DATE);// 2021-06-15</code></pre><p>与老时间 API 一样，我们可以指定格式：</p><pre><code class="java">localDateTime.format(DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd&quot;));</code></pre><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>从 Java7 到 Java8，提供了很多特性，除了 Lambda 表达式，时间 API 绝对也是良心功能了。而且从发布到现在已经过去这么多年，我们还是要与时俱进，逐渐使用优秀的 API 替换老 API 了。如果还在用 Java7 或者 Java6，然后还想使用 Java8 这种时间 API，这里推荐两个第三方库：<code>threetenbp</code>和<code>joda-time</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/eugenp/tutorials/tree/master/core-java-modules/core-java-8-datetime" target="_blank" rel="noopener">core-java-8-datetime</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1303904694304801" target="_blank" rel="noopener">ZonedDateTime</a></li></ul><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol><li><a href="https://www.howardliu.cn/java-date-and-time-intro/">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li>未完待续。..</li></ol><hr><p>你好，我是看山，10 年老猿，开源贡献者。游于码界，戏享人生。关注公众号：<a href="http://static.howardliu.cn/about/kanshanshuo.png" target="_blank" rel="noopener">看山的小屋</a>，领取学习资料。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-date-and-time-intro/">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/117945803" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文作为这个系列的第一篇，扒一扒 Date 和 Calendar 存在的问题，说说 Java8 提供的时间库是怎么解决这些问题的。后续再说一下 Java8 中 java.time 包中的一些核心类，例如 LocalDate、LocalTime、LocalDateTime、ZonedDateTime、Period、Duration。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Date" scheme="https://www.howardliu.cn/tags/Date/"/>
    
      <category term="Time" scheme="https://www.howardliu.cn/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>程序员进阶书单2021版</title>
    <link href="https://www.howardliu.cn/lists-book-recommendations-2021/"/>
    <id>https://www.howardliu.cn/lists-book-recommendations-2021/</id>
    <published>2021-06-08T14:18:46.000Z</published>
    <updated>2021-06-08T14:18:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/woman-6175010_1920.jpg" alt="程序员进阶书单2021版"></p><p>你好，我是看山。</p><p>今天列一下技术相关的书单，本文是第一版，后续持续更新。</p><a id="more"></a><blockquote><p>文中提到的部分书目我也没有读过，作为todo list，明确接下来一段时间的学习方向。</p></blockquote><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>因为本人属于Java栈，所以主要推荐的还是属于Java领域内的书目。</p><ul><li><a href="https://book.douban.com/subject/34898994/" target="_blank" rel="noopener">《Java核心技术：卷I 基础知识》</a>：本书由拥有20多年教学与研究经验的资深Java技术专家撰写（获Jolt大奖），是程序员的优选Java指南。无论是Java初学者还是有一定经验的Java工程师，这是一本非常不错的值得时常翻阅的技术手册。</li><li><a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">《Java编程思想》</a>：从Java的基础语法到最高级特性（深入的面向对象概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握。属于经典书目，可能很多Java栈的程序猿，都是从这本书开始的。</li><li><a href="https://book.douban.com/subject/30133440/" target="_blank" rel="noopener">《Java编程的逻辑》</a>：Java专家撰写，力求透彻讲解每个知识点，逐步建立编程知识图谱。本书以Java语言为例，由基础概念入手，到背后实现原理与逻辑，再到应用实践，融会贯通。</li><li><a href="https://book.douban.com/subject/30412517/" target="_blank" rel="noopener">《Effective Java》</a>：模仿《Effective C++》而成，一共包含90个条目，每个条目讨论Java程序设计中的一条规则。这些规则反映了最有经验的优秀程序员在实践中常用的一些有益的做法。前人的经验之作，想要升阶，这本书一定绕不开。最好是看第三版的，增加了Java 8的规则。</li><li><a href="https://book.douban.com/subject/2000732/" target="_blank" rel="noopener">《Head First Java》</a>：完整的面向对象（object-oriented，OO）程序设计和Java的学习指导。此书是根据学习理论所设计的，让你可以从学习程序语言的基础开始一直到包括线程、网络与分布式程序等项目。最重要的，你会学会如何像个面向对象开发者一样去思考。而且不只是读死书，你还会玩游戏、拼图、解谜题以及以意想不到的方式与Java交互。在这些活动中，你会写出一堆真正的Java程序，包括了一个船舰炮战游戏和一个网络聊天程序。</li><li><a href="https://book.douban.com/subject/10484692/" target="_blank" rel="noopener">《Java并发编程实战》</a>：深入浅出地介绍了Java线程和并发，是一本完美的Java并发参考手册。书中从并发性和线程安全性的基本概念出发，介绍了如何使用类库提供的基本并发构建块，用于避免并发危险、构造线程安全的类及验证线程安全的规则，如何将小的线程安全类组合成更大的线程安全类，如何利用线程来提高并发应用程序的吞吐量，如何识别可并行执行的任务，如何提高单线程子系统的响应性，如何确保并发程序执行预期任务，如何提高并发代码的性能和可伸缩性等内容，最后介绍了一些高级主题，如显式锁、原子变量、非阻塞算法以及如何开发自定义的同步工具类。</li><li><a href="https://book.douban.com/subject/26740520/" target="_blank" rel="noopener">《Java性能权威指南》</a>：通过使用JVM和Java平台，以及Java语言和应用程序接口，本书详尽讲解了Java性能调优的相关知识，帮助读者深入理解Java平台性能的各个方面，最终使程序如虎添翼。</li><li><a href="https://book.douban.com/subject/34879022/" target="_blank" rel="noopener">《Java系统性能优化实战》</a>：基于作者在实际工作中遇到的与系统相关的问题及解决之道，通过改善代码来提高系统性能，解决因为代码导致的系统故障。国人写的新书也很好，一些细节，一些过时的传言，作者都用jmh给测了。</li><li><a href="https://book.douban.com/subject/35258148/" target="_blank" rel="noopener">《Java性能优化实践：JVM调优策略、工具与技巧》</a>：本书从实验科学的角度探讨了Java性能优化的方方面面，重点阐述了最新的实用JVM性能调优策略、工具和技巧。通过本书，我们不仅可以了解Java原理和技术如何充分利用现代硬件和操作系统、衡量Java性能的陷阱以及微基准测试的弊端有哪些，还能深入研究可能使团队烦恼的几种性能测试和常见反模式、JVM垃圾收集、JIT编译和Java语言性能技术等。</li><li><a href="https://book.douban.com/subject/34949443/" target="_blank" rel="noopener">《Spring实战》</a>：一本经典而实用的畅销Spring 学习指南。</li><li><a href="https://book.douban.com/subject/26857423/" target="_blank" rel="noopener">《SpringBoot实战》</a>：Spring应用程序开发为中心，全面讲解如何运用Spring Boot提高效率，使应用程序的开发和管理更加轻松有趣。</li><li><a href="https://book.douban.com/subject/26952826/" target="_blank" rel="noopener">《精通Spring 4.x》</a>：虽然现在都已经是Spring 5.x了，但是Spring的基础并没有变，本书把应用和原理都讲的很透彻，IoC和AOP分析的很棒，娓娓道来。</li><li><a href="https://book.douban.com/subject/34907497/" target="_blank" rel="noopener">《深入理解Java虚拟机》</a>：这是一部从工作原理和工程实践两个维度深入剖析JVM的著作，是计算机领域公认的经典。</li><li><a href="https://book.douban.com/subject/34441840/" target="_blank" rel="noopener">《实战Java虚拟机：JVM故障诊断与性能优化》</a>：本书将通过200余个示例详细介绍JVM中的各种参数配置、故障排查、性能监控及性能优化，帮助Java人突破瓶颈。</li><li><a href="https://book.douban.com/subject/34812818/" target="_blank" rel="noopener">《新一代垃圾回收器ZGC设计与实现》</a>：有了ZGC，就忘记CMS，G1什么的吧。ZGC 所针对的是这些在未来普遍存在的大容量内存：TB 级别的堆容量，具有很低的停顿时间（小于 10 毫秒），对整体应用性能的影响也很小（对吞吐量的影响低于 15％）。ZGC 所采用的机制也可以在未来进行扩展，以支持一些令人兴奋的特性，如多层堆（用于热对象的 DRAM 和用于低频访问对象的 NVMe 闪存）。</li><li><a href="https://book.douban.com/subject/35079283/" target="_blank" rel="noopener">《深入理解JVM字节码》</a>：这是一本揭示JVM字节码“黑科技”的著作，它从原理和应用两个维度深入剖析了JVM字节码。书中内容涉及JVM字节码的大部分应用场景，如Java性能优化、软件防护与破解、APM等，通过大量实战案例讲解了它在这些场景中的实操技巧。</li><li><a href="https://book.douban.com/subject/34895968/" target="_blank" rel="noopener">《Java实战》</a>：现代Java应用充分利用了微服务、反应式架构以及流式数据等创新设计。现代Java特性，譬如Lambda、流以及大家期待已久的Java模块系统让这些设计的实现极其便利。是时候更新技能工具箱了，只有这样，你才能从容应对迎面而来的种种挑战！</li><li><a href="https://book.douban.com/subject/26772632/" target="_blank" rel="noopener">《Java8实战》</a>：本书全面介绍了Java 8 这个里程碑版本的新特性，包括Lambdas、流和函数式编程。有了函数式的编程特性，可以让代码更简洁，同时也能自动化地利用多核硬件。</li><li><a href="https://book.douban.com/subject/30358019/" target="_blank" rel="noopener">《实战Java高并发程序设计》</a>：主要介绍基于Java的并行程序设计基础、思路、方法和实战。第一，立足于并发程序基础，详细介绍Java进行并行程序设计的基本方法。第二，进一步详细介绍了JDK对并行程序的强大支持，帮助读者快速、稳健地进行并行程序开发。第三，详细讨论了“锁”的优化和提高并行程序性能级别的方法和思路。第四，介绍了并行的基本设计模式，以及Java 8/9/10对并行程序的支持和改进。第五，介绍了高并发框架Akka的使用方法。第六，详细介绍了并行程序的调试方法。第七，分析Jetty代码并给出一些其在高并发优化方面的例子。</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li><a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener">《深入理解计算机系统》</a>：这本书是程序员必读的一本书，这本书最大的优点是为程序员描述计算机系统的实现细节，帮助其在大脑中构造一个层次型的计算机系统。从最底层的数据在内存中的表示到流水线指令的构成，到虚拟存储器，到编译系统，到动态加载库，到最后的用户态应用。通过掌握程序是如何映射到系统上，以及程序是如何执行的，你能够更好的理解程序的行为为什么是这样的，以及效率底下是如何造成的。</li><li><a href="https://book.douban.com/subject/30280001/" target="_blank" rel="noopener">《计算机网络》</a>：经典的计算机网络教材，采用作者独创的自顶向下方法来讲授计算机网络的原理及其协议。</li><li><a href="https://book.douban.com/subject/25900403/" target="_blank" rel="noopener">《UNIX环境高级编程》</a>：UNIX编程“圣经”</li><li><a href="https://book.douban.com/subject/26434583/" target="_blank" rel="noopener">《UNIX网络编程：卷1》</a>：UNIX编程“圣经”</li><li><a href="https://book.douban.com/subject/4118577/" target="_blank" rel="noopener">《UNIX网络编程：卷2》</a>：UNIX编程“圣经”。可以看到，三本圣经，都是大部头很难啃的书，比较枯燥。修行路就是比较枯燥的。</li><li><a href="https://book.douban.com/subject/26825411/" target="_blank" rel="noopener">《TCP/IP详解 卷1：协议》</a>：本书内容丰富、概念清晰、论述详尽，适合任何希望理解TCP/IP协议实现的人阅读，更是TCP/IP领域研究人员和开发人员的权威参考书。无论是初学者还是功底深厚的网络领域高手，本书都是案头必备。</li><li><a href="https://book.douban.com/subject/30387220/" target="_blank" rel="noopener">《Wireshark数据包分析实战》</a>：从数据包分析与数据包嗅探器的基础知识开始，循序渐进地介绍Wireshark的基本使用方法及其数据包分析功能特性，同时还介绍了针对不同协议层与无线网络的具体实践技术与经验技巧。在此过程中，作者结合大量真实的案例，图文并茂地演示使用Wireshark进行数据包分析的技术方法，使读者能够顺着本书思路逐步掌握网络数据包嗅探与分析技能。</li><li><a href="https://book.douban.com/subject/30359954/" target="_blank" rel="noopener">《鸟哥的Linux私房菜：基础学习篇》</a>：讲解细致，深入浅出。可以对计算机和操作系统，以及Linux有一个非常全面的了解，并能够管理或者操作好一个Linux系统。</li><li><a href="https://book.douban.com/subject/27096665/" target="_blank" rel="noopener">《现代操作系统》</a>：这本书是操作系统领域的经典之作，书中集中讨论了操作系统的基本原理，包括进程、线程、存储管理、文件系统、输入/输出、死锁等，同时还包含了有关计算机安全、多媒体操作系统、掌上计算机操作系统、微内核、多核处理器上的虚拟机以及操作系统设计等方面的内容。</li><li><a href="https://book.douban.com/subject/1148282/" target="_blank" rel="noopener">《计算机程序的构造和解释》</a>：在过去的二十多年里，对于计算机科学的教育计划产生了深刻的影响。</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li><a href="https://book.douban.com/subject/3354490/" target="_blank" rel="noopener">《MySQL必知必会》</a>：书中从介绍简单的数据检索开始，逐步深入一些复杂的内容，包括联结的使用、子查询、正则表达式和基于全文本的搜索、存储过程、游标、触发器、表约束，等等。</li><li><a href="https://book.douban.com/subject/24250054/" target="_blank" rel="noopener">《SQL必知必会》</a>：本书是深受世界各地读者欢迎的SQL经典畅销书，内容丰富，文字简洁明快，针对Oracle、SQL Server、MySQL、DB2、PostgreSQL、SQLite等各种主流数据库提供了大量简明的实例。与其他同类图书不同，它没有过多阐述数据库基础理论，而是专门针对一线软件开发人员，直接从SQL SELECT开始，讲述实际工作环境中最常用和最必需的SQL知识，实用性极强。</li><li><a href="https://book.douban.com/subject/10548379/" target="_blank" rel="noopener">《数据库系统概念》</a>：本书是数据库系统方面的经典教材之一，其内容由浅入深，既包含数据库系统基本概念，又反映数据库技术新进展。它被国际上许多著名大学所采用，包括斯坦福大学、耶鲁大学、得克萨斯大学、康奈尔大学、伊利诺伊大学等。</li></ul><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><ul><li><a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">《算法》</a>：算法领域的经典参考书。不但全面介绍了关于算法和数据结构的必备知识，还给出了每位程序员应知应会的50个算法，并提供了实际代码。最不错的是，其深入浅出的算法介绍，让一些比较难的算法也变得容易理解。其中，还有大量的图解，详尽的代码和讲解。</li><li><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">《算法图解》</a>：本书示例丰富，图文并茂，以让人容易理解的方式阐释了算法，旨在帮助程序员在日常项目中更好地发挥算法的能量。</li><li><a href="https://book.douban.com/subject/20432061/" target="_blank" rel="noopener">《算法导论》</a>：本书将严谨性和全面性融为一体，深入讨论各类算法，并着力使这些算法的设计和分析能为各个层次的读者接受。全书各章自成体系，可以作为独立的学习单元；算法以英语和伪代码的形式描述，具备初步程序设计经验的人就能看懂；说明和解释力求浅显易懂，不失深度和数学严谨性。</li><li><a href="https://book.douban.com/subject/26302533/" target="_blank" rel="noopener">《编程珠玑》</a>：历史上最伟大的计算机科学著作之一。在书中，作者选取许多具有典型意义的复杂编程和算法问题，生动描绘了历史上众大师们在探索解决方案中发生的轶事、走过的弯路和不断精益求精的历程，引导读者像真正的程序员和软件工程师那样富于创新性地思考，并透彻阐述和总结了许多独特而精妙的设计原则、思考和解决问题的方法以及实用程序设计技巧。解决方案的代码均以C/C++语言编写，不仅有趣，而且有很大的实战示范意义。每章后所附习题极具挑战性和启发性，书末给出了简洁的解答。</li><li><a href="https://book.douban.com/subject/3351237/" target="_blank" rel="noopener">《数据结构与算法分析：Java语言描述》</a>：是国外数据结构与算法分析方面的经典教材，使用卓越的Java编程语言作为实现工具讨论了数据结构（组织大量数据的方法）和算法分析（对算法运行时间的估计）。</li></ul><h2 id="编程素养"><a href="#编程素养" class="headerlink" title="编程素养"></a>编程素养</h2><ul><li><a href="https://book.douban.com/subject/4199741/" target="_blank" rel="noopener">《代码整洁之道》</a>：代码质量与其整洁度成正比。干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好基础。作为编程领域的佼佼者，本书作者给出了一系列行之有效的整洁代码操作实践。这些实践在本书中体现为一条条规则（或称“启示”），并辅以来自现实项目的正、反两面的范例。只要遵循这些规则，就能编写出干净的代码，从而有效提升代码质量。</li><li><a href="https://book.douban.com/subject/35006892/" target="_blank" rel="noopener">《程序员修炼之道》</a>：由一系列的独立的部分组成，涵盖的主题从个人责任、职业发展，直到用于使代码保持灵活、并且易于改编和复用的各种架构技术。</li><li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">《重构 改善既有代码的设计》</a>：重构，一言以蔽之，就是在不改变外部行为的前提下，有条不紊地改善代码。多年前，正是本书原版的出版，使重构终于从编程高手们的小圈子走出，成为众多普通程序员日常开发工作中不可或缺的一部分。本书也因此成为与《设计模式》齐名的经典著作，被译为中、德、俄、日等众多语言，在世界范围内畅销不衰。</li><li><a href="https://book.douban.com/subject/1052241/" target="_blank" rel="noopener">《设计模式》</a>：这本书结合设计实作例从面向对象的设计中精选出23个设计模式，总结了面向对象设计中最有价值的经验，并且用简洁可复用的形式表达出来。书中分类描述了一组设计良好、表达清楚的软件设计模式，这些模式在实用环境下特别有用。此书适合大学计算机专业的学生、研究生及相关人员参考。</li><li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">《Head First 设计模式》</a>：一本设计模式入门书籍，用实际的编程案例讲解算法设计中会遇到的各种问题和需求变更，并以此逐步推导出良好的设计模式解决办法。</li><li><a href="https://book.douban.com/subject/35157817/" target="_blank" rel="noopener">《设计模式就该这样学：基于经典框架源码和真实业务场景》</a>：本书从软件架构设计必备的通用技能UML开始，重点介绍常用的类图和时序图；然后介绍软件架构设计常用的七大原则；接着结合JDK、Spring、MyBatis、Tomcat、Netty等经典框架源码对GoF的23种设计模式展开分析，并结合作者多年“踩坑填坑”和“教学答疑”经验，用深刻、全面、通俗、生动、有趣、接地气的方式结合真实业务场景分析每种设计模式，治愈“设计模式选择困难症”；之后介绍4种常用的新设计模式；最后总结软件架构、设计模式与应用框架之间的区别。</li><li><a href="https://book.douban.com/subject/1477390/" target="_blank" rel="noopener">《代码大全》</a>：一本完整的软件构建手册，涵盖了软件构建过程中的所有细节。它从软件质量和编程思想等方面论述了软件构建的各个问题，并详细论述了紧跟潮流的新技术、高屋建瓴的观点、通用的概念，还含有丰富而典型的程序示例。这本书中所论述的技术不仅填补了初级与高级编程技术之间的空白，而且也为程序员们提供了一个有关编程技巧的信息来源。这本书对经验丰富的程序员、技术带头人、自学的程序员及几乎不懂太多编程技巧的学生们都是大有裨益的。可以说，无论是什么背景的读者，阅读这本书都有助于在更短的时间内、更容易地写出更好的程序。</li><li><a href="https://book.douban.com/subject/35088343/" target="_blank" rel="noopener">《编程的原则：改善代码质量的101个方法》</a>：本书介绍了软件开发领域101个重要的编程原则，涉及编程中的永恒真理，指导方针，编程思想，程序员的视角、习惯和工具，以及编程的反模式等内容。书中以“这个原则是什么”“为什么要遵循这个原则”“具体应该怎么做”为中心，对各个原则进行介绍，简明扼要，通俗易懂。这些原则凝聚了前人的智慧，经过了历史的考验，是指导程序员改善代码、进一步提升编程能力的实用指南。</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li><a href="https://book.douban.com/subject/30443578/" target="_blank" rel="noopener">《软件架构设计》</a>：围绕软件架构设计，系统化地梳理技术架构与业务架构的方法论与实践。</li><li><a href="https://book.douban.com/subject/35217473/" target="_blank" rel="noopener">《架构师修炼之道：思维、方法与实践》</a>：作者结合多年的架构学习和项目开发经验，总结出一套架构学习的体系，从技术方法、思维意识、工具等方面讲解做好互联网后端架构设计的相关知识。通过相关知识的学习，读者能够掌握设计稳定、易维护、易扩展的软件架构的方法，也能够提升日常维护已有项目的能力。书中讲解的技术方法具有通用性，在其他非互联网行业的软件开发中，也具有借鉴意义。</li><li><a href="https://book.douban.com/subject/34960995/" target="_blank" rel="noopener">《发布！设计与部署稳定的分布式系统》</a>：作者根据自己的亲身经历和某些大型企业的案例，讲述了如何创建高稳定性的软件系统，分析了设计和实现中导致系统出现问题的原因。</li><li><a href="https://book.douban.com/subject/35178755/" target="_blank" rel="noopener">《可伸缩架构：云环境下的高可用与风险管理》</a>：一本关于现代化软件架构的书。书中介绍了如何构建和更新你的关键应用程序来满足日益苛刻的数字化客户的需求。书中还介绍了如何实现高可用性，如何使用现代化的开发和运维技术来架构应用程序，如何组织开发团队帮助应用程序和业务获得成功，如何将系统扩展到最大规模，以及如何利用云计算的可用资源来迎接上述挑战。</li><li><a href="https://book.douban.com/subject/35030121/" target="_blank" rel="noopener">《携程架构实践》</a>：本书浓缩了携程公司的整个技术架构，可以帮助读者了解支撑一家大型企业所需要的核心技术产品，以及它们的架构和面临的挑战。</li><li><a href="https://book.douban.com/subject/35062026/" target="_blank" rel="noopener">《架构师应该知道的37件事》</a>：本书汇集了一名架构师20多年来在全球各大企业任职的经验，共分为5个部分，分别对应在帮助大型企业进行IT转型的过程中，首席架构师必须高效处理的5个方面：企业或IT架构师的角色和能力、架构工作在大型企业中的价值、与各种干系人的沟通、对组织结构和系统的理解、对传统组织进行转型。本书科学而系统地归纳出软件架构师应该具备的完整能力模型，不仅帮助软件开发人员系统地学习如何掌握这37项技能，而且还能让他们进一步理解软件架构师的角色和本质，使他们最终突破技术“天花板”，成为一名合格的软件架构师。</li><li><a href="https://book.douban.com/subject/26772677/" target="_blank" rel="noopener">《微服务设计》</a>：本书全面介绍了微服务的建模、集成、测试、部署和监控，通过一个虚构的公司讲解了如何建立微服务架构。</li><li><a href="https://book.douban.com/subject/35092430/" target="_blank" rel="noopener">《微服务治理：体系、架构及实践》</a>：在微服务技术流行的当下，企业在实施微服务架构的时候，会对整个研发体系，包括开发、运维、团队组织、协同都带来冲击。因此必须构建起一整套以服务治理为核心、从线下到线上的新的能力体系来支撑这套新的架构技术，否则很难保证微服务架构的顺畅落地。 本书是作者多年服务治理经验总结，希望能够给仍在（微）服务治理迷局中夺路狂奔的计算机技术人员一点启发和指引。</li><li><a href="https://book.douban.com/subject/34801161/" target="_blank" rel="noopener">《企业级业务架构设计：方法论与实践》</a>：作者是一位资深的业务架构师，在金融行业工作超过19年，有丰富的大规模复杂金融系统业务架构设计和落地实施经验。作者在书中倡导“知行合一”的业务架构思想，全书内容围绕“行线”和“知线”两条主线展开。“行线”涵盖企业级业务架构的战略分析、架构设计、架构落地、长期管理的完整过程，“知线”则重点关注架构方法论的持续改良。</li><li><a href="https://book.douban.com/subject/30333919/" target="_blank" rel="noopener">《架构整洁之道》</a>：创造“Clean神话”的Bob大叔在架构领域的登峰之作，围绕“架构整洁”这一重要导向，系统地剖析其缘起、内涵及应用场景，涵盖软件研发完整过程及所有核心架构模式。</li><li><a href="https://book.douban.com/subject/26819666/" target="_blank" rel="noopener">《领域驱动设计：软件核心复杂性应对之道》</a>：全书围绕着设计和开发实践，结合若干真实的项目案例，向读者阐述如何在真实的软件开发中应用领域驱动设计。书中给出了领域驱动设计的系统化方法，并将人们普遍接受的一些最佳实践综合到一起，融入了作者的见解和经验，展现了一些可扩展的设计最佳实践、已验证过的技术以及便于应对复杂领域的软件项目开发的基本原则。</li></ul><h2 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h2><ul><li><a href="https://book.douban.com/subject/6862062/" target="_blank" rel="noopener">《持续交付：发布可靠软件的系统方法》</a>：讲述如何实现更快、更可靠、低成本的自动化软件交付，描述了如何通过增加反馈，并改进开发人员、测试人员、运维人员和项目经理之间的协作来达到这个目标。</li><li><a href="https://book.douban.com/subject/30419555/" target="_blank" rel="noopener">《持续交付2.0》</a>：本书重新定义了“持续交付”，增补了组织管理和系统架构两个维度，并辅助以真实案例，对诸多持续交付原则与实践加以解读，并对持续交付过程中的实践取舍之道加以论述。</li><li><a href="https://book.douban.com/subject/26979886/" target="_blank" rel="noopener">《学习敏捷：构建高效团队》</a>：本书以敏捷软件开发为中心，系统阐述了敏捷原则和实践的先进理念和重要意义，并分别讲解了Scrum、极限编程、精益和看板四套敏捷实践的应用。作者从开发团队的日常困境入手，用讲故事的形式展开问题，由表及里，层层讲解，并在每一章最后附上参考书，便于读者进一步查找学习。本书内容生动，语言通俗易懂，集趣味性和实用性于一体，是学习敏捷开发、提升团队效率的极佳参考书。</li><li><a href="https://book.douban.com/subject/26875239/" target="_blank" rel="noopener">《SRE: Google运维解密》</a>：Google SRE的关键成员解释了他们是如何对软件进行生命周期的整体性关注的，以及为什么这样做能够帮助Google成功地构建、部署、监控和运维世界上现存最大的软件系统。</li><li><a href="https://book.douban.com/subject/30219010/" target="_blank" rel="noopener">《进化：运维技术变革与实践探索》</a>：本书依托作者在电信和互联网行业多年的从业经历，结合一线实际工作实践，从应用生命周期的视角，全面详细地介绍了分布式架构体系下，应用运维体系建设的方方面面，涵盖了体系建设方法论指导、持续交付体系建设思路和实践、稳定性体系规划建设，以及故障的科学管理方法等内容，视角新颖且独特，换一个角度看运维，能够带给读者不一样的思考方式。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>左耳朵耗子在《程序员练级攻略》推荐的必读书籍清单，关注【公众号：看山的小屋】，回复“左耳”领取。如果想要付费订阅《左耳听风》，可以点<a href="http://gk.link/a/10sq6" target="_blank" rel="noopener">这里</a>，购买成功的话在公众号留言找我返现。</li><li><a href="https://mp.weixin.qq.com/s/U6CMqnT074__x8BFbZy0_w" target="_blank" rel="noopener">江南白衣的书单</a></li></ul><hr><p>你好，我是看山，公众号：<a href="http://static.howardliu.cn/about/kanshanshuo.png" target="_blank" rel="noopener">看山的小屋</a>，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/lists-book-recommendations-2021/">程序员进阶书单2021版</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/117727787" target="_blank" rel="noopener">程序员进阶书单2021版</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      今天列一下技术相关的书单，本文是第一版，后续持续更新。
    
    </summary>
    
    
      <category term="书单" scheme="https://www.howardliu.cn/categories/%E4%B9%A6%E5%8D%95/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="书单" scheme="https://www.howardliu.cn/tags/%E4%B9%A6%E5%8D%95/"/>
    
      <category term="技术成长" scheme="https://www.howardliu.cn/tags/%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>Geek 青年说北京沙龙分享</title>
    <link href="https://www.howardliu.cn/geek-talk-20210523/"/>
    <id>https://www.howardliu.cn/geek-talk-20210523/</id>
    <published>2021-05-31T06:28:34.000Z</published>
    <updated>2021-05-31T06:28:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/hybrid-6274156_1920.jpg" alt="Geek 青年说北京沙龙分享"></p><p>你好，我是看山。</p><p>5 月 23 号参加了 infoQ 写作平台组织的线下沙龙，瞻仰了很多大佬的英姿。在 Geek 青年说的环节，也壮起胆量上台分享了自己的一些观点。第一次上台，面对台下的大佬们，难免有些紧张。不过思考不易，整理出来，希望能够帮到有相同困惑的同仁们。</p><a id="more"></a><p>@文字君 阿萌提前准备了几个问题，其本意是提供一些分享的思路。奈何，京城的程序猿们比较保守，将这些思路当成了题目，完全打乱了阿萌的计划。下面是几个问题：</p><ol><li>我是如何走上写作之路的？</li><li>坚持写作给我带来了什么（长期收益、隐形投资、短期回报）</li><li>我的技术成长之路（学习策略、可推荐图书）</li><li>一个优秀的程序员的必备素质？（大佬特质有哪些）？</li></ol><p>前两个问题还好，与自身相关。后两个问题具有普遍意义，需要单独开文回答了。</p><h2 id="写作和收益"><a href="#写作和收益" class="headerlink" title="写作和收益"></a>写作和收益</h2><p>很多事情的发生都需要一个契机，就像是扣动扳机一样。</p><p>朋友在研二实习时面试的是百度，面试官看过他写的博客，感觉很好，加上他自身实力不俗，顺利拿到了 offer。</p><p>这对我来说，是一种触动，想着自己也开通一个账号，整理自己的所学所思所感，万一哪天面试用得到呢。于是，第一篇文章就这样诞生了。当时虽有目的，却动力不足，产出比较低，一年才 20 几篇，甚至在 2018 年停了 1 年。</p><p>每个人写作的目的不一样，但是写作带来的收益有一个是相似的，那就是：思考。无论是谁，什么段位，想要写成一篇文章，必然需要思考，思考前因后果。有时候写的不顺利，可能连续很长一段时间都会反复咀嚼反刍。这就是反复思考的过程，也是反复自省的过程。</p><p>我们做程序猿是比较难的，各种新技术层出不穷，很多时候我们会抱怨学不动了。但是我们做程序猿又是比较容易的，只要有一项技术精通摸透了，触类旁通，其他技术也能够很快上手。如果没有思考，很难做到精通。</p><p>我们在工作中有思考和没有思考会产生截然相反的两种结果，就像是送信的马儿和拉磨的驴子，可能它俩走路的长度一样，但是，马儿看过了世界，驴子看到的只是磨盘下的那个圈。</p><h2 id="两个模型"><a href="#两个模型" class="headerlink" title="两个模型"></a>两个模型</h2><p>分享两个模型：</p><ol><li>德雷福斯模型<br><img src="http://static.howardliu.cn/raving/%E5%BE%B7%E9%9B%B7%E7%A6%8F%E6%96%AF%E6%A8%A1%E5%9E%8B.png" alt="德雷福斯模型"></li><li>艾宾浩斯遗忘曲线<br><img src="http://static.howardliu.cn/raving/20200621182354129.png" alt="艾宾浩斯遗忘曲线"></li></ol><h3 id="德雷福斯模型"><a href="#德雷福斯模型" class="headerlink" title="德雷福斯模型"></a>德雷福斯模型</h3><p>德雷福斯模型定义了我们成长的路径：</p><ol><li>新手 Novice<ol><li>严格遵守规则或计划</li><li>几乎无法感知情境</li><li>无法酌情判断</li></ol></li><li>高级新手 Advanced Beginner<ol><li>依赖基于属性或不同侧面的行动准则</li><li>情境感知依然有限</li><li>对工作的不同方面，分开处理并且给予同等重要性</li></ol></li><li>胜任者 Competent<ol><li>能应对多线程活动或丰富的信息量</li><li>能从长期目标角度（至少部分）审视行动</li><li>有意识、刻意地制定计划</li><li>将流程标准化和常规化</li></ol></li><li>精通者 Proficient<ol><li>从整体把握全局，而不是观察各个方面</li><li>了解情境中最重要的事</li><li>感知情境与正常模式的偏差</li><li>决策越来越轻松</li><li>使用原则（maxims）指导行动，其含义因情况而异</li></ol></li><li>专家 Expert<ol><li>不再依赖规则、行动准则、原则</li><li>基于深刻、潜默的直觉把握情境</li><li>出现新情况或发生问题才使用分析法</li><li>看到未来可能的愿景</li></ol></li></ol><p>以做饭举例：</p><ul><li>新手就是必须照着菜谱做饭，甚至会拿出厨房秤，一丝一毫不能差。如果碰到盐少量、醋少量之类的模糊描述，就完全歇菜。</li><li>高级新手也需要菜谱，但是知道盐少量就是少加点是多少了。</li><li>胜任者基本上不需要菜谱了，菜谱就在脑袋中。但也是照本宣科，没有什么创新。</li><li>精通者在某种菜式中游刃有余，不过，还局限在某种范式中。比如：鲁菜、川菜、杭帮菜等。</li><li>专家没有固定套路，不局限于某种菜式。可以根据食材当时的情况，完全发挥其美味，信手拈来。</li></ul><p>我们也可以列出自己的技术栈和技能，然后每一项后面给自己下一个定义，这样就能够知道我们的差距在哪了。</p><h3 id="艾宾浩斯遗忘曲线"><a href="#艾宾浩斯遗忘曲线" class="headerlink" title="艾宾浩斯遗忘曲线"></a>艾宾浩斯遗忘曲线</h3><p>艾宾浩斯遗忘曲线是可以指导我们学习。</p><p>相信大家都会有一个疑惑，为什么考试之后的知识都遗忘了？就是因为这个遗忘曲线，我们的大脑和电脑不同的是，我们的存储会被清除，随着时间的推移，可能留下的记忆少了。</p><p>之前在读书笔记 <a href="https://www.howardliu.cn/dont-let-irrational-thinking-ruin-your-lift/">别让非理性思维毁了你的人生</a> 中提过，我们的大脑就是一台克鲁机，很多都是拼凑出来了，而且，由于我们的大脑耗能严重，所以奔着能省则省的原则，凡是不影响生死的记忆行为，都被海马体挡在外面了。</p><p>为了骗过海马体这个看门人，我们需要反复学习加深记忆。这也解释了很多同学的一个疑惑，明明很用功的在看书学习，但是偏偏看过一段时间之后，就忘记了。对学习动力造成很大的打击。其实，只是需要隔一段时间在复习一下。</p><p>通常来说，我们的复习节奏是这样，隔 1 天后、再隔 7 天后、再隔 14 天后、再隔 30 天后。也就是说，我们在 1 号学习的知识，需要在 2 号、9 号、23 号、次月 20 号这 4 天复习。这样我们的记忆会保持很久。</p><p>而且，兴趣是最好的记忆催化剂，我们要保持学习的兴趣。很多同学应该有感触，我们感兴趣的东西，哪怕不重复记忆，也可能过目不忘。但是我们感觉无聊的信息，很可能转头就忘。所以，让我们对这个世界保持兴趣，至少对我们要学习的那些东西保持兴趣。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/dont-let-irrational-thinking-ruin-your-lift/">别让非理性思维毁了你的人生</a></li><li><a href="https://www.howardliu.cn/geek-talk-20210523/">Geek 青年说北京沙龙分享</a></li><li><a href="https://www.howardliu.cn/lists-book-recommendations-2021/">程序员进阶书单2021版</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/geek-talk-20210523/">Geek 青年说北京沙龙分享</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/117415953" target="_blank" rel="noopener">Geek 青年说北京沙龙分享</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      5 月 23 号参加了 infoQ 写作平台组织的线下沙龙，瞻仰了很多大佬的英姿。在 Geek 青年说的环节，也壮起胆量上台分享了自己的一些观点。第一次上台，面对台下的大佬们，难免有些紧张。不过思考不易，整理出来，希望能够帮到有相同困惑的同仁们。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊，写作，技术成长" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A%EF%BC%8C%E5%86%99%E4%BD%9C%EF%BC%8C%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>一文掌握 Java8 的 Optional 的 6 种操作</title>
    <link href="https://www.howardliu.cn/java-util-optional/"/>
    <id>https://www.howardliu.cn/java-util-optional/</id>
    <published>2021-05-17T06:17:26.000Z</published>
    <updated>2021-05-17T06:17:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/hamburg-5286863_1920.jpg" alt="一文掌握 Java8 的 Optional 的 6 种操作"></p><p>你好，我是看山。</p><p>Java8 中引入了一个特别有意思类：<code>Optional</code>，一个可以让我们更加轻松的避免 NPE（空指针异常，NullPointException）的工具。</p><p>很久很久以前，为了避免 NPE，我们会写很多类似<code>if (obj != null) {}</code>的代码，有时候忘记写，就可能出现 NPE，造成线上故障。在 Java 技术栈中，如果谁的代码出现了 NPE，有极大的可能会被笑话，这个异常被很多人认为是低级错误。<code>Optional</code>的出现，可以让大家更加轻松的避免因为低级错误被嘲讽的概率。</p><a id="more"></a><h2 id="定义示例数据"><a href="#定义示例数据" class="headerlink" title="定义示例数据"></a>定义示例数据</h2><p>先定义待操作对象，万能的<code>Student</code>类和<code>Clazz</code>类（用到了 lombok 和 guava）：</p><pre><code class="java">@Data@AllArgsConstructor@NoArgsConstructorpublic class Clazz {    private String id;    private String name;}</code></pre><pre><code class="java">@Data@AllArgsConstructor@NoArgsConstructorpublic class Student {    private String id;    private String name;    private Clazz clazz;}</code></pre><p>然后定义一组测试数据：</p><pre><code class="java">final Clazz clazz1 = new Clazz(&quot;1&quot;, &quot;高一一班&quot;);final Student s1 = new Student(&quot;1&quot;, &quot;张三&quot;, clazz1);final Student s2 = new Student(&quot;2&quot;, &quot;李四&quot;, null);final List&lt;Student&gt; students = Lists.newArrayList(s1, s2);final List&lt;Student&gt; emptyStudents = Lists.newArrayList();final List&lt;Student&gt; nullStudents = null;</code></pre><h2 id="创建实例：of、ofNullable"><a href="#创建实例：of、ofNullable" class="headerlink" title="创建实例：of、ofNullable"></a>创建实例：of、ofNullable</h2><p>为了控制生成实例的方式，也是为了收紧空值<code>Optional</code>的定义，<code>Optional</code>将构造函数定义为<code>private</code>。想要创建<code>Optional</code>实例，可以借助<code>of</code>和<code>ofNullable</code>两个方法实现。</p><p>这两个方法的区别在于：<code>of</code>方法传入的参数不能是<code>null</code>的，否则会抛出<code>NullPointerException</code>。所以，对于可能是<code>null</code>的结果，一定使用<code>ofNullable</code>。</p><p>代码如下：</p><pre><code class="java">Optional.of(students);Optional.of(emptyStudents);Optional.ofNullable(nullStudents);</code></pre><p><code>Optional</code>类中还有一个静态方法：<code>empty</code>，这个方法直接返回了内部定义的一个常量<code>Optional&lt;?&gt; EMPTY = new Optional&lt;&gt;()</code>，这个常量的<code>value</code>是<code>null</code>。<code>ofNullable</code>方法也是借助了<code>empty</code>实现<code>null</code>的包装：</p><pre><code class="java">public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) {    return value == null ? empty() : of(value);}</code></pre><p>所以说，对于<code>null</code>的<code>Optional</code>包装类，指向的都是相同的实例对象，<code>Optional.empty() == Optional.ofNullable(null)</code>返回的是<code>true</code>。换句话说，空<code>Optional</code>是单例的。</p><blockquote><p>为了方便描述，下文中对值为<code>null</code>的<code>Optional</code>统称为“<strong>空<code>Optional</code></strong>”。</p></blockquote><h2 id="获取数据：get"><a href="#获取数据：get" class="headerlink" title="获取数据：get"></a>获取数据：get</h2><p><code>Optional</code>的<code>get</code>方法有些坑人，先看下它的源码：</p><pre><code class="java">public T get() {    if (value == null) {        throw new NoSuchElementException(&quot;No value present&quot;);    }    return value;}</code></pre><p>也就是说，<code>Optional</code>值为空时，使用<code>get</code>方法将抛出<code>NoSuchElementException</code>异常。如果不想抛出异常，或者能够 100%确定不是空<code>Optional</code>，或者使用<code>isPresent</code>方法判断。</p><p>如果能 100%确定不是空<code>Optional</code>，那就没有必要使用<code>Optional</code>包装，直接返回即可。如果需要使用<code>isPresent</code>方法，那就和直接判空没有区别了。所以，无论是第一种情况还是第二种情况，都违背了设计这个类的初衷。</p><h2 id="值为空判断：isPresent、ifPresent"><a href="#值为空判断：isPresent、ifPresent" class="headerlink" title="值为空判断：isPresent、ifPresent"></a>值为空判断：isPresent、ifPresent</h2><p><code>isPresent</code>用来判断值是否为空，类似于<code>obj != null</code>，<code>ifPresent</code>可以传入一个<code>Consumer</code>操作，当值不为空的时候，会执行<code>Consumer</code>函数。比如：</p><pre><code class="java">final Optional&lt;List&lt;Student&gt;&gt; nullValue = Optional.ofNullable(nullStudents);if (nullValue.isPresent()) {    System.out.println(&quot;value: &quot; + nullValue.get());}</code></pre><p>上面的方法等价于：</p><pre><code class="java">nullValue.ifPresent(value -&gt; System.out.println(&quot;value: &quot; + value));</code></pre><p><code>isPresent</code>判断的写法上是不是感觉很熟悉，感觉可以直接写为：</p><pre><code class="java">if (nullStudents != null) {    System.out.println(&quot;value: &quot; + nullStudents);}</code></pre><p>对于<code>isPresent</code>，如果是在自己可控的代码范围内，完全没有必要将值封装之后再判空。对于自己不可控的代码，后续的<code>filter</code>或者<code>map</code>方法可能比<code>isPresent</code>更好用一些。</p><p>对于<code>ifPresent</code>，在使用的时候会有一些限制，就是必须是非空<code>Optional</code>的时候，在会执行传入的<code>Consumer</code>函数。</p><h2 id="值处理：map、flatMap"><a href="#值处理：map、flatMap" class="headerlink" title="值处理：map、flatMap"></a>值处理：map、flatMap</h2><p><code>map</code>和<code>flatMap</code>是对<code>Optional</code>的值进行操作的方法，区别在于，<code>map</code>会将结果包装到<code>Optional</code>中返回，<code>flatMap</code>不会。但是两个方法返回值都是<code>Optional</code>类型，这也就要求，<code>flatMap</code>的方法函数返回值需要是<code>Optional</code>类型。</p><p>我们来看看<code>map</code>的实现：</p><pre><code class="java">public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) {    Objects.requireNonNull(mapper);    if (!isPresent())        return empty();    else {        return Optional.ofNullable(mapper.apply(value));    }}</code></pre><p>可以看到，如果<code>Optional</code>的值为空，<code>map</code>直接返回<code>Optional.EMPTY</code>，否则会执行函数结果，并使用<code>Optional.ofNullable</code>包装并返回。也即是说，只要类结构允许，我们可以一直<code>map</code>下去，就像是扒洋葱，一层一层，直到核心。</p><p>比如，我们要获取<code>s2</code>所在班级名称，在定义的时候，我们将<code>s2</code>的<code>clazz</code>属性定义为 null，如果以前需要写为：</p><pre><code class="java">String clazzNameOld;if (s2 != null &amp;&amp; s2.getClazz() != null &amp;&amp; s2.getClazz().getName() != null) {    clazzNameOld = s2.getClazz().getName();} else {    clazzNameOld = &quot;DEFAULT_NAME&quot;;}</code></pre><p>现在借助<code>Optional</code>可以写为：</p><pre><code class="java">final String clazzName = Optional.ofNullable(s2)        .map(Student::getClazz)        .map(Clazz::getName)        .orElse(&quot;DEFAULT_NAME&quot;);</code></pre><p>从代码上似乎没有多大改变，但是如果<code>Clazz</code>内部还有类对象。或者，我们在<code>if</code>判断的时候，少写一层检查呢？而且，<code>map</code>的精巧还在于它的返回值永远是<code>Optional</code>，这样，我们可以重复调用<code>map</code>方法，而不需要中间被打断，增加各种判空逻辑。</p><h2 id="值为空的处理：orElse、orElseGet、orElseThrow"><a href="#值为空的处理：orElse、orElseGet、orElseThrow" class="headerlink" title="值为空的处理：orElse、orElseGet、orElseThrow"></a>值为空的处理：orElse、orElseGet、orElseThrow</h2><p>这几个方法可以与<code>map</code>操作结合，一起完成对象操作。当值为空时，<code>orElse</code>和<code>orElseGet</code>返回默认值，<code>orElseThrow</code>抛出指定的异常。</p><p><code>orElse</code>和<code>orElseGet</code>的区别是，<code>orElse</code>方法传入的参数是明确的默认值，<code>orElseGet</code>方法传入的参数是获取默认值的函数。如果默认值的构造过程比较复杂，需要经过一系列的运算逻辑，那一定要使用<code>orElseGet</code>，因为<code>orElseGet</code>是在值为空的时候，才会执行函数，并返回默认值，如果值不为空，则不会执行函数，相比于<code>orElse</code>而言，减少了一次构造默认值的过程。</p><p>同样以上面的例子：</p><p><code>orElse</code>的写法：</p><pre><code class="java">final String clazzName = Optional.ofNullable(s2)        .map(Student::getClazz)        .map(Clazz::getName)        .orElse(null);</code></pre><p><code>orElseGet</code>的写法：</p><pre><code class="java">final String clazzName = Optional.of(s2)        .map(Student::getClazz)        .map(Clazz::getName)        .orElseGet(() -&gt; null);</code></pre><p>如果<code>clazz</code>属性一定不为空，为空则返回异常，可以使用<code>orElseThrow</code>：</p><pre><code class="java">final String clazzName = Optional.of(s2)        .map(Student::getClazz)        .map(Clazz::getName)        .orElseThrow(() -&gt; new IllegalArgumentException(&quot;clazz属性不合法&quot;));</code></pre><h2 id="条件过滤：filter"><a href="#条件过滤：filter" class="headerlink" title="条件过滤：filter"></a>条件过滤：filter</h2><p><code>filter</code>方法提供的是值验证，如果值验证为 true，返回当前值；否则，返回空<code>Optional</code>。比如，我们要遍历<code>students</code>，找到班级属性为空的，打印学生id：</p><pre><code class="java">for (final Student s : students) {    Optional.of(s)            .filter(x -&gt; x.getClazz() == null)            .ifPresent(x -&gt; System.out.println(x.getId()));}</code></pre><h2 id="其他：equals、hashCode、toString"><a href="#其他：equals、hashCode、toString" class="headerlink" title="其他：equals、hashCode、toString"></a>其他：equals、hashCode、toString</h2><p><code>Optional</code>重写了这三个方法。因为<code>Optional</code>可以认为是包装类，所以还是围绕这被包装的值重写这三个方法。下面给出这三个方法的源码：</p><pre><code class="java">public boolean equals(Object obj) {    // 同一对象判断    if (this == obj) {        return true;    }    // 类型判断    if (!(obj instanceof Optional)) {        return false;    }    Optional&lt;?&gt; other = (Optional&lt;?&gt;) obj;    // 最终还是值的判断    return Objects.equals(value, other.value);}public int hashCode() {    // 直接返回值的hashCode    return Objects.hashCode(value);}public String toString() {    return value != null        ? String.format(&quot;Optional[%s]&quot;, value) // 用到了值的toString结果        : &quot;Optional.empty&quot;;}</code></pre><p><code>equals</code>方法，<code>Optional.of(s1).equals(Optional.of(s2))</code>完全等价于<code>s1.equals(s2)</code>。</p><p><code>hashCode</code>方法，直接返回的是值的hashCode，如果是空<code>Optional</code>，返回的是0。</p><p><code>toString</code>方法，为了能够识别是<code>Optional</code>，将打印数据包装了一下。如果是空<code>Optional</code>，返回的是字符串“Optional.empty”；如果是非空，返回是是“Optional[值的toString]”。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>NPE 之所以讨厌，就是只要出现 NPE，我们就能够解决。但是一旦出现，都已经是事后，可能已经出现线上故障。偏偏在 Java 语言中，NPE 又很容易出现。<code>Optional</code>提供了模板方法，有效且高效的避免 NPE。</p><p>接下来，我们针对上面的使用，总结一下：</p><ol><li><code>Optional</code>是一个包装类，且不可变，不可序列化</li><li>没有公共构造函数，创建需要使用<code>of</code>、<code>ofNullable</code>方法</li><li>空<code>Optional</code>是单例，都是引用<code>Optional.EMPTY</code></li><li>想要获取<code>Optional</code>的值，可以使用<code>get</code>、<code>orElse</code>、<code>orElseGet</code>、<code>orElseThrow</code></li></ol><p>另外，还有一些实践上的建议：</p><ol><li>使用<code>get</code>方法前，必须使用<code>isPresent</code>检查。但是使用<code>isPresent</code>前，先思考下是否可以使用<code>orElse</code>、<code>orElseGet</code>等方法代替实现。</li><li><code>orElse</code>和<code>orElseGet</code>，优先选择<code>orElseGet</code>，这个是惰性计算</li><li><code>Optional</code>不要作为参数或者类属性，可以作为返回值</li><li>尽量将<code>map</code>、<code>filter</code>的函数参数抽出去作为单独方法，这样能够保持链式调用</li></ol><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/java-stream-collectors/">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://www.howardliu.cn/java-util-optional/">一文掌握 Java8 的 Optional 的 6 种操作</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-util-optional/">一文掌握 Java8 的 Optional 的 6 种操作</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/117057756" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      一文掌握 Java8 的 Optional 的 6 种操作
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="stream" scheme="https://www.howardliu.cn/tags/stream/"/>
    
      <category term="jdk8" scheme="https://www.howardliu.cn/tags/jdk8/"/>
    
      <category term="optional" scheme="https://www.howardliu.cn/tags/optional/"/>
    
  </entry>
  
  <entry>
    <title>一文掌握 Java8 Stream 中 Collectors 的 24 个操作</title>
    <link href="https://www.howardliu.cn/java-stream-collectors/"/>
    <id>https://www.howardliu.cn/java-stream-collectors/</id>
    <published>2021-05-12T11:49:59.000Z</published>
    <updated>2021-05-12T11:49:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/stadttheater-5002861_1920.jpg" alt="一文掌握 Java8 Stream 中 Collectors 的 24 个操作"></p><p>你好，我是看山。</p><p>Java8 应该算是业界主版本了，版本中重要性很高的一个更新是<code>Stream</code>流处理。关于流处理内容比较多，本文主要是说一下<code>Stream</code>中的<code>Collectors</code>工具类的使用。</p><a id="more"></a><p><code>Collectors</code>是<code>java.util.stream</code>包下的一个工具类，其中各个方法的返回值可以作为<code>java.util.stream.Stream#collect</code>的入参，实现对队列的各种操作，包括：分组、聚合等。官方文档给出一些例子：</p><blockquote><p>Implementations of {@link Collector} that implement various useful reduction operations, such as accumulating elements into collections, summarizing elements according to various criteria, etc.</p><p>The following are examples of using the predefined collectors to perform common mutable reduction tasks:</p><pre><code class="java">// Accumulate names into a ListList&lt;String&gt; list = people.stream().map(Person::getName).collect(Collectors.toList());// Accumulate names into a TreeSetSet&lt;String&gt; set = people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::new));// Convert elements to strings and concatenate them, separated by commasString joined = things.stream()        .map(Object::toString)        .collect(Collectors.joining(&quot;, &quot;));// Compute sum of salaries of employeeint total = employees.stream()        .collect(Collectors.summingInt(Employee::getSalary)));// Group employees by departmentMap&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream()        .collect(Collectors.groupingBy(Employee::getDepartment));// Compute sum of salaries by departmentMap&lt;Department, Integer&gt; totalByDept = employees.stream()        .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.summingInt(Employee::getSalary)));// Partition students into passing and failingMap&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream()        .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));</code></pre></blockquote><h2 id="定义示例数据"><a href="#定义示例数据" class="headerlink" title="定义示例数据"></a>定义示例数据</h2><p>先定义待操作对象，一个万能的<code>Student</code>类（用到了 lombok）：</p><pre><code class="java">@Data@AllArgsConstructorpublic class Student {    private String id;    private String name;    private LocalDate birthday;    private int age;    private double score;}</code></pre><p>然后定义一组测试数据：</p><pre><code class="java">final List&lt;Student&gt; students = Lists.newArrayList();students.add(new Student(&quot;1&quot;, &quot;张三&quot;, LocalDate.of(2009, Month.JANUARY, 1), 12, 12.123));students.add(new Student(&quot;2&quot;, &quot;李四&quot;, LocalDate.of(2010, Month.FEBRUARY, 2), 11, 22.123));students.add(new Student(&quot;3&quot;, &quot;王五&quot;, LocalDate.of(2011, Month.MARCH, 3), 10, 32.123));</code></pre><h2 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h2><h3 id="元素数量：counting"><a href="#元素数量：counting" class="headerlink" title="元素数量：counting"></a>元素数量：counting</h3><p>这个比较简单，就是统计聚合结果的元素数量：</p><pre><code class="java">// 3students.stream().collect(Collectors.counting())</code></pre><h3 id="平均值：averagingDouble、averagingInt、averagingLong"><a href="#平均值：averagingDouble、averagingInt、averagingLong" class="headerlink" title="平均值：averagingDouble、averagingInt、averagingLong"></a>平均值：averagingDouble、averagingInt、averagingLong</h3><p>这几个方法是计算聚合元素的平均值，区别是输入参数需要是对应的类型。</p><p>比如，求学生的分数平均值，因为分数是<code>double</code>类型，所以在不转类型的情况下，需要使用<code>averagingDouble</code>：</p><pre><code class="java">// 22.123students.stream().collect(Collectors.averagingDouble(Student::getScore))</code></pre><p>如果考虑转换精度，也是可以实现：</p><pre><code class="java">// 22.0students.stream().collect(Collectors.averagingInt(s -&gt; (int)s.getScore()))// 22.0students.stream().collect(Collectors.averagingLong(s -&gt; (long)s.getScore()))</code></pre><p>如果是求学生的平均年龄，因为年龄是<code>int</code>类型，就可以随意使用任何一个函数了：</p><pre><code class="java">// 11.0students.stream().collect(Collectors.averagingInt(Student::getAge))// 11.0students.stream().collect(Collectors.averagingDouble(Student::getAge))// 11.0students.stream().collect(Collectors.averagingLong(Student::getAge))</code></pre><blockquote><p>注意：这三个方法的返回值都是<code>Double</code>类型。</p></blockquote><h3 id="和：summingDouble、summingInt、summingLong"><a href="#和：summingDouble、summingInt、summingLong" class="headerlink" title="和：summingDouble、summingInt、summingLong"></a>和：summingDouble、summingInt、summingLong</h3><p>这三个方法和上面的平均值方法类似，也是需要注意元素的类型，在需要类型转换时，需要强制转换：</p><pre><code class="java">// 66students.stream().collect(Collectors.summingInt(s -&gt; (int)s.getScore()))// 66.369students.stream().collect(Collectors.summingDouble(Student::getScore))// 66students.stream().collect(Collectors.summingLong(s -&gt; (long)s.getScore()))</code></pre><p>但是对于不需要强制转换的类型，可以随意使用任何一个函数：</p><pre><code class="java">// 33students.stream().collect(Collectors.summingInt(Student::getAge))// 33.0students.stream().collect(Collectors.summingDouble(Student::getAge))// 33students.stream().collect(Collectors.summingLong(Student::getAge))</code></pre><blockquote><p>注意：这三个方法返回值和平均值的三个方法不一样，<code>summingDouble</code>返回的是<code>Double</code>类型、<code>summingInt</code>返回的是<code>Integer</code>类型，<code>summingLong</code>返回的是<code>Long</code>类型。</p></blockquote><h3 id="最大值-最小值元素：maxBy、minBy"><a href="#最大值-最小值元素：maxBy、minBy" class="headerlink" title="最大值/最小值元素：maxBy、minBy"></a>最大值/最小值元素：maxBy、minBy</h3><p>顾名思义，这两个函数就是求聚合元素中指定比较器中的最大/最小元素。比如，求年龄最大/最小的<code>Student</code>对象：</p><pre><code class="java">// Optional[Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)]，注意返回类型是Optionalstudents.stream().collect(Collectors.minBy(Comparator.comparing(Student::getAge)))// Optional[Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123)]，注意返回类型是Optionalstudents.stream().collect(Collectors.maxBy(Comparator.comparing(Student::getAge)))</code></pre><p>从源码可以看出来，这两个方法算是作者给的福利，用于完善数据统计的结果。内部都是封装了<code>reducing</code>方法和<code>BinaryOperator</code>工具类，这些下面会讲到。</p><pre><code class="java">public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? super T&gt; comparator) {    return reducing(BinaryOperator.maxBy(comparator));}public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; minBy(Comparator&lt;? super T&gt; comparator) {    return reducing(BinaryOperator.minBy(comparator));}</code></pre><h3 id="统计结果：summarizingDouble、summarizingInt、summarizingLong"><a href="#统计结果：summarizingDouble、summarizingInt、summarizingLong" class="headerlink" title="统计结果：summarizingDouble、summarizingInt、summarizingLong"></a>统计结果：summarizingDouble、summarizingInt、summarizingLong</h3><p>既然是数据操作，基本上逃不出计数、求平局、求和、最大、最小这几个，所以作者也是很贴心的实现了一组聚合的数据统计方法。</p><p>这组方法与求和、求平均的方法类似，都需要注意方法类型。比如，按照分数统计的话，需要进行类型转换：</p><pre><code class="java">// IntSummaryStatistics{count=3, sum=66, min=12, average=22.000000, max=32}students.stream().collect(Collectors.summarizingInt(s -&gt; (int) s.getScore()))// DoubleSummaryStatistics{count=3, sum=66.369000, min=12.123000, average=22.123000, max=32.123000}students.stream().collect(Collectors.summarizingDouble(Student::getScore))// LongSummaryStatistics{count=3, sum=66, min=12, average=22.000000, max=32}students.stream().collect(Collectors.summarizingLong(s -&gt; (long) s.getScore()))</code></pre><p>如果是用年龄统计的话，三个方法通用：</p><pre><code class="java">// IntSummaryStatistics{count=3, sum=33, min=10, average=11.000000, max=12}students.stream().collect(Collectors.summarizingInt(Student::getAge))// DoubleSummaryStatistics{count=3, sum=33.000000, min=10.000000, average=11.000000, max=12.000000}students.stream().collect(Collectors.summarizingDouble(Student::getAge))// LongSummaryStatistics{count=3, sum=33, min=10, average=11.000000, max=12}students.stream().collect(Collectors.summarizingLong(Student::getAge))</code></pre><blockquote><p>注意：这三个方法返回值不一样，<code>summarizingDouble</code>返回<code>DoubleSummaryStatistics</code>类型，<code>summarizingInt</code>返回<code>IntSummaryStatistics</code>类型，<code>summarizingLong</code>返回<code>LongSummaryStatistics</code>类型。</p></blockquote><h2 id="聚合、分组"><a href="#聚合、分组" class="headerlink" title="聚合、分组"></a>聚合、分组</h2><h3 id="聚合元素：toList、toSet、toCollection"><a href="#聚合元素：toList、toSet、toCollection" class="headerlink" title="聚合元素：toList、toSet、toCollection"></a>聚合元素：toList、toSet、toCollection</h3><p>这几个函数比较简单，是将聚合之后的元素，重新封装到队列中，然后返回。比如，得到所有<code>Student</code>的 ID 列表，只需要根据需要的结果类型使用不同的方法即可：</p><pre><code class="java">// List: [1, 2, 3]final List&lt;String&gt; idList = students.stream().map(Student::getId).collect(Collectors.toList());// Set: [1, 2, 3]final Set&lt;String&gt; idSet = students.stream().map(Student::getId).collect(Collectors.toSet());// TreeSet: [1, 2, 3]final Collection&lt;String&gt; idTreeSet = students.stream().map(Student::getId).collect(Collectors.toCollection(TreeSet::new));</code></pre><blockquote><p>注意：<code>toList</code>方法返回的是<code>List</code>子类，<code>toSet</code>返回的是<code>Set</code>子类，<code>toCollection</code>返回的是<code>Collection</code>子类。我们都知道，<code>Collection</code>的子类包括<code>List</code>、<code>Set</code>等众多子类，所以<code>toCollection</code>更加灵活。</p></blockquote><h3 id="聚合元素：toMap、toConcurrentMap"><a href="#聚合元素：toMap、toConcurrentMap" class="headerlink" title="聚合元素：toMap、toConcurrentMap"></a>聚合元素：toMap、toConcurrentMap</h3><p>这两个方法的作用是将聚合元素，重新组装为<code>Map</code>结构，也就是 k-v 结构。两者用法一样，区别是<code>toMap</code>返回的是<code>Map</code>，<code>toConcurrentMap</code>返回<code>ConcurrentMap</code>，也就是说，<code>toConcurrentMap</code>返回的是线程安全的 Map 结构。</p><p>比如，我们需要聚合<code>Student</code>的 id：</p><pre><code class="java">// {1=Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123), 2=Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123), 3=Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)}final Map&lt;String, Student&gt; map11 = students.stream()    .collect(Collectors.toMap(Student::getId, Function.identity()));</code></pre><p>但是，如果 id 有重复的，会抛出<code>java.lang.IllegalStateException: Duplicate key</code>异常，所以，为了保险起见，我们需要借助<code>toMap</code>另一个重载方法：</p><pre><code class="java">// {1=Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123), 2=Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123), 3=Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)}final Map&lt;String, Student&gt; map2 = students.stream()    .collect(Collectors.toMap(Student::getId, Function.identity(), (x, y) -&gt; x));</code></pre><p>可以看到，<code>toMap</code>有不同的重载方法，可以实现比较复杂的逻辑。比如，我们需要得到根据 id 分组的<code>Student</code>的姓名：</p><pre><code class="java">// {1=张三, 2=李四, 3=王五}final Map&lt;String, String&gt; map3 = students.stream()    .collect(Collectors.toMap(Student::getId, Student::getName, (x, y) -&gt; x));</code></pre><p>比如，我们需要得到相同年龄得分最高的<code>Student</code>对象集合：</p><pre><code class="java">// {10=Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123), 11=Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123), 12=Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123)}final Map&lt;Integer, Student&gt; map5 = students.stream()    .collect(Collectors.toMap(Student::getAge, Function.identity(), BinaryOperator.maxBy(Comparator.comparing(Student::getScore))));</code></pre><p>所以，<code>toMap</code>可玩性很高。</p><h3 id="分组：groupingBy、groupingByConcurrent"><a href="#分组：groupingBy、groupingByConcurrent" class="headerlink" title="分组：groupingBy、groupingByConcurrent"></a>分组：groupingBy、groupingByConcurrent</h3><p><code>groupingBy</code>与<code>toMap</code>都是将聚合元素进行分组，区别是，<code>toMap</code>结果是 1:1 的 k-v 结构，<code>groupingBy</code>的结果是 1:n 的 k-v 结构。</p><p>比如，我们对<code>Student</code>的年龄分组：</p><pre><code class="java">// List: {10=[Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)], 11=[Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123)], 12=[Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123)]}final Map&lt;Integer, List&lt;Student&gt;&gt; map1 = students.stream().collect(Collectors.groupingBy(Student::getAge));// Set: {10=[Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)], 11=[Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123)], 12=[Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123)]}final Map&lt;Integer, Set&lt;Student&gt;&gt; map12 = students.stream().collect(Collectors.groupingBy(Student::getAge, Collectors.toSet()));</code></pre><p>既然<code>groupingBy</code>也是分组，是不是也能够实现与<code>toMap</code>类似的功能，比如，根据 id 分组的<code>Student</code>：</p><pre><code class="java">// {1=Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123), 2=Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123), 3=Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)}final Map&lt;String, Student&gt; map3 = students.stream()    .collect(Collectors.groupingBy(Student::getId, Collectors.collectingAndThen(Collectors.toList(), list -&gt; list.get(0))));</code></pre><p>为了对比，把<code>toMap</code>的写法放在这：</p><pre><code class="java">// {1=Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123), 2=Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123), 3=Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)}final Map&lt;String, Student&gt; map2 = students.stream()    .collect(Collectors.toMap(Student::getId, Function.identity(), (x, y) -&gt; x));</code></pre><p>如果想要线程安全的<code>Map</code>，可以使用<code>groupingByConcurrent</code>。</p><h3 id="分组：partitioningBy"><a href="#分组：partitioningBy" class="headerlink" title="分组：partitioningBy"></a>分组：partitioningBy</h3><p><code>partitioningBy</code>与<code>groupingBy</code>的区别在于，<code>partitioningBy</code>借助<code>Predicate</code>断言，可以将集合元素分为<code>true</code>和<code>false</code>两部分。比如，按照年龄是否大于 11 分组：</p><pre><code class="java">// List: {false=[Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123), Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)], true=[Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123)]}final Map&lt;Boolean, List&lt;Student&gt;&gt; map6 = students.stream().collect(Collectors.partitioningBy(s -&gt; s.getAge() &gt; 11));// Set: {false=[Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123), Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123)], true=[Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123)]}final Map&lt;Boolean, Set&lt;Student&gt;&gt; map7 = students.stream().collect(Collectors.partitioningBy(s -&gt; s.getAge() &gt; 11, Collectors.toSet()));</code></pre><h2 id="链接数据：joining"><a href="#链接数据：joining" class="headerlink" title="链接数据：joining"></a>链接数据：joining</h2><p>这个方法对<code>String</code>类型的元素进行聚合，拼接成一个字符串返回，作用与<code>java.lang.String#join</code>类似，提供了 3 个不同重载方法，可以实现不同的需要。比如：</p><pre><code class="java">// javagosqlStream.of(&quot;java&quot;, &quot;go&quot;, &quot;sql&quot;).collect(Collectors.joining());// java, go, sqlStream.of(&quot;java&quot;, &quot;go&quot;, &quot;sql&quot;).collect(Collectors.joining(&quot;, &quot;));// 【java, go, sql】Stream.of(&quot;java&quot;, &quot;go&quot;, &quot;sql&quot;).collect(Collectors.joining(&quot;, &quot;, &quot;【&quot;, &quot;】&quot;));</code></pre><h2 id="操作链：collectingAndThen"><a href="#操作链：collectingAndThen" class="headerlink" title="操作链：collectingAndThen"></a>操作链：collectingAndThen</h2><p>这个方法在<code>groupingBy</code>的例子中出现过，它是先对集合进行一次聚合操作，然后通过<code>Function</code>定义的函数，对聚合后的结果再次处理。</p><p>比如<code>groupingBy</code>中的例子：</p><pre><code class="java">// {1=Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123), 2=Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123), 3=Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)}final Map&lt;String, Student&gt; map3 = students.stream()    .collect(Collectors.groupingBy(Student::getId, Collectors.collectingAndThen(Collectors.toList(), list -&gt; list.get(0))));</code></pre><p>显示将结果聚合成<code>List</code>列表，然后取列表的第 0 个元素返回，通过这种方式，实现 1:1 的 map 结构。</p><p>再来一个复杂一些的，找到聚合元素中年龄数据正确的<code>Student</code>列表：</p><pre><code class="java">// []，结果为空，是因为例子中所有人的年龄都是对的students.stream()        .collect(                Collectors.collectingAndThen(Collectors.toList(), (                        list -&gt; list.stream()                                .filter(s -&gt; (LocalDate.now().getYear() - s.getBirthday().getYear()) != s.getAge())                                .collect(Collectors.toList()))                )        );</code></pre><blockquote><p>这个例子纯粹是为了使用<code>collectingAndThen</code>的用法，其实可以简化为：</p><pre><code class="java">students.stream()        .filter(s -&gt; (LocalDate.now().getYear() - s.getBirthday().getYear()) != s.getAge())        .collect(Collectors.toList());</code></pre></blockquote><h2 id="操作后聚合：mapping"><a href="#操作后聚合：mapping" class="headerlink" title="操作后聚合：mapping"></a>操作后聚合：mapping</h2><p><code>mapping</code>先通过<code>Function</code>函数处理数据，然后通过<code>Collector</code>方法聚合元素。比如，获取获取<code>students</code>的姓名列表：</p><pre><code class="java">// [张三, 李四, 王五]students.stream()        .collect(Collectors.mapping(Student::getName, Collectors.toList()));</code></pre><p>这种计算与<code>java.util.stream.Stream#map</code>方式类似：</p><pre><code class="java">// [张三, 李四, 王五]students.stream()        .map(Student::getName)        .collect(Collectors.toList());</code></pre><p>从这点上看，还是通过<code>java.util.stream.Stream#map</code>更清晰一些。</p><h2 id="聚合后操作：reducing"><a href="#聚合后操作：reducing" class="headerlink" title="聚合后操作：reducing"></a>聚合后操作：reducing</h2><p><code>reducing</code>提供了 3 个重载方法：</p><ul><li><code>public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; reducing(BinaryOperator&lt;T&gt; op)</code>：直接通过<code>BinaryOperator</code>操作，返回值是<code>Optional</code></li><li><code>public static &lt;T&gt; Collector&lt;T, ?, T&gt; reducing(T identity, BinaryOperator&lt;T&gt; op)</code>：预定默认值，然后通过<code>BinaryOperator</code>操作</li><li><code>public static &lt;T, U&gt; Collector&lt;T, ?, U&gt; reducing(U identity, Function&lt;? super T, ? extends U&gt; mapper, BinaryOperator&lt;U&gt; op)</code>：预定默认值，通过<code>Function</code>操作元素，然后通过<code>BinaryOperator</code>操作</li></ul><p>比如，计算所有<code>students</code>的得分总数：</p><pre><code class="java">// Optional[66.369]，注意返回类型是Optionalstudents.stream()        .map(Student::getScore)        .collect(Collectors.reducing(Double::sum));// 66.369students.stream()        .map(Student::getScore)        .collect(Collectors.reducing(0.0, Double::sum));// 66.369students.stream()        .collect(Collectors.reducing(0.0, Student::getScore, Double::sum));</code></pre><p>同<code>mapping</code>，<code>reducing</code>的操作与<code>java.util.stream.Stream#reduce</code>方式类似：</p><pre><code class="java">// Optional[66.369]，注意返回类型是Optionalstudents.stream().map(Student::getScore).reduce(Double::sum);// 66.369students.stream().map(Student::getScore).reduce(0.0, Double::sum);</code></pre><p>在上文说到<code>maxBy</code>和<code>minBy</code>时，提到这两个函数就是通过<code>reducing</code>实现的。</p><blockquote><p>对于<code>mapping</code>和<code>reducing</code>，可以参考函数式编程中 map-reduce 的概念。</p></blockquote><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文主要讲解了 Java8 Stream 中 Collectors 定义的 24 个方法，这种流式计算逻辑，依靠 Fork/Join 框架，性能方面有很大的优势。如果没有掌握这些用法，可能在后续阅读代码时，会很吃力，毕竟，Java8 基本上已经是业界标杆了。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/java-stream-collectors/">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://www.howardliu.cn/java-util-optional/">一文掌握 Java8 的 Optional 的 6 种操作</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-stream-collectors/">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/116762456" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      一文掌握 Java8 Stream 中 Collectors 的 24 个操作。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="JDK8" scheme="https://www.howardliu.cn/tags/JDK8/"/>
    
      <category term="stream" scheme="https://www.howardliu.cn/tags/stream/"/>
    
      <category term="collectors" scheme="https://www.howardliu.cn/tags/collectors/"/>
    
  </entry>
  
  <entry>
    <title>面试真题：无重复字符的最长子串</title>
    <link href="https://www.howardliu.cn/longest-substring-without-repeating-character/"/>
    <id>https://www.howardliu.cn/longest-substring-without-repeating-character/</id>
    <published>2021-05-08T02:46:53.000Z</published>
    <updated>2021-05-08T02:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/altorithm/surfing-5628803_1920.jpg" alt="面试真题：无重复字符的最长子串"></p><p>你好，我是看山。</p><p>来一个算法题，面试之后查了一下，是 LeetCode 的第三题，难度中等。居然在面试过程中碰到 LeetCode 真题，事后总结一波。加深印象。</p><a id="more"></a><p>先看一下题目描述：</p><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p><p>输入：s = “abcabcbb”<br>输出：3<br>解释：因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><p>输入：s = “pwwkew”<br>输出：3<br>解释：因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p><p>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p></blockquote><p>看过题目之后，我最先想到的是一道数学题：一个线段上有 10 个点，求总共有多少的线段？如果是小朋友解题的话，一般就是，左手固定，右手向右移动，每移动一个点就加一个数，右手移动到末尾后，左手向右移动一个点，以此类推，知道最后一个点。这样就能够数出所有的线段数量，而且还不会乱。</p><p>其实上面这个算法题和我说的这个数学题的解法类似，采用小学生解法，只不过需要在数数的时候加一些判断，比如，线段中的点，有没有相同的。</p><p>来个图例：</p><p><img src="http://static.howardliu.cn/altorithm/WX20210508-115432.png" alt="无重复字符的最长子串"></p><p>根据图例写代码：</p><pre><code class="java">import java.util.HashSet;import java.util.Set;class Solution {    public static int lengthOfLongestSubstring(String s) {        if (s == null || s.isEmpty()) {            return 0;        }        final int len = s.length();        final Set&lt;Character&gt; sets = new HashSet&lt;&gt;();        int i = 0, j = 0, result = 0;        Character tmp ;        while (i &lt; len &amp;&amp; j &lt; len) {            tmp = s.charAt(j);            if (sets.contains(tmp)) {                sets.remove(s.charAt(i++));            } else {                sets.add(tmp);                result = Math.max(result, j++ - i + 1);            }        }        return result;    }}</code></pre><p>如果是面试，这个时候就可以交差了。既然是总结，就得再想一下这个解法有没有通用性。我们所采用的办法是，通过两个变量 i 和 j 指向计算元素，然后与 i 与 j 之间的元素进行判断，这种方式江湖称之为“双指针”。贴心的 LeetCode 也给过定义：</p><blockquote><p>双指针从广义上来说，是指用两个变量在线性结构上遍历而解决的问题。狭义上说，</p><ul><li>对于数组，指两个变量在数组上相向移动解决的问题；</li><li>对于链表，指两个变量在链表上同向移动解决的问题，也称为「快慢指针」问题。</li></ul><p>双指针算法通常不难，是基于暴力解法的优化，<strong>它们是很好的学习算法的入门问题</strong>。</p></blockquote><p>从 <a href="https://leetcode-cn.com/tag/two-pointers/problemset/" target="_blank" rel="noopener">这里</a> 可以找到所有 LeetCode 中关于双指针解法的题目，可以过足瘾。</p><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/longest-substring-without-repeating-character/">面试真题：无重复字符的最长子串</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/116545038" target="_blank" rel="noopener">面试真题：无重复字符的最长子串</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      找出不含有重复字符的最长子串的长度。
    
    </summary>
    
    
      <category term="算法" scheme="https://www.howardliu.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.howardliu.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="双指针" scheme="https://www.howardliu.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="滑动窗口" scheme="https://www.howardliu.cn/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Spring 实战：自定义 Filter 优雅获取请求参数和响应结果</title>
    <link href="https://www.howardliu.cn/spring-request-recorder/"/>
    <id>https://www.howardliu.cn/spring-request-recorder/</id>
    <published>2021-04-29T03:22:51.000Z</published>
    <updated>2021-04-29T03:22:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/spring/kingfisher-6146356_1920.jpg" alt="Spring 实战：自定义 Filter 优雅获取请求参数和响应结果"></p><p>你好，我是看山。</p><a id="more"></a><p>一个系统上线，肯定会或多或少的存在异常情况。为了更快更好的排雷，记录请求参数和响应结果是非常必要的。所以，Nginx 和 Tomcat 之类的 web 服务器，都提供了访问日志，可以帮助我们记录一些请求信息。</p><p>本文是在我们的应用中，定义一个<code>Filter</code>来实现记录请求参数和响应结果的功能。</p><p>有一定经验的都知道，如果我们在<code>Filter</code>中读取了<code>HttpServletRequest</code>或者<code>HttpServletResponse</code>的流，就没有办法再次读取了，这样就会造成请求异常。所以，我们需要借助 Spring 提供的<code>ContentCachingRequestWrapper</code>和<code>ContentCachingRequestWrapper</code>实现数据流的重复读取。</p><h2 id="定义-Filter"><a href="#定义-Filter" class="headerlink" title="定义 Filter"></a>定义 Filter</h2><p>通常来说，我们自定义的<code>Filter</code>是实现<code>Filter</code>接口，然后写一些逻辑，但是既然是在 Spring 中，那就借助 Spring 的一些特性。在我们的实现中，要继承<code>OncePerRequestFilter</code>实现我们的自定义实现。</p><p>从类名上推断，<code>OncePerRequestFilter</code>是每次请求只执行一次，但是，难道<code>Filter</code>在一次请求中还会执行多次吗？Spring 官方也是给出定义这个类的原因：</p><blockquote><p>Filter base class that aims to guarantee a single execution per request dispatch, on any servlet container. It provides a doFilterInternal(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, javax.servlet.FilterChain) method with HttpServletRequest and HttpServletResponse arguments.</p><p>As of Servlet 3.0, a filter may be invoked as part of a REQUEST or ASYNC dispatches that occur in separate threads. A filter can be configured in web.xml whether it should be involved in async dispatches. However, in some cases servlet containers assume different default configuration. Therefore sub-classes can override the method shouldNotFilterAsyncDispatch() to declare statically if they should indeed be invoked, once, during both types of dispatches in order to provide thread initialization, logging, security, and so on. This mechanism complements and does not replace the need to configure a filter in web.xml with dispatcher types.</p><p>Subclasses may use isAsyncDispatch(HttpServletRequest) to determine when a filter is invoked as part of an async dispatch, and use isAsyncStarted(HttpServletRequest) to determine when the request has been placed in async mode and therefore the current dispatch won’t be the last one for the given request.</p><p>Yet another dispatch type that also occurs in its own thread is ERROR. Subclasses can override shouldNotFilterErrorDispatch() if they wish to declare statically if they should be invoked once during error dispatches.</p></blockquote><p>也就是说，Spring 是为了兼容不同的 Web 容器，所以定义了只会执行一次的<code>OncePerRequestFilter</code>。</p><p>接下来开始定义我们的<code>Filter</code>类：</p><pre><code class="java">public class AccessLogFilter extends OncePerRequestFilter {    //... 这里有一些必要的属性    @Override    protected void doFilterInternal(final HttpServletRequest request,                                    final HttpServletResponse response,                                    final FilterChain filterChain)            throws ServletException, IOException {        // 如果是被排除的 uri，不记录 access_log        if (matchExclude(request.getRequestURI())) {            filterChain.doFilter(request, response);            return;        }        final String requestMethod = request.getMethod();        final boolean shouldWrapMethod = StringUtils.equalsIgnoreCase(requestMethod, HttpMethod.PUT.name())                || StringUtils.equalsIgnoreCase(requestMethod, HttpMethod.POST.name());        final boolean isFirstRequest = !isAsyncDispatch(request);        final boolean shouldWrapRequest = isFirstRequest &amp;&amp; !(request instanceof ContentCachingRequestWrapper) &amp;&amp; shouldWrapMethod;        final HttpServletRequest requestToUse = shouldWrapRequest ? new ContentCachingRequestWrapper(request) : request;        final boolean shouldWrapResponse = !(response instanceof ContentCachingResponseWrapper) &amp;&amp; shouldWrapMethod;        final HttpServletResponse responseToUse = shouldWrapResponse ? new ContentCachingResponseWrapper(response) : response;        final long startTime = System.currentTimeMillis();        Throwable t = null;        try {            filterChain.doFilter(requestToUse, responseToUse);        } catch (Exception e) {            t = e;            throw e;        } finally {            doSaveAccessLog(requestToUse, responseToUse, System.currentTimeMillis() - startTime, t);        }    }    // ... 这里是一些必要的方法</code></pre><blockquote><p>这段代码就是整个逻辑的核心所在，其他的内容从源码中找到。</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个代码中，整体的逻辑没有特别复杂的地方，只需要注意几个关键点就可以了。</p><ol><li>默认的<code>HttpServletRequest</code>和<code>HttpServletResponse</code>中的流被读取一次之后，再次读取会失败，所以要使用<code>ContentCachingRequestWrapper</code>和<code>ContentCachingResponseWrapper</code>进行包装，实现重复读取。</li><li>既然我们可以自定义<code>Filter</code>，那我们依赖的组件中也可能会自定义<code>Filter</code>，更有可能已经对请求和响应对象进行过封装，所以，一定要先进行一步判断。也就是<code>request instanceof ContentCachingRequestWrapper</code>和<code>response instanceof ContentCachingResponseWrapper</code>。</li></ol><p>只要注意了这两点，剩下的都是这个逻辑的细化实现。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>接下来我们就运行一遍，看看结果。先定义几种不同的请求：普通 get 请求、普通 post 请求、上传文件、下载文件，这四个接口几乎可以覆盖绝大部分场景。（因为都是比较简单的写法，源码就不赘述了，可以从文末的源码中找到）</p><p>先启动项目，然后借助 IDEA 的 http 请求工具：</p><pre><code class="script">###普通 get 请求GET http://localhost:8080/index/get?name=howard###普通 post 请求POST http://localhost:8080/index/postContent-Type: application/json{&quot;name&quot;:&quot;howard&quot;}###上传文件POST http://localhost:8080/index/uploadContent-Type: multipart/form-data; boundary=WebAppBoundary--WebAppBoundaryContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;history.txt&quot;Content-Type: multipart/form-data&lt;/Users/liuxh/history.txt--WebAppBoundary--###下载文件GET http://localhost:8080/index/download</code></pre><p>再看看打印的日志：</p><pre><code class="log">2021-04-29 19:44:57.495  INFO 83448 --- [nio-8080-exec-1] c.h.d.s.filter.AccessLogFilter           : time=44ms,ip=127.0.0.1,uri=/index/get,headers=[host:localhost:8080,connection:Keep-Alive,user-agent:Apache-HttpClient/4.5.12 (Java/11.0.7),accept-encoding:gzip,deflate],status=200,requestContentType=null,responseContentType=text/plain;charset=UTF-8,params=name=howard,request=,response=2021-04-29 19:44:57.551  INFO 83448 --- [nio-8080-exec-2] c.h.d.s.filter.AccessLogFilter           : time=36ms,ip=127.0.0.1,uri=/index/post,headers=[content-type:application/json,content-length:17,host:localhost:8080,connection:Keep-Alive,user-agent:Apache-HttpClient/4.5.12 (Java/11.0.7),accept-encoding:gzip,deflate],status=200,requestContentType=application/json,responseContentType=application/json,params=,request={&quot;name&quot;:&quot;howard&quot;},response={&quot;name&quot;:&quot;howard&quot;,&quot;timestamp&quot;:&quot;1619696697540&quot;}2021-04-29 19:44:57.585  INFO 83448 --- [nio-8080-exec-3] c.h.d.s.filter.AccessLogFilter           : time=20ms,ip=127.0.0.1,uri=/index/upload,headers=[content-type:multipart/form-data; boundary=WebAppBoundary,content-length:232,host:localhost:8080,connection:Keep-Alive,user-agent:Apache-HttpClient/4.5.12 (Java/11.0.7),accept-encoding:gzip,deflate],status=200,requestContentType=multipart/form-data; boundary=WebAppBoundary,responseContentType=application/json,params=,request=,response={&quot;contentLength&quot;:&quot;0&quot;,&quot;contentType&quot;:&quot;multipart/form-data&quot;}2021-04-29 19:44:57.626  INFO 83448 --- [nio-8080-exec-4] c.h.d.s.filter.AccessLogFilter           : time=27ms,ip=127.0.0.1,uri=/index/download,headers=[host:localhost:8080,connection:Keep-Alive,user-agent:Apache-HttpClient/4.5.12 (Java/11.0.7),accept-encoding:gzip,deflate],status=200,requestContentType=null,responseContentType=application/octet-stream;charset=utf-8,params=,request=,response=</code></pre><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>自定义<code>Filter</code>是比较简单的，只要能够注意几个关键点就可以了。不过后续还有扩展的空间，比如：</p><ol><li>定义排除的请求 uri，可以借助<code>AntPathMatcher</code>实现 ant 风格的定义</li><li>将请求日志单独存放，可以借助 logback 或者 log4j2 等框架的的日志配置实现，这样能更加方便的查找日志</li><li>与调用链技术结合，在请求日志中增加调用链的 TraceId 等，可以快速定位待查询的请求日志</li></ol><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>附上源码：<a href="https://github.com/howardliu-cn/effective-spring/tree/main/spring-filter" target="_blank" rel="noopener">https://github.com/howardliu-cn/effective-spring/tree/main/spring-filter</a></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response/">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response-exception/">SpringBoot 实战：如何优雅的处理异常</a></li><li><a href="https://www.howardliu.cn/spring-beanpostprocessor/">Spring 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://www.howardliu.cn/spring-request-recorder/">Spring 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/spring-request-recorder/">Spring 实战：自定义 Filter 优雅获取请求参数和响应结果</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/116276032" target="_blank" rel="noopener">Spring 实战：自定义 Filter 优雅获取请求参数和响应结果</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文是在我们的应用中，定义一个 Filter 来实现记录请求参数和响应结果的功能。
    
    </summary>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/categories/spring/"/>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/tags/spring/"/>
    
      <category term="filter" scheme="https://www.howardliu.cn/tags/filter/"/>
    
  </entry>
  
  <entry>
    <title>Spring 实战：通过 BeanPostProcessor 动态注入 ID 生成器</title>
    <link href="https://www.howardliu.cn/spring-beanpostprocessor/"/>
    <id>https://www.howardliu.cn/spring-beanpostprocessor/</id>
    <published>2021-04-25T09:03:15.000Z</published>
    <updated>2021-04-25T09:03:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/spring/pine-5541335_1920.jpg" alt="Spring 实战：通过 BeanPostProcessor 动态注入 ID 生成器"></p><p>你好，我是看山。</p><p>在分布式系统中，我们会需要 ID 生成器的组件，这个组件可以实现帮助我们生成顺序的或者带业务含义的 ID。</p><p>目前有很多经典的 ID 生成方式，比如数据库自增列（自增主键或序列）、Snowflake 算法、美团 Leaf 算法等等，所以，会有一些公司级或者业务级的 ID 生成器组件的诞生。本文就是通过 BeanPostProcessor 实现动态注入 ID 生成器的实战。</p><a id="more"></a><p>在 Spring 中，实现注入的方式很多，比如 springboot 的 starter，在自定义的 Configuration 中初始化 ID 生成器的 Bean，业务代码中通过<code>@AutoWired</code>或者<code>@Resource</code>注入即可，开箱即用。这种方式简单直接，但是缺点也是过于简单，缺少了使用方自定义的入口。</p><p>考虑一下实际场景，在同一个业务单据中，要保持 ID 的唯一，但是在不同单据中，可以重复。而且，这些算法在生成 ID 的时候，为了保持多线程返回结果唯一，都会锁定共享资源。如果不同业务，并发情景不同，可能低并发的业务被高并发的业务阻塞获取 ID，造成一些性能的损失。所以，我们要考虑将 ID 生成器，根据业务隔离开，这样 springboot 的 starter 就会显得不够灵活了。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>根据上面的需求，我们可以分几步实现我们的逻辑：</p><ol><li>自定义属性注解，用于判断是否需要注入属性对象</li><li>定义 ID 生成器接口、实现类，以及工厂类，工厂类是为了根据定义创建不同的 ID 生成器实现对象</li><li>定义 BeanPostProcessor，查找使用自定义注解定义的属性，实现注入</li></ol><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>首先自定义一个注解，可以定义一个<code>value</code>属性，作为隔离业务的标识：</p><pre><code class="java">@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.FIELD, ElementType.METHOD})public @interface IdGeneratorClient {    /**     * ID 生成器名称     *     * @return     */    String value() default &quot;DEFAULT&quot;;}</code></pre><h3 id="定义-ID-生成器"><a href="#定义-ID-生成器" class="headerlink" title="定义 ID 生成器"></a>定义 ID 生成器</h3><p>定义 ID 生成器的接口：</p><pre><code class="java">public interface IdGenerator {    String groupName();    long nextId();}</code></pre><p>实现 ID 生成器接口，偷懒使用<code>AtomicLong</code>实现自增，同时考虑 ID 生成器是分组的，通过<code>ConcurrentHashMap</code>实现 ID 生成器的持有：</p><pre><code class="java">class DefaultIdGenerator implements IdGenerator {    private static final Map&lt;String, AtomicLong&gt; ID_CACHE = new ConcurrentHashMap&lt;&gt;(new HashMap&lt;&gt;());    private final String groupName;    DefaultIdGenerator(final String groupName) {        this.groupName = groupName;        synchronized (ID_CACHE) {            ID_CACHE.computeIfAbsent(groupName, key -&gt; new AtomicLong(1));        }    }    @Override    public String groupName() {        return this.groupName;    }    @Override    public long nextId() {        return ID_CACHE.get(this.groupName).getAndIncrement();    }}</code></pre><p>如前面设计的，我们需要一个工厂类来创建 ID 生成器，示例中使用最简单的实现，我们真正使用的时候，还可以通过更加灵活的 SPI 实现（关于 SPI 的实现，这里挖个坑，后面专门写一篇填坑）：</p><pre><code class="java">public enum IdGeneratorFactory {    INSTANCE;    private static final Map&lt;String, IdGenerator&gt; ID_GENERATOR_MAP = new ConcurrentHashMap&lt;&gt;(new HashMap&lt;&gt;());    public synchronized IdGenerator create(final String groupName) {        return ID_GENERATOR_MAP.computeIfAbsent(groupName, key -&gt; new DefaultIdGenerator(groupName));    }}</code></pre><h3 id="定义-BeanPostProcessor"><a href="#定义-BeanPostProcessor" class="headerlink" title="定义 BeanPostProcessor"></a>定义 BeanPostProcessor</h3><p>前面都是属于基本操作，这里才是扩展的核心。我们的实现逻辑是：</p><ol><li>扫描 bean 的所有属性，然后找到定义了<code>IdGeneratorClient</code>注解的属性</li><li>获取注解的<code>value</code>值，作为 ID 生成器的分组标识</li><li>使用<code>IdGeneratorFactory</code>这个工厂类生成 ID 生成器实例，这里会返回新建的或已经定义的实例</li><li>通过反射将 ID 生成器实例写入 bean</li></ol><pre><code class="java">public class IdGeneratorBeanPostProcessor implements BeanPostProcessor {    @Override    public Object postProcessBeforeInitialization(final Object bean, final String beanName) throws BeansException {        return bean;    }    @Override    public Object postProcessAfterInitialization(final Object bean, final String beanName) throws BeansException {        parseFields(bean);        return bean;    }    private void parseFields(final Object bean) {        if (bean == null) {            return;        }        Class&lt;?&gt; clazz = bean.getClass();        parseFields(bean, clazz);        while (clazz.getSuperclass() != null &amp;&amp; !clazz.getSuperclass().equals(Object.class)) {            clazz = clazz.getSuperclass();            parseFields(bean, clazz);        }    }    private void parseFields(final Object bean, Class&lt;?&gt; clazz) {        if (bean == null || clazz == null) {            return;        }        for (final Field field : clazz.getDeclaredFields()) {            try {                final IdGeneratorClient annotation = AnnotationUtils.getAnnotation(field, IdGeneratorClient.class);                if (annotation == null) {                    continue;                }                final String groupName = annotation.value();                final Class&lt;?&gt; fieldType = field.getType();                if (fieldType.equals(IdGenerator.class)) {                    final IdGenerator idGenerator = IdGeneratorFactory.INSTANCE.create(groupName);                    invokeSetField(bean, field, idGenerator);                    continue;                }                throw new RuntimeException(&quot;未知字段类型无法初始化，bean: &quot; + bean + &quot;，field: &quot; + field);            } catch (Throwable t) {                throw new RuntimeException(&quot;初始化字段失败，bean=&quot; + bean + &quot;，field=&quot; + field, t);            }        }    }    private void invokeSetField(final Object bean, final Field field, final Object param) {        ReflectionUtils.makeAccessible(field);        ReflectionUtils.setField(field, bean, param);    }}</code></pre><p>实现<code>BeanPostProcessor</code>接口需要完成<code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>两个方法的定义。下图是 Spring 中 Bean 的实例化过程：</p><p><img src="http://static.howardliu.cn/spring/1350888580_1225.jpg" alt="Spring 中 Bean 的实例化过程图示"></p><p>从图中可以知道，Spring 调用<code>BeanPostProcessor</code>的这两个方法时，bean 已经被实例化，所有能注入的属性都已经被注入了，是一个完整的 bean。而且两个方法的返回值，可以是原来的 bean 实例，也可以是包装后的实例，这就要看我们的定义了。</p><h3 id="测试我们的代码"><a href="#测试我们的代码" class="headerlink" title="测试我们的代码"></a>测试我们的代码</h3><p>写一个测试用例，验证我们的实现是否生效：</p><pre><code class="java">@SpringBootTestclass SpringBeanPostProcessorApplicationTests {    @IdGeneratorClient    private IdGenerator defaultIdGenerator;    @IdGeneratorClient(&quot;group1&quot;)    private IdGenerator group1IdGenerator;    @Test    void contextLoads() {        Assert.notNull(defaultIdGenerator, &quot;注入失败&quot;);        System.out.println(defaultIdGenerator.groupName() + &quot; =&gt; &quot; + defaultIdGenerator.nextId());        Assert.notNull(group1IdGenerator, &quot;注入失败&quot;);        for (int i = 0; i &lt; 5; i++) {            System.out.println(defaultIdGenerator.groupName() + &quot; =&gt; &quot; + defaultIdGenerator.nextId());            System.out.println(group1IdGenerator.groupName() + &quot; =&gt; &quot; + group1IdGenerator.nextId());        }    }}</code></pre><p>运行结果为：</p><pre><code class="log">DEFAULT =&gt; 1DEFAULT =&gt; 2group1 =&gt; 1DEFAULT =&gt; 3group1 =&gt; 2DEFAULT =&gt; 4group1 =&gt; 3DEFAULT =&gt; 5group1 =&gt; 4DEFAULT =&gt; 6group1 =&gt; 5</code></pre><p>可以看到，默认的 ID 生成器与定义名称为 group1 的 ID 生成器是分别生成的，符合预期。</p><h2 id="文末思考"><a href="#文末思考" class="headerlink" title="文末思考"></a>文末思考</h2><p>我们实现了通过<code>BeanPostProcessor</code>实现自动注入自定义的业务对象，上面的实现还比较简单，有很多可以扩展的地方，比如工厂方法实现，可以借助 SPI 的方式更加灵活的创建 ID 生成器对象。同时，考虑到分布式场景，我们还可以在 ID 生成器实现类中，通过注入 rpc 实例，实现远程 ID 生成逻辑。</p><p>玩法无限，就看我们的想象了。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>附上源码：<a href="https://github.com/howardliu-cn/effective-spring/tree/main/spring-beanpostprocessor" target="_blank" rel="noopener">https://github.com/howardliu-cn/effective-spring/tree/main/spring-beanpostprocessor</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://howtodoinjava.com/spring-core/spring-bean-post-processors/" target="_blank" rel="noopener">Spring BeanPostProcessor Example</a></li><li><a href="https://www.baeldung.com/spring-beanpostprocessor" target="_blank" rel="noopener">Spring BeanPostProcessor</a></li></ul><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response/">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response-exception/">SpringBoot 实战：如何优雅的处理异常</a></li><li><a href="https://www.howardliu.cn/spring-beanpostprocessor/">Spring 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://www.howardliu.cn/spring-request-recorder/">Spring 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/spring-beanpostprocessor/">Spring 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/116139540" target="_blank" rel="noopener">Spring 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文通过实战的方式，了解 BeanPostProcessor 的作用。
    
    </summary>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/categories/spring/"/>
    
    
      <category term="BeanPostProcessor" scheme="https://www.howardliu.cn/tags/BeanPostProcessor/"/>
    
      <category term="实战" scheme="https://www.howardliu.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发基础（五）：面试实战之多线程顺序打印</title>
    <link href="https://www.howardliu.cn/java-concurrency-ordered-thread-print/"/>
    <id>https://www.howardliu.cn/java-concurrency-ordered-thread-print/</id>
    <published>2021-04-11T08:52:20.000Z</published>
    <updated>2021-04-11T08:52:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/java/plant-3263600_1920.jpg" alt="Java 并发基础（五）：面试实战之多线程顺序打印"></p><p>你好，我是看山。</p><p>来个面试题，让大家练练手。这个题在阿里和小米都被问过，所以放在这个抛砖引玉，期望能够得到一个更佳的答案。</p><a id="more"></a><p>实现 3 个线程 A、B、C，A 线程持续打印“A”，B 线程持续打印“B”，C 线程持续打印“C”，启动顺序是线程 C、线程 B、线程 A，打印的结果是：ABC。</p><h2 id="解法一：状态位变量控制"><a href="#解法一：状态位变量控制" class="headerlink" title="解法一：状态位变量控制"></a>解法一：状态位变量控制</h2><p>这个问题考察的是多线程协同顺序执行。也就是第一个线程最先达到执行条件，开始执行，执行完之后，第二个线程达到执行条件，开始执行，以此类推。可以想到的是，通过状态位来表示线程执行的条件，多个线程自旋等待状态位变化。</p><p>线上代码：</p><pre><code class="java">import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class ABCThread {    private static final Lock lock = new ReentrantLock();    private static volatile int state = 0;    private static final Thread threadA = new Thread(() -&gt; {        while (true) {            lock.lock();            try {                if (state % 3 == 0) {                    System.out.println(&quot;A&quot;);                    state++;                    break;                } else {                    System.out.println(&quot;A thread &amp; state = &quot; + state);                }            } finally {                lock.unlock();            }        }    });    private static final Thread threadB = new Thread(() -&gt; {        while (true) {            lock.lock();            try {                if (state % 3 == 1) {                    System.out.println(&quot;B&quot;);                    state++;                    break;                } else {                    System.out.println(&quot;B thread &amp; state = &quot; + state);                }            } finally {                lock.unlock();            }        }    });    private static final Thread threadC = new Thread(() -&gt; {        while (true) {            lock.lock();            try {                if (state % 3 == 2) {                    System.out.println(&quot;C&quot;);                    state++;                    break;                } else {                    System.out.println(&quot;C thread &amp; state = &quot; + state);                }            } finally {                lock.unlock();            }        }    });    public static void main(String[] args) {        threadC.start();        threadB.start();        threadA.start();    }}</code></pre><p>可以看到，状态位<code>state</code>使用<code>volatile</code>修饰，是希望一个线程修改状态位值之后，其他线程可以读取到刚修改的数据，这个属于 Java 内存模型的范围，后续会有单独的章节描述。</p><p>这个可以解题，但是却有很多性能上的损耗。因为每个进程都在自旋检查状态值<code>state</code>是否符合条件，而且自旋过程中会有获取锁的过程，代码中在不符合条件时打印了一些内容，比如：<code>System.out.println(&quot;A thread &amp; state = &quot; + state);</code>，我们可以运行一下看看结果：</p><pre><code class="log">C thread &amp; state = 0...67行C thread &amp; state = 0B thread &amp; state = 0...43行B thread &amp; state = 0AC thread &amp; state = 1...53行C thread &amp; state = 1BC</code></pre><p>可以看到，在A线程获取到锁之前，C线程和B线程自旋了100多次，然后A线程才获取机会获取锁和打印。然后在B线程获取锁之前，C线程又自旋了53次。性能损耗可见一斑。</p><h2 id="解法二：Condition实现条件判断"><a href="#解法二：Condition实现条件判断" class="headerlink" title="解法二：Condition实现条件判断"></a>解法二：Condition实现条件判断</h2><p>既然无条件自旋浪费性能，那就加上条件自旋。</p><p>代码如下：</p><pre><code class="java">import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class ABCThread2 {    private static final Lock lock = new ReentrantLock();    private static volatile int state = 0;    private static final Condition conditionA = lock.newCondition();    private static final Condition conditionB = lock.newCondition();    private static final Condition conditionC = lock.newCondition();    private static final Thread threadA = new Thread(() -&gt; {        while (true) {            lock.lock();            try {                while(state % 3 != 0) {                    System.out.println(&quot;A await start&quot;);                    conditionA.await();                    System.out.println(&quot;A await end&quot;);                }                System.out.println(&quot;A&quot;);                state++;                conditionB.signal();                break;            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                lock.unlock();            }        }    });    private static final Thread threadB = new Thread(() -&gt; {        while (true) {            lock.lock();            try {                while(state % 3 != 1) {                    System.out.println(&quot;B await start&quot;);                    conditionB.await();                    System.out.println(&quot;B await end&quot;);                }                System.out.println(&quot;B&quot;);                state++;                conditionC.signal();                break;            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                lock.unlock();            }        }    });    private static final Thread threadC = new Thread(() -&gt; {        while (true) {            lock.lock();            try {                while(state % 3 != 2) {                    System.out.println(&quot;C await start&quot;);                    conditionC.await();                    System.out.println(&quot;C await end&quot;);                }                System.out.println(&quot;C&quot;);                state++;                break;            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                lock.unlock();            }        }    });    public static void main(String[] args) {        threadC.start();        threadB.start();        threadA.start();    }}</code></pre><p>通过<code>Lock</code>锁的<code>Condition</code>实现有条件自旋，运行结果如下：</p><pre><code class="log">C await startB await startAB await endBC await endC</code></pre><p>可以从运行结果看到，C线程发现自己不符合要求，就通过<code>conditionC.await();</code>释放锁，然后等待条件被唤醒后重新获得锁。然后是B线程，最后是A线程开始执行，发现符合条件，直接运行，然后唤醒B线程的锁条件，依次类推。这种方式其实和信号量很类似。</p><h2 id="解法三：信号量"><a href="#解法三：信号量" class="headerlink" title="解法三：信号量"></a>解法三：信号量</h2><p>先上代码：</p><pre><code class="java">import java.util.concurrent.Semaphore;class ABCThread3 {    private static Semaphore semaphoreA = new Semaphore(1);    private static Semaphore semaphoreB = new Semaphore(1);    private static Semaphore semaphoreC = new Semaphore(1);    private static final Thread threadA = new Thread(() -&gt; {        try {            semaphoreA.acquire();            System.out.println(&quot;A&quot;);            semaphoreB.release();        } catch (InterruptedException e) {            e.printStackTrace();        }    });    private static final Thread threadB = new Thread(() -&gt; {        try {            semaphoreB.acquire();            System.out.println(&quot;B&quot;);            semaphoreC.release();        } catch (InterruptedException e) {            e.printStackTrace();        }    });    private static final Thread threadC = new Thread(() -&gt; {        try {            semaphoreC.acquire();            System.out.println(&quot;C&quot;);        } catch (InterruptedException e) {            e.printStackTrace();        }    });    public static void main(String[] args) throws InterruptedException {        semaphoreB.acquire();        semaphoreC.acquire();        threadC.start();        threadB.start();        threadA.start();    }}</code></pre><p>代码中执行前先执行了<code>semaphoreB.acquire();</code>和<code>semaphoreC.acquire();</code>，是为了将B和C的信号释放，这个时候，就能够阻塞B线程、C线程中信号量的获取，直到顺序获取了信号值。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>这个题是考察大家对线程执行顺序和线程之间协同的理解，文中所实现的三种方式，都能解题，只不过代码复杂度和性能有差异。因为其中涉及很多多线程的内容，后续会单独开文说明每个知识点。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/java-concurrency-synchronized/">Java 并发基础（一）：synchronized 锁同步</a></li><li><a href="https://www.howardliu.cn/main-thread-waiting-for-the-end-of-subthread/">Java 并发基础（二）：主线程等待子线程结束</a></li><li><a href="https://www.howardliu.cn/talk-about-CountDownLatch-again/">Java 并发基础（三）：再谈 CountDownLatch</a></li><li><a href="https://www.howardliu.cn/talk-about-CyclicBarrier-again/">Java 并发基础（四）：再谈 CyclicBarrier</a></li><li><a href="https://www.howardliu.cn/java-concurrency-ordered-thread-print/">Java 并发基础（五）：面试实战之多线程顺序打印</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-concurrency-ordered-thread-print/">Java 并发基础（五）：面试实战之多线程顺序打印</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/115609160" target="_blank" rel="noopener">Java 并发基础（五）：面试实战之多线程顺序打印</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      实现 3 个线程 A、B、C，A 线程持续打印“A”，B 线程持续打印“B”，C 线程持续打印“C”，启动顺序是线程 C、线程 B、线程 A，打印的结果是：ABC。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="concurrency" scheme="https://www.howardliu.cn/tags/concurrency/"/>
    
      <category term="thread" scheme="https://www.howardliu.cn/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发基础（一）：synchronized 锁同步</title>
    <link href="https://www.howardliu.cn/java-concurrency-synchronized/"/>
    <id>https://www.howardliu.cn/java-concurrency-synchronized/</id>
    <published>2021-03-28T07:55:40.000Z</published>
    <updated>2021-03-28T07:55:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/java/seagull-5884998_1920.jpg" alt="Java 并发基础（一）：synchronized 锁同步"></p><p>你好，我是看山。</p><p>synchronized 是 java 内置的同步锁实现，一个关键字实现对共享资源的锁定。synchronized 有 3 种使用场景，场景不同，加锁对象也不同：</p><ol><li>普通方法：锁对象是当前实例对象</li><li>静态方法：锁对象是类的 Class 对象</li><li>方法块：锁对象是 synchronized 括号中的对象</li></ol><a id="more"></a><h2 id="synchronized-实现原理"><a href="#synchronized-实现原理" class="headerlink" title="synchronized 实现原理"></a>synchronized 实现原理</h2><p>synchronized 是通过进入和退出 Monitor 对象实现锁机制，代码块通过一对 monitorenter/monitorexit 指令实现。在编译后，monitorenter 指令插入到同步代码块的开始位置，monitorexit 指令插入到方法结束和异常处，JVM 要保证 monitorenter 和 monitorexit 成对出现。任何对象都有一个 Monitor 与之关联，当且仅当一个 Monitor 被持有后，它将处于锁状态。</p><p>在执行 monitorenter 时，首先尝试获取对象的锁，如果对象没有被锁定或者当前线程持有锁，锁的计数器加 1；相应的，在执行 monitorexit 指令时，将锁的计数器减 1。当计数器减到 0 时，锁释放。如果在 monitorenter 获取锁失败，当前线程会被阻塞，直到对象锁被释放。</p><p>在 JDK6 之前，Monitor 的实现是依靠操作系统内部的互斥锁实现（一般使用的是 Mutex Lock 实现），线程阻塞会进行用户态和内核态的切换，所以同步操作是一个无差别的重量级锁。</p><p>后来，JDK 对 synchronized 进行升级，为了避免线程阻塞时在用户态与内核态之间切换线程，会在操作系统阻塞线程前，加入自旋操作。然后还实现 3 种不同的 Monitor：偏向锁（Biased Locking）、轻量级锁（Lightweight Locking）、重量级锁。在 JDK6 之后，synchronized 的性能得到很大的提升，相比于 ReentrantLock 而言，性能并不差，只不过 ReentrantLock 使用起来更加灵活。</p><h2 id="适应性自旋（Adaptive-Spinning）"><a href="#适应性自旋（Adaptive-Spinning）" class="headerlink" title="适应性自旋（Adaptive Spinning）"></a>适应性自旋（Adaptive Spinning）</h2><p>synchronized 对性能影响最大的是阻塞的实现，挂起线程和恢复线程都需要操作系统帮助完成，需要从用户态转到内核态，状态转换需要耗费很多 CPU 时间。</p><p>在我们大多数的应用中，共享数据的锁定状态只会持续很短的一段时间，为了这段时间挂起和回复线程消耗的时间不值得。而且，现在大多数的处理器都是多核处理器，如果让后一个线程再等一会，不释放 CPU，等前一个释放锁，后一个线程立马获取锁执行任务就行。这就是所谓的自旋，让线程执行一个忙循环，自己在原地转一会，每转一圈看看锁释放没有，释放了直接获取锁，没有释放就再转一圈。</p><p>自旋锁是在 JDK 1.4.2 引入（使用<code>-XX:+UseSpinning</code>参数打开），JDK 1.6 默认打开。自旋锁不能代替阻塞，因为自旋等待虽然避免了线程切换的开销，但是它要占用 CPU 时间，如果锁占用时间短，自旋等待效果挺好，反之，则是性能浪费。所以在 JDK 1.6 中引入了自适应自旋锁：如果同一个锁对象，自旋等待刚成功，且持有锁的线程正在运行，那本次自旋很有可能成功，会允许自旋等待持续时间长一些。反之，如果对于某个锁，自旋很少成功，那之后很有可能直接省略自旋过程，避免浪费 CPU 资源。</p><h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><h3 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h3><p>synchronized 用的锁存在于 Java 对象头里，对象头里的 Mark Word 里存储的数据会随标志位的变化而变化，变化如下：</p><p><img src="http://static.howardliu.cn/java/F7DE8310-E000-4B64-A3AA-9463B483BDF1.jpg" alt="Java 对象头 Mark Word"></p><h3 id="偏向锁（Biased-Locking）"><a href="#偏向锁（Biased-Locking）" class="headerlink" title="偏向锁（Biased Locking）"></a>偏向锁（Biased Locking）</h3><p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引入偏向锁。</p><p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，以后该线程在进入和退出同步块时不需要进行 CAS 操作来加锁和解锁，只需简单地测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。</p><h4 id="偏向锁获取"><a href="#偏向锁获取" class="headerlink" title="偏向锁获取"></a>偏向锁获取</h4><ol><li>当锁对象第一次被线程获取时，对象头的标志位设为 01，偏向模式设为 1，表示进入偏向模式。</li><li>测试线程 ID 是否指向当前线程，如果是，执行同步代码块，如果否，进入 3</li><li>使用 CAS 操作把获得到的这个锁的线程 ID 记录在对象的 Mark Word 中。如果成功，执行同步代码块，如果失败，说明存在过其他线程持有锁对象的偏向锁，开始尝试当前线程获取偏向锁</li><li>当到达全局安全点时（没有字节码正在执行），会暂停拥有偏向锁的线程，检查线程状态。如果线程已经结束，则将对象头设置成无锁状态（标志位为“01”），然后重新偏向新的线程；如果线程仍然活着，撤销偏向锁后升级到轻量级锁状态（标志位为“00”），此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。</li></ol><h4 id="偏向锁释放"><a href="#偏向锁释放" class="headerlink" title="偏向锁释放"></a>偏向锁释放</h4><p>偏向锁的释放采用的是惰性释放机制：只有等到竞争出现，才释放偏向锁。释放过程就是上面说的第 4 步，这里不再赘述。</p><h4 id="关闭偏向锁"><a href="#关闭偏向锁" class="headerlink" title="关闭偏向锁"></a>关闭偏向锁</h4><p>偏斜锁并不适合所有应用场景，撤销操作（revoke）是比较重的行为，只有当存在较多不会真正竞争的同步块时，才能体现出明显改善。实践中对于偏斜锁的一直是有争议的，有人甚至认为，当你需要大量使用并发类库时，往往意味着你不需要偏斜锁。</p><p>所以如果你确定应用程序里的锁通常情况下处于竞争状态，可以通过 JVM 参数关闭偏向锁：<code>-XX:-UseBiasedLocking=false</code>，那么程序默认会进入轻量级锁状态。</p><h3 id="轻量级锁（Lightweight-Locking）"><a href="#轻量级锁（Lightweight-Locking）" class="headerlink" title="轻量级锁（Lightweight Locking）"></a>轻量级锁（Lightweight Locking）</h3><p>轻量级锁不是用来代替重量级锁的，它的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能损耗。</p><h4 id="轻量级锁获取"><a href="#轻量级锁获取" class="headerlink" title="轻量级锁获取"></a>轻量级锁获取</h4><ol><li>如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝，官方称之为 Displaced Mark Word。这时候线程堆栈与对象头的状态如下图所示：<br> <img src="http://static.howardliu.cn/java/C9DCD644-0694-4FF3-8E2E-0FCEA7C0CB5E.png" alt="Lock Record"></li><li>拷贝对象头中的 Mark Word 复制到锁记录（Lock Record）中。</li><li>拷贝成功后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，并将 Lock record 里的 owner 指针指向 object mark word。</li><li>如果成功，当前线程持有该对象锁，将对象头的 Mark Word 锁标志位设置为“00”，表示对象处于轻量级锁定状态，执行同步代码块。这时候线程堆栈与对象头的状态如下图所示：<br><img src="http://static.howardliu.cn/java/3F5C415F-2953-4987-A38E-BB4AB97600AB.png" alt="Lock Record"></li><li>如果更新失败，检查对象头的 Mark Word 是否指向当前线程的栈帧，如果是，说明当前线程拥有锁，直接执行同步代码块。</li><li>如果否，说明多个线程竞争锁，如果当前只有一个等待线程，通过自旋尝试获取锁。当自旋超过一定次数，或又来一个线程竞争锁，轻量级锁膨胀为重量级锁。重量级锁使除了拥有锁的线程以外的线程都阻塞，防止 CPU 空转，锁标志的状态值变为“10”，Mark Word 中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</li></ol><h4 id="轻量级锁解锁"><a href="#轻量级锁解锁" class="headerlink" title="轻量级锁解锁"></a>轻量级锁解锁</h4><p>轻量级锁解锁的时机是，当前线程同步块执行完毕。</p><ol><li>通过 CAS 操作尝试把线程中复制的 Displaced Mark Word 对象替换当前的 Mark Word。</li><li>如果成功，整个同步过程完成</li><li>如果失败，说明存在竞争，且锁膨胀为重量级锁。释放锁的同时，会唤醒被挂起的线程。</li></ol><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>轻量级锁适应的场景是线程近乎交替执行同步块的情况，如果存在同一时间访问相同锁对象时（第一个线程持有锁，第二个线程自旋超过一定次数），轻量级锁会膨胀为重量级锁，Mark Word 的锁标记位更新为 10，Mark Word 指向互斥量（重量级锁）。</p><p>重量级锁是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的 Mutex Lock（互斥锁）。操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么 JDK 1.6 之前，synchronized 重量级锁效率低的原因。</p><p>下图是偏向锁、轻量级锁、重量级锁之间转换对象头 Mark Word 数据转变：</p><p><img src="http://static.howardliu.cn/java/640.png" alt="偏向锁、轻量级锁、重量级锁之间转换 "></p><p>网上有一个比较全的锁升级过程：</p><p><img src="http://static.howardliu.cn/java/synchronized.png" alt="锁升级过程"></p><h2 id="锁消除（Lock-Elimination）"><a href="#锁消除（Lock-Elimination）" class="headerlink" title="锁消除（Lock Elimination）"></a>锁消除（Lock Elimination）</h2><p>锁消除说的是虚拟机即时编译器在运行过程中，对于一些同步代码，如果检测到不可能存在共享数据竞争情况，就会删除锁。也就是说，即时编译器根据情况删除不必要的加锁操作。</p><p>锁消除的依据是逃逸分析。简单地说，逃逸分析就是分析对象的动态作用域。分三种情况：</p><ul><li>不逃逸：对象的作用域只在本线程本方法</li><li>方法逃逸：对象在方法内定义后，被外部方法所引用</li><li>线程逃逸：对象在方法内定义后，被外部线程所引用</li></ul><p>即时编译器会针对对象的不同情况进行优化处理：</p><ul><li>对象栈上分配（Stack Allocations，HotSpot 不支持）：直接在栈上创建对象。</li><li>标量替换（Scalar Replacement）：将对象拆散，直接创建被方法使用的成员变量。前提是对象不会逃逸出方法范围。</li><li>同步消除（Synchronization Elimination）：就是锁消除，前提是对象不会逃逸出线程。</li></ul><p>对于锁消除来说，就是逃逸分析中，那些不会逃出线程的加锁对象，就可以直接删除同步锁。</p><p>通过代码看一个例子：</p><pre><code class="java">public void elimination1() {    final Object lock = new Object();    synchronized (lock) {        System.out.println(&quot;lock 对象没有只会作用域本线程，所以会锁消除。&quot;);    }}public String elimination2() {    final StringBuffer sb = new StringBuffer();    sb.append(&quot;Hello, &quot;).append(&quot;World!&quot;);    return sb.toString();}public StringBuffer notElimination() {    final StringBuffer sb = new StringBuffer();    sb.append(&quot;Hello, &quot;).append(&quot;World!&quot;);    return sb;}</code></pre><p><code>elimination1()</code>中的锁对象<code>lock</code>作用域只是方法内，没有逃逸出线程，<code>elimination2()</code>中的<code>sb</code>也就这样，所以这两个方法的同步锁都会被消除。但是<code>notElimination()</code>方法中的<code>sb</code>是方法返回值，可能会被其他方法修改或者其他线程修改，所以，单看这个方法，不会消除锁，还得看调用方法。</p><h2 id="锁粗化（Lock-Coarsening）"><a href="#锁粗化（Lock-Coarsening）" class="headerlink" title="锁粗化（Lock Coarsening）"></a>锁粗化（Lock Coarsening）</h2><p>原则上，我们在编写代码的时候，要将同步块作用域的作用范围限制的尽量小。使得需要同步的操作数量尽量少，当存在锁竞争时，等待线程尽快获取锁。但是有时候，如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有出现线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机检测到有一串零碎的操作都是对同一对象的加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</p><p>比如上面例子中的<code>elimination2()</code>方法中，<code>StringBuffer</code>的<code>append</code>是同步方法，频繁操作时，会进行锁粗化，最后结果会类似于（只是类似，不是真实情况）：</p><pre><code class="java">public String elimination2() {    final StringBuilder sb = new StringBuilder();    synchronized (sb) {        sb.append(&quot;Hello, &quot;).append(&quot;World!&quot;);        return sb.toString();    }}</code></pre><p>或者</p><pre><code class="java">public synchronized String elimination3() {    final StringBuilder sb = new StringBuilder();    sb.append(&quot;Hello, &quot;).append(&quot;World!&quot;);    return sb.toString();}</code></pre><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><ol><li>同步操作中影响性能的有两点：<ol><li>加锁解锁过程需要额外操作</li><li>用户态与内核态之间转换代价比较大</li></ol></li><li>synchronized 在 JDK 1.6 中有大量优化：分级锁（偏向锁、轻量级锁、重量级锁）、锁消除、锁粗化等。</li><li>synchronized 复用了对象头的 Mark Word 状态位，实现不同等级的锁实现。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入理解 Java 虚拟机》</li><li>《Java 并发编程的艺术》</li></ul><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/java-concurrency-synchronized/">Java 并发基础（一）：synchronized 锁同步</a></li><li><a href="https://www.howardliu.cn/main-thread-waiting-for-the-end-of-subthread/">Java 并发基础（二）：主线程等待子线程结束</a></li><li><a href="https://www.howardliu.cn/talk-about-CountDownLatch-again/">Java 并发基础（三）：再谈 CountDownLatch</a></li><li><a href="https://www.howardliu.cn/talk-about-CyclicBarrier-again/">Java 并发基础（四）：再谈 CyclicBarrier</a></li><li><a href="https://www.howardliu.cn/java-concurrency-ordered-thread-print/">Java 并发基础（五）：面试实战之多线程顺序打印</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-concurrency-synchronized/">Java 并发基础（一）：synchronized 锁同步</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/115286598" target="_blank" rel="noopener">Java 并发基础（一）：synchronized 锁同步</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      synchronized 是 java 内置的同步锁实现，一个关键字实现对共享资源的锁定。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="concurrency" scheme="https://www.howardliu.cn/tags/concurrency/"/>
    
      <category term="synchronized" scheme="https://www.howardliu.cn/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>Docker 教程（三）：Docker 命令</title>
    <link href="https://www.howardliu.cn/docker-commands/"/>
    <id>https://www.howardliu.cn/docker-commands/</id>
    <published>2021-03-19T12:36:47.000Z</published>
    <updated>2021-03-19T12:36:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/docker/breakwater-6017041_1920.jpg" alt="Docker 教程（三）：Docker 命令"></p><p>你好，我是看山。</p><blockquote><p>本文源自并发编程网的翻译邀请，翻译的是 Jakob Jenkov 的 <a href="http://tutorials.jenkov.com/docker/index.html" target="_blank" rel="noopener">《Docker 教程》</a> 中的第三篇。</p></blockquote><a id="more"></a><p>我们通过 Docker 命令与操作 Docker 服务，可以构建 Docker 镜像、运行 Docker 容器、将 Docker 镜像推送到远程等。本文主要介绍一些常用的 Docker 命令。</p><p>Docker 有很多命令，本文不会介绍所有的命令，如果需要完整的命令教程，可以参考 <a href="https://docs.docker.com/engine/reference/commandline/docker/" target="_blank" rel="noopener">Docker command line reference</a>。</p><p>请注意，根据在 Linux 系统上安装 Docker 的方式，可能需要在所有命令前面加上<code>sudo</code>，使用 root 权限运行他们。比如：</p><pre><code class="bash">sudo docker build .</code></pre><p>… 而不仅仅是：</p><pre><code class="bash">docker build .</code></pre><h2 id="Docker-命令行工具"><a href="#Docker-命令行工具" class="headerlink" title="Docker 命令行工具"></a>Docker 命令行工具</h2><p>在 Linux 系统中安装 Docker 时，会安装一个名为<code>docker</code>的命令行工具，可以在 Linux 命令行执行。</p><p><code>docker</code>有很多的参数，不同的参数作用不同，可以指挥 Docker 做出不同的行为，可以认为是给 Docker 的命令。以下是<code>docker</code>命令示例：</p><pre><code class="bash">docker build .</code></pre><p>这个示例中包含三部分：<code>docker</code>命令、参数<code>build</code>、参数<code>.</code>。</p><p>参数<code>build</code>是一个 Docker 命令，换句话说，是一个给 docker 可执行命令行的命令。通常，docker 命令行的第一个参数都是 Docker 命令。</p><p>参数<code>.</code>是<code>build</code>命令的参数。</p><h2 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h2><p><code>docker build</code>命令是调用 Docker 从 Dockerfile 文件构建 docker 镜像，要使用<code>docker build</code>命令，必须告诉它从哪个 Dockerfile 文件生成镜像。关于 Dockerfile 的内容，可以查看 <a href="https://www.howardliu.cn/docker-dockerfile/">这里</a>。以下是<code>docker build</code>命令示例：</p><pre><code class="bash">docker build .</code></pre><p>参数<code>.</code>表示从当前目录找到 Dockerfile 文件。</p><h2 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h2><p><code>docker images</code>命令是列出本机的 Docker 镜像，以下是<code>docker images</code>命令示例：</p><pre><code class="bash">docker images</code></pre><p>运行上述命令会输出类似下面的内容：</p><pre><code class="text">REPOSITORY       TAG        IMAGE ID        CREATED          SIZEhello-world      latest     fce289e99eb9    9 months ago     1.84kB</code></pre><h2 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h2><p><code>docker run</code>命令用来基于给定的 Docker 镜像运行 Docker 容器，<code>docker run</code>的参数，可以是 Docker 镜像的名称或 ID，以下是运行 Docker 容器的示例：</p><pre><code class="bash">docker run hello-world</code></pre><p>这个例子会基于<code>hello-world</code>镜像运行 Docker 容器。</p><p>我们还可以通过 Docker 镜像 ID 运行 Docker 容器，命令如下：</p><pre><code class="bash">docker run fce289e99eb9</code></pre><h2 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h2><p><code>docker ps</code>命令用于显示当前系统中正在运行的 Docker 容器，示例如下：</p><pre><code class="bash">docker ps</code></pre><p>注意，一些 Docker 容器会在完成任务后立即关闭，在<code>docker ps</code>的结果列表中，这种 Docker 容器很有可能会很长时间都不可见。</p><p>【译者注：本文就 4 个命令，还有很多常用的命令没有提到，比如<code>docker exec</code>之类的。其实，对于 Docker 命令行来说，我们可以先浏览一遍，知道个大概，等有需要的时候，重点看一下。个人感觉，命令的需要关键是要经常用。如果不用，转眼就忘，可以类比 Linux 命令。】</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/docker-tutorial/">Docker 教程（一）：Docker 是什么</a></li><li><a href="https://www.howardliu.cn/docker-dockerfile/">Docker 教程（二）：Dockerfile</a></li><li><a href="https://www.howardliu.cn/docker-commands/">Docker 教程（三）：Docker 命令</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>原文链接：<a href="http://tutorials.jenkov.com/docker/docker-commands.html" target="_blank" rel="noopener">Docker Commands</a><br>翻译：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>译文链接：<a href="https://www.howardliu.cn/docker-commands/">Docker 教程（三）：Docker 命令</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/115048842" target="_blank" rel="noopener">Docker 教程（三）：Docker 命令</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      我们通过 Docker 命令与操作 Docker 服务，可以构建 Docker 镜像、运行 Docker 容器、将 Docker 镜像推送到远程等。本文主要介绍一些常用的 Docker 命令。
    
    </summary>
    
    
      <category term="docker" scheme="https://www.howardliu.cn/categories/docker/"/>
    
    
      <category term="DevOps" scheme="https://www.howardliu.cn/tags/DevOps/"/>
    
      <category term="Docker" scheme="https://www.howardliu.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 教程（二）：Dockerfile</title>
    <link href="https://www.howardliu.cn/docker-dockerfile/"/>
    <id>https://www.howardliu.cn/docker-dockerfile/</id>
    <published>2021-03-13T15:30:08.000Z</published>
    <updated>2021-03-13T15:30:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/docker/shops-5992277_1920.jpg" alt="Docker 教程（二）：Dockerfile"></p><p>你好，我是看山。</p><blockquote><p>本文源自并发编程网的翻译邀请，翻译的是 Jakob Jenkov 的 <a href="http://tutorials.jenkov.com/docker/index.html" target="_blank" rel="noopener">《Docker 教程》</a> 中的第二篇。</p></blockquote><a id="more"></a><p>Dockerfile 包含一组关于如何构建 Docker 镜像的说明，通过<code>docker build</code>命令执行 Dockerfile 文件，可以构建一个 Docker 镜像，本文介绍了如何编写 Dockerfile 文件以及构建一个 Docker 镜像。</p><h2 id="Dockerfile-的好处"><a href="#Dockerfile-的好处" class="headerlink" title="Dockerfile 的好处"></a>Dockerfile 的好处</h2><p>Dockerfile 文件以书面形式说明了如何构建一个 Docker 镜像，Docker 镜像通常包含如下内容：</p><ul><li>首先需要一个基本的 Docker 镜像，在这个基础 Docker 镜像上构建自己的 Docker 镜像。</li><li>一组需要安装在 Docker 镜像中的工具和应用。</li><li>一组需要复制到 Docker 镜像中的文件（比如配置文件）。</li><li>可能需要在防火墙中打开的网络（TPC/UDP）端口或其他。</li><li>等等。</li></ul><p>首先，在 Dockerfile 文件中以书面形式说明这些，就意味着，我们不用特意记住应用程序如何安装，包括操作系统什么要求、需要安装的应用程序、需要赋值的文件、需要打开的网络端口等，这些内容都被记录在 Dockerfile 中。</p><p>另外，通过 Dockerfile 文件构建 Docker 镜像，我们不需要手动执行这些繁琐重复且容易出错的工作。Docker 会自动做这些事情，简单、快速、且不容易出错。</p><p>第三，我们很容易和其他人分享 Dockerfile 文件，并且他们可以自己构建 Docker 镜像。</p><p>第四，Dockerfile 很容易存储在 Git 这样的版本控制器中，这样就可以跟踪 Dockerfile（服务器、应用配置）的变更记录。版本控制器也可以很容易的让人们协同合作，比如在 Dockerfile 上，以及分享 Dockerfile。</p><h2 id="Dockerfile-的结构"><a href="#Dockerfile-的结构" class="headerlink" title="Dockerfile 的结构"></a>Dockerfile 的结构</h2><p>Dockerfile 包含一组指令，每个指令有一个命令和参数组成，类似于命令行可执行文件。下面是一个 Dockerfile 简单示例：</p><pre><code class="dockerfile"># 基础镜像FROM ubuntu:latest# 这里可以有更多安装软件和复制文件到镜像中的说明。COPY    /myapp/target/myapp.jar    /myapp/myapp.jar# 在 Docker 容器中执行的命令。CMD echo Starting Docker Container</code></pre><h2 id="Docker-基础镜像"><a href="#Docker-基础镜像" class="headerlink" title="Docker 基础镜像"></a>Docker 基础镜像</h2><p>Docker 镜像是由层组成，每一层都会为最终的 Docker 镜像添加一些内容。每一个层实际上都是一个单独的 Docker 镜像，所以说，Docker 镜像是由一个或多个层镜像组成，我们可以在其上添加自己的层。</p><p>当通过 Dockerfile 文件指定自己的 Docker 镜像时，通常是从一个 Docker 基础镜像开始。这是另一个 Docker 镜像，可以在其上构建自己的 Docker 镜像。这个 Docker 基础镜像本身可能也包含多个层，并且是基于另一个基础镜像构建的。</p><p>我们可以使用<code>From</code>命令在 Dockerfile 文件中指定 Docker 镜像作为基础镜像，如下节所述。</p><h2 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h2><p><code>MAINTAINER</code>命令用于说明谁在维护这个 Dockerfile 文件。比如：</p><pre><code class="dockerfile">MAINTAINER   Joe Blocks &lt;joe@blocks.com&gt;</code></pre><p><code>MAINTAINER</code>命令并不常用，因为这类信息在 Git 存储或其他地方有了。</p><h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h2><p><code>FROM</code>命令用于指定 Docker 基础镜像，如果是从原始 Linux 镜像开始，可以使用如下命令：</p><pre><code class="dockerfile"># 基础镜像FROM ubuntu:latest</code></pre><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p><code>CMD</code>命令用于指定启动 Docker 容器是需要执行的命令，该容器是基于此 Dockerfile 构建的 Docker 镜像，下面是一些 Dockerfile 的<code>CMD</code>示例：</p><pre><code class="dockerfile">CMD echo Docker container started.</code></pre><p>本例是打印“Docker container started”这行文本。</p><p>下一个<code>CMD</code>示例是启动一个 java 应用：</p><pre><code class="dockerfile">CMD java -cp /myapp/myapp.jar com.jenkov.myapp.MainClass arg1 arg2 arg3</code></pre><h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h2><p><code>COPY</code>命令将一个或多个文件从主机（从 Dockerfile 文件构建 Docker 镜像的机器）复制到 Docker 镜像中，可以复制的内容包括文件或目录，下面是一个示例：</p><pre><code class="dockerfile">COPY    /myapp/target/myapp.jar    /myapp/myapp.jar</code></pre><p>这个例子是把主机的/myapp/target/myapp.jar 文件复制到 Docker 进行中的/myapp/myapp.jar 文件。第一个参数是主机路径（从哪里来），第二个参数是 Docker 镜像的路径（到哪里去）。</p><p>我们还可以复制一个目录到 Docker 镜像中，比如：</p><pre><code class="dockerfile">COPY    /myapp/config/prod    /myapp/config</code></pre><p>这个例子是把主机的/myapp/config/prod 目录复制到 Docker 镜像中的/myapp/config 目录。</p><p>我们还可以复制多个文件到 Docker 镜像中的一个目录中，比如：</p><pre><code class="dockerfile">COPY    /myapp/config/prod/conf1.cfg   /myapp/config/prod/conf2.cfg   /myapp/config/</code></pre><p>这个例子是将主机的/myapp/config/prod/conf1.cfg 文件和/myapp/conig/prod/conf2.cfg 文件复制到 Docker 镜像中的/myapp/config/目录中。注意，目标目录必须以/（斜杠）结束才能工作。</p><h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h2><p><code>ADD</code>命令与<code>COPY</code>命令工作方式相同，只有一些细微的差别：</p><ul><li><code>ADD</code>命令可以复制并提取 TAR 文件到 Docker 镜像中。</li><li><code>ADD</code>命令可以通过 HTTP 下载文件，并复制到 Docker 镜像中。</li></ul><p>下是一些示例：</p><pre><code class="dockerfile">ADD    myapp.tar    /myapp/</code></pre><p>这个例子是将指定的 TAR 文件解压缩并提取到 Docker 镜像的/myapp/目录中。</p><p>下面是另一个例子：</p><pre><code class="dockerfile">ADD    http://jenkov.com/myapp.jar    /myapp/</code></pre><h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><p><code>ENV</code>命令是在 Docker 镜像中设置环境变量，此环境变量可用于<code>CMD</code>命令在 Docker 镜像内部启动应用程序。举个例子：</p><pre><code class="dockerfile">ENV    MY_VAR   123</code></pre><p>本例将环境变量<code>MY_VAR</code>设置为值 123。</p><h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p><code>RUN</code>可以在 Docker 镜像中执行命令行指令，执行时机是 Docker 镜像构建过程中，所以<code>RUN</code>命令只会执行一次。<code>RUN</code>命令可用于在 Docker 镜像中安装应用程序、提取文件或其他命令行功能，这些操作只需要执行一次，以供 Docker 镜像后续使用。</p><pre><code class="dockerfile">RUN apt-get install some-needed-app</code></pre><h2 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h2><p><code>ARG</code>命令允许定义一个参数，这个参数可以在通过 Dockerfile 文件构建 Docker 镜像时，通过命令参数传递给 Docker。比如：</p><pre><code class="dockerfile">ARG tcpPort</code></pre><p>当执行<code>docker build</code>命令执行 Dockerfile 构建 Docker 镜像时，可以指定<code>tcpPort</code>参数，比如：</p><pre><code class="dockerfile">docker build --build-arg tcpPort=8080 .</code></pre><blockquote><p>注意，<code>--build-arg</code>后面的<code>tcpPort=8080</code>，是将<code>tcpPort</code>参数的值设置为 8080。</p></blockquote><p>我们可以通过多个<code>ARG</code>命令定义多个参数，举个例子：</p><pre><code class="dockerfile">ARG tcpPortARG useTls</code></pre><p>当构建 Docker 镜像时，必须为所有构建参数提供值。【译者注，1.13 版本之前，不提供值会直接报错，1.13 版本之后，不提供值不会报错，但是会弹出警告】。举个例子：</p><pre><code class="dockerfile">docker build --build-arg tcpPort=8080 --build-arg useTls=true .</code></pre><p>我们可以为<code>ARG</code>设置默认值，当构建 Docker 镜像时，如果没有指定参数值，将使用默认值。举个例子：</p><pre><code class="dockerfile">ARG tcpPort=8080ARG useTls=true</code></pre><p>如果<code>tcpPort</code>和<code>useTls</code>在生成 Docker 镜像时，都没有设置参数，将使用默认值 8080 和 true。</p><p><code>ARG</code>声明的参数通常在 Dockerfile 的其他地方引用，比如：</p><pre><code class="dockerfile">ARG tcpPort=8080ARG useTls=trueCMD start-my-server.sh -port ${tcpPort} -tls ${useTls}</code></pre><blockquote><p>注意：两个引用<code>${tcpPort}</code>和<code>${useTls}</code>，引用名是<code>tcpPort</code>和<code>useTls</code>这两个<code>ARG</code>声明的参数。</p></blockquote><pre><code class="dockerfile">docker build --build-arg tcpPort=8080</code></pre><h2 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h2><p><code>WORKDIR</code>命令指明了 Docker 镜像中的工作目录，工作目录将对<code>WORKDIR</code>指令之后的所有命令生效，举个例子：</p><pre><code class="dockerfile">WORKDIR    /java/jdk/bin</code></pre><h2 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h2><p><code>EXPOSE</code>命令将对外开放 Docker 容器中的网络端口，比如，如果 Docker 容器运行一个 web 服务器，那么，该 web 服务器可能需要打开端口 80，以便客户端链接到它。举个例子：</p><pre><code class="dockerfile">EXPOSE   8080</code></pre><p>我们还可以指明打开端口的通信协议，比如：UDP 和 TCP。下面是设置允许通信协议的示例：</p><pre><code class="dockerfile">EXPOSE   8080/tcp 9999/udp</code></pre><p>如果没有指定协议，将默认认定为 TCP 协议。</p><h2 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h2><p><code>VOLUME</code>命令会在 Docker 镜像中创建一个目录，这个目录可以挂载到 Docker 主机上。换句话说，可以在 Docker 镜像中创建目录，比如<code>/data</code>，这个目录可以在稍后挂载到 Docker 主机的<code>/container-data/container1</code>目录上。挂载成功后，容器会启动。下面是一个使用<code>VOLUME</code>命令在 Dockerfile 中定义装载目录的示例：</p><pre><code class="dockerfile">VOLUME   /data</code></pre><h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p><code>ENTRYPOINT</code>命令为从该 Docker 镜像启动 Docker 容器提供入口点，入口点是 Docker 容器启动时执行的应用程序或命令。这样，<code>ENTRYPOINT</code>和<code>CMD</code>工作方式类似，不同之处在于，使用<code>ENTRYPOINT</code>时，当<code>ENTRYPOINT</code>执行的应用程序完成时，Docker 容器将关闭。因此，<code>ENTRYPOINT</code>使 Docker 镜像本身成为一个可执行命令，可以启动，完成后关闭。以下是<code>ENTRYPOINT</code>示例：</p><pre><code class="dockerfile">ENTRYPOINT java -cp /apps/myapp/myapp.jar com.jenkov.myapp.Main</code></pre><p>这个示例将在容器启动时执行 Java 应用程序的主类<code>com.jenkov.myapp.Main</code>，当应用程序关闭时，Docker 容器也会关闭。</p><h2 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h2><p><code>HEALTHCHECK</code>命令可以定期执行健康检查，以监视 Docker 容器中运行的应用程序的运行状况。如果命令返回 0，Docker 将认为应用程序和容器正常，如果命令返回 1，Docker 会认为应用程序和容器不正常。示例如下：</p><pre><code class="dockerfile">HEALTHCHECK java -cp /apps/myapp/healthcheck.jar com.jenkov.myapp.HealthCheck https://localhost/healthcheck</code></pre><p>这个示例中使用了 java 应用程序的<code>com.jenkov.myapp.HealthCheck</code>作为健康检查的命令，我们可以使用任何有意义的健康检查命令。</p><h3 id="健康检查间隔时间"><a href="#健康检查间隔时间" class="headerlink" title="健康检查间隔时间"></a>健康检查间隔时间</h3><p>默认情况下，Docker 每 30 秒执行一次<code>HEALTHCHECK</code>命令。如果想修改时间间隔，我们可以自定义时间，通过<code>--interval</code>参数，可以指定健康检查的检查间隔时间。下面是一个将<code>HEALTHCHECK</code>间隔设置为 60 秒的示例：</p><pre><code class="dockerfile">HEALTHCHECK --interval=60s java -cp /apps/myapp/healthcheck.jar com.jenkov.myapp.HealthCheck https://localhost/healthcheck</code></pre><h3 id="健康检查开始时间"><a href="#健康检查开始时间" class="headerlink" title="健康检查开始时间"></a>健康检查开始时间</h3><p>默认情况下，Docker 会立即检查 Docker 容器的监控状况。但是，有些应用程序可能需要一段时间启动，因此，只有经过某段时间后再进行健康检查才有意义。我们可以使用<code>--start-period</code>参数设置健康检查开始时间。下面是一个将健康检查设置为 5 分钟的示例，在 Docker 开始健康检查之前，为容器和应用程序提供 300 秒（5 分钟）的启动时间：</p><pre><code class="dockerfile">HEALTHCHECK --start-period=300s java -cp /apps/myapp/healthcheck.jar com.jenkov.myapp.HealthCheck https://localhost/healthcheck</code></pre><h3 id="健康检查超时时间"><a href="#健康检查超时时间" class="headerlink" title="健康检查超时时间"></a>健康检查超时时间</h3><p>健康检查很有可能超时，如果<code>HEALTCHECK</code>命令需要超过给定时间限制才完成，Docker 将认为健康检查超时。可以使用<code>--timeout</code>参数设置超时时间，如下是设置超时时间为 5 秒的示例：</p><pre><code class="dockerfile">HEALTHCHECK --timeout=5s java -cp /apps/myapp/healthcheck.jar com.jenkov.myapp.HealthCheck https://localhost/healthcheck</code></pre><blockquote><p>注意，如果健康检查超时，Docker 也会认为容器不健康。</p></blockquote><h3 id="健康检查重复次数"><a href="#健康检查重复次数" class="headerlink" title="健康检查重复次数"></a>健康检查重复次数</h3><p>如果<code>HEALTHCHECK</code>命令执行失败，有可能是结果返回 1，或者执行超时，Docker 会在认定容器不健康前，重试 3 次<code>HEALTHCHECK</code>命令，用于检查 Docker 容器是否返回健康状态。可以通过<code>--retries</code>设置重试次数。下面是将重试次数设置为 5 的示例：</p><pre><code class="dockerfile">HEALTHCHECK --retries=5 java -cp /apps/myapp/healthcheck.jar com.jenkov.myapp.HealthCheck https://localhost/healthcheck</code></pre><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/docker-tutorial/">Docker 教程（一）：Docker 是什么</a></li><li><a href="https://www.howardliu.cn/docker-dockerfile/">Docker 教程（二）：Dockerfile</a></li><li><a href="https://www.howardliu.cn/docker-commands/">Docker 教程（三）：Docker 命令</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>原文链接：<a href="http://tutorials.jenkov.com/docker/dockerfile.html" target="_blank" rel="noopener">Docker Dockerfile</a><br>翻译：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>译文链接：<a href="https://www.howardliu.cn/docker-dockerfile/">Docker 教程（二）：Dockerfile</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/114808891" target="_blank" rel="noopener">Docker 教程（二）：Dockerfile</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Dockerfile 包含一组关于如何构建 Docker 镜像的说明，通过 docker build 命令执行 Dockerfile 文件，可以构建一个 Docker 镜像，本文介绍了如何编写 Dockerfile 文件以及构建一个 Docker 镜像。
    
    </summary>
    
    
      <category term="docker" scheme="https://www.howardliu.cn/categories/docker/"/>
    
    
      <category term="DevOps" scheme="https://www.howardliu.cn/tags/DevOps/"/>
    
      <category term="Docker" scheme="https://www.howardliu.cn/tags/Docker/"/>
    
      <category term="Dockerfile" scheme="https://www.howardliu.cn/tags/Dockerfile/"/>
    
  </entry>
  
  <entry>
    <title>Docker 教程（一）：Docker 是什么</title>
    <link href="https://www.howardliu.cn/docker-tutorial/"/>
    <id>https://www.howardliu.cn/docker-tutorial/</id>
    <published>2021-03-07T09:42:18.000Z</published>
    <updated>2021-03-07T09:42:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/docker/dandelion-5975473_1920.jpg" alt="Docker 教程"></p><blockquote><p>本文源自并发编程网的翻译邀请，翻译的是 Jakob Jenkov 的 <a href="http://tutorials.jenkov.com/docker/index.html" target="_blank" rel="noopener">《Docker 教程》</a> 中的第一篇，本文大概介绍了 Docker 是什么和有什么用。可能在工作中，会有专业运维同学管理服务器镜像或其他内容，但是如果不了解这些概念，很多时候我们不会全面了解到系统的全貌。</p></blockquote><a id="more"></a><p>Docker 是一种将应用程序和服务器配置打包成 Docker 镜像的方法，使用了一种称为 Dockerfile 的简单打包规范。Docker 镜像可以启动多个多个实例，这些运行的实例被称为 Docker 容器。这个系列的内容主要包括讲解什么是 Docker 镜像、什么是容器、什么是 Dockerfile，以及如何创建、运行和发布等。</p><h2 id="Docker-的优势"><a href="#Docker-的优势" class="headerlink" title="Docker 的优势"></a>Docker 的优势</h2><p>使用 Dockerfile 打包应用和服务器配置最大的好处是：</p><ul><li>不会忘记服务器是如何配置的，这些配置信息都记录在 Dockerfile 中。</li><li>很容易在一个全新啊的 Docker 主机上运行应用程序，只需要将应用程序的 Docker 镜像部署到这台 Docker 主机上，然后启动它即可。</li><li>可以使用 Kubernetes 和 Swarm 轻松管理集群中的 Docker 容器。</li><li>目前许多云服务器平台可以很轻松的部署 Docker 容器，Docker 已经成为让云更加独立的部署方案。</li><li>Docker 容器可以很简单的实现在客户自己的服务器上按照你的应用程序。</li></ul><h2 id="什么是-Docker-容器"><a href="#什么是-Docker-容器" class="headerlink" title="什么是 Docker 容器"></a>什么是 Docker 容器</h2><p>Linux 操作系统有几个特性：运行在操作系统上运行容器化的应用程序，这些容器化的特性，运行将文件系统和网络在各个容器化应用程序之间彼此分离。换句话说，一个容器化应用程序，不能访问另一个容器化应用程序的文件系统或网络，除非增加特殊配置，允许这种操作。Docker 使用 Linux 的容器化特性，并通过一组易于使用的工具公开这些特性。</p><p><img src="http://static.howardliu.cn/docker/docker-introduction-1.png" alt="什么是 Docker 容器"></p><h2 id="Docker-容器-vs-虚拟机"><a href="#Docker-容器-vs-虚拟机" class="headerlink" title="Docker 容器 vs. 虚拟机"></a>Docker 容器 vs. 虚拟机</h2><p>Docker 容器在本质上类似于虚拟机，两者的不同之处在于，虚拟机在总栈上有一个额外的操作系统。也就是说，虚拟机有完整的操作系统，然后这个虚拟机运行在一个有操作系统的主机上。</p><p>Docker 容器与虚拟机的实现不同，它没有自己单独的操作系统，直接运行在所在主机的操作系统中。所以，Docker 容器足够小，因为它不包含虚拟机操作系统。Docker 容器运行的也很好，因为它不需要虚拟机的虚拟化。</p><p><img src="http://static.howardliu.cn/docker/docker-introduction-2.png" alt="Docker 容器 vs. 虚拟机"></p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>如前所述，我们可以通过一个按规则定义的 Dockerfile 文件，指定要包含在 Docker 容器中的内容。Dockerfile 文件包含了一组有 Docker 命令行工具执行的 Docker 指令，按照 Dockerfile 执行的结果是 Docker 镜像。我们可以从 <a href="http://tutorials.jenkov.com/docker/dockerfile.html" target="_blank" rel="noopener">Dockerfile 教程</a> 中得到更详细的解释。【译者注：后续翻译完成后，将替换此处链接。】</p><h2 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h2><p>Docker 命令行工具按照 Dockerfile 中定义的结构执行指令时，会生产一个可移植、可运行的 Docker 镜像。这个 Docker 镜像中包含了所有 Docker 容器需要的文件和指令，同一个 Docker 镜像可以启动多个 Docker 容器。</p><p><img src="http://static.howardliu.cn/docker/docker-introduction-3.png" alt="Docker 镜像"></p><h2 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h2><p>Docker 镜像可以存储在 Docker 仓库中，一个可以将 Docker 镜像上传、下载的存储仓库。Docker 仓库可以是私有的，只能你或者你的组织或者你指定的人管理其中的镜像，也可以是公有的，任何人都可以管理其中的镜像，或者是从中下载 Docker 镜像。</p><p>一个公有的 Docker 仓库，是运行潜在用户下载、安装和运行软件的很好的方式，只需要将应用程序打包为 Docker 镜像，上传到公有的 Docker 仓库中，你的用户就可以访问并使用它。</p><p>Docker 公司已将 Docker 仓库作为一项托管服务，提供了私有和公有两种服务。一些云服务商，比如 AWS、AZure 和 Google，也提供了 Docker 仓库服务器，可以上传自己的 Docker 镜像。很容易的就能在云基础设施上的虚拟机或 Kubernetes 中使用这些镜像。</p><p><img src="http://static.howardliu.cn/docker/docker-introduction-4.png" alt="Docker 仓库"></p><h2 id="Docker-命令行工具"><a href="#Docker-命令行工具" class="headerlink" title="Docker 命令行工具"></a>Docker 命令行工具</h2><p>当在操作系统中安装 Docker 的时候，会同时安装 Docker 命令行工具。Docker 命令行工具可以通过 Dockerfile 构建 Docker 镜像，可以将 Docker 镜像上传到 Docker 仓库中，可以从 Docker 仓库中下载 Docker 镜像，可以操作 Docker 镜像启动或停止 Docker 容器。</p><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>Docker Compose 提供一种功能，可以将多个 Docker 容器链接成一个组合中，这个组合中的所有容器，可以一次性全部部署或停止。比如，一个 Docker 容器中运行应用，一个 Docker 容器中运行数据库，应用依赖于数据库，同时启动或停止，可以实现应用依赖的数据库没有正常运行。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/docker-tutorial/">Docker 教程（一）：Docker 是什么</a></li><li><a href="https://www.howardliu.cn/docker-dockerfile/">Docker 教程（二）：Dockerfile</a></li><li><a href="https://www.howardliu.cn/docker-commands/">Docker 教程（三）：Docker 命令</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>原文链接：<a href="http://tutorials.jenkov.com/docker/index.html" target="_blank" rel="noopener">Docker Tutorial</a><br>翻译：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>译文链接：<a href="https://www.howardliu.cn/docker-tutorial/">Docker 教程（一）：Docker 是什么</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/114497477" target="_blank" rel="noopener">Docker 教程（一）：Docker 是什么</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Docker 是一种将应用程序和服务器配置打包成 Docker 镜像的方法，使用了一种称为 Dockerfile 的简单打包规范。Docker 镜像可以启动多个多个实例，这些运行的实例被称为 Docker 容器。这个系列的内容主要包括讲解什么是 Docker 镜像、什么是容器、什么是 Dockerfile，以及如何创建、运行和发布等。
    
    </summary>
    
    
      <category term="docker" scheme="https://www.howardliu.cn/categories/docker/"/>
    
    
      <category term="DevOps" scheme="https://www.howardliu.cn/tags/DevOps/"/>
    
      <category term="Docker" scheme="https://www.howardliu.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Java 中 Vector 和 SynchronizedList 的区别</title>
    <link href="https://www.howardliu.cn/java-vector-vs-collections-synchronizedlist-arraylist/"/>
    <id>https://www.howardliu.cn/java-vector-vs-collections-synchronizedlist-arraylist/</id>
    <published>2021-02-27T13:50:05.000Z</published>
    <updated>2021-02-27T13:50:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/java/bird-6024257_1920.jpg" alt="Java 中 Vector 和 SynchronizedList 的区别"></p><p>你好，我是看山。</p><p>本文还是折腾 Java 中的队列，上次比较了 <a href="https://www.howardliu.cn/understanding-java-list/">Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList</a>，当时感觉挺明白，后来想想又有些不理解的地方，所以今天在重新翻出来研究一下，我承认我钻了牛角尖了。</p><a id="more"></a><p><code>Vector</code>虽然种种问题，但是都属于设计上的问题，为什么不在后续版本中进行优化呢？<code>HashMap</code>就优化了好几次。而<code>SynchronizedList</code>这个内部类（也就是通过<code>Collections.synchronizedList(new ArrayList())</code>创建的），也是采用了和<code>Vector</code>类似的同步方式（区别是一个在方法体、一个在方法块上，差别不大），为什么大家还是舍弃<code>Vector</code>呢？</p><p>其实，在 JDK 中，<code>Vector</code>一直没有被标记为<code>Deprecated</code>，也就是说，虽然外界传说<code>Vector</code>有各种问题，但是从 JDK 官方，从没有认为这个亲儿子没用。</p><p>所以，大家不用<code>Vector</code>的原因就剩下两种：</p><ol><li>其他队列比<code>Vector</code>更加适合，优中选优</li><li>大家都说<code>Vector</code>不好用，那我也不用了【个人感觉这种概率更大】</li></ol><blockquote><p>因为<code>Vector</code>主要是数组结构，所以下面大部分的对比都是比较的是针对<code>ArrayList</code>的同步封装。</p></blockquote><h2 id="有了Vector为什么还要有SynchronizedList"><a href="#有了Vector为什么还要有SynchronizedList" class="headerlink" title="有了Vector为什么还要有SynchronizedList"></a>有了<code>Vector</code>为什么还要有<code>SynchronizedList</code></h2><p>这个问题的答案是从 StackOverflow 中找到的。</p><p>在 JDK 1.2 之前，<code>Collections</code>是独立类库，不是 JDK/JRE 中的一部分。当时<code>synchronized</code>性能特别差，很多场景不需要使用同步方式，所以，独立类库的开发者删除了同步操作，这个应该就是<code>ArrayList</code>的前身。但是，少部分场景还是需要使用同步，于是就有了<code>SynchronizedList</code>，一个可以包装所有<code>List</code>子类的包装类，这个类在几乎所有方法上都加上了<code>synchronized</code>同步，这个设计与<code>Vector</code>相似。</p><p>古人说“文人相轻”，其实在编码界也是有鄙视链的。在这里就是：虽然我的设计和你的设计类似，但是我的设计就是比你的好。不过，<code>Collections</code>确实设计更优。</p><h2 id="一个SynchronizedList实现所有List的同步"><a href="#一个SynchronizedList实现所有List的同步" class="headerlink" title="一个SynchronizedList实现所有List的同步"></a>一个<code>SynchronizedList</code>实现所有<code>List</code>的同步</h2><p><code>SynchronizedList</code>定位是包装类，可以包装所有<code>List</code>的子类。也就是说，无论是<code>ArrayList</code>还是<code>LinkedList</code>都能过实现同步，完全不会修改底层数据结构，既实现的同步，又保留了底层接口的优点。比如<code>LinkedList</code>的插入、删除效率，<code>ArrayList</code>的顺序读取。而且，一个包装类就解决所有<code>List</code>子类的同步需求，完全不需要重复实现一遍。</p><p>相对而言，<code>Vector</code>就比较霸道了，任何想要同步的队列，都需要转换为<code>Vector</code>的数组结构。大家都知道，数组存储需要连续空间，顺序读取效率表现优秀，但是插入和删除效率就比较差了。</p><h2 id="将迭代器的同步权利交给用户"><a href="#将迭代器的同步权利交给用户" class="headerlink" title="将迭代器的同步权利交给用户"></a>将迭代器的同步权利交给用户</h2><p>同步方法中<code>SynchronizedList</code>和<code>Vector</code>很类似，不过迭代器方法有了不同想法。</p><p>看源码就知道，<code>SynchronizedList</code>中的<code>iterator</code>和<code>listIterator</code>方法都没有实现同步，所以在获取迭代器的时候不会阻塞。</p><pre><code class="java">public Iterator&lt;E&gt; iterator() {    return list.iterator(); // Must be manually synched by user!}public ListIterator&lt;E&gt; listIterator() {    return list.listIterator(); // Must be manually synched by user}public ListIterator&lt;E&gt; listIterator(int index) {    return list.listIterator(index); // Must be manually synched by user}</code></pre><p>如果需要迭代的话，直接用<code>synchronized</code>包一下队列对象就可以了，代码如下：</p><pre><code class="java">final List&lt;String&gt; list = Collections.synchronizedList(new ArrayList());list.add(&quot;A&quot;);list.add(&quot;B&quot;);list.add(&quot;C&quot;);final Iterator&lt;String&gt; iterator = list.iterator();synchronized (list) {    while (iterator.hasNext()) {        final String next = iterator.next();        System.out.println(next);    }}</code></pre><p>我们再看下<code>Vector</code>迭代器实现：</p><pre><code class="java">/**    * An optimized version of AbstractList.Itr    */private class Itr implements Iterator&lt;E&gt; {    int cursor;       // index of next element to return    int lastRet = -1; // index of last element returned; -1 if no such    int expectedModCount = modCount;    public boolean hasNext() {        // Racy but within spec, since modifications are checked        // within or after synchronization in next/previous        return cursor != elementCount;    }    public E next() {        synchronized (Vector.this) {            checkForComodification();            int i = cursor;            if (i &gt;= elementCount)                throw new NoSuchElementException();            cursor = i + 1;            return elementData(lastRet = i);        }    }    public void remove() {        if (lastRet == -1)            throw new IllegalStateException();        synchronized (Vector.this) {            checkForComodification();            Vector.this.remove(lastRet);            expectedModCount = modCount;        }        cursor = lastRet;        lastRet = -1;    }    // 此处省略一些方法}</code></pre><p><code>Vector</code>的迭代器用<code>synchronized (Vector.this)</code>加锁，其实也是对当前类实例加锁，和我们自己实现的加锁方式一致。当然，从这点上来说，<code>Vector</code>能够保证在开发人员无意识的情况下，避免为同步造成的错误，这也是<code>Vector</code>的一个优点。</p><h2 id="Vector不完全一无是处"><a href="#Vector不完全一无是处" class="headerlink" title="Vector不完全一无是处"></a><code>Vector</code>不完全一无是处</h2><p>虽然<code>Vector</code>在其他地方败给了<code>Collections</code>，但是在扩容这方面，还有一个可取之处。先看看<code>Vector</code>的扩容方法：</p><pre><code class="java">private void grow(int minCapacity) {    // overflow-conscious code    int oldCapacity = elementData.length;    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?                                        capacityIncrement : oldCapacity);    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    elementData = Arrays.copyOf(elementData, newCapacity);}</code></pre><p>在计算新数组长度的时候，会检查<code>capacityIncrement</code>是否大于 0，如果是，就扩容<code>capacityIncrement</code>的大小。就是说，在<code>Vector</code>中可以指定扩容大小，如果没有指定，默认扩容到原来的 2 倍；而<code>ArrayList</code>只能扩容到 1.5 倍，没有办法自定义扩容大小。</p><blockquote><p>仔细想想，这点并没有什么用处。</p></blockquote><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><ol><li><code>Vector</code>内部结构是数组，与<code>Collections.synchronizedList(new ArrayList())</code>类似。</li><li><code>Vector</code>可以指定扩容大小，默认是扩容到原数组长度的 2 倍；<code>ArrayList</code>不能指定扩容大小，直接扩容到原数组大小的 1.5 倍。</li><li><code>SynchronizedList</code>是一个包装类，可以将<code>List</code>子类都包装为同步队列，从非线程安全队列转为线程安全队列，没有性能延迟，直接包装即可；<code>Vector</code>是一个基于数组的同步队列，其他队列想要转换为<code>Vector</code>，需要有数据拷贝。</li><li><code>SynchronizedList</code>的迭代器没有做同步，需要用户自己实现；<code>Vector</code>的迭代器做好了同步，开发人员不需要关心同步。</li><li><code>Vector</code>至今未标记<code>Deprecated</code>，而且随着 JDK 发布，也在更新实现。虽然 JDK 承诺兼容，但是一直没有标记过期，其用意不得而知。</li></ol><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol><li><a href="https://www.howardliu.cn/understanding-java-list/">认识 Java 中的队列：Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList</a></li><li><a href="https://www.howardliu.cn/arraylist-is-not-thread-safe/">如果非要在多线程中使用 ArrayList 会发生什么？</a></li><li><a href="https://stackoverflow.com/questions/1386275/why-is-java-vector-and-stack-class-considered-obsolete-or-deprecated" target="_blank" rel="noopener">Why is Java Vector (and Stack) class considered obsolete or deprecated?</a></li><li><a href="https://stackoverflow.com/questions/14932034/in-java-vector-and-collections-synchronizedlist-are-all-synchronized-whats-th" target="_blank" rel="noopener">In java, Vector and Collections.synchronizedList are all synchronized, what’s the difference?</a></li></ol><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-vector-vs-collections-synchronizedlist-arraylist/">Java 中 Vector 和 Collections.synchronizedList(new ArrayList()) 的区别</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/114238758" target="_blank" rel="noopener">Java 中 Vector 和 Collections.synchronizedList(new ArrayList()) 的区别</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Java 中 Vector 和 SynchronizedList 的区别
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="线程安全" scheme="https://www.howardliu.cn/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件架构-事件驱动架构</title>
    <link href="https://www.howardliu.cn/event-driven-architecture/"/>
    <id>https://www.howardliu.cn/event-driven-architecture/</id>
    <published>2021-02-20T13:21:45.000Z</published>
    <updated>2021-02-20T13:21:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/software-architecture/jellyfish-2427426_1920.jpg" alt="软件架构-事件驱动架构"></p><p>你好，我是看山。</p><blockquote><p>本文源自并发编程网的翻译邀请，翻译的是 Jakob Jenkov 的 <a href="http://tutorials.jenkov.com/software-architecture/index.html" target="_blank" rel="noopener">《软件架构》</a> 中关于事件驱动的内容，虽然是 2014 年的文章，但是从软件架构层面上，并不过时。</p></blockquote><p>以下是正文。</p><p>事件驱动架构是一种系统或组件之间通过发送事件和响应事件彼此交互的架构风格。当某个事件发生时，组件A不直接调用组件B，而只是发出一个事件。组件A不知道哪些组件监听并处理这些事件。事件驱动架构可以在进程内和进程间使用。比如，GUI框架中会大量使用事件驱动。【译者注：目前很多系统采用微服务架构，事件驱动使用的更加广泛了。】此外，正如我在<a href="http://tutorials.jenkov.com/java-concurrency/concurrency-models.html" target="_blank" rel="noopener">并发模型教程</a> 中所提到的，装配线并发模型（AKA reactive，非阻塞并发模型）也使用了事件驱动架构。</p><p>本文主要介绍进程之间的事件驱动架构，后文提到这个词的时候也是指进程交互方式。</p><a id="more"></a><h2 id="进程间的事件驱动架构"><a href="#进程间的事件驱动架构" class="headerlink" title="进程间的事件驱动架构"></a>进程间的事件驱动架构</h2><p>事件驱动架构是一种架构风格，先将请求事件集中存放在一个或多个事件队列中，然后事件从这些事件队列转发到后端服务，处理这些事件。</p><p>因为事件可以被看做是消息流，所以事件驱动架构也被称为消息驱动架构或者流处理架构。流处理架构又可以被称为lambda架构。为了保证统一，后文会继续使用事件驱动这个名词。</p><h2 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h2><p>在事件驱动架构中，你会有一个或多个集中的事件队列，所有的事件被处理前，会先保存在集中的事件队列中。下面给出一个简单示例：</p><p><img src="http://static.howardliu.cn/software-architecture/event-driven-architecture-1.png" alt="event-driven-architecture"></p><p>事件插入队列时是有序的，这样就可以顺序处理这些事件。</p><h2 id="事件日志"><a href="#事件日志" class="headerlink" title="事件日志"></a>事件日志</h2><p>写入事件队列时，消息可能写入到事件日志（通常是磁盘存储）中。如果发生系统崩溃，系统只需要重放事件日志即可恢复到崩溃前的状态。下面是一个事件驱动架构的示例，其中包括一个用于持久化事件的事件日志：</p><p><img src="http://static.howardliu.cn/software-architecture/event-driven-architecture-2.png" alt="event-driven-architecture"></p><p>我们还可以通过备份事件日志，来备份系统状态。在将新版本的系统部署在生产环境之前，可以使用这个备份数据对其性能进行测试。或者，通过重放事件日志的备份，来重现某些错误。</p><h2 id="事件收集器"><a href="#事件收集器" class="headerlink" title="事件收集器"></a>事件收集器</h2><p>请求都是通过网络传输，比如HTTP或者其他协议。为了保持一致，可以通过事件采集器接收来自不同来源的事件。下面是一个添加了事件收集器的事件驱动架构示例：</p><p><img src="http://static.howardliu.cn/software-architecture/event-driven-architecture-3.png" alt="event-driven-architecture"></p><h2 id="响应队列"><a href="#响应队列" class="headerlink" title="响应队列"></a>响应队列</h2><p>有时，我们还需要向请求（即事件）返回响应，所以，很多事件驱动架构除了包含事件队列，还会有一个响应队列。下面是包含事件队列（入队队列）和响应队列（出队队列）的事件驱动架构示例：</p><p><img src="http://static.howardliu.cn/software-architecture/event-driven-architecture-4.png" alt="event-driven-architecture"></p><p>如你所见，响应队列必须路由到正确的事件收集器。比如，如果HTTP收集器（本质上是web服务器）通过HTTP接收的请求发送到事件队列中，则该事件生成的响应可能也需要通过HTTP收集器发回客户端。</p><p>通常，响应队列不会持久化，也就意味着它不会写入事件日志，只有输入的事件才会持久化到事件日志中。</p><h2 id="读事件-vs-写事件"><a href="#读事件-vs-写事件" class="headerlink" title="读事件 vs. 写事件"></a>读事件 vs. 写事件</h2><p>如果将所有传入的请求都认为是事件，就需要将这些事件都推送到事件队列中。如果事件队列是实现了持久化（持久化到事件日志中），就意味着所有事件都需要持久化。通常持久化都比较慢，如果我们能够过滤掉一些不需要持久化的事件，我们就能够提升队列的性能。</p><p>我们将事件持久化到事件日志的原因是，我们可以重放事件日志，并重建因为事件引起的系统状态变化。为了支持这个特性，实际上只需要持久化更改系统状态的事件。换句话说，我们只需要将事件分为读事件和写事件。读事件只读取系统数据，不会更改，写事件会更改系统数据。</p><p>通过根据读和写划分事件，我们只需要持久化写事件的消息即可。这将提升事件队列的性能，提升比例大小，取决于读写事件之间的比例。</p><p>为了将事件划分为读写事件，需要在事件到达事件队列之前，也就是事件收集器中进行区分。否则，事件队列无法知道到达的事件是否需要持久化。</p><p>还可以将事件队列拆分为两个，一个用于存储读事件的事件队列，一个用于存储写事件的事件队列。这样读事件就不会慢于写事件，事件队列也不需要检查每条事件是否需要持久化。读事件队列不需要进行持久化，写事件队列始终持久化事件。</p><p>下面是一个事件驱动架构的示例，其中事件队列分为读和写事件队列：</p><p><img src="http://static.howardliu.cn/software-architecture/event-driven-architecture-5.png" alt="event-driven-architecture"></p><p>上图示例中箭头比较乱，但实际上创建3个丢列并在它们之间分发消息简单很多。</p><h2 id="事件日志重放的挑战"><a href="#事件日志重放的挑战" class="headerlink" title="事件日志重放的挑战"></a>事件日志重放的挑战</h2><p>事件驱动架构的一大优点是，在系统崩溃或系统重启情况下，只需要重放事件日志，就能够重建系统状态。在日志可以独立于时间和周边系统的情况下重放日志，这是一个很大的优势。</p><p>但是，完全独立于时间重放事件日志有时候很难实现。接下来介绍下事件日志重放的一些挑战。</p><h3 id="处理动态数据"><a href="#处理动态数据" class="headerlink" title="处理动态数据"></a>处理动态数据</h3><p>如前所述，写事件处理时可能会修改系统数据。有些情况，这种数据的修改受事件处理时动态数据的影响。比如，处理事件的日期和时间或者特定日期和时间的货币汇率。</p><p>这些动态数据会对事件重放造成困难。如果在不同的时间重放事件日志，处理该事件的服务可能会解析不同的动态值，比如其他的日期和时间或其他汇率。因此，在不同的日期重放事件日志，可能会出现重建系统数据与最初处理事件产生的数据不一致。</p><p>要解决动态数据的问题，可以让写事件队列将所需的动态数据标记在事件中。但是，要实现这种方案，需要事件队列知道每条事件消息需要哪些动态数据。这样会使事件队列的设计复杂化，每次需要新的动态数据时，事件队列都需要知道如何查找这些动态数据。</p><p>另外一种解决方案是，写事件队列只在写事件上标记事件的日期和时间。使用事件的原始日期和时间，处理事件的服务可以查找给定日期和时间对应的动态数据。比如，可以通过原始的日期和时间，查询当时有效的汇率。这就要求处理事件的服务需要基于日期和时间查询动态数据，但是这只是理想状态。</p><h3 id="与外部系统的交互"><a href="#与外部系统的交互" class="headerlink" title="与外部系统的交互"></a>与外部系统的交互</h3><p>事件日志重放的另一个挑战是与外部系统的协调。比如，事件日志中包含电商平台的订单，在第一次处理这个事件时，需要将订单发送到外部支付网关，以从客户信用卡中收费。</p><p>如果重放事件日志，就不希望再次为同一个订单向客户收费。因此，就不希望在事件重放时，将订单发送到外部支付网关。</p><h2 id="事件日志重放解决方案"><a href="#事件日志重放解决方案" class="headerlink" title="事件日志重放解决方案"></a>事件日志重放解决方案</h2><p>解决重放事件日志问题挺不容易的。有些系统没有问题，可以直接重放事件日志；有些系统可能需要知道原始事件的日期和时间；有些系统可能需要知道更多类似于事件原始处理过程中从外部系统获取的原始数据。</p><h3 id="重放模式"><a href="#重放模式" class="headerlink" title="重放模式"></a>重放模式</h3><p>在任何情况下，倾听写事件队列中事件的任何服务都必须知道传入事件是原始事件还是重放事件。这样，处理服务就能够确定如何处理动态数据或者如何与外部系统交互了。</p><h3 id="多步骤事件队列"><a href="#多步骤事件队列" class="headerlink" title="多步骤事件队列"></a>多步骤事件队列</h3><p>另外一个解决方案是采用多步骤事件队列。第一步，收集所有写事件；第二步，解析动态数据；第三步，与外部系统交互。如果需要重放事件日志，只需要跳过第一步和第二步，重放第三步即可。具体如何实现，需要取决于具体的系统设计。</p><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>原文链接：<a href="http://tutorials.jenkov.com/software-architecture/event-driven-architecture.html" target="_blank" rel="noopener">Event-driven Architecture</a><br>翻译: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>译文链接: <a href="https://www.howardliu.cn/event-driven-architecture/">软件架构-事件驱动架构</a><br>CSDN主页: <a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/113923639" target="_blank" rel="noopener">软件架构-事件驱动架构</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      事件驱动架构是一种系统或组件之间通过发送事件和响应事件彼此交互的架构风格。
    
    </summary>
    
    
      <category term="architect" scheme="https://www.howardliu.cn/categories/architect/"/>
    
    
      <category term="架构" scheme="https://www.howardliu.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="事件驱动" scheme="https://www.howardliu.cn/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
</feed>
