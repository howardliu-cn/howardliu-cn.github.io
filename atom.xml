<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沉潜飞动</title>
  
  <subtitle>君子藏器于身，待时而动。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.howardliu.cn/"/>
  <updated>2024-12-05T03:08:06.000Z</updated>
  <id>https://www.howardliu.cn/</id>
  
  <author>
    <name>Howard Liu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java23 的新特性</title>
    <link href="https://www.howardliu.cn/java/java-23-features/"/>
    <id>https://www.howardliu.cn/java/java-23-features/</id>
    <published>2024-09-16T00:20:00.000Z</published>
    <updated>2024-12-05T03:08:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/202409141635767.png" alt="Java23 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新遵循每六个月发布一次的节奏，LTS版本则每两年发布一次，以快速验证新特性，推动 Java 的发展。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java23 在 2024 年 9 月 17 日发布GA版本，共十二大特性：</p><ul><li>JEP 455: 模式匹配中使用原始类型（Primitive Types in Patterns, instanceof, and switch，预览）</li><li>JEP 466: 类文件API（Class-File API，第二次预览）</li><li>JEP 467: Markdown格式文档注释（Markdown Documentation Comments）</li><li>JEP 469: 向量API（Vector API，第八次孵化）</li><li>JEP 473: 流收集器（Stream Gatherers，第二次预览）</li><li>JEP 471: 标记sun.misc.Unsafe中的内存管理方法为过时（Deprecate the Memory-Access Methods in sun.misc.Unsafe for Removal）</li><li>JEP 474: ZGC：默认分代收集模式（ZGC: Generational Mode by Default）</li><li>JEP 476: 模块导入声明（Module Import Declarations，预览）</li><li>JEP 477: 隐式声明的类和实例方法（Implicitly Declared Classes and Instance Main Methods，第三次预览）</li><li>JEP 480: 结构化并发（Structured Concurrency，第三次预览）</li><li>JEP 481: 作用域值（Scoped Values，第三次预览）</li><li>JEP 482: 灵活的构造函数主体（Flexible Constructor Bodies，第二次预览）</li></ul><p>接下来我们一起看看这些特性。</p><h2 id="JEP-467-Markdown格式文档注释（Markdown-Documentation-Comments）"><a href="#JEP-467-Markdown格式文档注释（Markdown-Documentation-Comments）" class="headerlink" title="JEP 467: Markdown格式文档注释（Markdown Documentation Comments）"></a>JEP 467: Markdown格式文档注释（Markdown Documentation Comments）</h2><p>Markdown是一种轻量级的标记语言，可用于在纯文本文档中添加格式化元素，具体语法可以参考<a href="https://www.markdownguide.org/basic-syntax/" target="_blank" rel="noopener">Markdown Guide</a>。本文就是使用Markdown语法编写的。</p><p>在Java注释中引入Markdown，目标是使API文档注释以源代码形式更易于编写和阅读。主要收益包括：</p><ul><li>提高文档编写的效率：Markdown语法相比HTML更为简洁，开发者可以更快地编写和修改文档注释。</li><li>增强文档的可读性：Markdown格式的文档在源代码中更易于阅读，有助于开发者快速理解API的用途和行为。</li><li>促进文档的一致性：通过支持Markdown，可以确保文档风格的一致性，减少因格式问题导致的文档混乱。</li><li>简化文档维护：Markdown格式的文档注释更易于维护和更新，特别是在多人协作的项目中，可以减少因文档格式问题导致的沟通成本。</li></ul><p>具体使用方式是在注释前面增加<code>///</code>，比如<code>java.lang.Object.hashCode</code>的注释：</p><pre><code class="java">/** * Returns a hash code value for the object. This method is * supported for the benefit of hash tables such as those provided by * {@link java.util.HashMap}. * &lt;p&gt; * The general contract of {@code hashCode} is: * &lt;ul&gt; * &lt;li&gt;Whenever it is invoked on the same object more than once during *     an execution of a Java application, the {@code hashCode} method *     must consistently return the same integer, provided no information *     used in {@code equals} comparisons on the object is modified. *     This integer need not remain consistent from one execution of an *     application to another execution of the same application. * &lt;li&gt;If two objects are equal according to the {@link *     #equals(Object) equals} method, then calling the {@code *     hashCode} method on each of the two objects must produce the *     same integer result. * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal *     according to the {@link #equals(Object) equals} method, then *     calling the {@code hashCode} method on each of the two objects *     must produce distinct integer results.  However, the programmer *     should be aware that producing distinct integer results for *     unequal objects may improve the performance of hash tables. * &lt;/ul&gt; * * @implSpec * As far as is reasonably practical, the {@code hashCode} method defined * by class {@code Object} returns distinct integers for distinct objects. * * @return  a hash code value for this object. * @see     java.lang.Object#equals(java.lang.Object) * @see     java.lang.System#identityHashCode */</code></pre><p>如果使用JEP 467的Markdown方式：</p><pre><code class="java">/// Returns a hash code value for the object. This method is/// supported for the benefit of hash tables such as those provided by/// [java.util.HashMap].////// The general contract of `hashCode` is://////   - Whenever it is invoked on the same object more than once during///     an execution of a Java application, the `hashCode` method///     must consistently return the same integer, provided no information///     used in `equals` comparisons on the object is modified.///     This integer need not remain consistent from one execution of an///     application to another execution of the same application.///   - If two objects are equal according to the///     [equals][#equals(Object)] method, then calling the///     `hashCode` method on each of the two objects must produce the///     same integer result.///   - It is _not_ required that if two objects are unequal///     according to the [equals][#equals(Object)] method, then///     calling the `hashCode` method on each of the two objects///     must produce distinct integer results.  However, the programmer///     should be aware that producing distinct integer results for///     unequal objects may improve the performance of hash tables.////// @implSpec/// As far as is reasonably practical, the `hashCode` method defined/// by class `Object` returns distinct integers for distinct objects.////// @return  a hash code value for this object./// @see     java.lang.Object#equals(java.lang.Object)/// @see     java.lang.System#identityHashCode</code></pre><p>简单两种写法的差异，相同注释，Markdown的写法更加简洁：</p><p><img src="https://static.howardliu.cn/Object-hashcode-diff-3.png" alt="Object hashcode注释差异"></p><h2 id="JEP-474-ZGC：默认分代收集模式（ZGC-Generational-Mode-by-Default）"><a href="#JEP-474-ZGC：默认分代收集模式（ZGC-Generational-Mode-by-Default）" class="headerlink" title="JEP 474: ZGC：默认分代收集模式（ZGC: Generational Mode by Default）"></a>JEP 474: ZGC：默认分代收集模式（ZGC: Generational Mode by Default）</h2><p>分代ZGC从Java21正式发布，需要通过命令<code>-XX:+UseZGC -XX:+ZGenerational</code>显式使用分代ZGC。在Java23中，分代ZGC已作为ZGC默认方式，不需要显式指定了。在后续版本中，非分代ZGC将被删除。ZGC发展历程可以查看<a href="https://wiki.openjdk.org/display/zgc/Main" target="_blank" rel="noopener">https://wiki.openjdk.org/display/zgc/Main</a>。</p><p>基于「大部分对象朝生夕死」的分代假说，ZGC提供了分代版本，将内存划分为年轻代和老年代，并为这两种代分别维护不同的垃圾收集策略。</p><p>我们看下<a href="https://kstefanj.github.io/2023/11/07/hazelcast-on-generational-zgc.html" target="_blank" rel="noopener">Hazelcast Jet on Generational ZGC</a>中给出的测评效果：</p><p><img src="https://static.howardliu.cn/p9999-event-latency.png" alt="JEP 439: 分代ZGC（Generational ZGC）"></p><p>从上图可以看到，非分代 ZGC 在低负载下表现非常好，但随着分配压力的增加，延迟也会增加。使用分代 ZGC 后，即使在高负载下，延迟也非常低，而且延迟效果优于G1。</p><p>如果想用回非分代ZGC，需要通过命令<code>-XX:+UseZGC -XX:-ZGenerational</code>切换为非分代ZGC，启动过程会收到JVM的告警：“the ZGenerational option is deprecated is issued.”和“the non-generational mode is deprecated for removal is issued.”。</p><h2 id="预览功能"><a href="#预览功能" class="headerlink" title="预览功能"></a>预览功能</h2><h3 id="JEP-455-模式匹配中使用原始类型（Primitive-Types-in-Patterns-instanceof-and-switch，预览）"><a href="#JEP-455-模式匹配中使用原始类型（Primitive-Types-in-Patterns-instanceof-and-switch，预览）" class="headerlink" title="JEP 455: 模式匹配中使用原始类型（Primitive Types in Patterns, instanceof, and switch，预览）"></a>JEP 455: 模式匹配中使用原始类型（Primitive Types in Patterns, instanceof, and switch，预览）</h3><p>JEP 455 的目标是通过允许在所有模式上下文中使用原始类型来增强模式匹配，并扩展 instanceof 和 switch 以使其适用于所有原始类型。这旨在实现统一的数据探索，无论是原始类型还是引用类型。</p><p>在 Java 中，模式匹配主要针对引用类型，而原始类型在模式匹配中的使用受到限制。这导致了代码的冗余和不一致性。JEP 455 允许在 instanceof 和 switch 语句中直接使用原始类型，而无需进行额外的类型转换。这使得模式匹配更加灵活和强大，提高代码的可读性和一致性。</p><p>我们看下示例代码：</p><pre><code class="java">// 先看个例子switch (x.getStatus()) {    case 0 -&gt; &quot;okay&quot;;    case 1 -&gt; &quot;warning&quot;;    case 2 -&gt; &quot;error&quot;;    default -&gt; &quot;unknown status: &quot; + x.getStatus();}// default语句改造一下switch (x.getStatus()) {    case 0 -&gt; &quot;okay&quot;;    case 1 -&gt; &quot;warning&quot;;    case 2 -&gt; &quot;error&quot;;    case int i -&gt; &quot;unknown status: &quot; + i;}// 还可以增加检查值逻辑switch (x.getYearlyFlights()) {    case 0 -&gt; ...;    case 1 -&gt; ...;    case 2 -&gt; issueDiscount();    case int i when i &gt;= 100 -&gt; issueGoldCard();    case int i -&gt; ... appropriate action when i &gt; 2 &amp;&amp; i &lt; 100 ...}// 在数值精度问题场景中if (i &gt;= -128 &amp;&amp; i &lt;= 127) {    byte b = (byte)i;    ... b ...}// 可以通过instanceof增强直接判断类型if (i instanceof byte b) {    ... b ...}</code></pre><h3 id="JEP-466-类文件API（Class-File-API，第二次预览）"><a href="#JEP-466-类文件API（Class-File-API，第二次预览）" class="headerlink" title="JEP 466: 类文件API（Class-File API，第二次预览）"></a>JEP 466: 类文件API（Class-File API，第二次预览）</h3><p>Java中一直缺少官方的类文件操作API，想要操作class，我们需要借助第三方库，比如javassist、ASM、ByteBuddy等。从2017年开始，Java每半年有一次升级，特性更新频率增加，需要第三方库同步更新，是比较困难的。</p><p>还有一个原因是Java中使用了ASM实现<code>jar</code>、<code>jlink</code>等工具，以及lambda表达式等。这就会出现一个问题，Java版本N依赖了ASM版本M，如果Java N中有类API，ASM M中是不会有的，只有Java N发布后，ASM升级到M+1才会有，Java想要使用ASM M+1，需要升级到Java N+1。是不是很颠，一个官方基础语言，居然要依赖一个依赖这个语言的第三方工具。是可忍孰不可忍。</p><p>于是有了类文件API，目标是提供一个准确、完整、高性能且遵循Java虚拟机规范定义的类文件格式的API，最终也会替换JDK内部的ASM副本。</p><p>因为当前还是预览版，我们先简单看下官方示例：</p><p>如果要实现下面这段：</p><pre><code class="java">void fooBar(boolean z, int x) {    if (z)        foo(x);    else        bar(x);}</code></pre><p>我们在ASM的写法：</p><pre><code class="java">ClassWriter classWriter = ...;MethodVisitor mv = classWriter.visitMethod(0, &quot;fooBar&quot;, &quot;(ZI)V&quot;, null, null);mv.visitCode();mv.visitVarInsn(ILOAD, 1);Label label1 = new Label();mv.visitJumpInsn(IFEQ, label1);mv.visitVarInsn(ALOAD, 0);mv.visitVarInsn(ILOAD, 2);mv.visitMethodInsn(INVOKEVIRTUAL, &quot;Foo&quot;, &quot;foo&quot;, &quot;(I)V&quot;, false);Label label2 = new Label();mv.visitJumpInsn(GOTO, label2);mv.visitLabel(label1);mv.visitVarInsn(ALOAD, 0);mv.visitVarInsn(ILOAD, 2);mv.visitMethodInsn(INVOKEVIRTUAL, &quot;Foo&quot;, &quot;bar&quot;, &quot;(I)V&quot;, false);mv.visitLabel(label2);mv.visitInsn(RETURN);mv.visitEnd();</code></pre><p>在JEP 457中的写法：</p><pre><code class="java">ClassBuilder classBuilder = ...;classBuilder.withMethod(&quot;fooBar&quot;, MethodTypeDesc.of(CD_void, CD_boolean, CD_int), flags,                        methodBuilder -&gt; methodBuilder.withCode(codeBuilder -&gt; {    Label label1 = codeBuilder.newLabel();    Label label2 = codeBuilder.newLabel();    codeBuilder.iload(1)        .ifeq(label1)        .aload(0)        .iload(2)        .invokevirtual(ClassDesc.of(&quot;Foo&quot;), &quot;foo&quot;, MethodTypeDesc.of(CD_void, CD_int))        .goto_(label2)        .labelBinding(label1)        .aload(0)        .iload(2)        .invokevirtual(ClassDesc.of(&quot;Foo&quot;), &quot;bar&quot;, MethodTypeDesc.of(CD_void, CD_int))        .labelBinding(label2);        .return_();});</code></pre><p>还可以这样写：</p><pre><code class="java">CodeBuilder classBuilder = ...;classBuilder.withMethod(&quot;fooBar&quot;, MethodTypeDesc.of(CD_void, CD_boolean, CD_int), flags,                        methodBuilder -&gt; methodBuilder.withCode(codeBuilder -&gt; {    codeBuilder.iload(codeBuilder.parameterSlot(0))               .ifThenElse(                   b1 -&gt; b1.aload(codeBuilder.receiverSlot())                           .iload(codeBuilder.parameterSlot(1))                           .invokevirtual(ClassDesc.of(&quot;Foo&quot;), &quot;foo&quot;,                                          MethodTypeDesc.of(CD_void, CD_int)),                   b2 -&gt; b2.aload(codeBuilder.receiverSlot())                           .iload(codeBuilder.parameterSlot(1))                           .invokevirtual(ClassDesc.of(&quot;Foo&quot;), &quot;bar&quot;,                                          MethodTypeDesc.of(CD_void, CD_int))               .return_();});</code></pre><p>写法上比ASM更加优雅。</p><h3 id="JEP-473-流收集器（Stream-Gatherers，第二次预览）"><a href="#JEP-473-流收集器（Stream-Gatherers，第二次预览）" class="headerlink" title="JEP 473: 流收集器（Stream Gatherers，第二次预览）"></a>JEP 473: 流收集器（Stream Gatherers，第二次预览）</h3><p>流收集器旨在增强Java Stream API、以支持自定义中间操作。这一特性允许开发者以更灵活和高效的方式处理数据流，从而提高流管道的表达能力和转换数据的能力。</p><p>流收集器通过引入新的中间操作<code>Stream::gather(Gatherer)</code>，允许开发者定义自定义的转换实体（称为Gatherer），从而对流中的元素进行转换。这些转换可以是一对一、一对多、多对一或多对多的转换方式。此外，流收集器还支持保存以前遇到的元素，以便进行进一步的处理。</p><p>我们通过实例感受下这一特性的魅力：</p><pre><code class="java">public record WindowFixed&lt;TR&gt;(int windowSize) implements Gatherer&lt;TR, ArrayList&lt;TR&gt;, List&lt;TR&gt;&gt; {    public static void main(String[] args) {        var list = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9)                .gather(new WindowFixed&lt;&gt;(3))                .toList();        // [[1, 2, 3], [4, 5, 6], [7, 8, 9]]        System.out.println(list);    }    public WindowFixed {        // Validate input        if (windowSize &lt; 1) {            throw new IllegalArgumentException(&quot;window size must be positive&quot;);        }    }    @Override    public Supplier&lt;ArrayList&lt;TR&gt;&gt; initializer() {        // 创建一个 ArrayList 来保存当前打开的窗口        return () -&gt; new ArrayList&lt;&gt;(windowSize);    }    @Override    public Integrator&lt;ArrayList&lt;TR&gt;, TR, List&lt;TR&gt;&gt; integrator() {        // 集成器在每次消费元素时被调用        return Gatherer.Integrator.ofGreedy((window, element, downstream) -&gt; {            // 将元素添加到当前打开的窗口            window.add(element);            // 直到达到所需的窗口大小，            // 返回 true 表示希望继续接收更多元素            if (window.size() &lt; windowSize) {                return true;            }            // 当窗口已满时，通过创建副本关闭窗口            var result = new ArrayList&lt;TR&gt;(window);            // 清空窗口以便开始新的窗口            window.clear();            // 将关闭的窗口发送到下游            return downstream.push(result);        });    }    // 由于此操作本质上是顺序的，因此无法并行化，因此省略了合并器    @Override    public BiConsumer&lt;ArrayList&lt;TR&gt;, Downstream&lt;? super List&lt;TR&gt;&gt;&gt; finisher() {        // 终结器在没有更多元素传递时运行        return (window, downstream) -&gt; {            // 如果下游仍然接受更多元素且当前打开的窗口非空，则将其副本发送到下游            if (!downstream.isRejecting() &amp;&amp; !window.isEmpty()) {                downstream.push(new ArrayList&lt;TR&gt;(window));                window.clear();            }        };    }}</code></pre><p>该特性还是预览版，等正式发布后再细说。</p><h3 id="JEP-476-模块导入声明（Module-Import-Declarations，预览）"><a href="#JEP-476-模块导入声明（Module-Import-Declarations，预览）" class="headerlink" title="JEP 476: 模块导入声明（Module Import Declarations，预览）"></a>JEP 476: 模块导入声明（Module Import Declarations，预览）</h3><p>模块导入声明目标是增强 Java 编程语言，使其能够简洁地导入一个模块导出的所有包。这简化了模块库的重用，但并不要求导入代码本身必须在模块中。</p><p>在 Java 中，开发者经常需要从模块中导入多个包，这会导致代码中出现大量的 import 语句，增加了代码的冗余和复杂性。JEP 476 引入了一种新的导入声明方式，使得开发者可以更简洁地导入一个模块的所有包，从而提高代码的可读性和开发效率。</p><p>比如下面这段代码：</p><pre><code class="java">import java.util.Map;                   // or import java.util.*;import java.util.function.Function;     // or import java.util.function.*;import java.util.stream.Collectors;     // or import java.util.stream.*;import java.util.stream.Stream;         // (can be removed)String[] fruits = new String[] { &quot;apple&quot;, &quot;berry&quot;, &quot;citrus&quot; };Map&lt;String, String&gt; m =    Stream.of(fruits)          .collect(Collectors.toMap(s -&gt; s.toUpperCase().substring(0,1),                                    Function.identity()));</code></pre><p>使用import导入了依赖的类，在JEP 476后，我们可以通过<code>import module java.base;</code>一行代码解决。</p><p>这种方式虽然简洁，但是可能存在问题，比如<code>Date</code>类，在<code>java.util</code>和<code>java.sql</code>中都有<code>Date</code>类，如果有场景需要这两个模块，就需要显式指明<code>Date</code>类的来源：</p><pre><code class="java">import module java.base;      // exports java.util, which has a public Date classimport module java.sql;       // exports java.sql, which has a public Date classimport java.sql.Date;         // resolve the ambiguity of the simple name Date!...Date d = ...                  // Ok!  Date is resolved to java.sql.Date...</code></pre><h3 id="JEP-477-隐式声明的类和实例方法（Implicitly-Declared-Classes-and-Instance-Main-Methods，第三次预览）"><a href="#JEP-477-隐式声明的类和实例方法（Implicitly-Declared-Classes-and-Instance-Main-Methods，第三次预览）" class="headerlink" title="JEP 477: 隐式声明的类和实例方法（Implicitly Declared Classes and Instance Main Methods，第三次预览）"></a>JEP 477: 隐式声明的类和实例方法（Implicitly Declared Classes and Instance Main Methods，第三次预览）</h3><p>隐式声明的类和实例方法的目标是简化 Java 语言，使得学生和初学者可以更容易地编写他们的第一个程序，而无需理解为大型程序设计的复杂语言特性。</p><p>无论学习哪门语言，第一课一定是打印<code>Hello, World!</code>，Java中的写法是：</p><pre><code class="java">public class HelloWorld {    public static void main(String[] args) {        System.out.println (&quot;Hello, World!&quot;);    }}</code></pre><p>如果是第一次接触，一定会有很多疑问，<code>public</code>干啥的，<code>main</code>方法的约定参数<code>args</code>是什么鬼？然后老师就说，这就是模板，照着抄就行，不这样写不运行。</p><p>现在可以简化为：</p><pre><code class="java">class HelloWorld {    void main() {        System.out.println (&quot;Hello, World!&quot;);    }}</code></pre><p>我们还可以这样写：</p><pre><code class="java">String greeting() { return &quot;Hello, World!&quot;; }void main() {    System.out.println(greeting());}</code></pre><p><code>main</code>方法直接简化为名字和括号，甚至连类也不需要显性定义了。虽然看起来没啥用，但是在JShell中使用，就比较友好了。</p><p>本次预览新增了三个IO操作方法：</p><pre><code class="java">public static void println(Object obj);public static void print(Object obj);public static String readln(String prompt);</code></pre><p>想要快速实现控制台操作，可以这样写了：</p><pre><code class="java">void main() {    String name = readln(&quot;请输入姓名: &quot;);    print(&quot;很高兴见到你, &quot;);    println(name);}</code></pre><p>作为一个老程序猿，也不得不哇塞一下。</p><h3 id="JEP-480-结构化并发（Structured-Concurrency，第三次预览）"><a href="#JEP-480-结构化并发（Structured-Concurrency，第三次预览）" class="headerlink" title="JEP 480: 结构化并发（Structured Concurrency，第三次预览）"></a>JEP 480: 结构化并发（Structured Concurrency，第三次预览）</h3><p>结构化并发API（Structured Concurrency API）旨在简化多线程编程，通过引入一个API来处理在不同线程中运行的多个任务作为一个单一工作单元，从而简化错误处理和取消操作，提高可靠性，并增强可观测性。本次发布是第一次预览。</p><p>结构化并发API提供了明确的语法结构来定义子任务的生命周期，并启用一个运行时表示线程间的层次结构。这有助于实现错误传播和取消以及并发程序的有意义观察。</p><p>Java使用异常处理机制来管理运行时错误和其他异常。当异常在代码中产生时，如何被传递和处理的过程称为异常传播。</p><p>在结构化并发环境中，异常可以通过显式地从当前环境中抛出并传播到更大的环境中去处理。</p><p>在Java并发编程中，非受检异常的处理是程序健壮性的重要组成部分。特别是对于非受检异常的处理，这关系到程序在遇到错误时是否能够优雅地继续运行或者至少提供有意义的反馈。</p><pre><code class="java">try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {    var task1 = scope.fork(() -&gt; {        Thread.sleep(1000);        return &quot;Result from task 1&quot;;    });    var task2 = scope.fork(() -&gt; {        Thread.sleep(2000);        return &quot;Result from task 2&quot;;    });    scope.join();    scope.throwIfFailed(RuntimeException::new);    System.out.println(task1.get());    System.out.println(task2.get());} catch (Exception e) {    e.printStackTrace();}</code></pre><p>在这个例子中，handle()方法使用StructuredTaskScope来并行执行两个子任务：task1和task2。通过使用try-with-resources语句自动管理资源，并确保所有子任务都在try块结束时正确完成或被取消。这种方式使得线程的生命周期和任务的逻辑结构紧密相关，提高了代码的清晰度和错误处理的效率。使用 StructuredTaskScope 可以确保一些有价值的属性：</p><ul><li>错误处理与短路：如果task1或task2子任务中的任何一个失败，另一个如果尚未完成则会被取消。（这由 ShutdownOnFailure 实现的关闭策略来管理；还有其他策略可能）。</li><li>取消传播：如果在运行上面方法的线程在调用 join() 之前或之中被中断，则线程在退出作用域时会自动取消两个子任务。</li><li>清晰性：设置子任务，等待它们完成或被取消，然后决定是成功（并处理已经完成的子任务的结果）还是失败（子任务已经完成，因此没有更多需要清理的）。</li><li>可观察性：线程转储清楚地显示了任务层次结构，其中运行task1或task2的线程被显示为作用域的子任务。</li></ul><p>上面的示例能够很好的解决我们的一个痛点，有两个可并行的任务A和B，A+B才是完整结果，任何一个失败，另外一个也不需要成功，结构化并发API就可以很容易的实现这个逻辑。</p><h3 id="JEP-481-作用域值（Scoped-Values，第三次预览）"><a href="#JEP-481-作用域值（Scoped-Values，第三次预览）" class="headerlink" title="JEP 481: 作用域值（Scoped Values，第三次预览）"></a>JEP 481: 作用域值（Scoped Values，第三次预览）</h3><p>作用域值（Scoped Values）在Java20孵化，在Java21第一次预览，在Java22第二次预览，旨在提供一种安全且高效的方法来共享数据，无需使用方法参数。这一特性允许在不使用方法参数的情况下，将数据安全地共享给方法，优先于线程局部变量，特别是在使用大量虚拟线程时。</p><p>在多线程环境中，作用域值可以在线程内和线程间共享不可变数据，例如从父线程向子线程传递数据，从而解决了在多线程应用中传递数据的问题。此外，作用域值提高了数据的安全性、不变性和封装性，并且在多线程环境中使用事务、安全主体和其他形式的共享上下文的应用程序中表现尤为突出。</p><p>作用域值的主要特点：</p><ul><li>不可变性：作用域值是不可变的，这意味着一旦设置，其值就不能更改。这种不可变性减少了并发编程中意外副作用的风险。</li><li>作用域生命周期：作用域值的生命周期仅限于 run 方法定义的作用域。一旦执行离开该作用域，作用域值将不再可访问。</li><li>继承性：子线程会自动继承父线程的作用域值，从而允许在线程边界间无缝共享数据。</li></ul><p>在这个功能之前，在多线程间传递数据，我们有两种选择：</p><ol><li>方法参数：显示参数传递；缺点是新增参数时修改联动修改一系列方法，如果是框架或SDK层面的，无法做到向下兼容。</li><li><code>ThreadLocal</code>：在<code>ThreadLocal</code>保存当前线程变量。</li></ol><p>使用过<code>ThreadLocal</code>的都清楚，<code>ThreadLocal</code>会有三大问题。</p><ol><li>无约束的可变性：每个线程局部变量都是可变的。任何可以调用线程局部变量的<code>get</code>方法的代码都可以随时调用该变量的<code>set</code>方法。即使线程局部变量中的对象是不可变的，每个字段都被声明为final，情况仍然如此。<code>ThreadLocal</code> API允许这样做，以便支持一个完全通用的通信模型，在该模型中，数据可以在方法之间以任何方向流动。这可能会导致数据流混乱，导致程序难以分辨哪个方法更新共享状态以及以何种顺序进行。</li><li>无界生存期：一旦通过<code>set</code>方法设置了一个线程局部变量的副本，该值就会在该线程的生存期内保留，或者直到该线程中的代码调用<code>remove</code>方法。我们有时候会忘记调用<code>remove</code>，如果使用线程池，在一个任务中设置的线程局部变量的值如果不清除，可能会意外泄漏到无关的任务中，导致危险的安全漏洞（比如人员SSO）。对于依赖于线程局部变量的无约束可变性的程序来说，可能没有明确的点可以保证线程调用<code>remove</code>是安全的，可能会导致内存泄漏，因为每个线程的数据在退出之前都不会被垃圾回收。</li><li>昂贵的继承：当使用大量线程时，线程局部变量的开销可能会更糟糕，因为父线程的线程局部变量可以被子线程继承。（事实上，线程局部变量并不是某个特定线程的本地变量。）当开发人员选择创建一个继承了线程局部变量的子线程时，该子线程必须为之前在父线程中写入的每个线程局部变量分配存储空间。这可能会显著增加内存占用。子线程不能共享父线程使用的存储，因为ThreadLocal API要求更改线程的线程局部变量副本在其他线程中不可见。这也会有另一个隐藏的问题，子线程没有办法向父线程<code>set</code>数据。</li></ol><p>作用域值可以有效解决上面提到的问题，而且写起来更加优雅。</p><p>我们一起看下作用域值的使用：</p><pre><code class="java">// 声明一个作用域值用于存储用户名public final static ScopedValue&lt;String&gt; USERNAME = ScopedValue.newInstance();private static final Runnable printUsername = () -&gt;        System.out.println(Thread.currentThread().threadId() + &quot; 用户名是 &quot; + USERNAME.get());public static void main(String[] args) throws Exception {    // 将用户名 &quot;Bob&quot; 绑定到作用域并执行 Runnable    ScopedValue.where(USERNAME, &quot;Bob&quot;).run(() -&gt; {        printUsername.run();        new Thread(printUsername).start();    });    // 将用户名 &quot;Chris&quot; 绑定到另一个作用域并执行 Runnable    ScopedValue.where(USERNAME, &quot;Chris&quot;).run(() -&gt; {        printUsername.run();        new Thread(() -&gt; {            new Thread(printUsername).start();            printUsername.run();        }).start();    });    // 检查在任何作用域外 USERNAME 是否被绑定    System.out.println(&quot;用户名是否被绑定: &quot; + USERNAME.isBound());}</code></pre><p>写起来干净利索，而且功能更强。</p><h3 id="JEP-482-灵活的构造函数主体（Flexible-Constructor-Bodies，第二次预览）"><a href="#JEP-482-灵活的构造函数主体（Flexible-Constructor-Bodies，第二次预览）" class="headerlink" title="JEP 482: 灵活的构造函数主体（Flexible Constructor Bodies，第二次预览）"></a>JEP 482: 灵活的构造函数主体（Flexible Constructor Bodies，第二次预览）</h3><p>我们都知道，在子类的构造函数中，比如通过<code>super(……)</code>调用父类，在<code>super</code>之前是不允许有其他语句的。</p><p>大部分的时候这种限制都没问题，但是有时候不太灵活。如果想在<code>super</code>之前加上一些子类特有逻辑，比如想统计下子类构造耗时，就得重写一遍父类的实现。</p><p>除了有损灵活性，这种重写的做法也会造成父子类之间的关系变得奇怪。假设父类是SDK中的一个类，SDK升级时在父类构造函数增加了一些逻辑，我们项目中是无法继承这些逻辑的，某次需要升级SDK（比如低版本有安全风险），验证不完整的情况下，就很容易出现bug。</p><p>JEP 482 的目标是提高构造函数的可读性和可预测性，同时保持构造函数调用的自上而下的规则。通过允许在显式调用 <code>super()</code> 或 <code>this()</code> 前初始化字段，从而实现更灵活的构造函数主体。这一变化使得代码更具表现力。</p><p>我们看下示例代码：</p><pre><code class="java">public class PositiveBigInteger extends BigInteger {    public PositiveBigInteger(long value) {        if (value &lt;= 0) {            throw new IllegalArgumentException(&quot;non-positive value&quot;);        }        super(value);    }}</code></pre><h2 id="孵化功能"><a href="#孵化功能" class="headerlink" title="孵化功能"></a>孵化功能</h2><h3 id="JEP-469-向量API（Vector-API，第八次孵化）"><a href="#JEP-469-向量API（Vector-API，第八次孵化）" class="headerlink" title="JEP 469: 向量API（Vector API，第八次孵化）"></a>JEP 469: 向量API（Vector API，第八次孵化）</h3><p>向量API的功能是提供一个表达向量计算的API，旨在通过引入向量计算API来提高Java应用程序的性能。这一API允许开发者在支持的CPU架构上可靠地编译为最佳向量指令，从而实现比等效的标量计算更高的性能。这些计算在运行时可靠地编译成支持的CPU架构上的最优向量指令，从而实现比等效标量计算更优的性能。</p><p>下面这个是官方给的示例：</p><pre><code class="java">// 标量计算示例void scalarComputation(float[] a, float[] b, float[] c) {    for (int i = 0; i &lt; a.length ; i++) {        c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;    }}// 使用向量API的向量计算示例static final VectorSpecies&lt;Float&gt; SPECIES = FloatVector.SPECIES_PREFERRED;void vectorComputation(float[] a, float[] b, float[] c) {    int i = 0;    int upperBound = SPECIES.loopBound(a.length);    for (; i &lt; upperBound; i += SPECIES.length()) {        // FloatVector va, vb, vc;        var va = FloatVector.fromArray(SPECIES, a, i);        var vb = FloatVector.fromArray(SPECIES, b, i);        var vc = va.mul(va).add(vb.mul(vb)).neg();        vc.intoArray(c, i);    }    for (; i &lt; a.length; i++) {        c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;    }}</code></pre><p>向量API在Java中的独特优势在于其高效的并行计算能力、丰富的向量化指令集、跨平台的数据并行算法支持以及对机器学习的特别优化。</p><h2 id="弃用或废弃"><a href="#弃用或废弃" class="headerlink" title="弃用或废弃"></a>弃用或废弃</h2><h3 id="JEP-471-标记sun-misc-Unsafe中的内存管理方法为过时（Deprecate-the-Memory-Access-Methods-in-sun-misc-Unsafe-for-Removal）"><a href="#JEP-471-标记sun-misc-Unsafe中的内存管理方法为过时（Deprecate-the-Memory-Access-Methods-in-sun-misc-Unsafe-for-Removal）" class="headerlink" title="JEP 471: 标记sun.misc.Unsafe中的内存管理方法为过时（Deprecate the Memory-Access Methods in sun.misc.Unsafe for Removal）"></a>JEP 471: 标记sun.misc.Unsafe中的内存管理方法为过时（Deprecate the Memory-Access Methods in sun.misc.Unsafe for Removal）</h3><p>JEP 471 的目标是将 <code>sun.misc.Unsafe</code> 类中的内存访问方法标记为过时，并计划在未来版本中移除这些方法。这些方法包括直接访问 JVM 垃圾回收堆或非堆内存的操作。</p><p><code>sun.misc.Unsafe</code>类自 2002 年引入以来，被广泛用于执行低级操作，如直接内存访问和线程调度。然而，这些方法存在安全隐患，可能导致内存泄漏和数据竞争等问题。随着 Java 平台的发展，出现了更安全的替代 API，如 VarHandle API（JEP 193, JDK 9）和 Foreign Function &amp; Memory API（JEP 454, JDK 22），这些 API 提供了更安全和标准化的内存访问方式。</p><p>这一特性主要收益是：</p><ul><li>提高安全性：移除不安全的内存访问方法，减少潜在的安全风险。</li><li>标准化内存管理：鼓励开发者使用标准 API，提高代码的可维护性和可移植性。</li><li>促进平台发展：为 Java 平台的未来发展铺平道路，支持更多高级特性。</li></ul><p>JEP 471 将 <code>sun.misc.Unsafe</code> 中的内存访问方法标记为过时，并计划在未来版本中移除这些方法。具体步骤包括：</p><ol><li>在 Java23 中标记这些方法为过时。</li><li>在 Java25 或之前版本中发出运行时警告。</li><li>在 Java26 或之后版本中默认抛出异常。</li><li>在后续版本中移除这些方法。</li></ol><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java23 新增的特性，完整的特性清单可以从 <a href="https://openjdk.org/projects/jdk/23/" target="_blank" rel="noopener">https://openjdk.org/projects/jdk/23/</a> 查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/By2JoZqAHA6U36PG8qvCcg" target="_blank" rel="noopener">Java17 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/W6Esovb7zzCL_seXgY84jA" target="_blank" rel="noopener">Java18 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/WutbAX_IQNqP4M3rud9f_g" target="_blank" rel="noopener">Java19 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/DvZYrZTtGfdXNsXGzmQN1A" target="_blank" rel="noopener">Java20 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/iiXa9rpJu1Vedpke0XpBzQ" target="_blank" rel="noopener">Java21 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/eHHFaJErH8XH4QSRrfcehQ" target="_blank" rel="noopener">Java22 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/XvB0D2vzhaAvHESupdALag" target="_blank" rel="noopener">Java23 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">Java24 的新特性</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java/java-23-features">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java23 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java23 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      从 2017 年开始，Java 版本更新遵循每六个月发布一次的节奏，LTS版本则每两年发布一次，以快速验证新特性，推动 Java 的发展。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java23" scheme="https://www.howardliu.cn/tags/Java23/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java22 的新特性</title>
    <link href="https://www.howardliu.cn/java/java-22-features/"/>
    <id>https://www.howardliu.cn/java/java-22-features/</id>
    <published>2024-09-14T00:20:00.000Z</published>
    <updated>2024-12-05T03:08:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/202409131947520.jpg" alt="Java22 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。让我们跟随 Java 的脚步，配合示例讲解，看一看每个版本的新特性，本期是 Java22 的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java22 在 2024 年 3 月 19 日发布GA版本，共十二大特性：</p><ul><li>JEP 423: G1垃圾回收器的区域固定（Region Pinning for G1）</li><li>JEP 447: super(…)前置语句（Statements before super(…)，预览）</li><li>JEP 454: 外部函数和内存API（Foreign Function &amp; Memory API）</li><li>JEP 456: 未命名变量和模式（Unnamed Variables &amp; Patterns）</li><li>JEP 457: 类文件API（Class-File API，预览）</li><li>JEP 458: 启动多文件源代码程序（Launch Multi-File Source-Code Programs）</li><li>JEP 459: 字符串模板（String Templates，第二次预览）</li><li>JEP 460: 向量API（Vector API，第七次孵化）</li><li>JEP 461: 流收集器（Stream Gatherers，预览）</li><li>JEP 462: 结构化并发（Structured Concurrency，第二次预览）</li><li>JEP 463: 隐式声明的类和实例主方法（Implicitly Declared Classes and Instance Main Methods，第二次预览）</li><li>JEP 464: 作用域值（Scoped Values，第二次预览）</li></ul><p>接下来我们一起看看这些特性。</p><h2 id="JEP-423-G1垃圾回收器的区域固定（Region-Pinning-for-G1）"><a href="#JEP-423-G1垃圾回收器的区域固定（Region-Pinning-for-G1）" class="headerlink" title="JEP 423: G1垃圾回收器的区域固定（Region Pinning for G1）"></a>JEP 423: G1垃圾回收器的区域固定（Region Pinning for G1）</h2><p>JEP 423: G1垃圾回收器的区域固定旨在解决在使用Java本地接口（JNI）时遇到的垃圾回收（GC）延迟问题。</p><p>在使用JNI时，Java线程需要等待GC操作完成，这会导致应用程序的延迟增加。特别是在JNI关键区域，GC操作会被暂停，直到线程离开该区域。这种机制虽然可以确保GC的稳定性，但会显著增加应用程序的延迟。</p><p>JEP 423通过引入区域固定机制来解决上述问题。具体来说，该特性允许在G1垃圾回收器中固定JNI代码使用的内存区域，这样即使在这些区域中存在GC操作，也不会影响到其他区域的垃圾回收。这通过以下方式实现：</p><ol><li>区域计数器：在每个区域中维护一个计数器，用于记录该区域中的临界对象数量。当一个临界对象被获取时，计数器增加；当一个临界对象被释放时，计数器减少。</li><li>区域固定：在进行GC操作时，G1垃圾回收器会固定那些包含临界对象的区域，确保这些区域在GC期间保持不变。这样，即使线程处于JNI关键区域，垃圾回收也可以继续进行，而不会被暂停。</li></ol><p>JEP 423可以带来显著的性能改进：</p><ol><li>减少延迟：通过允许在JNI关键区域期间继续进行垃圾回收，减少了应用程序的延迟。</li><li>提高效率：Java线程无需等待GC操作完成，从而提高了开发人员的工作效率。</li><li>增强可预测性：该特性还增强了垃圾回收的可预测性，特别是在处理大对象时。</li></ol><h2 id="JEP-454-外部函数和内存API（Foreign-Function-amp-Memory-API）"><a href="#JEP-454-外部函数和内存API（Foreign-Function-amp-Memory-API）" class="headerlink" title="JEP 454: 外部函数和内存API（Foreign Function &amp; Memory API）"></a>JEP 454: 外部函数和内存API（Foreign Function &amp; Memory API）</h2><p>FFM API是为了提供一个更安全、更高效的替代JNI（Java Native Interface）的API。JNI虽然允许Java程序调用本地代码，但其使用复杂且容易引入安全问题。FFM API旨在简化这一过程，提高开发者的生产力和体验，同时增强性能、安全性和一致性。在Java22中正式发布。</p><p>FFM API通过有效地调用外部函数（即JVM外部的代码）并安全地访问外部内存（即不受JVM管理的内存），使Java程序能够调用本机库并处理本机数据，而不会出现脆弱性和危险。</p><p>FFM API经历了多轮孵化和预览，从Java17的JEP 412开始，经过Java18的JEP 419和Java19的JEP 424，再到Java20的JEP 434和Java21的JEP 442，最终在Java22中正式发布。这些改进包括：</p><ul><li>API的集中管理：通过Arena接口集中管理本地段的生命周期。</li><li>安全访问外部内存：通过<code>MemoryLayout</code>和<code>VarHandle</code>操作和访问结构化的外部内存。</li><li>调用外部函数：通过<code>Linker</code>、<code>FunctionDescriptor</code>和<code>SymbolLookup</code>调用外部函数。</li></ul><p>FFM API的主要收益包括：</p><ul><li>提高性能：通过直接调用本地函数和操作内存，提高了程序的执行效率。</li><li>增强安全性：通过更严格的内存管理机制，减少了内存泄漏和安全漏洞的风险。</li><li>提升开发体验：简化了与本地代码的交互，使得开发者可以更专注于业务逻辑的实现。</li></ul><p>我们看下官方示例：</p><pre><code class="java">// 1. 在C库路径上查找名为radixsort的外部函数Linker linker = Linker.nativeLinker();SymbolLookup stdlib = linker.defaultLookup();final MemorySegment memorySegment = stdlib.find(&quot;radixsort&quot;).orElseThrow();FunctionDescriptor descriptor = FunctionDescriptor.ofVoid(        ValueLayout.ADDRESS,        ValueLayout.JAVA_INT,        ValueLayout.ADDRESS);MethodHandle radixsort = linker.downcallHandle(memorySegment, descriptor);// 下面的代码将使用这个外部函数对字符串进行排序// 2. 分配栈上内存来存储四个字符串String[] javaStrings = {&quot;mouse&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;car&quot;};// 3. 使用try-with-resources来管理离堆内存的生命周期try (Arena offHeap = Arena.ofConfined()) {    // 4. 分配一段离堆内存来存储四个指针    MemorySegment pointers = offHeap.allocateArray(ValueLayout.ADDRESS, javaStrings.length);    // 5. 将字符串从栈上内存复制到离堆内存    for (int i = 0; i &lt; javaStrings.length; i++) {        MemorySegment cString = offHeap.allocateUtf8String(javaStrings[i]);        pointers.setAtIndex(ValueLayout.ADDRESS, i, cString);    }    // 6. 通过调用外部函数对离堆数据进行排序    radixsort.invoke(pointers, javaStrings.length, MemorySegment.NULL, &#39;\0&#39;);    // 7. 将排序后的字符串从离堆内存复制回栈上内存    for (int i = 0; i &lt; javaStrings.length; i++) {        MemorySegment cString = pointers.getAtIndex(ValueLayout.ADDRESS, i);        javaStrings[i] = cString.getUtf8String(0);    }} // 8. 所有离堆内存在此处被释放// 验证排序结果assert Arrays.equals(javaStrings, new String[] {&quot;car&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;mouse&quot;});  // true</code></pre><p>我们都知道，JNI也是可以调用外部代码的，那FFM API相较于JNI的优势在于：</p><ol><li>更安全的内存访问：FFM API 提供了一种更安全和受控的方式来与本地代码交互，避免了JNI中常见的内存泄漏和数据损坏问题。</li><li>直接访问本地内存：FFM API 允许Java程序直接访问本地内存（即Java堆外的内存），这使得数据处理更加高效和灵活。</li><li>跨语言函数调用：FFM API 支持调用Java程序的外部函数，以与外部代码和数据一起操作，而无需依赖JNI的复杂机制。</li><li>更高效的集成：FFM API 使得Java与C、C++等语言编写的库集成更加方便和高效，特别是在数据处理和机器学习等领域。</li><li>减少代码复杂性：FFM API 提供了一种更简洁的API，减少了JNI中复杂的代码编写和维护工作。</li><li>更广泛的适用性：FFM API 不仅适用于简单的函数调用，还可以处理复杂的内存管理任务，如堆外内存的管理。</li><li>提高性能：FFM API 通过高效的调用外部函数和安全地访问外部内存，提高了程序的运行效率。</li></ol><h2 id="JEP-456-未命名变量和模式（Unnamed-Variables-amp-Patterns）"><a href="#JEP-456-未命名变量和模式（Unnamed-Variables-amp-Patterns）" class="headerlink" title="JEP 456: 未命名变量和模式（Unnamed Variables &amp; Patterns）"></a>JEP 456: 未命名变量和模式（Unnamed Variables &amp; Patterns）</h2><p>JEP 456: 未命名变量和模式（Unnamed Variables &amp; Patterns）是一个重要新特性，在Java21中预览，在Java22中发布。旨在提高Java代码的可读性和可维护性。这一特性允许开发者在声明变量或嵌套模式时使用下划线字符（_）来表示未命名的变量或模式，从而简化代码并减少不必要的噪声，提高代码可读性和可维护性。</p><p>比如：</p><pre><code class="java">public static void main(String[] args) {    var _ = new Point(1, 2);}record Point(int x, int y) {}</code></pre><p>这个可以用在任何定义变量的地方，比如：</p><ul><li><code>... instanceof Point(_, int y)</code></li><li><code>r instanceof Point _</code></li><li><code>switch …… case Box(_)</code></li><li><code>for (Order _ : orders)</code></li><li><code>for (int i = 0, _ = sideEffect(); i &lt; 10; i++)</code></li><li><code>try { ... } catch (Exception _) { ... } catch (Throwable _) { ... }</code></li></ul><p>只要是这个不准备用，可以一律使用<code>_</code>代替。</p><h2 id="JEP-458-启动多文件源代码程序（Launch-Multi-File-Source-Code-Programs）"><a href="#JEP-458-启动多文件源代码程序（Launch-Multi-File-Source-Code-Programs）" class="headerlink" title="JEP 458: 启动多文件源代码程序（Launch Multi-File Source-Code Programs）"></a>JEP 458: 启动多文件源代码程序（Launch Multi-File Source-Code Programs）</h2><p>这个功能主要是提升<code>java</code>命令的能力。比如我们手搓了两个类：</p><pre><code class="java">// Prog.javaclass Prog {    public static void main(String[] args) { Helper.run(); }}// Helper.javaclass Helper {    static void run() { System.out.println(&quot;Hello!&quot;); }}</code></pre><p>想要运行<code>Prog</code>的main方法，在JEP 458之前，我们需要先编译<code>Helper</code>，然后通过<code>-classpath</code>指令加载编译后的类，才能运行<code>Prog</code>。但是现在，<code>java</code>帮我们做了，我们直接使用<code>java Prog.java</code>就可以执行了。</p><p>很方便的一个功能，但是似乎好像大概看起来没什么用，但是对于Java生态有深远影响：</p><ol><li>增强Java启动器功能：JEP 458允许Java启动器执行包含一个或多个文件的Java源码应用程序。这一改进使得开发者可以更灵活地启动和运行Java程序，特别是在需要处理多个源文件的复杂项目中，这一特性将大大提升开发效率和便利性。</li><li>促进Java生态系统的持续演进：JEP 458的引入是Java生态系统持续演进的一部分，与Java21的新特性和Quarkus的创新应用相辅相成。这些更新不仅提升了与现代Java生态系统的兼容性，还引入了领域模型验证的改进和依赖于Java17的新特性，为开发者提供了更加稳定、高效的工具集。</li><li>推动Java项目的发展：JEP 458的新特性被归类到四个主要的Java项目中，即Amber、Loom、Panama和Valhalla。这些项目旨在通过精巧的合并，孵化一系列组件，以便最终将其纳入到JDK中。这表明JEP 458不仅是一个独立的特性，而是Java生态系统中更广泛技术演进的一部分，有助于推动整个Java生态系统的创新和发展。</li><li>简化Java开发流程：通过简化启动多文件源码程序的过程，JEP 458有助于简化Java开发流程，使得开发者可以更加专注于业务逻辑的实现，而不是在启动和运行程序上花费过多时间。</li></ol><h2 id="预览功能"><a href="#预览功能" class="headerlink" title="预览功能"></a>预览功能</h2><h3 id="JEP-447-super-…-前置语句（Statements-before-super-…-）"><a href="#JEP-447-super-…-前置语句（Statements-before-super-…-）" class="headerlink" title="JEP 447: super(…)前置语句（Statements before super(…)）"></a>JEP 447: super(…)前置语句（Statements before super(…)）</h3><p>我们都知道，在子类的构造函数中，如果通过<code>super(……)</code>调用父类，在<code>super</code>之前是不允许有其他语句的。</p><p>大部分的时候这种限制都没问题，但是有时候不太灵活。如果想在<code>super</code>之前加上一些子类特有逻辑，比如想统计下子类构造耗时，就得重写一遍父类的实现。</p><p>除了有损灵活性，这种重写的做法也会造成父子类之间的关系变得奇怪。假设父类是SDK中的一个类，SDK升级时在父类构造函数增加了一些逻辑，我们项目中是无法继承这些逻辑的，某次需要升级SDK（比如低版本有安全风险），验证不完整的情况下，就很容易出现bug。</p><p>在 JEP 447 中，允许在构造函数中不引用正在创建的实例的语句出现在显式构造函数调用（如 super()）之前。这一特性旨在为开发者提供更多的灵活性，允许在调用父类构造函数之前执行一些验证或其他处理操作。</p><p>引入这一特性的主要动机是提高构造函数的灵活性和可读性。通过允许在 super() 调用之前执行语句，开发者可以在构造函数中添加额外的逻辑，例如进行一些初始化检查或执行一些特定的处理操作，而不必依赖于 super() 调用之后的代码。</p><p>我们看下示例代码：</p><pre><code class="java">public class PositiveBigInteger extends BigInteger {    public PositiveBigInteger(long value) {        if (value &lt;= 0) {            throw new IllegalArgumentException(&quot;non-positive value&quot;);        }        super(value);    }}</code></pre><h3 id="JEP-457-类文件API（Class-File-API，预览）"><a href="#JEP-457-类文件API（Class-File-API，预览）" class="headerlink" title="JEP 457: 类文件API（Class-File API，预览）"></a>JEP 457: 类文件API（Class-File API，预览）</h3><p>Java中一直缺少官方的类文件操作API，想要操作class，我们需要借助第三方库，比如javassist、ASM、ByteBuddy等。从2017年开始，Java每半年有一次升级，特性更新频率增加，需要第三方库同步更新，是比较困难的。</p><p>还有一个原因是Java中使用了ASM实现<code>jar</code>、<code>jlink</code>等工具，以及lambda表达式等。这就会出现一个问题，Java版本N依赖了ASM版本M，如果Java N中有类API，ASM M中是不会有的，只有Java N发布后，ASM升级到M+1才会有，Java想要使用ASM M+1，需要升级到Java N+1。是不是很颠，一个官方基础语言，居然要依赖一个依赖这个语言的第三方工具。是可忍孰不可忍。</p><p>于是有了JEP 457，目标是提供一个准确、完整、高性能且遵循Java虚拟机规范定义的类文件格式的API，最终也会替换JDK内部的ASM副本。</p><p>因为当前还是预览版，我们先简单看下官方示例：</p><p>如果要实现下面这段：</p><pre><code class="java">void fooBar(boolean z, int x) {    if (z)        foo(x);    else        bar(x);}</code></pre><p>我们在ASM的写法：</p><pre><code class="java">ClassWriter classWriter = ...;MethodVisitor mv = classWriter.visitMethod(0, &quot;fooBar&quot;, &quot;(ZI)V&quot;, null, null);mv.visitCode();mv.visitVarInsn(ILOAD, 1);Label label1 = new Label();mv.visitJumpInsn(IFEQ, label1);mv.visitVarInsn(ALOAD, 0);mv.visitVarInsn(ILOAD, 2);mv.visitMethodInsn(INVOKEVIRTUAL, &quot;Foo&quot;, &quot;foo&quot;, &quot;(I)V&quot;, false);Label label2 = new Label();mv.visitJumpInsn(GOTO, label2);mv.visitLabel(label1);mv.visitVarInsn(ALOAD, 0);mv.visitVarInsn(ILOAD, 2);mv.visitMethodInsn(INVOKEVIRTUAL, &quot;Foo&quot;, &quot;bar&quot;, &quot;(I)V&quot;, false);mv.visitLabel(label2);mv.visitInsn(RETURN);mv.visitEnd();</code></pre><p>在JEP 457中的写法：</p><pre><code class="java">ClassBuilder classBuilder = ...;classBuilder.withMethod(&quot;fooBar&quot;, MethodTypeDesc.of(CD_void, CD_boolean, CD_int), flags,                        methodBuilder -&gt; methodBuilder.withCode(codeBuilder -&gt; {    Label label1 = codeBuilder.newLabel();    Label label2 = codeBuilder.newLabel();    codeBuilder.iload(1)        .ifeq(label1)        .aload(0)        .iload(2)        .invokevirtual(ClassDesc.of(&quot;Foo&quot;), &quot;foo&quot;, MethodTypeDesc.of(CD_void, CD_int))        .goto_(label2)        .labelBinding(label1)        .aload(0)        .iload(2)        .invokevirtual(ClassDesc.of(&quot;Foo&quot;), &quot;bar&quot;, MethodTypeDesc.of(CD_void, CD_int))        .labelBinding(label2);        .return_();});</code></pre><p>还可以这样写：</p><pre><code class="java">CodeBuilder classBuilder = ...;classBuilder.withMethod(&quot;fooBar&quot;, MethodTypeDesc.of(CD_void, CD_boolean, CD_int), flags,                        methodBuilder -&gt; methodBuilder.withCode(codeBuilder -&gt; {    codeBuilder.iload(codeBuilder.parameterSlot(0))               .ifThenElse(                   b1 -&gt; b1.aload(codeBuilder.receiverSlot())                           .iload(codeBuilder.parameterSlot(1))                           .invokevirtual(ClassDesc.of(&quot;Foo&quot;), &quot;foo&quot;,                                          MethodTypeDesc.of(CD_void, CD_int)),                   b2 -&gt; b2.aload(codeBuilder.receiverSlot())                           .iload(codeBuilder.parameterSlot(1))                           .invokevirtual(ClassDesc.of(&quot;Foo&quot;), &quot;bar&quot;,                                          MethodTypeDesc.of(CD_void, CD_int))               .return_();});</code></pre><p>写法上比ASM更加优雅。</p><h3 id="JEP-459-字符串模板（String-Templates，第二次预览）"><a href="#JEP-459-字符串模板（String-Templates，第二次预览）" class="headerlink" title="JEP 459: 字符串模板（String Templates，第二次预览）"></a>JEP 459: 字符串模板（String Templates，第二次预览）</h3><p>字符串模板是一个值得期待的功能，旨在增强Java编程语言。该特性通过将文字文本与嵌入式表达式和模板处理器结合，生成专门的结果，从而补充了Java现有的字符串文字和文本块。</p><p>相对Java21中JEP 430，主要的优化改动包括：</p><ul><li>增强的表达式支持：允许在字符串模板中嵌入更复杂的表达式，这些表达式可以在运行时被计算和校验。</li><li>模板处理器：引入了模板处理器的概念，使得字符串模板可以更加灵活地处理不同的数据格式和结构。</li><li>安全性提升：通过在运行时对嵌入的表达式进行校验，提高了代码的安全性。</li></ul><p>字符串模板通过将文本和嵌入式表达式结合在一起，使得Java程序能够以一种更加直观和安全的方式构建字符串。与传统的字符串拼接（使用+操作符）、<code>StringBuilder</code>或<code>String.format</code> 等方法相比，字符串模板提供了一种更加清晰和安全的字符串构建方式。特别是当字符串需要从用户提供的值构建并传递给其他系统时（例如，构建数据库查询），使用字符串模板可以有效地验证和转换模板及其嵌入表达式的值，从而提高Java程序的安全性。</p><p>让我们通过代码看一下这个特性的魅力：</p><pre><code class="java">public static void main(String[] args) {    // 拼装变量    String name = &quot;看山&quot;;    String info = STR. &quot;My name is \{ name }&quot; ;    assert info.equals(&quot;My name is 看山&quot;);    // 拼装变量    String firstName = &quot;Howard&quot;;    String lastName = &quot;Liu&quot;;    String fullName = STR. &quot;\{ firstName } \{ lastName }&quot; ;    assert fullName.equals(&quot;Howard Liu&quot;);    String sortName = STR. &quot;\{ lastName }, \{ firstName }&quot; ;    assert sortName.equals(&quot;Liu, Howard&quot;);    // 模板中调用方法    String s2 = STR. &quot;You have a \{ getOfferType() } waiting for you!&quot; ;    assert s2.equals(&quot;You have a gift waiting for you!&quot;);    Request req = new Request(&quot;2017-07-19&quot;, &quot;09:15&quot;, &quot;https://www.howardliu.cn&quot;);    // 模板中引用对象属性    String s3 = STR. &quot;Access at \{ req.date } \{ req.time } from \{ req.address }&quot; ;    assert s3.equals(&quot;Access at 2017-07-19 09:15 from https://www.howardliu.cn&quot;);    LocalTime now = LocalTime.now();    String markTime = DateTimeFormatter            .ofPattern(&quot;HH:mm:ss&quot;)            .format(now);    // 模板中调用方法    String time = STR. &quot;The time is \{            // The java.time.format package is very useful            DateTimeFormatter                    .ofPattern(&quot;HH:mm:ss&quot;)                    .format(now)            } right now&quot; ;    assert time.equals(&quot;The time is &quot; + markTime + &quot; right now&quot;);    // 模板嵌套模板    String[] fruit = {&quot;apples&quot;, &quot;oranges&quot;, &quot;peaches&quot;};    String s4 = STR. &quot;\{ fruit[0] }, \{            STR. &quot;\{ fruit[1] }, \{ fruit[2] }&quot;            }&quot; ;    assert s4.equals(&quot;apples, oranges, peaches&quot;);    // 模板与文本块结合    String title = &quot;My Web Page&quot;;    String text = &quot;Hello, world&quot;;    String html = STR. &quot;&quot;&quot;    &lt;html&gt;      &lt;head&gt;        &lt;title&gt;\{ title }&lt;/title&gt;      &lt;/head&gt;      &lt;body&gt;        &lt;p&gt;\{ text }&lt;/p&gt;      &lt;/body&gt;    &lt;/html&gt;    &quot;&quot;&quot; ;    assert html.equals(&quot;&quot;&quot;            &lt;html&gt;              &lt;head&gt;                &lt;title&gt;My Web Page&lt;/title&gt;              &lt;/head&gt;              &lt;body&gt;                &lt;p&gt;Hello, world&lt;/p&gt;              &lt;/body&gt;            &lt;/html&gt;            &quot;&quot;&quot;);    // 带格式化的字符串模板    record Rectangle(String name, double width, double height) {        double area() {            return width * height;        }    }    Rectangle[] zone = new Rectangle[] {            new Rectangle(&quot;Alfa&quot;, 17.8, 31.4),            new Rectangle(&quot;Bravo&quot;, 9.6, 12.4),            new Rectangle(&quot;Charlie&quot;, 7.1, 11.23),    };    String table = FMT. &quot;&quot;&quot;        Description     Width    Height     Area        %-12s\{ zone[0].name }  %7.2f\{ zone[0].width }  %7.2f\{ zone[0].height }     %7.2f\{ zone[0].area() }        %-12s\{ zone[1].name }  %7.2f\{ zone[1].width }  %7.2f\{ zone[1].height }     %7.2f\{ zone[1].area() }        %-12s\{ zone[2].name }  %7.2f\{ zone[2].width }  %7.2f\{ zone[2].height }     %7.2f\{ zone[2].area() }        \{ &quot; &quot;.repeat(28) } Total %7.2f\{ zone[0].area() + zone[1].area() + zone[2].area() }        &quot;&quot;&quot;;    assert table.equals(&quot;&quot;&quot;            Description     Width    Height     Area            Alfa            17.80    31.40      558.92            Bravo            9.60    12.40      119.04            Charlie          7.10    11.23       79.73                                         Total  757.69            &quot;&quot;&quot;);}public static String getOfferType() {    return &quot;gift&quot;;}record Request(String date, String time, String address) {}</code></pre><p>这个功能当前是第二次预览，Java23的8.12版本中还没有展示字符串模板的第三次预览（JEP 465: String Templates），还不能确定什么时候可以正式用上。</p><h3 id="JEP-461-流收集器（Stream-Gatherers，预览）"><a href="#JEP-461-流收集器（Stream-Gatherers，预览）" class="headerlink" title="JEP 461: 流收集器（Stream Gatherers，预览）"></a>JEP 461: 流收集器（Stream Gatherers，预览）</h3><p>JEP 461旨在增强Java Stream API、以支持自定义中间操作。这一特性允许开发者以更灵活和高效的方式处理数据流，从而提高流管道的表达能力和转换数据的能力。</p><p>流收集器通过引入新的中间操作<code>Stream::gather(Gatherer)</code>，允许开发者定义自定义的转换实体（称为Gatherer），从而对流中的元素进行转换。这些转换可以是一对一、一对多、多对一或多对多的转换方式。此外，流收集器还支持保存以前遇到的元素，以便进行进一步的处理。</p><p>我们通过实例感受下这一特性的魅力：</p><pre><code class="java">public record WindowFixed&lt;TR&gt;(int windowSize) implements Gatherer&lt;TR, ArrayList&lt;TR&gt;, List&lt;TR&gt;&gt; {    public static void main(String[] args) {        var list = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9)                .gather(new WindowFixed&lt;&gt;(3))                .toList();        // [[1, 2, 3], [4, 5, 6], [7, 8, 9]]        System.out.println(list);    }    public WindowFixed {        // Validate input        if (windowSize &lt; 1) {            throw new IllegalArgumentException(&quot;window size must be positive&quot;);        }    }    @Override    public Supplier&lt;ArrayList&lt;TR&gt;&gt; initializer() {        // 创建一个 ArrayList 来保存当前打开的窗口        return () -&gt; new ArrayList&lt;&gt;(windowSize);    }    @Override    public Integrator&lt;ArrayList&lt;TR&gt;, TR, List&lt;TR&gt;&gt; integrator() {        // 集成器在每次消费元素时被调用        return Gatherer.Integrator.ofGreedy((window, element, downstream) -&gt; {            // 将元素添加到当前打开的窗口            window.add(element);            // 直到达到所需的窗口大小，            // 返回 true 表示希望继续接收更多元素            if (window.size() &lt; windowSize) {                return true;            }            // 当窗口已满时，通过创建副本关闭窗口            var result = new ArrayList&lt;TR&gt;(window);            // 清空窗口以便开始新的窗口            window.clear();            // 将关闭的窗口发送到下游            return downstream.push(result);        });    }    // 由于此操作本质上是顺序的，因此无法并行化，因此省略了合并器    @Override    public BiConsumer&lt;ArrayList&lt;TR&gt;, Downstream&lt;? super List&lt;TR&gt;&gt;&gt; finisher() {        // 终结器在没有更多元素传递时运行        return (window, downstream) -&gt; {            // 如果下游仍然接受更多元素且当前打开的窗口非空，则将其副本发送到下游            if (!downstream.isRejecting() &amp;&amp; !window.isEmpty()) {                downstream.push(new ArrayList&lt;TR&gt;(window));                window.clear();            }        };    }}</code></pre><p>该特性还是预览版，等正式发布后再细说。</p><h3 id="JEP-462-结构化并发（Structured-Concurrency，第二次预览）"><a href="#JEP-462-结构化并发（Structured-Concurrency，第二次预览）" class="headerlink" title="JEP 462: 结构化并发（Structured Concurrency，第二次预览）"></a>JEP 462: 结构化并发（Structured Concurrency，第二次预览）</h3><p>结构化并发API（Structured Concurrency API）旨在简化多线程编程，通过引入一个API来处理在不同线程中运行的多个任务作为一个单一工作单元，从而简化错误处理和取消操作，提高可靠性，并增强可观测性。本次发布是第一次预览。</p><p>结构化并发API提供了明确的语法结构来定义子任务的生命周期，并启用一个运行时表示线程间的层次结构。这有助于实现错误传播和取消以及并发程序的有意义观察。</p><p>在JEP 462中，结构化并发API被进一步完善，使其更加易于使用和维护。主要的优化包括：</p><ul><li>工作单元概念：将一组相关任务视为一个工作单元，这样可以简化错误处理和取消操作。</li><li>增强的可观测性：通过API提供了更好的错误处理机制和任务状态跟踪功能，增强了代码的可观察性。</li><li>虚拟线程支持：与Project Loom项目结合，支持在线程内和线程间共享不可变数据，这在使用大量虚拟线程时尤其有用。</li></ul><p>Java使用异常处理机制来管理运行时错误和其他异常。当异常在代码中产生时，如何被传递和处理的过程称为异常传播。</p><p>在结构化并发环境中，异常可以通过显式地从当前环境中抛出并传播到更大的环境中去处理。</p><p>在Java并发编程中，非受检异常的处理是程序健壮性的重要组成部分。特别是对于非受检异常的处理，这关系到程序在遇到错误时是否能够优雅地继续运行或者至少提供有意义的反馈。</p><pre><code class="java">try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {    var task1 = scope.fork(() -&gt; {        Thread.sleep(1000);        return &quot;Result from task 1&quot;;    });    var task2 = scope.fork(() -&gt; {        Thread.sleep(2000);        return &quot;Result from task 2&quot;;    });    scope.join();    scope.throwIfFailed(RuntimeException::new);    System.out.println(task1.get());    System.out.println(task2.get());} catch (Exception e) {    e.printStackTrace();}</code></pre><p>在这个例子中，handle()方法使用StructuredTaskScope来并行执行两个子任务：task1和task2。通过使用try-with-resources语句自动管理资源，并确保所有子任务都在try块结束时正确完成或被取消。这种方式使得线程的生命周期和任务的逻辑结构紧密相关，提高了代码的清晰度和错误处理的效率。使用 StructuredTaskScope 可以确保一些有价值的属性：</p><ul><li>错误处理与短路：如果task1或task2子任务中的任何一个失败，另一个如果尚未完成则会被取消。（这由 ShutdownOnFailure 实现的关闭策略来管理；还有其他策略可能）。</li><li>取消传播：如果在运行上面方法的线程在调用 join() 之前或之中被中断，则线程在退出作用域时会自动取消两个子任务。</li><li>清晰性：设置子任务，等待它们完成或被取消，然后决定是成功（并处理已经完成的子任务的结果）还是失败（子任务已经完成，因此没有更多需要清理的）。</li><li>可观察性：线程转储清楚地显示了任务层次结构，其中运行task1或task2的线程被显示为作用域的子任务。</li></ul><p>上面的示例能够很好的解决我们的一个痛点，有两个可并行的任务A和B，A+B才是完整结果，任何一个失败，另外一个也不需要成功，结构化并发API就可以很容易的实现这个逻辑。</p><h3 id="JEP-463-隐式声明的类和实例主方法（Implicitly-Declared-Classes-and-Instance-Main-Methods，第二次预览）"><a href="#JEP-463-隐式声明的类和实例主方法（Implicitly-Declared-Classes-and-Instance-Main-Methods，第二次预览）" class="headerlink" title="JEP 463: 隐式声明的类和实例主方法（Implicitly Declared Classes and Instance Main Methods，第二次预览）"></a>JEP 463: 隐式声明的类和实例主方法（Implicitly Declared Classes and Instance Main Methods，第二次预览）</h3><p>无论学习哪门语言，第一课一定是打印<code>Hello, World!</code>，Java中的写法是：</p><pre><code class="java">public class HelloWorld {    public static void main(String[] args) {        System.out.println (&quot;Hello, World!&quot;);    }}</code></pre><p>如果是第一次接触，一定会有很多疑问，<code>public</code>干啥的，<code>main</code>方法的约定参数<code>args</code>是什么鬼？然后老师就说，这就是模板，照着抄就行，不这样写不运行。</p><p>JEP 445特性后，可以简化为：</p><pre><code class="java">class HelloWorld {    void main() {        System.out.println (&quot;Hello, World!&quot;);    }}</code></pre><p>我们还可以这样写：</p><pre><code class="java">String greeting() { return &quot;Hello, World!&quot;; }void main() {    System.out.println(greeting());}</code></pre><p><code>main</code>方法直接简化为名字和括号，甚至连类也不需要显性定义了。虽然看起来没啥用，但是在JShell中使用，就比较友好了。</p><h3 id="JEP-464-作用域值（Scoped-Values，第二次预览）"><a href="#JEP-464-作用域值（Scoped-Values，第二次预览）" class="headerlink" title="JEP 464: 作用域值（Scoped Values，第二次预览）"></a>JEP 464: 作用域值（Scoped Values，第二次预览）</h3><p>作用域值（Scoped Values）在Java20孵化，在Java21第一次预览，在Java22第二次预览，旨在提供一种安全且高效的方法来共享数据，无需使用方法参数。这一特性允许在不使用方法参数的情况下，将数据安全地共享给方法，优先于线程局部变量，特别是在使用大量虚拟线程时。</p><p>在多线程环境中，作用域值可以在线程内和线程间共享不可变数据，例如从父线程向子线程传递数据，从而解决了在多线程应用中传递数据的问题。此外，作用域值提高了数据的安全性、不变性和封装性，并且在多线程环境中使用事务、安全主体和其他形式的共享上下文的应用程序中表现尤为突出。</p><p>作用域值的主要特点：</p><ul><li>不可变性：作用域值是不可变的，这意味着一旦设置，其值就不能更改。这种不可变性减少了并发编程中意外副作用的风险。</li><li>作用域生命周期：作用域值的生命周期仅限于 run 方法定义的作用域。一旦执行离开该作用域，作用域值将不再可访问。</li><li>继承性：子线程会自动继承父线程的作用域值，从而允许在线程边界间无缝共享数据。</li></ul><p>在这个功能之前，在多线程间传递数据，我们有两种选择：</p><ol><li>方法参数：显示参数传递；缺点是新增参数时修改联动修改一系列方法，如果是框架或SDK层面的，无法做到向下兼容。</li><li><code>ThreadLocal</code>：在<code>ThreadLocal</code>保存当前线程变量。</li></ol><p>使用过<code>ThreadLocal</code>的都清楚，<code>ThreadLocal</code>会有三大问题。</p><ol><li>无约束的可变性：每个线程局部变量都是可变的。任何可以调用线程局部变量的<code>get</code>方法的代码都可以随时调用该变量的<code>set</code>方法。即使线程局部变量中的对象是不可变的，每个字段都被声明为final，情况仍然如此。<code>ThreadLocal</code> API允许这样做，以便支持一个完全通用的通信模型，在该模型中，数据可以在方法之间以任何方向流动。这可能会导致数据流混乱，导致程序难以分辨哪个方法更新共享状态以及以何种顺序进行。</li><li>无界生存期：一旦通过<code>set</code>方法设置了一个线程局部变量的副本，该值就会在该线程的生存期内保留，或者直到该线程中的代码调用<code>remove</code>方法。我们有时候会忘记调用<code>remove</code>，如果使用线程池，在一个任务中设置的线程局部变量的值如果不清除，可能会意外泄漏到无关的任务中，导致危险的安全漏洞（比如人员SSO）。对于依赖于线程局部变量的无约束可变性的程序来说，可能没有明确的点可以保证线程调用<code>remove</code>是安全的，可能会导致内存泄漏，因为每个线程的数据在退出之前都不会被垃圾回收。</li><li>昂贵的继承：当使用大量线程时，线程局部变量的开销可能会更糟糕，因为父线程的线程局部变量可以被子线程继承。（事实上，线程局部变量并不是某个特定线程的本地变量。）当开发人员选择创建一个继承了线程局部变量的子线程时，该子线程必须为之前在父线程中写入的每个线程局部变量分配存储空间。这可能会显著增加内存占用。子线程不能共享父线程使用的存储，因为ThreadLocal API要求更改线程的线程局部变量副本在其他线程中不可见。这也会有另一个隐藏的问题，子线程没有办法向父线程<code>set</code>数据。</li></ol><p>作用域值可以有效解决上面提到的问题，而且写起来更加优雅。</p><p>我们一起看下作用域值的使用：</p><pre><code class="java">// 声明一个作用域值用于存储用户名public final static ScopedValue&lt;String&gt; USERNAME = ScopedValue.newInstance();private static final Runnable printUsername = () -&gt;        System.out.println(Thread.currentThread().threadId() + &quot; 用户名是 &quot; + USERNAME.get());public static void main(String[] args) throws Exception {    // 将用户名 &quot;Bob&quot; 绑定到作用域并执行 Runnable    ScopedValue.where(USERNAME, &quot;Bob&quot;).run(() -&gt; {        printUsername.run();        new Thread(printUsername).start();    });    // 将用户名 &quot;Chris&quot; 绑定到另一个作用域并执行 Runnable    ScopedValue.where(USERNAME, &quot;Chris&quot;).run(() -&gt; {        printUsername.run();        new Thread(() -&gt; {            new Thread(printUsername).start();            printUsername.run();        }).start();    });    // 检查在任何作用域外 USERNAME 是否被绑定    System.out.println(&quot;用户名是否被绑定: &quot; + USERNAME.isBound());}</code></pre><p>写起来干净利索，而且功能更强。</p><h2 id="孵化功能"><a href="#孵化功能" class="headerlink" title="孵化功能"></a>孵化功能</h2><h3 id="JEP-460-向量API（Vector-API，第七次孵化）"><a href="#JEP-460-向量API（Vector-API，第七次孵化）" class="headerlink" title="JEP 460: 向量API（Vector API，第七次孵化）"></a>JEP 460: 向量API（Vector API，第七次孵化）</h3><p>向量API的功能是提供一个表达向量计算的API，旨在通过引入向量计算API来提高Java应用程序的性能。这一API允许开发者在支持的CPU架构上可靠地编译为最佳向量指令，从而实现比等效的标量计算更高的性能。这些计算在运行时可靠地编译成支持的CPU架构上的最优向量指令，从而实现比等效标量计算更优的性能。</p><p>下面这个是官方给的示例：</p><pre><code class="java">// 标量计算示例void scalarComputation(float[] a, float[] b, float[] c) {    for (int i = 0; i &lt; a.length ; i++) {        c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;    }}// 使用向量API的向量计算示例static final VectorSpecies&lt;Float&gt; SPECIES = FloatVector.SPECIES_PREFERRED;void vectorComputation(float[] a, float[] b, float[] c) {    int i = 0;    int upperBound = SPECIES.loopBound(a.length);    for (; i &lt; upperBound; i += SPECIES.length()) {        // FloatVector va, vb, vc;        var va = FloatVector.fromArray(SPECIES, a, i);        var vb = FloatVector.fromArray(SPECIES, b, i);        var vc = va.mul(va).add(vb.mul(vb)).neg();        vc.intoArray(c, i);    }    for (; i &lt; a.length; i++) {        c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;    }}</code></pre><p>向量API在Java中的独特优势在于其高效的并行计算能力、丰富的向量化指令集、跨平台的数据并行算法支持以及对机器学习的特别优化。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java22 新增的特性，完整的特性清单可以从 <a href="https://openjdk.org/projects/jdk/22/" target="_blank" rel="noopener">https://openjdk.org/projects/jdk/22/</a> 查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/By2JoZqAHA6U36PG8qvCcg" target="_blank" rel="noopener">Java17 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/W6Esovb7zzCL_seXgY84jA" target="_blank" rel="noopener">Java18 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/WutbAX_IQNqP4M3rud9f_g" target="_blank" rel="noopener">Java19 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/DvZYrZTtGfdXNsXGzmQN1A" target="_blank" rel="noopener">Java20 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/iiXa9rpJu1Vedpke0XpBzQ" target="_blank" rel="noopener">Java21 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/eHHFaJErH8XH4QSRrfcehQ" target="_blank" rel="noopener">Java22 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/XvB0D2vzhaAvHESupdALag" target="_blank" rel="noopener">Java23 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">Java24 的新特性</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java/java-22-features">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java22 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java22 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。让我们跟随 Java 的脚步，配合示例讲解，看一看每个版本的新特性，本期是 Java22 的新特性。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java22" scheme="https://www.howardliu.cn/tags/Java22/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java21 的新特性</title>
    <link href="https://www.howardliu.cn/java/java-21-features/"/>
    <id>https://www.howardliu.cn/java/java-21-features/</id>
    <published>2024-09-13T00:20:00.000Z</published>
    <updated>2024-12-05T03:07:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>你好，我是看山。</p><a id="more"></a><p><img src="https://static.howardliu.cn/202409122326976.jpg" alt="Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java21 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。让我们跟随 Java 的脚步，配合示例讲解，看一看每个版本的新特性，本期是 Java21 的新特性。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java21 在 2023 年 9 月 19 日发布GA版本，Java21是长期支持版（LTS，Long-Term Support），共十五大特性：</p><ul><li>JEP 430: 字符串模板（String Templates，预览）</li><li>JEP 431: 有序集合（Sequenced Collections）</li><li>JEP 439: 分代ZGC（Generational ZGC）</li><li>JEP 440: Record模式（Record Patterns）</li><li>JEP 441: switch模式匹配（Pattern Matching for switch）</li><li>JEP 442: 外部函数和内存API（Foreign Function &amp; Memory API，FFM API，第三次预览）</li><li>JEP 443: 未命名模式和变量（Unnamed Patterns and Variables，预览）</li><li>JEP 444: 虚拟线程（Virtual Threads）</li><li>JEP 445: 未命名类和示例main方法（Unnamed Classes and Instance Main Methods，预览）</li><li>JEP 446: 作用域值（Scoped Values，预览）</li><li>JEP 448: 向量API（Vector API，第六次孵化）</li><li>JEP 449: 启用Windows32位 x86支持（Deprecate the Windows 32-bit x86 Port for Removal）</li><li>JEP 451: 准备禁止动态加载代理（Prepare to Disallow the Dynamic Loading of Agents）</li><li>JEP 452: 密钥封装机制 API（Key Encapsulation Mechanism API）</li><li>JEP 453: 结构化并发API（Structured Concurrency，预览）</li></ul><p>接下来我们一起看看这些特性。</p><h2 id="JEP-431-有序集合（Sequenced-Collections）"><a href="#JEP-431-有序集合（Sequenced-Collections）" class="headerlink" title="JEP 431: 有序集合（Sequenced Collections）"></a>JEP 431: 有序集合（Sequenced Collections）</h2><p>JEP 431:有序集合是Java21版本中引入的一个新特性，旨在为Java集合框架添加对有序集合的支持。</p><p>有序集合是一种具有定义好的元素访问顺序的集合类型，它允许以一致的方式访问和处理集合中的元素，无论是从第一个元素到最后一个元素，还是从最后一个元素到第一个元素。</p><p>在 Java 中，集合类库非常重要且使用频率非常高，但是缺乏一种能够表示具有定义好的元素访问顺序的集合类型。</p><p>例如，<code>List</code>和<code>Deque</code>都定义了元素的访问顺序，但它们的共同父接口<code>Collection</code>却没有。同样，Set不定义元素的访问顺序，其子类型如<code>HashSet</code>也没有定义，但子类型如<code>SortedSet</code>和<code>LinkedHashSet</code>则有定义。因此，支持访问顺序的功能散布在整个类型层次结构中，使得在API中表达某些有用的概念变得困难。<code>Collection</code>太通用，将此类约束留给文档规范，可能导致难以调试的错误。</p><p>而且，虽然某些集合有顺序操作方法，但是却不尽相同，比如</p><table><thead><tr><th></th><th>First element</th><th>Last element</th></tr></thead><tbody><tr><td>List</td><td>list.get(0)</td><td>list.get(list.size() - 1)</td></tr><tr><td>Deque</td><td>deque.getFirst()</td><td>deque.getLast()</td></tr><tr><td>SortedSet</td><td>sortedSet.first()</td><td>sortedSet.last()</td></tr><tr><td>LinkedHashSet</td><td>linkedHashSet.iterator().next()</td><td>缺失</td></tr></tbody></table><p>于是在Java21提供了有序集合<code>SequencedCollection</code>、<code>SequencedSet</code>、<code>SequencedMap</code>：</p><pre><code class="java">interface SequencedCollection&lt;E&gt; extends Collection&lt;E&gt; {    // new method    SequencedCollection&lt;E&gt; reversed();    // methods promoted from Deque    void addFirst(E);    void addLast(E);    E getFirst();    E getLast();    E removeFirst();    E removeLast();}interface SequencedSet&lt;E&gt; extends Set&lt;E&gt;, SequencedCollection&lt;E&gt; {    SequencedSet&lt;E&gt; reversed();    // covariant override}interface SequencedMap&lt;K,V&gt; extends Map&lt;K,V&gt; {    // new methods    SequencedMap&lt;K,V&gt; reversed();    SequencedSet&lt;K&gt; sequencedKeySet();    SequencedCollection&lt;V&gt; sequencedValues();    SequencedSet&lt;Entry&lt;K,V&gt;&gt; sequencedEntrySet();    V putFirst(K, V);    V putLast(K, V);    // methods promoted from NavigableMap    Entry&lt;K, V&gt; firstEntry();    Entry&lt;K, V&gt; lastEntry();    Entry&lt;K, V&gt; pollFirstEntry();    Entry&lt;K, V&gt; pollLastEntry();}</code></pre><p><code>SequencedCollection</code>的<code>reversed()</code>方法提供了一个原始集合的反向视图。任何对原始集合的修改都会在视图中可见。如果允许，视图中的修改会写回到原始集合。</p><p><img src="https://static.howardliu.cn/SequencedCollectionDiagram20220216.png" alt="JEP 431: 有序集合（Sequenced Collections）"></p><p>我们看一个例子，假设我们有一个LinkedHashSet，现在我们想要获取它的反向视图并以反向顺序遍历它：</p><pre><code class="java">LinkedHashSet&lt;Integer&gt; linkedHashSet = new LinkedHashSet&lt;&gt;(Arrays.asList(3, 2, 1));// 获取反向视图SequencedCollection&lt;Integer&gt; reversed = linkedHashSet.reversed();// 反向遍历System.out.println(&quot;原始数据：&quot; + linkedHashSet);System.out.println(&quot;反转数据：&quot; + reversed);// 运行结果：// 原始数据：[3, 2, 1]// 反转数据：[1, 2, 3]</code></pre><p>这些方法都是便捷方法，内部数据结构没有变化，其实本质也是原来的用法。比如<code>ArrayList</code>中的<code>getFirst</code>和<code>getLast</code>方法：</p><pre><code class="java">/** * {@inheritDoc} * * @throws NoSuchElementException {@inheritDoc} * @since 21 */public E getFirst() {    if (size == 0) {        throw new NoSuchElementException();    } else {        return elementData(0);    }}/** * {@inheritDoc} * * @throws NoSuchElementException {@inheritDoc} * @since 21 */public E getLast() {    int last = size - 1;    if (last &lt; 0) {        throw new NoSuchElementException();    } else {        return elementData(last);    }}</code></pre><h2 id="JEP-439-分代ZGC（Generational-ZGC）"><a href="#JEP-439-分代ZGC（Generational-ZGC）" class="headerlink" title="JEP 439: 分代ZGC（Generational ZGC）"></a>JEP 439: 分代ZGC（Generational ZGC）</h2><p>ZGC从Java11开始预览，Java15提供生产支持，Java16增加并发线程堆栈处理，发展到Java21提供了分代ZGC，具体发展历程可以查看<a href="https://wiki.openjdk.org/display/zgc/Main" target="_blank" rel="noopener">https://wiki.openjdk.org/display/zgc/Main</a>。</p><p>江湖传说，ZGC（Z Garbage Collector）的Z表示最后一个GC，可见其雄心勃勃。而分代ZGC的出现，就是革自己的命。</p><p>与非分代ZGC相比，在不影响吞吐量的的情况下，带来更多的好处：</p><ul><li>更低的分配停顿风险；</li><li>更低的堆内存开销；</li><li>更低的CPU开销。</li></ul><p>分代ZGC的目标是：</p><ul><li>暂停时间不超过1ms（ZGC的目标是10ms）</li><li>支持从几M字节到几T字节的堆大小；</li><li>尽量少的配置。</li></ul><p>在Java21中，分代ZGC的实现细节主要包括以下几个方面：</p><ul><li>分代设计：基于「大部分对象朝生夕死」的分代假说，分代ZGC将内存划分为年轻代和老年代，并为这两种代分别维护不同的垃圾收集策略。这种设计可以更有效地处理不同生命周期的对象，从而提高整体性能。</li><li>彩色指针结构：分代ZGC使用彩色指针结构来优化内存访问。元数据被放在指针的低阶位，而对象地址被放在高阶位。这种结构可以减少加载屏障中的机器指令数量，从而提高性能。</li><li>写屏障技术：分代ZGC引入了写屏障技术，以确保在对象年龄更新时能够正确地通知垃圾收集器。这有助于减少垃圾收集过程中对应用程序的影响。</li><li>内存管理优化：通过分代收集，分代ZGC可以更频繁地对新生代进行垃圾收集，从而减少分配停顿的风险，降低内存开销，并减少垃圾收集的CPU开销。</li></ul><p>我们可以通过命令<code>-XX:+UseZGC -XX:+ZGenerational</code>使用分代ZGC。</p><p>为了平稳的过渡，在Java21中必须增加<code>-XX:+ZGenerational</code>参数，显性的指明使用分代ZGC，在未来，非分代ZGC将被移除，<code>ZGenerational</code>参数也就作废了。</p><p>我们看下<a href="https://kstefanj.github.io/2023/11/07/hazelcast-on-generational-zgc.html" target="_blank" rel="noopener">Hazelcast Jet on Generational ZGC</a>中给出的测评效果：</p><p><img src="https://static.howardliu.cn/p9999-event-latency.png" alt="JEP 439: 分代ZGC（Generational ZGC）"></p><p>从上图可以看到，非分代 ZGC 在低负载下表现非常好，但随着分配压力的增加，延迟也会增加。使用分代 ZGC 后，即使在高负载下，延迟也非常低，而且延迟效果优于G1。</p><h2 id="JEP-440-Record模式（Record-Patterns）"><a href="#JEP-440-Record模式（Record-Patterns）" class="headerlink" title="JEP 440: Record模式（Record Patterns）"></a>JEP 440: Record模式（Record Patterns）</h2><p>Record类型提供不可变对象的简单实现（其实就是Java Bean，但是省略一堆的getter、setter、hashcode、equals、toString等方法），Java16开始一直在演化增强（参见<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a>）。</p><p>Record模式归属于Amber项目的一部分，Amber项目旨在通过小而美的方式，增强Java语言特性。本次的Record模式，主要是使Record类型可以直接在instanceof和switch模式匹配中使用。</p><p>Record模式最初作为预览功能在JEP 405中提出，并在Java19中交付。JEP 432提出了第二次预览，基于持续的经验和反馈进行了进一步的完善。终于在JEP 440正式转正。</p><p>我们一起看个示例，比如有下面几个基础元素：</p><pre><code class="java">// 颜色enum Color { RED, GREEN, BLUE}// 点record Point(int x, int y) {}// 带颜色的点record ColoredPoint(Point p, Color color) {}// 正方形record Square(ColoredPoint upperLeft, ColoredPoint lowerRight) {}</code></pre><p>我们分别通过instanceof模式匹配和switch模式匹配判断输入参数的类型，打印不同的格式：</p><pre><code class="java">private static void instancePatternsAndPrint(Object o) {    if (o instanceof Square(ColoredPoint upperLeft, ColoredPoint lowerRight)) {        System.out.println(&quot;Square类型：&quot; + upperLeft + &quot; &quot; + lowerRight);    } else if (o instanceof ColoredPoint(Point(int x, int y), Color color)) {        System.out.println(&quot;ColoredPoint类型：&quot; + x + &quot; &quot; + y + &quot; &quot; + color);    } else if (o instanceof Point p) {        System.out.println(&quot;Point类型：&quot; + p);    }}private static void switchPatternsAndPrint(Object o) {    switch (o) {        case Square(ColoredPoint upperLeft, ColoredPoint lowerRight) -&gt; {            System.out.println(&quot;Square类型：&quot; + upperLeft + &quot; &quot; + lowerRight);        }        case ColoredPoint(Point(int x, int y), Color color) -&gt; {            System.out.println(&quot;ColoredPoint类型：&quot; + x + &quot; &quot; + y + &quot; &quot; + color);        }        case Point p -&gt; {            System.out.println(&quot;Point类型：&quot; + p);        }        default -&gt; throw new IllegalStateException(&quot;Unexpected value: &quot; + o);    }}</code></pre><p>我们通过main方法执行下：</p><pre><code class="java">public static void main(String[] args) {    var p = new Point(1, 2);    var cp1 = new ColoredPoint(p, Color.RED);    var cp2 = new ColoredPoint(p, Color.GREEN);    var square = new Square(cp1, cp2);    instancePatternsAndPrint(square);    instancePatternsAndPrint(cp1);    instancePatternsAndPrint(p);    switchPatternsAndPrint(square);    switchPatternsAndPrint(cp1);    switchPatternsAndPrint(p);}// 结果是：//// Square类型：ColoredPoint[p=Point[x=1, y=2], color=RED] ColoredPoint[p=Point[x=1, y=2], color=GREEN]// ColoredPoint类型：1 2 RED// Point类型：Point[x=1, y=2]//// Square类型：ColoredPoint[p=Point[x=1, y=2], color=RED] ColoredPoint[p=Point[x=1, y=2], color=GREEN]// ColoredPoint类型：1 2 RED// Point类型：Point[x=1, y=2]</code></pre><h2 id="JEP-441-switch模式匹配（Pattern-Matching-for-switch）"><a href="#JEP-441-switch模式匹配（Pattern-Matching-for-switch）" class="headerlink" title="JEP 441: switch模式匹配（Pattern Matching for switch）"></a>JEP 441: switch模式匹配（Pattern Matching for switch）</h2><p>switch模式经过四次预览，终于转正。</p><p>switch模式匹配是一个非常赞的功能，可以在选择器表达式使用基础判断和任意引用类型，包括instanceof操作符。这意味着可以更灵活地使用对象、数组、列表等复杂数据结构作为switch语句的基础，从而简化代码并提高可读性。</p><p>switch模式匹配允许在switch语句中使用模式来测试表达式，每个模式都有特定的动作，从而可以简洁、安全地表达复杂的数据导向查询。</p><p>通过代码看下switch模式匹配的魅力；</p><pre><code class="java">static String formatValue(Object obj) {    return switch (obj) {        case null -&gt; &quot;null&quot;;        case Integer i -&gt; String.format(&quot;int %d&quot;, i);        case Long l -&gt; String.format(&quot;long %d&quot;, l);        case Double d -&gt; String.format(&quot;double %f&quot;, d);        case String s -&gt; String.format(&quot;String %s&quot;, s);        case Person(String name, String address) -&gt; String.format(&quot;Person %s %s&quot;, name, address);        default -&gt; obj.toString();    };}public record Person(String name, String address) {}public static void main(String[] args) {    System.out.println(formatValue(10));    System.out.println(formatValue(20L));    System.out.println(formatValue(3.14));    System.out.println(formatValue(&quot;Hello&quot;));    System.out.println(formatValue(null));    System.out.println(formatValue(new Person(&quot;Howard&quot;, &quot;Beijing&quot;)));}// 运行结果// int 10// long 20// double 3.140000// String Hello// null// Person Howard Beijing</code></pre><h2 id="JEP-444-虚拟线程（Virtual-Threads）"><a href="#JEP-444-虚拟线程（Virtual-Threads）" class="headerlink" title="JEP 444: 虚拟线程（Virtual Threads）"></a>JEP 444: 虚拟线程（Virtual Threads）</h2><p>虚拟线程是一种轻量级的线程实现，旨在显著降低编写、维护和观察高吞吐量并发应用程序的难度。它们占用的资源少，不需要被池化，可以创建大量虚拟线程，特别适用于IO密集型任务，因为它们可以高效地调度大量虚拟线程来处理并发请求，从而显著提高程序的吞吐量和响应速度。</p><p>虚拟线程有下面几个特点：</p><ol><li>轻量级：虚拟线程是JVM内部实现的轻量级线程，不需要操作系统内核参与，创建和上下文切换的成本远低于传统的操作系统线程（即平台线程），且占用的内存资源较少。</li><li>减少CPU时间消耗：由于虚拟线程不依赖于操作系统平台线程，因此在进行线程切换时耗费的CPU时间会大大减少，从而提高了程序的执行效率。</li><li>简化多线程编程：虚拟线程通过结构化并发API来简化多线程编程，使得开发者可以更容易地编写、维护和观察高吞吐量并发应用程序。</li><li>适用于大量任务场景：虚拟线程非常适合需要创建和销毁大量线程的任务、需要执行大量计算的任务（如数据处理、科学计算等）以及需要实现任务并行执行以提高程序性能的场景。</li><li>提高系统吞吐量：通过对虚拟线程的介绍和与Go协程的对比，可以看出虚拟线程能够大幅提高系统的整体吞吐量。</li></ol><p>不考虑虚拟线程实现原理，对开发者而言，使用体验上与传统线程几乎没有区别。我们一起试用下。</p><pre><code class="java">try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {    IntStream.range(0, 10_000).forEach(i -&gt; {        executor.submit(() -&gt; {            Thread.sleep(Duration.ofSeconds(1));            System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i);            return i;        });    });}Thread.startVirtualThread(() -&gt; {    System.out.println(&quot;Hello from a virtual thread[Thread.startVirtualThread]&quot;);});final ThreadFactory factory = Thread.ofVirtual().factory();factory.newThread(() -&gt; {            System.out.println(&quot;Hello from a virtual thread[ThreadFactory.newThread]&quot;);        })        .start();</code></pre><p>虚拟线程为了降低使用门槛，直接提供了与原生线程类似的方法：</p><ul><li><code>Executors.newVirtualThreadPerTaskExecutor()</code>，可以像普通线程池一样创建虚拟线程。</li><li><code>Thread.startVirtualThread</code>，通过工具方法直接创建并运行虚拟线程。</li><li><code>Thread.ofVirtual().factory().newThread()</code>，另一个工具方法可以创建并运行虚拟线程。<code>Thread</code>还有一个<code>ofPlatform()</code>方法，用来构建普通线程。</li></ul><p>通过本地简单测试（在「公众号：看山的小屋」回复”java”获取源码），1w个模拟线程运行时，性能方面虚拟线程 &gt; 线程池。</p><p>需要注意的是，虚拟线程适用于IO密集场景，而非CPU密集的场景。</p><h2 id="JEP-452-密钥封装机制-API（Key-Encapsulation-Mechanism-API-KEM-API）"><a href="#JEP-452-密钥封装机制-API（Key-Encapsulation-Mechanism-API-KEM-API）" class="headerlink" title="JEP 452: 密钥封装机制 API（Key Encapsulation Mechanism API, KEM API）"></a>JEP 452: 密钥封装机制 API（Key Encapsulation Mechanism API, KEM API）</h2><p>KEM是一种现代加密技术，它通过使用非对称或公钥密码学来保护对称密钥。与传统的加密方法不同，KEM使用公钥的属性来派生一个相关的对称密钥，这个过程不需要填充，因此可以更容易地证明其安全性。</p><p>KEM的工作流程</p><ol><li>密钥对生成函数：返回包含公钥和私钥的一对密钥。</li><li>密钥封装函数：由发送方调用，接受接收方的公钥和加密选项；返回一个秘密密钥K和一个密钥封装消息（在ISO 18033-2中称为ciphertext）。发送方将密钥封装消息发送给接收方。</li><li>密钥解封函数：由接收方调用，接受接收方的私钥和收到的密钥封装消息；返回秘密密钥K。</li></ol><p>据说这种算法是可以解决量子计算威胁，若有有安全需求，可以深入研究下。</p><h2 id="预览功能"><a href="#预览功能" class="headerlink" title="预览功能"></a>预览功能</h2><h3 id="JEP-430-字符串模板（String-Templates，预览）"><a href="#JEP-430-字符串模板（String-Templates，预览）" class="headerlink" title="JEP 430: 字符串模板（String Templates，预览）"></a>JEP 430: 字符串模板（String Templates，预览）</h3><p>字符串模板是一个值得期待的功能，Java21中提供了预览版。</p><p>字符串模板通过将文本和嵌入式表达式结合在一起，使得Java程序能够以一种更加直观和安全的方式构建字符串。与传统的字符串拼接（使用+操作符）、<code>StringBuilder</code>或<code>String.format</code> 等方法相比，字符串模板提供了一种更加清晰和安全的字符串构建方式。特别是当字符串需要从用户提供的值构建并传递给其他系统时（例如，构建数据库查询），使用字符串模板可以有效地验证和转换模板及其嵌入表达式的值，从而提高Java程序的安全性。</p><p>让我们通过代码看一下这个特性的魅力：</p><pre><code class="java">public static void main(String[] args) {    // 拼装变量    String name = &quot;看山&quot;;    String info = STR. &quot;My name is \{ name }&quot; ;    assert info.equals(&quot;My name is 看山&quot;);    // 拼装变量    String firstName = &quot;Howard&quot;;    String lastName = &quot;Liu&quot;;    String fullName = STR. &quot;\{ firstName } \{ lastName }&quot; ;    assert fullName.equals(&quot;Howard Liu&quot;);    String sortName = STR. &quot;\{ lastName }, \{ firstName }&quot; ;    assert sortName.equals(&quot;Liu, Howard&quot;);    // 模板中调用方法    String s2 = STR. &quot;You have a \{ getOfferType() } waiting for you!&quot; ;    assert s2.equals(&quot;You have a gift waiting for you!&quot;);    Request req = new Request(&quot;2017-07-19&quot;, &quot;09:15&quot;, &quot;https://www.howardliu.cn&quot;);    // 模板中引用对象属性    String s3 = STR. &quot;Access at \{ req.date } \{ req.time } from \{ req.address }&quot; ;    assert s3.equals(&quot;Access at 2017-07-19 09:15 from https://www.howardliu.cn&quot;);    LocalTime now = LocalTime.now();    String markTime = DateTimeFormatter            .ofPattern(&quot;HH:mm:ss&quot;)            .format(now);    // 模板中调用方法    String time = STR. &quot;The time is \{            // The java.time.format package is very useful            DateTimeFormatter                    .ofPattern(&quot;HH:mm:ss&quot;)                    .format(now)            } right now&quot; ;    assert time.equals(&quot;The time is &quot; + markTime + &quot; right now&quot;);    // 模板嵌套模板    String[] fruit = {&quot;apples&quot;, &quot;oranges&quot;, &quot;peaches&quot;};    String s4 = STR. &quot;\{ fruit[0] }, \{            STR. &quot;\{ fruit[1] }, \{ fruit[2] }&quot;            }&quot; ;    assert s4.equals(&quot;apples, oranges, peaches&quot;);    // 模板与文本块结合    String title = &quot;My Web Page&quot;;    String text = &quot;Hello, world&quot;;    String html = STR. &quot;&quot;&quot;    &lt;html&gt;      &lt;head&gt;        &lt;title&gt;\{ title }&lt;/title&gt;      &lt;/head&gt;      &lt;body&gt;        &lt;p&gt;\{ text }&lt;/p&gt;      &lt;/body&gt;    &lt;/html&gt;    &quot;&quot;&quot; ;    assert html.equals(&quot;&quot;&quot;            &lt;html&gt;              &lt;head&gt;                &lt;title&gt;My Web Page&lt;/title&gt;              &lt;/head&gt;              &lt;body&gt;                &lt;p&gt;Hello, world&lt;/p&gt;              &lt;/body&gt;            &lt;/html&gt;            &quot;&quot;&quot;);    // 带格式化的字符串模板    record Rectangle(String name, double width, double height) {        double area() {            return width * height;        }    }    Rectangle[] zone = new Rectangle[] {            new Rectangle(&quot;Alfa&quot;, 17.8, 31.4),            new Rectangle(&quot;Bravo&quot;, 9.6, 12.4),            new Rectangle(&quot;Charlie&quot;, 7.1, 11.23),    };    String table = FMT. &quot;&quot;&quot;        Description     Width    Height     Area        %-12s\{ zone[0].name }  %7.2f\{ zone[0].width }  %7.2f\{ zone[0].height }     %7.2f\{ zone[0].area() }        %-12s\{ zone[1].name }  %7.2f\{ zone[1].width }  %7.2f\{ zone[1].height }     %7.2f\{ zone[1].area() }        %-12s\{ zone[2].name }  %7.2f\{ zone[2].width }  %7.2f\{ zone[2].height }     %7.2f\{ zone[2].area() }        \{ &quot; &quot;.repeat(28) } Total %7.2f\{ zone[0].area() + zone[1].area() + zone[2].area() }        &quot;&quot;&quot;;    assert table.equals(&quot;&quot;&quot;            Description     Width    Height     Area            Alfa            17.80    31.40      558.92            Bravo            9.60    12.40      119.04            Charlie          7.10    11.23       79.73                                         Total  757.69            &quot;&quot;&quot;);}public static String getOfferType() {    return &quot;gift&quot;;}record Request(String date, String time, String address) {}</code></pre><p>这个功能当前是第一次预览，在Java22第二次预览，Java23的8.12版本中还没有展示字符串模板的第三次预览（JEP 465: String Templates），还不能确定什么时候可以正式用上。</p><h3 id="JEP-442-外部函数和内存API（Foreign-Function-amp-Memory-API，FFM-API，第三次预览）"><a href="#JEP-442-外部函数和内存API（Foreign-Function-amp-Memory-API，FFM-API，第三次预览）" class="headerlink" title="JEP 442: 外部函数和内存API（Foreign Function &amp; Memory API，FFM API，第三次预览）"></a>JEP 442: 外部函数和内存API（Foreign Function &amp; Memory API，FFM API，第三次预览）</h3><p>FFM API经历过多次的预览及改进，从JEP 412（第一轮孵化）开始，逐步发展到JEP 442（第三次预览）。相较于前两次的改进主要体现在以下几个方面：</p><ol><li>管理本地内存段的生命周期：在JEP 442中，通过新的Arena API集中管理本地内存段的生命周期，这使得内存管理更加高效和安全。</li><li>增强布局路径：引入了一个新的元素来解引用地址布局，这使得内存布局更加灵活和强大。</li><li>优化短暂使用期函数调用：提供了一个链接器选项，优化了对短暂使用期函数（例如clock_gettime）的调用，这些函数不会调用到Java代码。</li><li>本地链接器实现：引入了一个基于libffi的本地链接器实现，以便于移植。</li><li>移除VaList：在JEP 442中移除了VaList，这是对API的一次简化。</li></ol><p>我们看下官方示例：</p><pre><code class="java">// 1. 在C库路径上查找名为radixsort的外部函数Linker linker = Linker.nativeLinker();SymbolLookup stdlib = linker.defaultLookup();final MemorySegment memorySegment = stdlib.find(&quot;radixsort&quot;).orElseThrow();FunctionDescriptor descriptor = FunctionDescriptor.ofVoid(        ValueLayout.ADDRESS,        ValueLayout.JAVA_INT,        ValueLayout.ADDRESS);MethodHandle radixsort = linker.downcallHandle(memorySegment, descriptor);// 下面的代码将使用这个外部函数对字符串进行排序// 2. 分配栈上内存来存储四个字符串String[] javaStrings = {&quot;mouse&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;car&quot;};// 3. 使用try-with-resources来管理离堆内存的生命周期try (Arena offHeap = Arena.ofConfined()) {    // 4. 分配一段离堆内存来存储四个指针    MemorySegment pointers = offHeap.allocateArray(ValueLayout.ADDRESS, javaStrings.length);    // 5. 将字符串从栈上内存复制到离堆内存    for (int i = 0; i &lt; javaStrings.length; i++) {        MemorySegment cString = offHeap.allocateUtf8String(javaStrings[i]);        pointers.setAtIndex(ValueLayout.ADDRESS, i, cString);    }    // 6. 通过调用外部函数对离堆数据进行排序    radixsort.invoke(pointers, javaStrings.length, MemorySegment.NULL, &#39;\0&#39;);    // 7. 将排序后的字符串从离堆内存复制回栈上内存    for (int i = 0; i &lt; javaStrings.length; i++) {        MemorySegment cString = pointers.getAtIndex(ValueLayout.ADDRESS, i);        javaStrings[i] = cString.getUtf8String(0);    }} // 8. 所有离堆内存在此处被释放// 验证排序结果assert Arrays.equals(javaStrings, new String[] {&quot;car&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;mouse&quot;});  // true</code></pre><p>我们都知道，JNI也是可以调用外部代码的，那FFM API相较于JNI的优势在于：</p><ol><li>更安全的内存访问：FFM API 提供了一种更安全和受控的方式来与本地代码交互，避免了JNI中常见的内存泄漏和数据损坏问题。</li><li>直接访问本地内存：FFM API 允许Java程序直接访问本地内存（即Java堆外的内存），这使得数据处理更加高效和灵活。</li><li>跨语言函数调用：FFM API 支持调用Java程序的外部函数，以与外部代码和数据一起操作，而无需依赖JNI的复杂机制。</li><li>更高效的集成：FFM API 使得Java与C、C++等语言编写的库集成更加方便和高效，特别是在数据处理和机器学习等领域。</li><li>减少代码复杂性：FFM API 提供了一种更简洁的API，减少了JNI中复杂的代码编写和维护工作。</li><li>更广泛的适用性：FFM API 不仅适用于简单的函数调用，还可以处理复杂的内存管理任务，如堆外内存的管理。</li><li>提高性能：FFM API 通过高效地调用外部函数和安全地访问外部内存，提高了程序的运行效率。</li></ol><p>这个功能将在下一个版本 Java22 正式发布。</p><h3 id="JEP-443-未命名模式和变量（Unnamed-Patterns-and-Variables，预览）"><a href="#JEP-443-未命名模式和变量（Unnamed-Patterns-and-Variables，预览）" class="headerlink" title="JEP 443: 未命名模式和变量（Unnamed Patterns and Variables，预览）"></a>JEP 443: 未命名模式和变量（Unnamed Patterns and Variables，预览）</h3><p>该特性使用下划线字符 <code>_</code> 来表示未命名的模式和变量，从而简化代码并提高代码可读性和可维护性。</p><p>比如：</p><pre><code class="java">public static void main(String[] args) {    var _ = new Point(1, 2);}record Point(int x, int y) {}</code></pre><p>这个可以用在任何定义变量的地方，比如：</p><ul><li><code>... instanceof Point(_, int y)</code></li><li><code>r instanceof Point _</code></li><li><code>switch …… case Box(_)</code></li><li><code>for (Order _ : orders)</code></li><li><code>for (int i = 0, _ = sideEffect(); i &lt; 10; i++)</code></li><li><code>try { ... } catch (Exception _) { ... } catch (Throwable _) { ... }</code></li></ul><p>只要是这个不准备用，可以一律使用<code>_</code>代替。</p><h3 id="JEP-445-未命名类和示例main方法（Unnamed-Classes-and-Instance-Main-Methods，预览）"><a href="#JEP-445-未命名类和示例main方法（Unnamed-Classes-and-Instance-Main-Methods，预览）" class="headerlink" title="JEP 445: 未命名类和示例main方法（Unnamed Classes and Instance Main Methods，预览）"></a>JEP 445: 未命名类和示例main方法（Unnamed Classes and Instance Main Methods，预览）</h3><p>无论学习哪门语言，第一课一定是打印<code>Hello, World!</code>，Java中的写法是：</p><pre><code class="java">public class HelloWorld {    public static void main(String[] args) {        System.out.println (&quot;Hello, World!&quot;);    }}</code></pre><p>如果是第一次接触，一定会有很多疑问，<code>public</code>干啥的，<code>main</code>方法的约定参数<code>args</code>是什么鬼？然后老师就说，这就是模板，照着抄就行，不这样写不运行。</p><p>JEP 445特性后，可以简化为：</p><pre><code class="java">class HelloWorld {    void main() {        System.out.println (&quot;Hello, World!&quot;);    }}</code></pre><p>我们还可以这样写：</p><pre><code class="java">String greeting() { return &quot;Hello, World!&quot;; }void main() {    System.out.println(greeting());}</code></pre><p>虽然看起来没啥用，但是在JShell中使用，就比较友好了。</p><h3 id="JEP-446-作用域值（Scoped-Values，预览）"><a href="#JEP-446-作用域值（Scoped-Values，预览）" class="headerlink" title="JEP 446: 作用域值（Scoped Values，预览）"></a>JEP 446: 作用域值（Scoped Values，预览）</h3><p>作用域值（Scoped Values）在Java20孵化，在Java21预览，旨在提供一种安全且高效的方法来共享数据，无需使用方法参数。这一特性允许在不使用方法参数的情况下，将数据安全地共享给方法，优先于线程局部变量，特别是在使用大量虚拟线程时。</p><p>在多线程环境中，作用域值可以在线程内和线程间共享不可变数据，例如从父线程向子线程传递数据，从而解决了在多线程应用中传递数据的问题。此外，作用域值提高了数据的安全性、不变性和封装性，并且在多线程环境中使用事务、安全主体和其他形式的共享上下文的应用程序中表现尤为突出。</p><p>作用域值的主要特点：</p><ul><li>不可变性：作用域值是不可变的，这意味着一旦设置，其值就不能更改。这种不可变性减少了并发编程中意外副作用的风险。</li><li>作用域生命周期：作用域值的生命周期仅限于 run 方法定义的作用域。一旦执行离开该作用域，作用域值将不再可访问。</li><li>继承性：子线程会自动继承父线程的作用域值，从而允许在线程边界间无缝共享数据。</li></ul><p>在这个功能之前，在多线程间传递数据，我们有两种选择：</p><ol><li>方法参数：显示参数传递；缺点是新增参数时修改联动修改一系列方法，如果是框架或SDK层面的，无法做到向下兼容。</li><li><code>ThreadLocal</code>：在<code>ThreadLocal</code>保存当前线程变量。</li></ol><p>使用过<code>ThreadLocal</code>的都清楚，<code>ThreadLocal</code>会有三大问题。</p><ol><li>无约束的可变性：每个线程局部变量都是可变的。任何可以调用线程局部变量的<code>get</code>方法的代码都可以随时调用该变量的<code>set</code>方法。即使线程局部变量中的对象是不可变的，每个字段都被声明为final，情况仍然如此。<code>ThreadLocal</code> API允许这样做，以便支持一个完全通用的通信模型，在该模型中，数据可以在方法之间以任何方向流动。这可能会导致数据流混乱，导致程序难以分辨哪个方法更新共享状态以及以何种顺序进行。</li><li>无界生存期：一旦通过<code>set</code>方法设置了一个线程局部变量的副本，该值就会在该线程的生存期内保留，或者直到该线程中的代码调用<code>remove</code>方法。我们有时候会忘记调用<code>remove</code>，如果使用线程池，在一个任务中设置的线程局部变量的值如果不清除，可能会意外泄漏到无关的任务中，导致危险的安全漏洞（比如人员SSO）。对于依赖于线程局部变量的无约束可变性的程序来说，可能没有明确的点可以保证线程调用<code>remove</code>是安全的，可能会导致内存泄漏，因为每个线程的数据在退出之前都不会被垃圾回收。</li><li>昂贵的继承：当使用大量线程时，线程局部变量的开销可能会更糟糕，因为父线程的线程局部变量可以被子线程继承。（事实上，线程局部变量并不是某个特定线程的本地变量。）当开发人员选择创建一个继承了线程局部变量的子线程时，该子线程必须为之前在父线程中写入的每个线程局部变量分配存储空间。这可能会显著增加内存占用。子线程不能共享父线程使用的存储，因为ThreadLocal API要求更改线程的线程局部变量副本在其他线程中不可见。这也会有另一个隐藏的问题，子线程没有办法向父线程<code>set</code>数据。</li></ol><p>作用域值可以有效解决上面提到的问题，而且写起来更加优雅。</p><p>我们一起看下作用域值的使用：</p><pre><code class="java">// 声明一个作用域值用于存储用户名public final static ScopedValue&lt;String&gt; USERNAME = ScopedValue.newInstance();private static final Runnable printUsername = () -&gt;        System.out.println(Thread.currentThread().threadId() + &quot; 用户名是 &quot; + USERNAME.get());public static void main(String[] args) throws Exception {    // 将用户名 &quot;Bob&quot; 绑定到作用域并执行 Runnable    ScopedValue.where(USERNAME, &quot;Bob&quot;).run(() -&gt; {        printUsername.run();        new Thread(printUsername).start();    });    // 将用户名 &quot;Chris&quot; 绑定到另一个作用域并执行 Runnable    ScopedValue.where(USERNAME, &quot;Chris&quot;).run(() -&gt; {        printUsername.run();        new Thread(() -&gt; {            new Thread(printUsername).start();            printUsername.run();        }).start();    });    // 检查在任何作用域外 USERNAME 是否被绑定    System.out.println(&quot;用户名是否被绑定: &quot; + USERNAME.isBound());}</code></pre><p>写起来干净利索，而且功能更强。</p><h3 id="JEP-453-结构化并发API（Structured-Concurrency，预览）"><a href="#JEP-453-结构化并发API（Structured-Concurrency，预览）" class="headerlink" title="JEP 453: 结构化并发API（Structured Concurrency，预览）"></a>JEP 453: 结构化并发API（Structured Concurrency，预览）</h3><p>JEP 453: 结构化并发API（Structured Concurrency API）旨在简化多线程编程，通过引入一个API来处理在不同线程中运行的多个任务作为一个单一工作单元，从而简化错误处理和取消操作，提高可靠性，并增强可观测性。本次发布是第一次预览。</p><p>结构化并发API提供了明确的语法结构来定义子任务的生命周期，并启用一个运行时表示线程间的层次结构。这有助于实现错误传播和取消以及并发程序的有意义观察。</p><p>Java使用异常处理机制来管理运行时错误和其他异常。当异常在代码中产生时，如何被传递和处理的过程称为异常传播。</p><p>在结构化并发环境中，异常可以通过显式地从当前环境中抛出并传播到更大的环境中去处理。</p><p>在Java并发编程中，非受检异常的处理是程序健壮性的重要组成部分。特别是对于非受检异常的处理，这关系到程序在遇到错误时是否能够优雅地继续运行或者至少提供有意义的反馈。</p><pre><code class="java">try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {    var task1 = scope.fork(() -&gt; {        Thread.sleep(1000);        return &quot;Result from task 1&quot;;    });    var task2 = scope.fork(() -&gt; {        Thread.sleep(2000);        return &quot;Result from task 2&quot;;    });    scope.join();    scope.throwIfFailed(RuntimeException::new);    System.out.println(task1.get());    System.out.println(task2.get());} catch (Exception e) {    e.printStackTrace();}</code></pre><p>在这个例子中，handle()方法使用StructuredTaskScope来并行执行两个子任务：task1和task2。通过使用try-with-resources语句自动管理资源，并确保所有子任务都在try块结束时正确完成或被取消。这种方式使得线程的生命周期和任务的逻辑结构紧密相关，提高了代码的清晰度和错误处理的效率。使用 StructuredTaskScope 可以确保一些有价值的属性：</p><ul><li>错误处理与短路：如果task1或task2子任务中的任何一个失败，另一个如果尚未完成则会被取消。（这由 ShutdownOnFailure 实现的关闭策略来管理；还有其他策略可能）。</li><li>取消传播：如果在运行上面方法的线程在调用 join() 之前或之中被中断，则线程在退出作用域时会自动取消两个子任务。</li><li>清晰性：设置子任务，等待它们完成或被取消，然后决定是成功（并处理已经完成的子任务的结果）还是失败（子任务已经完成，因此没有更多需要清理的）。</li><li>可观察性：线程转储清楚地显示了任务层次结构，其中运行task1或task2的线程被显示为作用域的子任务。</li></ul><p>上面的示例能够很好的解决我们的一个痛点，有两个可并行的任务A和B，A+B才是完整结果，任何一个失败，另外一个也不需要成功，结构化并发API就可以很容易的实现这个逻辑。</p><h2 id="孵化功能"><a href="#孵化功能" class="headerlink" title="孵化功能"></a>孵化功能</h2><h3 id="JEP-448-向量API（Vector-API，第六次孵化）"><a href="#JEP-448-向量API（Vector-API，第六次孵化）" class="headerlink" title="JEP 448: 向量API（Vector API，第六次孵化）"></a>JEP 448: 向量API（Vector API，第六次孵化）</h3><p>向量API的功能是提供一个表达向量计算的API，旨在通过引入向量计算API来提高Java应用程序的性能。这一API允许开发者在支持的CPU架构上可靠地编译为最佳向量指令，从而实现比等效的标量计算更高的性能。这些计算在运行时可靠地编译成支持的CPU架构上的最优向量指令，从而实现比等效标量计算更优的性能。</p><p>下面这个是官方给的示例：</p><pre><code class="java">// 标量计算示例void scalarComputation(float[] a, float[] b, float[] c) {    for (int i = 0; i &lt; a.length ; i++) {        c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;    }}// 使用向量API的向量计算示例static final VectorSpecies&lt;Float&gt; SPECIES = FloatVector.SPECIES_PREFERRED;void vectorComputation(float[] a, float[] b, float[] c) {    int i = 0;    int upperBound = SPECIES.loopBound(a.length);    for (; i &lt; upperBound; i += SPECIES.length()) {        // FloatVector va, vb, vc;        var va = FloatVector.fromArray(SPECIES, a, i);        var vb = FloatVector.fromArray(SPECIES, b, i);        var vc = va.mul(va).add(vb.mul(vb)).neg();        vc.intoArray(c, i);    }    for (; i &lt; a.length; i++) {        c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;    }}</code></pre><p>向量API在Java中的独特优势在于其高效的并行计算能力、丰富的向量化指令集、跨平台的数据并行算法支持以及对机器学习的特别优化。</p><h2 id="弃用"><a href="#弃用" class="headerlink" title="弃用"></a>弃用</h2><h3 id="JEP-449-启用Windows32位-x86支持（Deprecate-the-Windows-32-bit-x86-Port-for-Removal）"><a href="#JEP-449-启用Windows32位-x86支持（Deprecate-the-Windows-32-bit-x86-Port-for-Removal）" class="headerlink" title="JEP 449: 启用Windows32位 x86支持（Deprecate the Windows 32-bit x86 Port for Removal）"></a>JEP 449: 启用Windows32位 x86支持（Deprecate the Windows 32-bit x86 Port for Removal）</h3><p>旨在弃用并最终移除Windows 32位x86平台上的Java支持，原因是该平台已经逐渐被淘汰、性能限制和安全问题等。主要影响对象是OpenJDK的开发者和Windows 32位x86平台上的Java用户。</p><h3 id="JEP-451-准备禁止动态加载代理（Prepare-to-Disallow-the-Dynamic-Loading-of-Agents）"><a href="#JEP-451-准备禁止动态加载代理（Prepare-to-Disallow-the-Dynamic-Loading-of-Agents）" class="headerlink" title="JEP 451: 准备禁止动态加载代理（Prepare to Disallow the Dynamic Loading of Agents）"></a>JEP 451: 准备禁止动态加载代理（Prepare to Disallow the Dynamic Loading of Agents）</h3><p>该特性主要目的是通过在运行中的JVM中动态加载代理时发出警告，来帮助用户为将来的版本做好准备。这些警告旨在提高JVM的默认完整性，因为未来的版本将默认禁止动态加载代理。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java21 新增的特性，完整的特性清单可以从 <a href="https://openjdk.org/projects/jdk/21/" target="_blank" rel="noopener">https://openjdk.org/projects/jdk/21/</a> 查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/By2JoZqAHA6U36PG8qvCcg" target="_blank" rel="noopener">Java17 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/W6Esovb7zzCL_seXgY84jA" target="_blank" rel="noopener">Java18 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/WutbAX_IQNqP4M3rud9f_g" target="_blank" rel="noopener">Java19 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/DvZYrZTtGfdXNsXGzmQN1A" target="_blank" rel="noopener">Java20 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/iiXa9rpJu1Vedpke0XpBzQ" target="_blank" rel="noopener">Java21 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/eHHFaJErH8XH4QSRrfcehQ" target="_blank" rel="noopener">Java22 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/XvB0D2vzhaAvHESupdALag" target="_blank" rel="noopener">Java23 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">Java24 的新特性</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java/java-21-features">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java21 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java21 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Java21 在 2023 年 9 月 19 日发布GA版本，Java21是长期支持版（LTS，Long-Term Support），共十五大特性。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java21" scheme="https://www.howardliu.cn/tags/Java21/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java20 的新特性</title>
    <link href="https://www.howardliu.cn/java/java-20-features/"/>
    <id>https://www.howardliu.cn/java/java-20-features/</id>
    <published>2024-09-12T01:00:00.000Z</published>
    <updated>2024-12-05T03:07:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/woman-8388428_1920.jpg" alt="Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java20 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。让我们跟随 Java 的脚步，配合示例讲解，看一看每个版本的新特性，本期是 Java20 的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java20 在 2023 年 3 月 21 日发布GA版本，共七大特性，这些新特性处于预览或孵化阶段，旨在简化并发编程、提高性能和增强语言表达能力。这七大特性分别是：</p><ul><li>JEP 429: 作用域值（Scoped Values，孵化），来自Amber项目，允许在线程内和线程间共享不可变数据，优于传统的线程局部变量。它主要用于在多线程应用中安全地传递和访问数据，例如从父线程向子线程传递数据。</li><li>JEP 432: Record模式（Record Patterns，第二次预览），来自Amber项目，用于简化数据结构的模式匹配。</li><li>JEP 433: Switch模式匹配（Pattern Matching for switch，第四次预览），来自Amber项目，用于改进switch语句中的模式匹配。</li><li>JEP 434: 外部函数和内存API（Foreign Function &amp; Memory API，FFM API，第二次预览），来自Loom项目，旨在提供更高效的内存管理和外部函数调用能力。</li><li>JEP 436: 虚拟线程（Virtual Threads，第二次预览），来自Loom项目，通过引入轻量级虚拟线程来简化高吞吐量并发应用程序的开发和维护。</li><li>JEP 437: 结构化并发API (Structured Concurrency，第二次孵化)，来自Loom项目，旨在简化多线程编程，提高应用程序的可靠性和可观察性。</li><li>JEP 438: 向量API（Vector API，第五次孵化），用于表达向量计算，提高了性能和代码可读性。</li></ul><p>接下来我们一起看看这些特性。</p><h2 id="预览功能"><a href="#预览功能" class="headerlink" title="预览功能"></a>预览功能</h2><h3 id="JEP-432-Record模式（第二次预览）"><a href="#JEP-432-Record模式（第二次预览）" class="headerlink" title="JEP 432: Record模式（第二次预览）"></a>JEP 432: Record模式（第二次预览）</h3><p>Record类型提供不可变对象的简单实现（其实就是Java Bean，但是省略一堆的getter、setter、hashcode、equals、toString等方法），Java16开始一直在演化增强（参见<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a>）。</p><p>Record模式归属于Amber项目的一部分，Amber项目旨在通过小而美的方式，增强Java语言特性。本次的Record模式，主要是使Record类型可以直接在instanceof和switch模式匹配中使用。</p><p>Record模式最初作为预览功能在JEP 405中提出，并在Java19中交付。JEP 432提出了第二次预览，基于持续的经验和反馈进行了进一步的完善。主要变化包括：</p><ul><li>支持推断泛型记录模式的类型参数，</li><li>允许记录模式出现在增强for循环的头部，</li><li>移除了对命名记录模式的支持。</li></ul><p>我们一起看个示例，比如有下面几个基础元素：</p><pre><code class="java">// 颜色enum Color { RED, GREEN, BLUE}// 点record Point(int x, int y) {}// 带颜色的点record ColoredPoint(Point p, Color color) {}// 正方形record Square(ColoredPoint upperLeft, ColoredPoint lowerRight) {}</code></pre><p>我们分别通过instanceof模式匹配和switch模式匹配判断输入参数的类型，打印不同的格式：</p><pre><code class="java">private static void instancePatternsAndPrint(Object o) {    if (o instanceof Square(ColoredPoint upperLeft, ColoredPoint lowerRight)) {        System.out.println(&quot;Square类型：&quot; + upperLeft + &quot; &quot; + lowerRight);    } else if (o instanceof ColoredPoint(Point(int x, int y), Color color)) {        System.out.println(&quot;ColoredPoint类型：&quot; + x + &quot; &quot; + y + &quot; &quot; + color);    } else if (o instanceof Point p) {        System.out.println(&quot;Point类型：&quot; + p);    }}private static void switchPatternsAndPrint(Object o) {    switch (o) {        case Square(ColoredPoint upperLeft, ColoredPoint lowerRight) -&gt; {            System.out.println(&quot;Square类型：&quot; + upperLeft + &quot; &quot; + lowerRight);        }        case ColoredPoint(Point(int x, int y), Color color) -&gt; {            System.out.println(&quot;ColoredPoint类型：&quot; + x + &quot; &quot; + y + &quot; &quot; + color);        }        case Point p -&gt; {            System.out.println(&quot;Point类型：&quot; + p);        }        default -&gt; throw new IllegalStateException(&quot;Unexpected value: &quot; + o);    }}</code></pre><p>我们通过main方法执行下：</p><pre><code class="java">public static void main(String[] args) {    var p = new Point(1, 2);    var cp1 = new ColoredPoint(p, Color.RED);    var cp2 = new ColoredPoint(p, Color.GREEN);    var square = new Square(cp1, cp2);    instancePatternsAndPrint(square);    instancePatternsAndPrint(cp1);    instancePatternsAndPrint(p);    switchPatternsAndPrint(square);    switchPatternsAndPrint(cp1);    switchPatternsAndPrint(p);}// 结果是：//// Square类型：ColoredPoint[p=Point[x=1, y=2], color=RED] ColoredPoint[p=Point[x=1, y=2], color=GREEN]// ColoredPoint类型：1 2 RED// Point类型：Point[x=1, y=2]//// Square类型：ColoredPoint[p=Point[x=1, y=2], color=RED] ColoredPoint[p=Point[x=1, y=2], color=GREEN]// ColoredPoint类型：1 2 RED// Point类型：Point[x=1, y=2]</code></pre><h3 id="JEP-433-switch模式匹配（第四次预览）"><a href="#JEP-433-switch模式匹配（第四次预览）" class="headerlink" title="JEP 433: switch模式匹配（第四次预览）"></a>JEP 433: switch模式匹配（第四次预览）</h3><p>在Java20之前，switch模式匹配的选择器表达式只能是基本数据类型或字符串。在Java20中，这一限制被取消，允许选择器表达式为任何引用类型，包括instanceof操作符。这意味着可以更灵活地使用对象、数组、列表等复杂数据结构作为switch语句的基础，从而简化代码并提高可读性。</p><p>switch模式匹配允许在switch语句中使用模式来测试表达式，每个模式都有特定的动作，从而可以简洁、安全地表达复杂的数据导向查询。</p><p>主要功能包括：</p><ul><li>增强表达性和适用性：允许在case标签中出现模式，扩展了switch表达式和语句的表达能力和适用范围。</li><li>放宽对null的敌意：当需要时，可以放宽switch对null的敌意。</li><li>提高安全性：要求模式switch语句覆盖所有可能的输入值，增加了switch语句的安全性。</li><li>保持兼容性：确保所有现有的switch表达式和语句继续无变化地编译并以相同的语义执行。</li></ul><p>通过代码看下switch模式匹配的魅力；</p><pre><code class="java">static String formatValue(Object obj) {    return switch (obj) {        case null -&gt; &quot;null&quot;;        case Integer i -&gt; String.format(&quot;int %d&quot;, i);        case Long l -&gt; String.format(&quot;long %d&quot;, l);        case Double d -&gt; String.format(&quot;double %f&quot;, d);        case String s -&gt; String.format(&quot;String %s&quot;, s);        case Person(String name, String address) -&gt; String.format(&quot;Person %s %s&quot;, name, address);        default -&gt; obj.toString();    };}public record Person(String name, String address) {}public static void main(String[] args) {    System.out.println(formatValue(10));    System.out.println(formatValue(20L));    System.out.println(formatValue(3.14));    System.out.println(formatValue(&quot;Hello&quot;));    System.out.println(formatValue(null));    System.out.println(formatValue(new Person(&quot;Howard&quot;, &quot;Beijing&quot;)));}// 运行结果// int 10// long 20// double 3.140000// String Hello// null// Person Howard Beijing</code></pre><h3 id="JEP-434-外部函数和内存API（第二次预览）"><a href="#JEP-434-外部函数和内存API（第二次预览）" class="headerlink" title="JEP 434: 外部函数和内存API（第二次预览）"></a>JEP 434: 外部函数和内存API（第二次预览）</h3><p>外部函数和内存API（Foreign Function &amp; Memory API，简称FFM API）旨在提供一种机制，使Java程序能够与Java运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即JVM之外的代码）以及安全地访问外部内存（即非JVM管理的内存），该API使得Java程序能够调用本地库并处理本地数据，而无需使用JNI带来的脆弱性和危险。</p><p>简单说，FFM API是为了替换JNI的函数，在Java20中是第二次预览版，最终会在Java22中转正。</p><p>FFM API的主要功能包括：</p><ul><li>易用性：用一个更优越、完全Java开发模型替代了Java原生接口（JNI）。</li><li>性能：提供与现有API（如JNI和sun.misc.Unsafe ）相当甚至更好的性能。</li><li>通用性：支持操作不同类型的外部内存（例如，本地内存、持久内存和托管堆内存），并计划随着时间的推移适应其他平台（例如，32位x86）和用C语言之外的语言（例如C++、Fortran）编写的外部函数。</li><li>安全性：允许程序在默认情况下对外部内存执行不安全的操作，但会向用户发出警告。</li></ul><p>我们来看一个官方给的示例：如何获取C库函数<code>radixsort</code>的方法句柄，并使用它来对四个字符串进行排序。</p><pre><code class="java">// 1. 找到C库路径上的外部函数Linker linker = Linker.nativeLinker();SymbolLookup stdlib = linker.defaultLookup();MethodHandle radixSort = linker.downcallHandle(stdlib.lookup (&quot;radixsort&quot;), ...);// 2. 在堆上分配内存存储四个字符串String[] javaStrings = { &quot;mouse&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;car&quot; };// 3. 在非堆上分配内存存储四个指针SegmentAllocator allocator = SegmentAllocator.implicitAllocator();MemorySegment offHeap = allocator.allocateArray(ValueLayout.ADDRESS, javaStrings.length );// 4. 将字符串从堆上复制到非堆上for (int i = 0; i &lt; javaStrings.length ; i++) {    // 分配一个字符串到非堆上，然后存储其指针    MemorySegment cString = allocator.allocateUtf8String(javaStrings[i]);    offHeap.setAtIndex(ValueLayout.ADDRESS, i, cString);}// 5. 调用外部函数对非堆上的数据进行排序radixSort.invoke (offHeap, javaStrings.length , MemoryAddress.NULL, &#39;\0&#39;);// 6. 将（重新排序的）字符串从非堆上复制回堆上for (int i = 0; i &lt; javaStrings.length ; i++) {    MemoryAddress cStringPtr = offHeap.getAtIndex(ValueLayout.ADDRESS, i);    javaStrings[i] = cStringPtr.getUtf8String(0);}assert Arrays.equals (javaStrings, new String[] {&quot;car&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;mouse&quot;}); // true</code></pre><blockquote><p>友情提示：官方的代码仅是示意，很多API还在调整，只有等到正式发行时才能暂时确定下来。</p></blockquote><h3 id="JEP-436-虚拟线程（第二次预览）"><a href="#JEP-436-虚拟线程（第二次预览）" class="headerlink" title="JEP 436: 虚拟线程（第二次预览）"></a>JEP 436: 虚拟线程（第二次预览）</h3><p>虚拟线程是一种轻量级的线程实现，旨在显著降低编写、维护和观察高吞吐量并发应用程序的难度。它们占用的资源少，不需要被池化，可以创建大量虚拟线程，特别适用于IO密集型任务，因为它们可以高效地调度大量虚拟线程来处理并发请求，从而显著提高程序的吞吐量和响应速度。</p><p>相比于传统现成，虚拟线程性能显著提升。</p><p>虚拟线程在Java19中第一次预览，在Java20第二次预览，本次预览没有引入新的API，做了一些最终化处理，为Java21正式发布做准备。</p><p>虚拟线程有下面几个特点：</p><ol><li>轻量级：虚拟线程是JVM内部实现的轻量级线程，不需要操作系统内核参与，创建和上下文切换的成本远低于传统的操作系统线程（即平台线程），且占用的内存资源较少。</li><li>减少CPU时间消耗：由于虚拟线程不依赖于操作系统平台线程，因此在进行线程切换时耗费的CPU时间会大大减少，从而提高了程序的执行效率。</li><li>简化多线程编程：虚拟线程通过结构化并发API来简化多线程编程，使得开发者可以更容易地编写、维护和观察高吞吐量并发应用程序。</li><li>适用于大量任务场景：虚拟线程非常适合需要创建和销毁大量线程的任务、需要执行大量计算的任务（如数据处理、科学计算等）以及需要实现任务并行执行以提高程序性能的场景。</li><li>提高系统吞吐量：通过对虚拟线程的介绍和与Go协程的对比，可以看出虚拟线程能够大幅提高系统的整体吞吐量。</li></ol><p>虽然虚拟线程是预览功能，不妨碍我们一起试用下。</p><pre><code class="java">try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {    IntStream.range(0, 10_000).forEach(i -&gt; {        executor.submit(() -&gt; {            Thread.sleep(Duration.ofSeconds(1));            System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i);            return i;        });    });}Thread.startVirtualThread(() -&gt; {    System.out.println(&quot;Hello from a virtual thread[Thread.startVirtualThread]&quot;);});final ThreadFactory factory = Thread.ofVirtual().factory();factory.newThread(() -&gt; {            System.out.println(&quot;Hello from a virtual thread[ThreadFactory.newThread]&quot;);        })        .start();</code></pre><p>虚拟线程为了降低使用门槛，直接提供了与原生线程类似的方法：</p><ul><li><code>Executors.newVirtualThreadPerTaskExecutor()</code>，可以像普通线程池一样创建虚拟线程。</li><li><code>Thread.startVirtualThread</code>，通过工具方法直接创建并运行虚拟线程。</li><li><code>Thread.ofVirtual().factory().newThread()</code>，另一个工具方法可以创建并运行虚拟线程。<code>Thread</code>还有一个<code>ofPlatform()</code>方法，用来构建普通线程。</li></ul><p>通过本地简单测试（在「公众号：看山的小屋」回复”java”获取源码），1w个模拟线程运行时，性能方面虚拟线程 &gt; 线程池。</p><h2 id="孵化功能"><a href="#孵化功能" class="headerlink" title="孵化功能"></a>孵化功能</h2><h3 id="JEP-429-作用域值（孵化）"><a href="#JEP-429-作用域值（孵化）" class="headerlink" title="JEP 429: 作用域值（孵化）"></a>JEP 429: 作用域值（孵化）</h3><p>JEP 429: 作用域值（Scoped Values），旨在促进在线程内和线程间共享不可变数据。这一特性为现代 Java 应用程序提供了一种更高效和安全的替代传统 ThreadLocal 机制的方法，尤其是在并发编程的背景下。</p><p>作用域值允许开发者定义一个变量，该变量可以在特定的作用域内访问，包括当前线程及其创建的任何子线程。这一机制特别适用于在方法调用链中隐式传递数据，而无需在方法签名中添加额外的参数。</p><p>作用域值的主要特点：</p><ul><li>不可变性：作用域值是不可变的，这意味着一旦设置，其值就不能更改。这种不可变性减少了并发编程中意外副作用的风险。</li><li>作用域生命周期：作用域值的生命周期仅限于 run 方法定义的作用域。一旦执行离开该作用域，作用域值将不再可访问。</li><li>继承性：子线程会自动继承父线程的作用域值，从而允许在线程边界间无缝共享数据。</li></ul><p>在之前，在多线程间传递数据，我们会使用<code>ThreadLocal</code>来保存当前线程变量，用完需要手动清理，如果忘记清理或者使用不规范，可能导致内存泄漏等问题。作用域值通过自动管理生命周期和内存，减少了这种风险。</p><p>我们一起看下作用域值的使用：</p><pre><code class="java">// 声明一个作用域值用于存储用户名public final static ScopedValue&lt;String&gt; USERNAME = ScopedValue.newInstance();private static final Runnable printUsername = () -&gt;        System.out.println(Thread.currentThread().threadId() + &quot; 用户名是 &quot; + USERNAME.get());public static void main(String[] args) throws Exception {    // 将用户名 &quot;Bob&quot; 绑定到作用域并执行 Runnable    ScopedValue.where(USERNAME, &quot;Bob&quot;).run(() -&gt; {        printUsername.run();        new Thread(printUsername).start();    });    // 将用户名 &quot;Chris&quot; 绑定到另一个作用域并执行 Runnable    ScopedValue.where(USERNAME, &quot;Chris&quot;).run(() -&gt; {        printUsername.run();        new Thread(() -&gt; {            new Thread(printUsername).start();            printUsername.run();        }).start();    });    // 检查在任何作用域外 USERNAME 是否被绑定    System.out.println(&quot;用户名是否被绑定: &quot; + USERNAME.isBound());}</code></pre><p>写起来干净利索，而且功能更强。</p><h3 id="JEP-437-结构化并发API-第二次孵化"><a href="#JEP-437-结构化并发API-第二次孵化" class="headerlink" title="JEP 437: 结构化并发API (第二次孵化)"></a>JEP 437: 结构化并发API (第二次孵化)</h3><p>JEP 437: 结构化并发API（Structured Concurrency API）旨在简化多线程编程，通过引入一个API来处理在不同线程中运行的多个任务作为一个单一工作单元，从而简化错误处理和取消操作，提高可靠性，并增强可观测性。这是一个处于孵化阶段的API。</p><p>结构化并发API提供了明确的语法结构来定义子任务的生命周期，并启用一个运行时表示线程间的层次结构。这有助于实现错误传播和取消以及并发程序的有意义观察。</p><p>Java使用异常处理机制来管理运行时错误和其他异常。当异常在代码中产生时，如何被传递和处理的过程称为异常传播。</p><p>在结构化并发环境中，异常可以通过显式地从当前环境中抛出并传播到更大的环境中去处理。</p><p>在Java并发编程中，非受检异常的处理是程序健壮性的重要组成部分。特别是对于非受检异常的处理，这关系到程序在遇到错误时是否能够优雅地继续运行或者至少提供有意义的反馈。</p><pre><code class="java">try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {    var task1 = scope.fork(() -&gt; {        Thread.sleep(1000);        return &quot;Result from task 1&quot;;    });    var task2 = scope.fork(() -&gt; {        Thread.sleep(2000);        return &quot;Result from task 2&quot;;    });    scope.join();    scope.throwIfFailed(RuntimeException::new);    System.out.println(task1.get());    System.out.println(task2.get());} catch (Exception e) {    e.printStackTrace();}</code></pre><p>在这个例子中，handle()方法使用StructuredTaskScope来并行执行两个子任务：task1和task2。通过使用try-with-resources语句自动管理资源，并确保所有子任务都在try块结束时正确完成或被取消。这种方式使得线程的生命周期和任务的逻辑结构紧密相关，提高了代码的清晰度和错误处理的效率。使用 StructuredTaskScope 可以确保一些有价值的属性：</p><ul><li>错误处理与短路：如果task1或task2子任务中的任何一个失败，另一个如果尚未完成则会被取消。（这由 ShutdownOnFailure 实现的关闭策略来管理；还有其他策略可能）。</li><li>取消传播：如果在运行上面方法的线程在调用 join() 之前或之中被中断，则线程在退出作用域时会自动取消两个子任务。</li><li>清晰性：设置子任务，等待它们完成或被取消，然后决定是成功（并处理已经完成的子任务的结果）还是失败（子任务已经完成，因此没有更多需要清理的）。</li><li>可观察性：线程转储清楚地显示了任务层次结构，其中运行task1或task2的线程被显示为作用域的子任务。</li></ul><p>上面的示例能够很好的解决我们的一个痛点，有两个可并行的任务A和B，A+B才是完整结果，任何一个失败，另外一个也不需要成功，结构化并发API就可以很容易的实现这个逻辑。</p><h3 id="JEP-438-向量API（第五次孵化）"><a href="#JEP-438-向量API（第五次孵化）" class="headerlink" title="JEP 438: 向量API（第五次孵化）"></a>JEP 438: 向量API（第五次孵化）</h3><p>向量API的功能是提供一个表达向量计算的API，这些计算在运行时可靠地编译成支持的CPU架构上的最优向量指令，从而实现比等效标量计算更优的性能。</p><p>下面这个是官方给的示例：</p><pre><code class="java">// 标量计算示例void scalarComputation(float[] a, float[] b, float[] c) {    for (int i = 0; i &lt; a.length ; i++) {        c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;    }}// 使用向量API的向量计算示例static final VectorSpecies&lt;Float&gt; SPECIES = FloatVector.SPECIES_PREFERRED;void vectorComputation(float[] a, float[] b, float[] c) {    int i = 0;    int upperBound = SPECIES.loopBound(a.length);    for (; i &lt; upperBound; i += SPECIES.length()) {        // FloatVector va, vb, vc;        var va = FloatVector.fromArray(SPECIES, a, i);        var vb = FloatVector.fromArray(SPECIES, b, i);        var vc = va.mul(va).add(vb.mul(vb)).neg();        vc.intoArray(c, i);    }    for (; i &lt; a.length; i++) {        c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;    }}</code></pre><p>向量API在Java中的独特优势在于其高效的并行计算能力、丰富的向量化指令集、跨平台的数据并行算法支持以及对机器学习的特别优化。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java20 新增的特性，完整的特性清单可以从 <a href="https://openjdk.org/projects/jdk/20/" target="_blank" rel="noopener">https://openjdk.org/projects/jdk/20/</a> 查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/By2JoZqAHA6U36PG8qvCcg" target="_blank" rel="noopener">Java17 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/W6Esovb7zzCL_seXgY84jA" target="_blank" rel="noopener">Java18 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/WutbAX_IQNqP4M3rud9f_g" target="_blank" rel="noopener">Java19 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/DvZYrZTtGfdXNsXGzmQN1A" target="_blank" rel="noopener">Java20 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/iiXa9rpJu1Vedpke0XpBzQ" target="_blank" rel="noopener">Java21 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/eHHFaJErH8XH4QSRrfcehQ" target="_blank" rel="noopener">Java22 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/XvB0D2vzhaAvHESupdALag" target="_blank" rel="noopener">Java23 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">Java24 的新特性</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java/java-20-features">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java20 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java20 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Java20 在 2023 年 3 月 21 日发布GA版本，共七大特性，这些新特性处于预览或孵化阶段，旨在简化并发编程、提高性能和增强语言表达能力。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java20" scheme="https://www.howardliu.cn/tags/Java20/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java19 的新特性</title>
    <link href="https://www.howardliu.cn/java/java-19-features/"/>
    <id>https://www.howardliu.cn/java/java-19-features/</id>
    <published>2024-09-11T00:20:00.000Z</published>
    <updated>2024-12-05T03:03:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/bird-8936789_1920.jpg" alt="Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java19 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。让我们跟随 Java 的脚步，配合示例讲解，看一看每个版本的新特性，本期是 Java19 的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java19 在 2022 年 9 月 20 日发布GA版本，共七大特性，这些新特性大多处于预览或孵化阶段，旨在简化并发编程、提高性能和增强语言表达能力。这七大特性分别是：</p><ul><li>JEP 405: Record 模式（预览）</li><li>JEP 422: Linux/RISC-V移植</li><li>JEP 424: 外部函数和内存API（预览）</li><li>JEP 425: 虚拟线程（预览）</li><li>JEP 426: 向量API（第四次孵化）</li><li>JEP 427: Switch模式匹配（第三次预览）</li><li>JEP 428: 结构化并发API (孵化)</li></ul><p>接下来我们一起看看这些特性。</p><h2 id="JEP-422-Linux-RISC-V-移植"><a href="#JEP-422-Linux-RISC-V-移植" class="headerlink" title="JEP 422: Linux/RISC-V 移植"></a>JEP 422: Linux/RISC-V 移植</h2><p>JEP 422 是将 Java 开发环境（JDK）移植到基于 RISC-V 指令集架构的 Linux 系统上。</p><p>RISC-V 是一种开源且无版税的指令集架构，最初由加州大学伯克利分校设计，并由 RISC-V 国际基金会共同开发和维护。</p><p>该移植项目的目标包括以下几个方面：</p><ul><li>支持多种子系统：移植版本将支持模板解释器、C1 和 C2 JIT 编译器以及所有当前的主要垃圾回收器，如 ZGC 和 Shenandoah。</li><li>硬件配置支持：目前仅支持 RV64GV 配置，这是一种通用的 64 位 ISA，包含向量指令。未来可能会考虑支持其他 RISC-V 配置，例如 RV32G 的一般用途 32 位配置。</li><li>集成到 JDK 主线代码库中：重点在于将移植的内容集成到 JDK 的主仓库中，确保其能够在 RISC-V 架构上正常运行。</li></ul><p>此外，RISC-V 架构具有模块化设计，采用精简、可靠且支持多平台的优点，这使得它在嵌入式系统和高性能计算领域有广泛的应用前景。</p><p>通过此次移植，Java 将能够更好地适应这些新兴的硬件平台，从而扩展其生态系统并提高其在不同硬件架构上的兼容性和可用性，增强 Java 在嵌入式系统和高性能计算等领域的应用能力.</p><h2 id="预览功能"><a href="#预览功能" class="headerlink" title="预览功能"></a>预览功能</h2><h3 id="JEP-405-Record-模式（预览）"><a href="#JEP-405-Record-模式（预览）" class="headerlink" title="JEP 405: Record 模式（预览）"></a>JEP 405: Record 模式（预览）</h3><p>Record是Java16正式发布的基础类型，提供不可变对象的简单实现（其实就是Java Bean，但是省略一堆的getter、setter、hashcode、equals、toString等方法）（参见<a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a>）。</p><p>JEP 405: Record模式归属于Amber项目的一部分，Amber项目旨在通过小而美的方式，增强Java语言特性。本次的Record模式，主要是使Record类型可以直接在instanceof和switch模式匹配中使用。主要体现在4个方面：</p><ol><li>解构记录值：Record模式允许用户对Record的值进行解构，这意味着可以将一个Record类型的实例分解成其各个组成元素。</li><li>嵌套Record模式和instanceof模式：Record模式可以与instanceof模式匹配嵌套使用，从而创建强大、声明性和可组合的数据导航和处理形式。这种嵌套使得数据查询和处理更加灵活和复杂。</li><li>语法和代码生成的变化：为了支持Record模式，Java19需要从语法到代码生成以及DOM模型进行大量的修改。这表明JEP 405不仅在功能上带来了新的特性，还在语言内部结构上进行了深入的调整。</li><li>目标和用途：JEP 405的目标是扩展模式匹配的能力，实现更复杂的数据查询和处理。通过引入Record模式，开发者可以以一种更加声明性和可组合的方式进行数据导航和处理。</li></ol><p>我们一起看个示例，比如有下面几个基础元素：</p><pre><code class="java">// 颜色enum Color { RED, GREEN, BLUE}// 点record Point(int x, int y) {}// 带颜色的点record ColoredPoint(Point p, Color color) {}// 正方形record Square(ColoredPoint upperLeft, ColoredPoint lowerRight) {}</code></pre><p>我们分别通过instanceof模式匹配和switch模式匹配判断输入参数的类型，打印不同的格式：</p><pre><code class="java">private static void instancePatternsAndPrint(Object o) {    if (o instanceof Square(ColoredPoint upperLeft, ColoredPoint lowerRight)) {        System.out.println(&quot;Square类型：&quot; + upperLeft + &quot; &quot; + lowerRight);    } else if (o instanceof ColoredPoint(Point(int x, int y), Color color)) {        System.out.println(&quot;ColoredPoint类型：&quot; + x + &quot; &quot; + y + &quot; &quot; + color);    } else if (o instanceof Point p) {        System.out.println(&quot;Point类型：&quot; + p);    }}private static void switchPatternsAndPrint(Object o) {    switch (o) {        case Square(ColoredPoint upperLeft, ColoredPoint lowerRight) -&gt; {            System.out.println(&quot;Square类型：&quot; + upperLeft + &quot; &quot; + lowerRight);        }        case ColoredPoint(Point(int x, int y), Color color) -&gt; {            System.out.println(&quot;ColoredPoint类型：&quot; + x + &quot; &quot; + y + &quot; &quot; + color);        }        case Point p -&gt; {            System.out.println(&quot;Point类型：&quot; + p);        }        default -&gt; throw new IllegalStateException(&quot;Unexpected value: &quot; + o);    }}</code></pre><p>我们通过main方法执行下：</p><pre><code class="java">public static void main(String[] args) {    var p = new Point(1, 2);    var cp1 = new ColoredPoint(p, Color.RED);    var cp2 = new ColoredPoint(p, Color.GREEN);    var square = new Square(cp1, cp2);    instancePatternsAndPrint(square);    instancePatternsAndPrint(cp1);    instancePatternsAndPrint(p);    switchPatternsAndPrint(square);    switchPatternsAndPrint(cp1);    switchPatternsAndPrint(p);}// 结果是：//// Square类型：ColoredPoint[p=Point[x=1, y=2], color=RED] ColoredPoint[p=Point[x=1, y=2], color=GREEN]// ColoredPoint类型：1 2 RED// Point类型：Point[x=1, y=2]//// Square类型：ColoredPoint[p=Point[x=1, y=2], color=RED] ColoredPoint[p=Point[x=1, y=2], color=GREEN]// ColoredPoint类型：1 2 RED// Point类型：Point[x=1, y=2]</code></pre><p>是不是很简洁，就像Java8提供的Lambda表达式一样，很丝滑。</p><h3 id="JEP-424-外部函数和内存API（预览）"><a href="#JEP-424-外部函数和内存API（预览）" class="headerlink" title="JEP 424: 外部函数和内存API（预览）"></a>JEP 424: 外部函数和内存API（预览）</h3><p>JEP 424: 外部函数和内存API（Foreign Function &amp; Memory API，简称FFM API）旨在提供一种机制，使Java程序能够与Java运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即JVM之外的代码）以及安全地访问外部内存（即非JVM管理的内存），该API使得Java程序能够调用本地库并处理本地数据，而无需使用JNI带来的脆弱性和危险。</p><p>简单说，FFM API是为了替换JNI的函数，在Java19中是第一次预览版，最终会在Java22中转正。</p><p>FFM API的主要功能包括：</p><ul><li>易用性：用一个更优越、完全Java开发模型替代了Java原生接口（JNI）。</li><li>性能：提供与现有API（如JNI和sun.misc.Unsafe ）相当甚至更好的性能。</li><li>通用性：支持操作不同类型的外部内存（例如，本地内存、持久内存和托管堆内存），并计划随着时间的推移适应其他平台（例如，32位x86）和用C语言之外的语言（例如C++、Fortran）编写的外部函数。</li><li>安全性：允许程序在默认情况下对外部内存执行不安全的操作，但会向用户发出警告。</li></ul><p>我们来看一个官方给的示例：如何获取C库函数<code>radixsort</code>的方法句柄，并使用它来对四个字符串进行排序。</p><pre><code class="java">// 1. 找到C库路径上的外部函数Linker linker = Linker.nativeLinker();SymbolLookup stdlib = linker.defaultLookup();MethodHandle radixSort = linker.downcallHandle(stdlib.lookup (&quot;radixsort&quot;), ...);// 2. 在堆上分配内存存储四个字符串String[] javaStrings = { &quot;mouse&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;car&quot; };// 3. 在非堆上分配内存存储四个指针SegmentAllocator allocator = SegmentAllocator.implicitAllocator();MemorySegment offHeap = allocator.allocateArray(ValueLayout.ADDRESS, javaStrings.length );// 4. 将字符串从堆上复制到非堆上for (int i = 0; i &lt; javaStrings.length ; i++) {    // 分配一个字符串到非堆上，然后存储其指针    MemorySegment cString = allocator.allocateUtf8String(javaStrings[i]);    offHeap.setAtIndex(ValueLayout.ADDRESS, i, cString);}// 5. 调用外部函数对非堆上的数据进行排序radixSort.invoke (offHeap, javaStrings.length , MemoryAddress.NULL, &#39;\0&#39;);// 6. 将（重新排序的）字符串从非堆上复制回堆上for (int i = 0; i &lt; javaStrings.length ; i++) {    MemoryAddress cStringPtr = offHeap.getAtIndex(ValueLayout.ADDRESS, i);    javaStrings[i] = cStringPtr.getUtf8String(0);}assert Arrays.equals (javaStrings, new String[] {&quot;car&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;mouse&quot;}); // true</code></pre><blockquote><p>友情提示：官方的代码仅是示意，很多API还在调整，只有等到正式发行时才能暂时确定下来。</p></blockquote><h3 id="JEP-425-虚拟线程（预览）"><a href="#JEP-425-虚拟线程（预览）" class="headerlink" title="JEP 425: 虚拟线程（预览）"></a>JEP 425: 虚拟线程（预览）</h3><p>虚拟线程是一种轻量级的线程实现，旨在显著降低编写、维护和观察高吞吐量并发应用程序的难度。它们占用的资源少，不需要被池化，可以创建大量虚拟线程，特别适用于IO密集型任务，因为它们可以高效地调度大量虚拟线程来处理并发请求，从而显著提高程序的吞吐量和响应速度。</p><p>相比于传统现成，虚拟线程性能显著提升。</p><p>虚拟线程有下面几个特点：</p><ol><li>轻量级：虚拟线程是JVM内部实现的轻量级线程，不需要操作系统内核参与，创建和上下文切换的成本远低于传统的操作系统线程（即平台线程），且占用的内存资源较少。</li><li>减少CPU时间消耗：由于虚拟线程不依赖于操作系统平台线程，因此在进行线程切换时耗费的CPU时间会大大减少，从而提高了程序的执行效率。</li><li>简化多线程编程：虚拟线程通过结构化并发API来简化多线程编程，使得开发者可以更容易地编写、维护和观察高吞吐量并发应用程序。</li><li>适用于大量任务场景：虚拟线程非常适合需要创建和销毁大量线程的任务、需要执行大量计算的任务（如数据处理、科学计算等）以及需要实现任务并行执行以提高程序性能的场景。</li><li>提高系统吞吐量：通过对虚拟线程的介绍和与Go协程的对比，可以看出虚拟线程能够大幅提高系统的整体吞吐量。</li></ol><p>虽然虚拟线程在Java19中是预览功能，不妨碍我们一起试用下。</p><pre><code class="java">try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {    IntStream.range(0, 10_000).forEach(i -&gt; {        executor.submit(() -&gt; {            Thread.sleep(Duration.ofSeconds(1));            System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i);            return i;        });    });}Thread.startVirtualThread(() -&gt; {    System.out.println(&quot;Hello from a virtual thread[Thread.startVirtualThread]&quot;);});final ThreadFactory factory = Thread.ofVirtual().factory();factory.newThread(() -&gt; {            System.out.println(&quot;Hello from a virtual thread[ThreadFactory.newThread]&quot;);        })        .start();</code></pre><p>虚拟线程为了降低使用门槛，直接提供了与原生线程类似的方法：</p><ul><li><code>Executors.newVirtualThreadPerTaskExecutor()</code>，可以像普通线程池一样创建虚拟线程。</li><li><code>Thread.startVirtualThread</code>，通过工具方法直接创建并运行虚拟线程。</li><li><code>Thread.ofVirtual().factory().newThread()</code>，另一个工具方法可以创建并运行虚拟线程。<code>Thread</code>还有一个<code>ofPlatform()</code>方法，用来构建普通线程。</li></ul><p>通过本地简单测试（在「公众号：看山的小屋」回复”java”获取源码），1w个模拟线程运行时，性能方面虚拟线程 &gt; 线程池。</p><h3 id="JEP-427-Switch模式匹配（第三次预览）"><a href="#JEP-427-Switch模式匹配（第三次预览）" class="headerlink" title="JEP 427: Switch模式匹配（第三次预览）"></a>JEP 427: Switch模式匹配（第三次预览）</h3><p>switch模式匹配是老朋友了，最终会在Java21转正。</p><p>switch模式匹配允许在switch语句中使用模式来测试表达式，每个模式都有特定的动作，从而可以简洁、安全地表达复杂的数据导向查询。</p><p>主要功能包括：</p><ul><li>增强表达性和适用性：允许在case标签中出现模式，扩展了switch表达式和语句的表达能力和适用范围。</li><li>放宽对null的敌意：当需要时，可以放宽switch对null的敌意。</li><li>提高安全性：要求模式switch语句覆盖所有可能的输入值，增加了switch语句的安全性。</li><li>保持兼容性：确保所有现有的switch表达式和语句继续无变化地编译并以相同的语义执行。</li></ul><pre><code class="java">static String formatValue(Object obj) {    return switch (obj) {        case null -&gt; &quot;null&quot;;        case Integer i -&gt; String.format(&quot;int %d&quot;, i);        case Long l -&gt; String.format(&quot;long %d&quot;, l);        case Double d -&gt; String.format(&quot;double %f&quot;, d);        case String s -&gt; String.format(&quot;String %s&quot;, s);        default -&gt; obj.toString();    };}public record Person(String name, String address) {}public static void main(String[] args) {    System.out.println(formatValue(10));    System.out.println(formatValue(20L));    System.out.println(formatValue(3.14));    System.out.println(formatValue(&quot;Hello&quot;));    System.out.println(formatValue(null));}// 运行结果// int 10// long 20// double 3.140000// String Hello// null</code></pre><h2 id="孵化功能"><a href="#孵化功能" class="headerlink" title="孵化功能"></a>孵化功能</h2><h3 id="JEP-426-向量API（第四次孵化）"><a href="#JEP-426-向量API（第四次孵化）" class="headerlink" title="JEP 426: 向量API（第四次孵化）"></a>JEP 426: 向量API（第四次孵化）</h3><p>向量API的功能是提供一个表达向量计算的API，这些计算在运行时可靠地编译成支持的CPU架构上的最优向量指令，从而实现比等效标量计算更优的性能。</p><p>下面这个是官方给的示例：</p><pre><code class="java">// 标量计算示例void scalarComputation(float[] a, float[] b, float[] c) {    for (int i = 0; i &lt; a.length ; i++) {        c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;    }}// 使用向量API的向量计算示例static final VectorSpecies&lt;Float&gt; SPECIES = FloatVector.SPECIES_PREFERRED;void vectorComputation(float[] a, float[] b, float[] c) {    int i = 0;    int upperBound = SPECIES.loopBound(a.length);    for (; i &lt; upperBound; i += SPECIES.length()) {        // FloatVector va, vb, vc;        var va = FloatVector.fromArray(SPECIES, a, i);        var vb = FloatVector.fromArray(SPECIES, b, i);        var vc = va.mul(va).add(vb.mul(vb)).neg();        vc.intoArray(c, i);    }    for (; i &lt; a.length; i++) {        c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;    }}</code></pre><p>在Java19中，向量API（Vector API）的性能改进主要体现在以下几个方面：</p><ul><li>向量计算的编译优化：Java 19中的Vector API能够将向量计算表达式在运行时可靠地编译为支持的CPU架构上的最佳向量指令。这意味着它能够利用特定CPU架构的向量指令集来执行计算，从而实现比等效标量计算更优的性能。</li><li>加载和存储向量操作：根据外部函数和内存API预览的定义，在MemorySegment之间加载和存储向量。这使得向量数据的处理更加高效，特别是在需要频繁访问大量数据的情况下。</li><li>新增交叉通道向量操作：Java 19还增加了两个新的交叉通道向量操作，即压缩和扩展。这些操作进一步增强了向量计算的能力，使其可以更灵活地处理不同类型的向量数据。</li><li>第四轮孵化：Vector API在Java 19中进行了第四轮孵化，这意味着经过前三轮孵化的反馈和改进后，该API已经变得更加成熟和稳定。这种持续的迭代和优化确保了其在实际应用中的可靠性和性能。</li></ul><p>向量API在Java中的独特优势在于其高效的并行计算能力、丰富的向量化指令集、跨平台的数据并行算法支持以及对机器学习的特别优化。</p><h3 id="JEP-428-结构化并发API-孵化"><a href="#JEP-428-结构化并发API-孵化" class="headerlink" title="JEP 428: 结构化并发API (孵化)"></a>JEP 428: 结构化并发API (孵化)</h3><p>结构化并发API，旨在简化多线程编程。结构化并发是一种多线程编程方法，通过使用新的API来管理多线程代码。将不同线程中的多个任务视为单个工作单元，简化错误处理和提高可靠性。</p><p>结构化并发API提供了明确的语法结构来定义子任务的生命周期，并启用一个运行时表示线程间的层次结构。这有助于实现错误传播和取消以及并发程序的有意义观察。</p><p>Java使用异常处理机制来管理运行时错误和其他异常。当异常在代码中产生时，如何被传递和处理的过程称为异常传播。</p><p>在结构化并发环境中，异常可以通过显式地从当前环境中抛出并传播到更大的环境中去处理。</p><p>在Java并发编程中，非受检异常的处理是程序健壮性的重要组成部分。特别是对于非受检异常的处理，这关系到程序在遇到错误时是否能够优雅地继续运行或者至少提供有意义的反馈。</p><pre><code class="java">try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {    var task1 = scope.fork(() -&gt; {        Thread.sleep(1000);        return &quot;Result from task 1&quot;;    });    var task2 = scope.fork(() -&gt; {        Thread.sleep(2000);        return &quot;Result from task 2&quot;;    });    scope.join();    scope.throwIfFailed(RuntimeException::new);    System.out.println(task1.get());    System.out.println(task2.get());} catch (Exception e) {    e.printStackTrace();}</code></pre><p>在这个例子中，handle()方法使用StructuredTaskScope来并行执行两个子任务：task1和task2。通过使用try-with-resources语句自动管理资源，并确保所有子任务都在try块结束时正确完成或被取消。这种方式使得线程的生命周期和任务的逻辑结构紧密相关，提高了代码的清晰度和错误处理的效率。使用 StructuredTaskScope 可以确保一些有价值的属性：</p><ul><li>错误处理与短路：如果task1或task2子任务中的任何一个失败，另一个如果尚未完成则会被取消。（这由 ShutdownOnFailure 实现的关闭策略来管理；还有其他策略可能）。</li><li>取消传播：如果在运行上面方法的线程在调用 join() 之前或之中被中断，则线程在退出作用域时会自动取消两个子任务。</li><li>清晰性：设置子任务，等待它们完成或被取消，然后决定是成功（并处理已经完成的子任务的结果）还是失败（子任务已经完成，因此没有更多需要清理的）。</li><li>可观察性：线程转储清楚地显示了任务层次结构，其中运行task1或task2的线程被显示为作用域的子任务。</li></ul><p>上面的示例能够很好的解决我们的一个痛点，有两个可并行的任务A和B，A+B才是完整结果，任何一个失败，另外一个也不需要成功，结构化并发API就可以很容易的实现这个逻辑。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java19 新增的特性，完整的特性清单可以从 <a href="https://openjdk.org/projects/jdk/19/" target="_blank" rel="noopener">https://openjdk.org/projects/jdk/19/</a> 查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/By2JoZqAHA6U36PG8qvCcg" target="_blank" rel="noopener">Java17 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/W6Esovb7zzCL_seXgY84jA" target="_blank" rel="noopener">Java18 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/WutbAX_IQNqP4M3rud9f_g" target="_blank" rel="noopener">Java19 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/DvZYrZTtGfdXNsXGzmQN1A" target="_blank" rel="noopener">Java20 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/iiXa9rpJu1Vedpke0XpBzQ" target="_blank" rel="noopener">Java21 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/eHHFaJErH8XH4QSRrfcehQ" target="_blank" rel="noopener">Java22 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/XvB0D2vzhaAvHESupdALag" target="_blank" rel="noopener">Java23 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">Java24 的新特性</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java/java-19-features">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java19 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java19 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Java19 在 2022 年 9 月 20 日发布GA版本，共七大特性，这些新特性大多处于预览或孵化阶段，旨在简化并发编程、提高性能和增强语言表达能力。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java19" scheme="https://www.howardliu.cn/tags/Java19/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java18 的新特性</title>
    <link href="https://www.howardliu.cn/java/java-18-features/"/>
    <id>https://www.howardliu.cn/java/java-18-features/</id>
    <published>2024-09-10T00:20:00.000Z</published>
    <updated>2024-12-05T02:30:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/bird-8922501_1920.jpg" alt="Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java18 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。让我们跟随 Java 的脚步，配合示例讲解，看一看每个版本的新特性，本期是 Java18 的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java18 是在 2022 年 3 月 22 日正式发布，有9大特性：</p><ul><li>JEP 400: 使用 UTF-8 作为默认字符集</li><li>JEP 408: 简单的网络服务器</li><li>JEP 413: Java API 文档中的代码片段</li><li>JEP 416: 使用方法句柄重新实现核心反射机制</li><li>JEP 417: Vector API（第三次孵化）</li><li>JEP 418: Internet-Address地址解析 SPI</li><li>JEP 419: 外部函数和内存 API (第二次孵化)</li><li>JEP 420: switch 模式匹配（第二次预览）</li><li>JEP 421: 弃用 Finalization</li></ul><p>接下来我们一起看看这些特性。</p><h2 id="JEP-400-使用-UTF-8-作为默认字符集"><a href="#JEP-400-使用-UTF-8-作为默认字符集" class="headerlink" title="JEP 400: 使用 UTF-8 作为默认字符集"></a>JEP 400: 使用 UTF-8 作为默认字符集</h2><p>Java从出生目标就是跨平台使用，“一处编码，处处运行”，所以有一些适配不同平台的逻辑，字符集就是其中一个。在Java 18之前，Java的默认字符集是基于系统环境的。</p><p>可以通过命令查看：</p><pre><code class="shell">java -XshowSettings:properties -version 2&gt;&amp;1 | grep file.encoding</code></pre><p>或者：</p><pre><code class="java">Charset.defaultCharset()</code></pre><p>但是在跨平台使用时，这种特性可能导致字符编码的问题。</p><p>比如：</p><ul><li>代码的编译字符集是UTF-8，运行字符集是其他的，假设是输出中文字符，比如<code>System.out.println(&quot;你好&quot;);</code>，在Mac和Windows上表现就会不一致，在Windows上就会出现乱码，这是因为，在Java18之前，Windows默认字符集是GBK；</li><li>IO文件流操作，比如文件是UTF-8字符集编写，在不同环境读取文件内容，表现就会不一致。最常见的就是乱码神兽“<strong>锟斤拷</strong>”。</li></ul><p>通过将UTF-8作为默认字符集，不再需要设置file.encoding，可以统一字符编码的处理方式，提高国际化应用的兼容性。开发者可以更方便地进行开发和部署，减少了因字符集不一致导致的调试和维护问题。</p><p>Java 18中默认使用UTF-8字符集不仅简化了开发流程，还显著提升了代码的可预测性和可移植性，同时增强了对全球化和多语言应用的支持。</p><p>这是一个ROI很高的特性。</p><h2 id="JEP-408-简单的网络服务器"><a href="#JEP-408-简单的网络服务器" class="headerlink" title="JEP 408: 简单的网络服务器"></a>JEP 408: 简单的网络服务器</h2><p>JEP 408是为开发者提供一个轻量级、简单易用的 HTTP 服务器，通过命令行工具<code>jwebserver</code>可以启动一个最小化的静态 Web 服务器，这个服务器仅支持静态资源的访问，不支持 CGI（Common Gateway Interface）或类似 servlet 的功能，主要用于原型制作、测试和开发环境中的静态文件托管与共享。</p><p>它的应用场景包括：</p><ul><li>原型开发：由于其简单易用的特性，jwebserver 可以作为快速原型开发工具，帮助开发者在短时间内搭建起一个可以访问静态资源的 Web 服务。这对于需要验证某个功能或概念的初期阶段非常有用。</li><li>快速部署：对于一些小规模的应用或者临时性的项目，使用 jwebserver 可以快速启动并运行一个简单的 Web 服务，而无需复杂的配置和环境搭建。这使得开发者能够迅速将想法转化为实际的可访问服务。</li><li>学习与教育：jwebserver 提供了一个直观的平台，让初学者可以轻松上手 Java Web 开发。通过简单的命令行操作，用户可以快速理解 Web 服务器的工作原理及其基本配置。</li><li>测试与调试：在进行 Web 应用的测试和调试时，jwebserver 可以作为一个独立的工具来提供静态文件的访问服务，从而方便开发者对应用进行测试和调试。</li><li>本地开发环境：在本地开发环境中，jwebserver 可以替代传统的 Web 服务器如 Apache Tomcat 或 Nginx，为开发者提供一个轻量级的选择，以减少系统资源的占用。</li></ul><p>我们可以简单试一下，在当前目录编写index.html：</p><pre><code class="html">&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;欢迎参观&lt;/h2&gt;    &lt;h3&gt;&lt;a href=&quot;https://www.howardliu.cn/&quot;&gt;看山的小屋 howardliu.cn&lt;/a&gt;&lt;/h3&gt;    &lt;p&gt;        一起&lt;strong&gt;开心&lt;/strong&gt;学技术    &lt;/p&gt;    &lt;p&gt;        让我们一起&lt;strong&gt;扬帆起航&lt;/strong&gt;    &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>运行<code>jwebserver</code>命令：</p><pre><code class="shell">$ ./bin/jwebserverBinding to loopback by default. For all interfaces use &quot;-b 0.0.0.0&quot; or &quot;-b ::&quot;.Serving /Users/liuxinghao/Library/Java/JavaVirtualMachines/temurin-18.0.2.1/Contents/Home and subdirectories on 127.0.0.1 port 8000URL http://127.0.0.1:8000/</code></pre><p>打开<code>http://127.0.0.1:8000/</code>就可以直接看到index.html的效果：</p><p><img src="https://static.howardliu.cn/20240803-114331.png" alt="看山的小屋 howardliu.cn"></p><p><code>jwebserver</code>还支持指定地址和端口等参数，具体使用可以通过命令查看：</p><pre><code class="shell">$ ./bin/jwebserver -hUsage: jwebserver [-b bind address] [-p port] [-d directory]                  [-o none|info|verbose] [-h to show options]                  [-version to show version information]Options:-b, --bind-address    - Address to bind to. Default: 127.0.0.1 (loopback).                        For all interfaces use &quot;-b 0.0.0.0&quot; or &quot;-b ::&quot;.-d, --directory       - Directory to serve. Default: current directory.-o, --output          - Output format. none|info|verbose. Default: info.-p, --port            - Port to listen on. Default: 8000.-h, -?, --help        - Prints this help message and exits.-version, --version   - Prints version information and exits.</code></pre><h2 id="JEP-413-Java-API-文档中的代码片段"><a href="#JEP-413-Java-API-文档中的代码片段" class="headerlink" title="JEP 413: Java API 文档中的代码片段"></a>JEP 413: Java API 文档中的代码片段</h2><p>JEP 413是Java 18中的一个新特性，旨在简化在Java API文档中嵌入示例源代码的过程。这一特性通过引入一个新的<code>@snippet</code>标签来实现，该标签可以用于标准的JavaDoc生成器。</p><p>在JEP 413之前，要在Java代码注释中添加示例代码非常麻烦，通常需要使用复杂的字符转义或预定义的标记（如 <code>{@code ...}</code>标记或<code>&lt;pre&gt;</code>标签），这不仅增加了编写和维护文档的复杂性，还可能导致文档中的代码片段无法正确显示。而JEP 413通过引入<code>@snippet</code>标签，使得在API文档中嵌入示例源代码变得更加简单和直观。</p><p><code>@snippet</code>标签有两种用法：</p><ol><li>内联片段（inline snippet），即代码片段直接包含在标签内；<pre><code class="java">/*** The following code shows how to use {@code Optional.isPresent}:* {@snippet :* if (v.isPresent()) {*     System.out.println(&quot;v: &quot; + v.get());* }* }*/</code></pre></li><li>外部片段（external snippet），即代码片段从单独的源文件中读取。<pre><code class="java">/*** The following code shows how to use {@code Optional.isPresent}:* {@snippet file=&quot;ShowOptional.java&quot; region=&quot;example&quot;}*/</code></pre>引用代码如下：<pre><code class="java">public class ShowOptional { void show(Optional&lt;String&gt; v) {     // @start region=&quot;example&quot;     if (v.isPresent()) {         System.out.println(&quot;v: &quot; + v.get());     }     // @end }}</code></pre></li></ol><blockquote><p>需要注意的，引入外部片段的时候，file参数指定的文件通常位于与源文件同一层级下的一级目录中的snippet-files目录内。</p></blockquote><p>JEP 413在Java API文档的增强主要是下面几个方面：</p><ul><li>引入<code>@snippet</code> JavaDoc标签：JEP 413引入了一个新的标准Doclet标签<code>@snippet</code>JavaDoc，这使得在API文档中嵌入示例源代码变得更加简单。这个标签允许开发者直接在Javadoc注释中包含可编译的源代码片段，从而提高了文档的可读性和实用性。</li><li>简化代码示例的嵌入：在JEP 413之前，要在JavaDoc中添加代码示例通常需要使用复杂的标记，如<pre>标签或通过<code>@code</code>标签包裹代码段。而JEP 413通过简化这些过程，使得开发者可以更方便地在文档中嵌入代码示例。</pre></li><li>增强验证和维护能力：通过提供对源代码片段的API访问，JEP 413不仅简化了文档的编写，还增强了源代码片段的验证能力。尽管最终正确性仍由作者负责，但新的工具支持使得实现这一目标变得更加容易。</li><li>语法高亮和格式化支持：与之前的版本相比，JEP 413不仅支持代码片段的嵌入，还提供了语法高亮和格式化的功能。这意味着在生成的Javadoc文档中，代码示例会以更清晰、易读的方式展示，从而提高文档的可读性和用户体验。</li><li>提升用户体验：JEP 413的引入大大改善了在JavaDoc中嵌入代码示例的体验。例如，在之前版本中，开发者需要手动处理大量的HTML和XML标记，而JEP 413则通过标准化的方式减少了这些工作量。</li><li>提高开发效率和代码质量：通过使用规范且更新及时的API文档，开发者可以更快地理解和使用库中的功能。这种清晰的文档有助于减少错误和混淆，从而提高整体的开发效率和代码质量。</li></ul><blockquote><p>我只有在写基础工具的时候才会写这方面的实力，其他时候使用普通注释就行了。所以，这个功能使用的概率比较小，大家了解下就好。🐶</p></blockquote><h2 id="JEP-416-使用方法句柄重新实现核心反射机制"><a href="#JEP-416-使用方法句柄重新实现核心反射机制" class="headerlink" title="JEP 416: 使用方法句柄重新实现核心反射机制"></a>JEP 416: 使用方法句柄重新实现核心反射机制</h2><p>JEP 416 是 Java18 中的一个重要新特性，其核心内容是使用方法句柄（Method Handles）重新实现 Java 核心反射机制。具体来说，它在 java.lang.invoke 的方法句柄之上重构了 java.lang.reflect.Method 、Constructor 和 Field 等类的实现逻辑。</p><p>JEP 416主要目标是把反射API与JVM内部结构解耦，便于维护和更新，降低成本和复杂度，而且需要兼顾性能和兼容性。</p><p>这一改动主要体现在以下几个方面：</p><ol><li>性能提升：通过使用方法句柄来处理反射操作，Java18 显著提高了反射操作的性能和速度。这意味着在进行反射操作时，如调用方法、构造函数或访问字段等，可以更快地完成这些操作。</li><li>代码量减少：由于方法句柄的引入，开发者在编写反射相关的代码时，可以更简洁地表达意图，从而减少代码量。这不仅使得代码更加清晰易读，也进一步提升了开发效率。</li><li>无需修改现有 API：这项改动不会影响现有的 Java 反射 API，因此开发者无需对现有的反射相关代码进行修改即可体验到性能上的提升。这对于已经在使用反射功能的项目来说是一个非常友好的特性。</li><li>重构核心反射机制：在 java.lang.invoke 的方法句柄之上，Java 18 对 java.lang.reflect.Method 、Constructor 和 Field 等类进行了重构，使得它们的实现逻辑更加高效。这种重构不仅优化了内部实现，还可能带来一些未预见的性能提升。</li></ol><p>这项改动不会改变现有的反射相关 API，因此开发者可以在不修改现有代码的情况下体验到更好的反射性能。总的来说，JEP 416 的引入旨在简化 Java 反射机制的维护工作，并提升其运行效率。</p><p>官方给的基准测试数据如下：</p><p>基准线（Java18 之前实现）</p><pre><code>Benchmark                                     Mode  Cnt   Score  Error  UnitsReflectionSpeedBenchmark.constructorConst     avgt   10  68.049 ± 0.872  ns/opReflectionSpeedBenchmark.constructorPoly      avgt   10  94.132 ± 1.805  ns/opReflectionSpeedBenchmark.constructorVar       avgt   10  64.543 ± 0.799  ns/opReflectionSpeedBenchmark.instanceFieldConst   avgt   10  35.361 ± 0.492  ns/opReflectionSpeedBenchmark.instanceFieldPoly    avgt   10  67.089 ± 3.288  ns/opReflectionSpeedBenchmark.instanceFieldVar     avgt   10  35.745 ± 0.554  ns/opReflectionSpeedBenchmark.instanceMethodConst  avgt   10  77.925 ± 2.026  ns/opReflectionSpeedBenchmark.instanceMethodPoly   avgt   10  96.094 ± 2.269  ns/opReflectionSpeedBenchmark.instanceMethodVar    avgt   10  80.002 ± 4.267  ns/opReflectionSpeedBenchmark.staticFieldConst     avgt   10  33.442 ± 2.659  ns/opReflectionSpeedBenchmark.staticFieldPoly      avgt   10  51.918 ± 1.522  ns/opReflectionSpeedBenchmark.staticFieldVar       avgt   10  33.967 ± 0.451  ns/opReflectionSpeedBenchmark.staticMethodConst    avgt   10  75.380 ± 1.660  ns/opReflectionSpeedBenchmark.staticMethodPoly     avgt   10  93.553 ± 1.037  ns/opReflectionSpeedBenchmark.staticMethodVar      avgt   10  76.728 ± 1.614  ns/op</code></pre><p>当前（Java18 实现）</p><pre><code>Benchmark                                     Mode  Cnt    Score   Error  UnitsReflectionSpeedBenchmark.constructorConst     avgt   10   32.392 ± 0.473  ns/opReflectionSpeedBenchmark.constructorPoly      avgt   10  113.947 ± 1.205  ns/opReflectionSpeedBenchmark.constructorVar       avgt   10   76.885 ± 1.128  ns/opReflectionSpeedBenchmark.instanceFieldConst   avgt   10   18.569 ± 0.161  ns/opReflectionSpeedBenchmark.instanceFieldPoly    avgt   10   98.671 ± 2.015  ns/opReflectionSpeedBenchmark.instanceFieldVar     avgt   10   54.193 ± 3.510  ns/opReflectionSpeedBenchmark.instanceMethodConst  avgt   10   33.421 ± 0.406  ns/opReflectionSpeedBenchmark.instanceMethodPoly   avgt   10  109.129 ± 1.959  ns/opReflectionSpeedBenchmark.instanceMethodVar    avgt   10   90.420 ± 2.187  ns/opReflectionSpeedBenchmark.staticFieldConst     avgt   10   19.080 ± 0.179  ns/opReflectionSpeedBenchmark.staticFieldPoly      avgt   10   92.130 ± 2.729  ns/opReflectionSpeedBenchmark.staticFieldVar       avgt   10   53.899 ± 1.051  ns/opReflectionSpeedBenchmark.staticMethodConst    avgt   10   35.907 ± 0.456  ns/opReflectionSpeedBenchmark.staticMethodPoly     avgt   10  102.895 ± 1.604  ns/opReflectionSpeedBenchmark.staticMethodVar      avgt   10   82.123 ± 0.629  ns/op</code></pre><p>从基准测试来看，新实现有好有坏，效果差别不大，基本符合新扩展便于维护又对性能没有明显影响的预期。</p><h2 id="JEP-418-Internet-Address-地址解析-SPI"><a href="#JEP-418-Internet-Address-地址解析-SPI" class="headerlink" title="JEP 418: Internet-Address 地址解析 SPI"></a>JEP 418: Internet-Address 地址解析 SPI</h2><p>JEP 418旨在改进Internet-Address 地址解析的灵活性和可配置性。具体来说，它引入了一个服务提供者接口（SPI），使得<code>java.net.InetAddress</code>可以使用平台内置解析器之外的第三方解析器。</p><p>在Java18之前版本中，Internet-Address 地址解析主要依赖于内置的解析器，这些解析器通常会结合本地的hosts文件和DNS来解析主机名和IP地址。然而，这种设计限制了开发者对解析器的选择和定制能力。通过引入SPI，JEP 418允许开发者自定义网络地址解析策略，从而提高了系统的灵活性和可扩展性。</p><p>例如，开发者可以通过实现SPI接口，创建自己的解析器，并将其注册到系统中，这样java.net.InetAddress.getByName()方法就可以使用这些自定义解析器来进行地址解析了。这不仅增强了系统的灵活性，还为特定需求提供了更多的选择和控制。</p><h2 id="预览功能"><a href="#预览功能" class="headerlink" title="预览功能"></a>预览功能</h2><h3 id="JEP-420-switch-模式匹配（第二次预览）"><a href="#JEP-420-switch-模式匹配（第二次预览）" class="headerlink" title="JEP 420: switch 模式匹配（第二次预览）"></a>JEP 420: switch 模式匹配（第二次预览）</h3><p>switch 模式匹配第一次预览是在Java17中（JEP 406，参见<a href="https://mp.weixin.qq.com/s/By2JoZqAHA6U36PG8qvCcg" target="_blank" rel="noopener">Java17 的新特性</a>），旨在通过引入模式匹配来增强Java编程语言的表达能力，使得在switch语句和表达式中可以更灵活地进行条件判断和分支选择。</p><p>JEP 420允许在switch的选择器表达式中使用任何引用类型，并且case标签可以包含模式，包括条件模式。这意味着开发者可以在switch语句中直接匹配变量的不同状态或类型，从而简化代码并提高其可读性和健壮性。</p><p>基于这个特性，我们可以将一个复杂的if-else结构转换为更加简洁的switch模式匹配结构，这不仅提高了代码的可维护性，还减少了出错的可能性。</p><p>此外，JEP 420还扩展了模式匹配的语言特性，使得开发者能够对数据进行更复杂、更直观的查询和操作。这种改进特别适用于处理多样的数据结构和复杂的数据查询场景，有助于提升开发效率和代码质量。</p><p>总结而言，JEP 420通过引入switch模式匹配，进一步丰富了Java的控制流结构，使代码编写更加高效和易懂。</p><p>在JEP 420中，switch语句的模式匹配语法如下：</p><pre><code class="java">switch (表达式) {case 模式1 -&gt; 操作1;case 模式2 -&gt; 操作2;// 可以有多个case子句default -&gt; 默认操作;}</code></pre><h2 id="孵化功能"><a href="#孵化功能" class="headerlink" title="孵化功能"></a>孵化功能</h2><h3 id="JEP-417-Vector-API（第三次孵化）"><a href="#JEP-417-Vector-API（第三次孵化）" class="headerlink" title="JEP 417: Vector API（第三次孵化）"></a>JEP 417: Vector API（第三次孵化）</h3><p>Vector 向量计算 API 是在 Java16 引入（JEP 338，参见 <a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a>），可以在运行时借助 CPU 向量运算指令，实现更优的计算能力。在 Java17 第二次孵化（JEP 414，参见<a href="https://mp.weixin.qq.com/s/By2JoZqAHA6U36PG8qvCcg" target="_blank" rel="noopener">Java17 的新特性</a>），针对性能和实现进行了改进，包括字节向量与布尔数组之间进行转换。</p><p>Vector 向量计算 API是一个为了高性能计算设计的API，旨在利用CPU的向量指令集来优化性能，特别是在科学计算领域。其目标是提供一种更高效的编程方式，为Java语言的未来发展奠定基础。</p><blockquote><p>Vector 向量计算 API在最新的Java23中还在孵化，一时半会还用不了，我们就持续关注着吧。</p></blockquote><h3 id="JEP-419-外部函数和内存-API-第二次孵化"><a href="#JEP-419-外部函数和内存-API-第二次孵化" class="headerlink" title="JEP 419: 外部函数和内存 API (第二次孵化)"></a>JEP 419: 外部函数和内存 API (第二次孵化)</h3><p>外部函数和内存 API第一次孵化是在Java17中（JEP 412，参见<a href="https://mp.weixin.qq.com/s/By2JoZqAHA6U36PG8qvCcg" target="_blank" rel="noopener">Java17 的新特性</a>）。</p><p>JEP 419旨在使Java程序能够更安全、高效地与本地代码和数据进行互操作。通过这个API，开发者可以调用JVM之外的外部函数，并且能够安全地访问不受JVM管理的外部内存。</p><p>具体来说，该API定义了一系列类和接口，使得客户端代码可以在库和应用程序中分配外部内存（如MemorySegment、MemoryAddress和SegmentAllocator）、操作和访问结构化外部内存（如MemoryLayout和VarHandle），并管理外部资源的生命周期。这使得Java程序无需使用JNI（Java Native Interface）即可直接调用本地库和处理本地数据，从而避免了JNI带来的潜在风险和复杂性。</p><p>通过更加优雅的方式访问外部函数是从 Java14 开始的，经历了多个孵化版本：</p><ul><li>Java14 的 JEP 370：外部存储器访问 API（孵化）</li><li>Java15 的 JEP 383：外部存储器访问 API（第二版孵化功能）</li><li>Java16 的 JEP 389：外部链接器 API（孵化功能）</li><li>Java16 的 JEP 393：外部存储器访问 API（第三版孵化功能）</li><li>Java17 的 JEP 412：外部函数和内存 API</li></ul><p>可以看出来，虽然一直在孵化，但是功能越来越强大了。</p><h2 id="弃用和删除"><a href="#弃用和删除" class="headerlink" title="弃用和删除"></a>弃用和删除</h2><h3 id="JEP-421-弃用-Finalization"><a href="#JEP-421-弃用-Finalization" class="headerlink" title="JEP 421: 弃用 Finalization"></a>JEP 421: 弃用 Finalization</h3><p>将 Finalization 标记为过期：<code>@Deprecated(forRemoval=true)</code>，具体API包括：</p><ul><li>java.lang.Object.finalize()</li><li>java.lang.Enum.finalize()</li><li>java.awt.Graphics.finalize()</li><li>java.awt.PrintJob.finalize()</li><li>java.util.concurrent.ThreadPoolExecutor.finalize()</li><li>javax.imageio.spi.ServiceRegistry.finalize()</li><li>javax.imageio.stream.FileCacheImageInputStream.finalize()</li><li>javax.imageio.stream.FileImageInputStream.finalize()</li><li>javax.imageio.stream.FileImageOutputStream.finalize()</li><li>javax.imageio.stream.ImageInputStreamImpl.finalize()</li><li>javax.imageio.stream.MemoryCacheImageInputStream.finalize()</li></ul><p>了解过JVM GC逻辑的都知道，finalize虽然提供了资源回收，但其实并不可靠和安全，为了规范使用，开始主键淘汰这些过期的设计方案。</p><p>关于资源回收，推荐使用 try-with-resources 或者 java.lang.ref.Cleaner，这些都是简单直接高效的回收方式。</p><p>我们应该在日常开发中，应该有意识的写优雅的代码。代码功力，没有武功秘笈可以在短时间快速提升，都是日常一行一行积攒的，量变引起质变，低质量的编码，是无法引起质变的。</p><p>你我共勉。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java18 新增的特性，完整的特性清单可以从 <a href="https://openjdk.org/projects/jdk/18/" target="_blank" rel="noopener">https://openjdk.org/projects/jdk/18/</a> 查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/By2JoZqAHA6U36PG8qvCcg" target="_blank" rel="noopener">Java17 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/W6Esovb7zzCL_seXgY84jA" target="_blank" rel="noopener">Java18 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/WutbAX_IQNqP4M3rud9f_g" target="_blank" rel="noopener">Java19 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/DvZYrZTtGfdXNsXGzmQN1A" target="_blank" rel="noopener">Java20 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/iiXa9rpJu1Vedpke0XpBzQ" target="_blank" rel="noopener">Java21 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/eHHFaJErH8XH4QSRrfcehQ" target="_blank" rel="noopener">Java22 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/XvB0D2vzhaAvHESupdALag" target="_blank" rel="noopener">Java23 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">Java24 的新特性</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java/java-18-features">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java18 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java18 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。让我们跟随 Java 的脚步，配合示例讲解，看一看每个版本的新特性，本期是 Java18 的新特性。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java18" scheme="https://www.howardliu.cn/tags/Java18/"/>
    
  </entry>
  
  <entry>
    <title>羊不羊的关我什么事？</title>
    <link href="https://www.howardliu.cn/what-i-think-of-covid-19/"/>
    <id>https://www.howardliu.cn/what-i-think-of-covid-19/</id>
    <published>2023-01-07T14:40:56.000Z</published>
    <updated>2023-01-07T14:40:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/raving/b919bbc6863c45cb94c7f5a0ce376f18.jpg" alt="这段经历终将成为历史"></p><blockquote><p>本文共：1976字 预计阅读时间：5分钟</p></blockquote><p>你好，我是看山。</p><p>不出意外，看到这篇文章的人八成阳了。</p><p>先放个统计，12月23号的时候，部门发起了一次投票，480人参与，只有20%的壮士还没阳。</p><a id="more"></a><p><img src="https://static.howardliu.cn/raving/1.jpeg" alt="是否感染新冠统计"></p><p>在这一波高峰期前，我们公司已经居家好几个周了，所以投票结果基本上能够反应社会情况。</p><p>今天就想聊两件事：</p><ol><li>为啥突然放开了？</li><li>我对放开的看法。</li></ol><h2 id="为啥放开"><a href="#为啥放开" class="headerlink" title="为啥放开"></a>为啥放开</h2><p>什么情况下可以放开？基本上有三种情况：</p><ol><li>第一种情况是大家希望的，像SARS一样，新冠病毒消失了；</li><li>第二种情况是不需要防，新冠病毒致死率重症率降低到可容忍范围（比如无限接近0），我们与病毒共生了；</li><li>第三种情况是防不住，虽然病毒致死率还很高，但一个眼神交流就会传染，防不胜防了。</li></ol><p>现在显然不是第一种情况。</p><p>我们先来看个数据：</p><p>新冠病毒原始毒株的R0值在3-5；德尔塔毒株的R0值为6-8；奥密克戎BA.1的R0值约为9.5；奥密克戎BA.2的R0值约为13.3；奥密克戎BA.4/5的R0值可能达到18.6……</p><p>R0值（R naught）是基本传染数（basic reproductive number）的简称，又译作基本再生数，指的是在没有采取任何干预措施的情况下，平均每位感染者在传染期内使易感者个体致病的数量。数字越大说明传播能力越强，控制难度越大。</p><p>简单说就是，R0是2时，一个传染俩，两个传四个，四个传八个，以此类推……经过4个循环，病例数就增加到64人。</p><p>咱们把新冠病毒的R0值做个图：</p><p><img src="https://static.howardliu.cn/raving/B1234E4F-0095-4002-99A4-74530209393F.png" alt="新冠集中毒株的R0值曲线"></p><p>这就是所谓的指数爆炸：</p><ul><li>当R0等于3的时候，经过4次传播，结果是81；</li><li>当R0等于6的时候，经过4次传播，结果是1296；</li><li>当R0等于9的时候，经过4次传播，结果是6561；</li><li>当R0等于13的时候，经过4次传播，结果是28561；</li><li>……</li></ul><p>当R0超过一定范围，不是我们想防就能防得住的。就比如年初的上海，奥密克戎的高传播性迅速击溃了精准防控，演变成后来的封城。</p><p>奥密克戎的变异株的传染能力还在增强，据说现在是21了（没有查到官方数据）。</p><p>这个时候，我们如果还想像前几年似的，想通过封控来阻断传染，就要举全国之力了。那种情况下，大家就只能待在家里，各种行业停摆。显然是不现实的，不是每家都有能够吃一个月的战略储备粮，也不是每家都能够啥也不干白来一个月钱的。</p><p>也就是说，现在是防不住了。</p><p><img src="https://static.howardliu.cn/raving/1BE20C5B-4E99-462F-A95C-60550E27304A.png" alt="不用下楼会感染了新冠"></p><p>然后我们再看看致病性，鉴于大家或者周围人都阳过，就算是有经验。我身边人阳了之后的征兆基本上这这几种：</p><ol><li>发烧，有的低烧好几天（免疫力差）、有的高烧一两天（免疫力强）；</li><li>咳嗽，干咳或者湿咳，因人而异；</li><li>嗓子疼，戏称宝娟嗓，严重地说不出话，感觉像是吞刀片一样；</li><li>浑身疼，主要变现是肌肉酸疼，浑身没劲；</li></ol><p>可以看到，这些症状和普通的流感很像。甚至没有抗原的情况下，都不能断定自己是流感还是新冠。</p><p>也就是说，大部分人阳了之后症状都很轻，且属于上呼吸道的症状，基本上对肺部没啥影响。</p><p>这样就符合第二种情况了，我们大多数人可以与新冠病毒共生了。</p><p>从经济的角度看，我们不可能无限期的收紧防控措施，很多企业在这段封控期间艰难度日，每一次收紧，企业都会受到冲击，我们没有办法不计成本的封控，孩子要长大，成人要工作，企业要发展，人们要生活。时移世易，当封控成本远远大于收益时，当感染后对身体影响很小时，我们就要选择更适合的方式。</p><h2 id="我的看法"><a href="#我的看法" class="headerlink" title="我的看法"></a>我的看法</h2><p>再来说下我对放开的看法：坚决拥护，但也会做好个人防护。</p><p>首先说个人防护，相信大家从各种渠道了解过，病毒是RNA复制，变异方向多变且速度快，就有概率出现传染性强且致死率高的毒株。只要我们做好防护，别让病毒在我们体内有复制的机会，那变异的机会就会少很多。</p><p>然后说坚决拥护，就这几周看过来，商场在渐渐恢复，大家生活轻松很多，连前几天几乎瘫痪的物流快递业，现在也逐渐恢复了。一切都在向好的方向发展，有什么理由不拥护呢？</p><p>给大家看一下北京地铁最近15日客流量和往年日均客流量图。</p><p><img src="https://static.howardliu.cn/raving/B5237931-A4EE-47B1-8E68-0B1A7399572C.png" alt="北京地铁最近15日客流量"></p><p><img src="https://static.howardliu.cn/raving/375EB016-DA3D-4D34-A161-CCF332189190.png" alt="北京地铁往年日均客流量"></p><p>最近15日客流量每个工作日都在递增，在1月6日已经达到769万。再看年日均客流，2023年刚开始7天，日均客流量已经达到去年平均水平。</p><p>回想前段时间，2022年11月25日客流量跌到了108万，在放开之后，逐步恢复生机。</p><p>从上帝视角看，中央踩刹车打方向盘的举措是正确的。就这几天复工经历看，同事们带着口罩，偶尔听到几声咳嗽，也都没人在意，我们以较小的成本实现了与新冠共存。</p><p>放一个新华社的<a href="https://h5.xinhuaxmt.com/h5/m1/covid19/index.html" target="_blank" rel="noopener">新冠防疫手册</a>，虽然病毒毒性弱了，但是阳的时候还是很难受的，能不重阳就不重阳吧。</p><p>最后，多年之后，当我们回忆起这三年，可能有感慨、有怀念、有悲伤，更多的可能是对当下美好生活的珍惜。</p><p>祝大家身体健康。</p><p><img src="https://static.howardliu.cn/raving/1FE35223-7DD2-4910-89C7-081ACCF12BE3.jpg" alt="护体金钟罩"></p><p>青山不改，绿水长流，我们下次见。</p><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/what-i-think-of-covid-19/">羊不羊的关我什么事？</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://static.howardliu.cn/raving/b919bbc6863c45cb94c7f5a0ce376f18.jpg&quot; alt=&quot;这段经历终将成为历史&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文共：1976字 预计阅读时间：5分钟&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你好，我是看山。&lt;/p&gt;
&lt;p&gt;不出意外，看到这篇文章的人八成阳了。&lt;/p&gt;
&lt;p&gt;先放个统计，12月23号的时候，部门发起了一次投票，480人参与，只有20%的壮士还没阳。&lt;/p&gt;
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="新冠" scheme="https://www.howardliu.cn/tags/%E6%96%B0%E5%86%A0/"/>
    
      <category term="covid-19" scheme="https://www.howardliu.cn/tags/covid-19/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实战：国际化组件 MessageSource 与 Nacos 组合实现动态配置能力</title>
    <link href="https://www.howardliu.cn/springboot-action-messagesource-nacos/"/>
    <id>https://www.howardliu.cn/springboot-action-messagesource-nacos/</id>
    <published>2022-08-14T02:52:50.000Z</published>
    <updated>2022-08-14T02:52:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/jellyfish-g1ec9e22b7_1920.jpeg" alt="SpringBoot 实战：国际化组件 MessageSource 与 Nacos 组合实现动态配置能力"></p><p>你好，我是看山。</p><p>前面介绍了 Spring 的 MessageSource 组件的用法、执行逻辑和源码，本文我们将根据前面的知识，实现自己的动态刷新的国际化组件。</p><a id="more"></a><p>现在大家都用的是微服务，为了高可用，每个服务部署时最少两个实例。</p><ul><li>如果使用<code>ResourceBundleMessageSource</code>实现国际化，每次修改配置文件，都需要重启服务。</li><li>如果使用<code>ReloadableResourceBundleMessageSource</code>，我们可以借助多个服务挂在同一个磁盘或同一个卷读取同一个配置文件，借助远程工具，修改文件实现动态配置内容的修改。但是这就涉及到文本编辑，不能很好的实现审计记录和文件管控。</li></ul><p>所以，我们要实现一个适用于微服务架构、方便修改、具备审计功能的动态的国际化配置组件。本文选择 Nacos 实现，Nacos 有配置中心的能力，适合在微服务架构中使用，同时也具备方便修改和审计能力，只要我们实现从 Nacos 加载国际化配置的能力，就可以轻松实现目标。</p><h2 id="几个关键点"><a href="#几个关键点" class="headerlink" title="几个关键点"></a>几个关键点</h2><p>Spring 提供的默认实现中，<code>ReloadableResourceBundleMessageSource</code>实现了动态刷新的能力，只不过是从文件读取内容，我们可以借助<code>ReloadableResourceBundleMessageSource</code>的逻辑实现，只是将其改为从 Nacos 读取内容。</p><p>这个实现，通常可以有两种方案（假设我们新实现的类命名为<code>NacosBundleMessageSource</code>）：</p><ol><li>继承<code>ReloadableResourceBundleMessageSource</code>：重写读取配置的方法，然后通过 Spring 注入新的方法。这种方式有优点和缺点：<ol><li>优点 1：我们可以保持与<code>ReloadableResourceBundleMessageSource</code>相似的结构和执行逻辑，当 Spring 进行升级的时候，我们直接通过继承获取了能力；</li><li>优点 2：我们只需要覆盖几个关键方法，需要重写的方法比较少；</li><li>缺点 1：当我们期望在系统中引入多种类型的 MessageSource 组件时，就不能简单的通过类型加载了。比如<code>applicationContext.getBean(ReloadableResourceBundleMessageSource.class)</code>会找到<code>ReloadableResourceBundleMessageSource</code>和<code>NacosBundleMessageSource</code>两个 Bean，Spring 容器就不知道该返回哪个了；</li><li>缺点 2：虽然继承能够少写代码，但是一旦 Spring 修改了执行逻辑，我们的<code>NacosBundleMessageSource</code>就可能需要重写。</li></ol></li><li>模仿<code>ReloadableResourceBundleMessageSource</code>：完全实现自己的一个动态加载类。与第一种的优缺点正好相反：<ol><li>优点 1：完全不同的类，Bean 对应的 class 类型不同，<code>applicationContext.getBean</code>可以通过 class 类型获取；</li><li>优点 2：与<code>ReloadableResourceBundleMessageSource</code>的类定义没有关系，除非 Spring 修改底层逻辑，否则不会因为<code>ReloadableResourceBundleMessageSource</code>的变动出现不兼容的情况；</li><li>缺点 1：当 Spring 对<code>ReloadableResourceBundleMessageSource</code>进行升级，提出更加优化的写法，我们就需要重写<code>NacosBundleMessageSource</code>了；</li><li>缺点 2：既然是仿写，很多方法都是与<code>ReloadableResourceBundleMessageSource</code>完全相同的重复代码。</li></ol></li></ol><p>考虑到两种方案的优缺点，结合业务中的逻辑，最终选择方案二。</p><h2 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h2><p>我们要实现的国际化组件，在 Spring 的实现中，使用的是<code>Locale</code>表示指定的区域，在这个类中，定义了三个不同的维度<code>language</code>、<code>country</code>、<code>variant</code>，翻译过来是<code>语言</code>、<code>国家</code>、<code>变种</code>，结合<code>BaseLocale</code>的定义，可以将<code>country</code>看做是语言大类。</p><p>根据前面的介绍，我们的国际化配置文件定义格式是根据<code>Locale</code>格式定义的。比如，basename 是 messages，Locale 是 de_AT_oo 的话，对应的配置文件可以是“messages_de_AT_OO”、“messages_de_AT”、“messages_de”。</p><p>所以我们需要用到递归的方式获取文件名：</p><pre><code class="java">protected List&lt;String&gt; calculateFilenamesForLocale(String basename, Locale locale) {    List&lt;String&gt; result = new ArrayList&lt;&gt;(3);    String language = locale.getLanguage();    String country = locale.getCountry();    String variant = locale.getVariant();    StringBuilder temp = new StringBuilder(basename);    temp.append(&#39;_&#39;);    if (language.length() &gt; 0) {        temp.append(language);        result.add(0, temp.toString());    }    temp.append(&#39;_&#39;);    if (country.length() &gt; 0) {        temp.append(country);        result.add(0, temp.toString());    }    if (variant.length() &gt; 0 &amp;&amp; (language.length() &gt; 0 || country.length() &gt; 0)) {        temp.append(&#39;_&#39;).append(variant);        result.add(0, temp.toString());    }    return result;}</code></pre><h2 id="加载方式"><a href="#加载方式" class="headerlink" title="加载方式"></a>加载方式</h2><p>既然是从 Nacos 读取配置，那配置文件的内容就需要通过 Nacos 获取。这里使用了<code>NacosConfigManager</code>获取：</p><pre><code class="java">protected Properties loadProperties(String filename) throws IOException, NacosException {    final Properties props = newProperties();    final String dataId = filename + NacosConstants.PROPERTIES_SUFFIX;    logger.info(&quot;Loading properties for &quot; + dataId);    final String config = nacosConfigManager.getConfigService().getConfig(dataId, nacosGroup, 5000);    if (StringUtils.hasText(config)) {        logger.info(&quot;No properties found for &quot; + dataId);        throw new NoSuchFileException(dataId);    }    try (Reader reader = new StringReader(config)) {        this.propertiesPersister.load(props, reader);        logger.info(&quot;Loaded properties for &quot; + dataId);    }    return props;}</code></pre><p>方法传入的<code>filename</code>就是从上一节中获取的文件名。当然，文件名是我们计算出来的，可能不存在，此处直接抛出<code>NoSuchFileException</code>，由上层逻辑捕捉处理：</p><pre><code class="java">protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder) {    long refreshTimestamp = (getCacheMillis() &lt; 0 ? -1 : System.currentTimeMillis());    try {        Properties props = loadProperties(filename);        propHolder = new PropertiesHolder(props, -1);    } catch (NacosException ex) {        if (logger.isWarnEnabled()) {            logger.warn(&quot;Could not get properties form nacos &quot;, ex);        }        // Empty holder representing &quot;not valid&quot;.        propHolder = new PropertiesHolder();    } catch (IOException ex) {        if (logger.isInfoEnabled()) {            logger.info(&quot;Could not get properties form nacos, the message is &quot; + ex.getMessage());        }        // Empty holder representing &quot;not valid&quot;.        propHolder = new PropertiesHolder();    }    propHolder.setRefreshTimestamp(refreshTimestamp);    this.cachedProperties.put(filename, propHolder);    logger.info(&quot;Refreshed properties for &quot; + filename);    return propHolder;}</code></pre><p>我们可以看到，从 Nacos 中读取配置逻辑的上层会捕捉<code>Exception</code>，然后创建一个空的配置管理器。此处会有两个异常：</p><ul><li><code>NacosException</code>：读取 Nacos 失败抛出的异常，包括 Nacos 链接不正确或者是读取失败等；</li><li><code>IOException</code>：没有指定文件名的配置时会抛出 IOException。</li></ul><h2 id="动态刷新"><a href="#动态刷新" class="headerlink" title="动态刷新"></a>动态刷新</h2><p>前一节讲了加载 Nacos 配置文件的方式，本节说一下怎么实现 Nacos 配置文件的监听，动态刷新配置内容。</p><p>我们先介绍一下实现 Nacos 监听的几个类：</p><ul><li>NacosRefreshHistory：nacos 配置文件刷新的历史记录，会保存 Nacos 配置文件的刷新历史，最多存储 20 个；</li><li>ConfigService：一般使用的时候是 NacosConfigService 类，这个类是使用<code>NacosConfigManager#getConfigService</code>通过反射创建的，用于存储 Nacos 监听器，实现监听逻辑；</li><li>Listener：这个就是具体的监听器了，在我们的例子中，使用的是<code>AbstractSharedListener</code>的匿名子类，实现动态刷新的逻辑就在这个类里。</li></ul><p>首先，我们当前组件是 MessageSource，用于实现国际化的组件。这个组件是在整个应用就绪后再加载就行，所以，我们监听 Spring 的<code>ApplicationReadyEvent</code>事件即可。</p><pre><code class="java">@Overridepublic void onApplicationEvent(ApplicationReadyEvent event) {    // many Spring context    if (this.ready.compareAndSet(false, true)) {        for (Locale defaultLocale : this.nacosBundleMessageSource.defaultLocales()) {            this.nacosBundleMessageSource.getMergedProperties(defaultLocale);        }        this.registerNacosListenersForApplications();    }}</code></pre><p>然后是我们需要对所有可能的配置文件进行监听，就需要用到前文的<code>calculateFilenamesForLocale</code>方法，计算所有可能出现的名字。</p><pre><code class="java">private void registerNacosListenersForApplications() {    if (!isRefreshEnabled()) {        return;    }    this.nacosBundleMessageSource.getBasenameSet().stream()            .map(basename -&gt; this.nacosBundleMessageSource.defaultLocales().stream()                    .map(locale -&gt; this.nacosBundleMessageSource.calculateAllFilenames(basename, locale))                    .flatMap(List::stream)                    .collect(Collectors.toList())            )            .flatMap(List::stream)            .forEach(x -&gt; registerNacosListener(nacosBundleMessageSource.getNacosGroup(), x + NacosConstants.PROPERTIES_SUFFIX));}</code></pre><p>最后，我们需要向 Nacos 的运行管理器中注册文件监听，实现动态刷新的能力。</p><pre><code class="java">private void registerNacosListener(final String groupKey, final String dataKey) {    final String key = NacosPropertySourceRepository.getMapKey(dataKey, groupKey);    final Listener listener = listenerMap.computeIfAbsent(key, lst -&gt; new AbstractSharedListener() {        @Override        public void innerReceive(String dataId, String group, String configInfo) {            refreshCountIncrement();            nacosRefreshHistory.addRefreshRecord(dataId, group, configInfo);            try {                nacosBundleMessageSource.forceRefresh(dataId, configInfo);                if (log.isDebugEnabled()) {                    log.debug(&quot;Refresh Nacos config group={},dataId={},configInfo={}&quot;, group, dataId, configInfo);                }            } catch (IOException e) {                log.warn(&quot;Nacos refresh failed, dataId: {}, group: {}, configInfo: {}&quot;,                        dataId, group, configInfo, e);            }        }    });    try {        configService.addListener(dataKey, groupKey, listener);    } catch (NacosException e) {        log.warn(&quot;register fail for nacos listener ,dataId=[{}],group=[{}]&quot;, dataKey, groupKey, e);    }}</code></pre><p>至此，我们获取了国际化组件 MessageSource 与 Nacos 组合实现动态配置能力。本文中的实例已经传到 GitHub，关注公众号「看山的小屋」，回复<code>spring</code>获取源码。</p><h2 id="发散一下"><a href="#发散一下" class="headerlink" title="发散一下"></a>发散一下</h2><p>接下来，我们再重头想一下，我们最初想要实现一个适用于微服务架构、方便修改、具备审计功能的动态的国际化配置组件。选择 Nacos 作为例子，是因为 Nacos 本身实现了动态监听的能力，可以快速复刻<code>ReloadableResourceBundleMessageSource</code>的能力。那 Nacos 具备什么能力呢？</p><ol><li>中心化存储：因为我们想在微服务架构中使用，就不能采用与独立服务耦合的方式，需要所有服务可以读取的方式。比如数据库（包括关系型数据库、非关系型数据库等）、分布式缓存、远程磁盘（或者 Docker 的卷）等；</li><li>可监听：任何配置的修改能够被服务感知，想要做到这个，就是在配置发生修改时，发送一个修改时间，通知监听服务配置被修改。可以采用被动和主动两种方式：<ol><li>被动方式：这个比较简单，只要将组件中的缓存逻辑删除就可以了，每次查询配置都直接存储器中读取，但是这又与性能相悖，一般不采用这个方案；</li><li>主动方式：通过发送事件或者消息的方式，比如采用 CQRS 模式，发生修改时，发送一条消息，各个微服务监听这个消息，重新加载配置；</li></ol></li><li>可审计：这个能力简单说就是要记录每次修改的时间、人物、动作等信息，这个功能是常用功能，这里就不赘述了。</li></ol><p>只要具备上面三个特性，我们可以通过各种组合实现，比如：</p><ol><li>可挂在磁盘</li><li>Git+Hook</li><li>MySQL+Redis+MQ</li><li>……</li></ol><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文从实践角度出发，实现了一个适用于微服务架构、方便修改、具备审计功能的动态的国际化配置组件。文中的实例已经传到 GitHub，关注公众号「看山的小屋」，回复<code>spring</code>获取源码。如果是你，你会采用哪种方案呢？欢迎一起讨论。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/zUrx7duy0-OY1oYn8FeKOw" target="_blank" rel="noopener">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://mp.weixin.qq.com/s/H599Wri3VbjTuLBnf7pD3w" target="_blank" rel="noopener">SpringBoot 实战：如何优雅地处理异常</a></li><li><a href="https://mp.weixin.qq.com/s/fcVE-cE7tDuWKoNNX9rsoQ" target="_blank" rel="noopener">SpringBoot 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://mp.weixin.qq.com/s/xQQbl6VNF2eCgmQPrMyc4w" target="_blank" rel="noopener">SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li><li><a href="https://mp.weixin.qq.com/s/coKjuefWMmCA4bSkRDIRVA" target="_blank" rel="noopener">SpringBoot 实战：优雅地使用枚举参数</a></li><li><a href="https://mp.weixin.qq.com/s/pet_rA7-O1JD3QfQ1fqxAQ" target="_blank" rel="noopener">SpringBoot 实战：优雅地使用枚举参数（原理篇）</a></li><li><a href="https://mp.weixin.qq.com/s/2OXArNObVejXLvMOmE3oqw" target="_blank" rel="noopener">SpringBoot 实战：在 RequestBody 中优雅地使用枚举参数</a></li><li><a href="https://mp.weixin.qq.com/s/hdioIIwPA2lv2khfRmKhOQ" target="_blank" rel="noopener">SpringBoot 实战：在 RequestBody 中优雅地使用枚举参数（原理篇）</a></li><li><a href="https://mp.weixin.qq.com/s/vbccn0kTdyOlmznDr3RItw" target="_blank" rel="noopener">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a></li><li><a href="https://mp.weixin.qq.com/s/s8PQXLT8Ni3dLqsOgf3syA" target="_blank" rel="noopener">SpringBoot 实战：加载和读取资源文件内容</a></li><li><a href="https://mp.weixin.qq.com/s/dGPhS5vdbnFdiTxkpr2mLg" target="_blank" rel="noopener">SpringBoot 实战：国际化组件 MessageSource</a></li><li><a href="https://mp.weixin.qq.com/s/FzX-nVMl96RwI6ITULhQcQ" target="_blank" rel="noopener">SpringBoot 实战：国际化组件MessageSource的执行逻辑与源码</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/springboot-action-messagesource-nacos/">SpringBoot 实战：国际化组件 MessageSource 与 Nacos 组合实现动态配置能力</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">SpringBoot 实战：国际化组件 MessageSource 与 Nacos 组合实现动态配置能力</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      前面介绍了 Spring 的 MessageSource 组件的用法、执行逻辑和源码，本文我们将根据前面的知识，实现自己的动态刷新的国际化组件。
    
    </summary>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/categories/spring/"/>
    
    
      <category term="SpringBoot 实战" scheme="https://www.howardliu.cn/tags/SpringBoot-%E5%AE%9E%E6%88%98/"/>
    
      <category term="SpringBoot" scheme="https://www.howardliu.cn/tags/SpringBoot/"/>
    
      <category term="spring" scheme="https://www.howardliu.cn/tags/spring/"/>
    
      <category term="SpringBoot 手册" scheme="https://www.howardliu.cn/tags/SpringBoot-%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实战：国际化组件 MessageSource 的执行逻辑与源码</title>
    <link href="https://www.howardliu.cn/springboot-action-messagesource-principle/"/>
    <id>https://www.howardliu.cn/springboot-action-messagesource-principle/</id>
    <published>2022-08-07T13:04:19.000Z</published>
    <updated>2022-08-07T13:04:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/squirrel-7025721_1920.jpeg" alt="SpringBoot 实战：国际化组件 MessageSource 的执行逻辑与源码"></p><p>你好，我是看山。</p><p>前文介绍了 SpringBoot 中的国际化组件<code>MessageSource</code>的使用，本章我们一起看下<code>ResourceBundleMessageSource</code>和<code>ReloadableResourceBundleMessageSource</code>的执行逻辑。SpringBoot 的 MessageSource 组件有很多抽象化，源码看起来比较分散，所以本文会通过流程图的方式进行讲解。</p><a id="more"></a><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>配置文件是基础，会影响执行逻辑，我们先来看下配置项：</p><ul><li>basename：加载资源的文件名，可以多个资源名称，通过逗号隔开，默认是“messages”；</li><li>encoding：加载文件的字符集，默认是 UTF-8，这个不多说；</li><li>cacheDuration：文件加载到内存后缓存时间，默认单位是秒。如果没有设置，只会加载一次缓存，不会自动更新。这个参数在 ResourceBundleMessageSource、ReloadableResourceBundleMessageSource 稍微有些差异，会具体说下。</li><li>fallbackToSystemLocale：这是一个兜底开关。默认情况下，如果在指定语言中找不到对应的值，会从 basename 参数（默认是 messages.properties）中查找，如果再找不到可能直接返回或抛错。该参数设置为 true 的话，还会再走一步兜底逻辑，从当前系统语言对应配置文件中查找。该参数默认是 true；</li><li>alwaysUseMessageFormat：MessageSource 组件通过<code>MessageFormat.format</code>函数对国际化信息格式化，如果注入参数，输出结果是经过格式化的。比如<code>MessageFormat.format(&quot;Hello, {0}!&quot;, &quot;Kanshan&quot;)</code>输出结果是“Hello, Kanshan!”。该参数控制的是，当输入参数为空时，是否还是使用<code>MessageFormat.format</code>函数对结果进行格式化，默认是 false；</li><li>useCodeAsDefaultMessage：当没有找到对应信息的时候，是否返回 code。也就是当找了所有能找的配置文件后，还是没有找到对应的信息，是否直接返回 code 值。默认是 false，即不返回 code，抛出<code>NoSuchMessageException</code>异常。</li></ul><p>这些配置参数都有各自的默认值。如果没有特殊的需求，可以直接直接按照默认约定使用。</p><h2 id="执行逻辑"><a href="#执行逻辑" class="headerlink" title="执行逻辑"></a>执行逻辑</h2><p>接下来我们看下流程图，下面的流程图绿色部分是 cacheDuration 没有配置的情况。对于 ResourceBundleMessageSource 是只加载一次配置文件，ReloadableResourceBundleMessageSource 会根据文件修改时间判断是否需要重新加载。</p><h3 id="ResourceBundleMessageSource-的流程图"><a href="#ResourceBundleMessageSource-的流程图" class="headerlink" title="ResourceBundleMessageSource 的流程图"></a>ResourceBundleMessageSource 的流程图</h3><p><img src="https://static.howardliu.cn/spring/springboot-messagesource-ResourceBundleMessageSource.png" alt="ResourceBundleMessageSource"></p><h3 id="ReloadableResourceBundleMessageSource-的流程图"><a href="#ReloadableResourceBundleMessageSource-的流程图" class="headerlink" title="ReloadableResourceBundleMessageSource 的流程图"></a>ReloadableResourceBundleMessageSource 的流程图</h3><p><img src="https://static.howardliu.cn/spring/springboot-messagesource-ReloadableResourceBundleMessageSource.png" alt="ReloadableResourceBundleMessageSource"></p><h3 id="AbstractMessageSource-的几个-getMessage-方法源码"><a href="#AbstractMessageSource-的几个-getMessage-方法源码" class="headerlink" title="AbstractMessageSource 的几个 getMessage 方法源码"></a>AbstractMessageSource 的几个 getMessage 方法源码</h3><pre><code class="java">@Overridepublic final String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale) {    String msg = getMessageInternal(code, args, locale);    if (msg != null) {        return msg;    }    if (defaultMessage == null) {        return getDefaultMessage(code);    }    return renderDefaultMessage(defaultMessage, args, locale);}@Overridepublic final String getMessage(String code, @Nullable Object[] args, Locale locale) throws NoSuchMessageException {    String msg = getMessageInternal(code, args, locale);    if (msg != null) {        return msg;    }    String fallback = getDefaultMessage(code);    if (fallback != null) {        return fallback;    }    throw new NoSuchMessageException(code, locale);}@Overridepublic final String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException {    String[] codes = resolvable.getCodes();    if (codes != null) {        for (String code : codes) {            String message = getMessageInternal(code, resolvable.getArguments(), locale);            if (message != null) {                return message;            }        }    }    String defaultMessage = getDefaultMessage(resolvable, locale);    if (defaultMessage != null) {        return defaultMessage;    }    throw new NoSuchMessageException(!ObjectUtils.isEmpty(codes) ? codes[codes.length - 1] : &quot;&quot;, locale);}</code></pre><p>第一个<code>getMessage</code>方法，是可以传入默认值<code>defaultMessage</code>的，也就是当所有 basename 的配置文件中不存在 code 指定的值，就会使用<code>defaultMessage</code>值进行格式化返回。</p><p>第二个<code>getMessage</code>方法，是通过判断<code>useCodeAsDefaultMessage</code>配置，如果设置了 true，在所有 basename 的配置文件中不存在 code 指定的值的情况下，会返回 code 作为返回值。但是当设置为 false 时，code 不存在的情况下，会抛出<code>NoSuchMessageException</code>异常。</p><p>第三个<code>getMessage</code>方法，传入的是<code>MessageSourceResolvable</code>接口对象，查找的 code 更加多种多样。不过如果最后还是找不到，会抛出<code>NoSuchMessageException</code>异常。</p><h2 id="缓存的使用"><a href="#缓存的使用" class="headerlink" title="缓存的使用"></a>缓存的使用</h2><p>我们看源码不仅仅是为了看功能组件的实现，还是学习更加优秀的编程方式。比如下面这段内存缓存的使用，Spring 源码中很多地方都用到了这种内存缓存的使用方式：</p><pre><code class="java">// 两层 Map，第一层是 basename，第二层是 localeprivate final Map&lt;String, Map&lt;Locale, ResourceBundle&gt;&gt; cachedResourceBundles =        new ConcurrentHashMap&lt;&gt;();@Nullableprotected ResourceBundle getResourceBundle(String basename, Locale locale) {    if (getCacheMillis() &gt;= 0) {        // Fresh ResourceBundle.getBundle call in order to let ResourceBundle        // do its native caching, at the expense of more extensive lookup steps.        return doGetBundle(basename, locale);    }    else {        // Cache forever: prefer locale cache over repeated getBundle calls.        // 先从缓存中获取第一层 basename 的缓存        Map&lt;Locale, ResourceBundle&gt; localeMap = this.cachedResourceBundles.get(basename);        if (localeMap != null) {            // 如果命中第一层，在通过 locale 获取第二层的值            ResourceBundle bundle = localeMap.get(locale);            if (bundle != null) {                // 如果命中第二层缓存，直接返回                return bundle;            }        }        try {            // 走到这里，说明没有命中缓存，就根据 basename 和 locale 创建对象            ResourceBundle bundle = doGetBundle(basename, locale);            if (localeMap == null) {                // 如果 localeMap 为空，说明第一级就不存在，通过 Map 的 computeIfAbsent 方法初始化                localeMap = this.cachedResourceBundles.computeIfAbsent(basename, bn -&gt; new ConcurrentHashMap&lt;&gt;());            }            // 将新建的 ResourceBundle 对象放入 localeMap 中            localeMap.put(locale, bundle);            return bundle;        }        catch (MissingResourceException ex) {            if (logger.isWarnEnabled()) {                logger.warn(&quot;ResourceBundle [&quot; + basename + &quot;] not found for MessageSource: &quot; + ex.getMessage());            }            // Assume bundle not found            // -&gt; do NOT throw the exception to allow for checking parent message source.            return null;        }    }}</code></pre><p>还有一种使用 Map 实现内存缓存的写法，比如我们就对上面的这个方法进行改写：</p><pre><code class="java">public class ResourceBundleMessageSourceExt extends ResourceBundleMessageSource {    private final Map&lt;BasenameLocale, ResourceBundle&gt; cachedResourceBundles = new ConcurrentHashMap&lt;&gt;();    @Override    protected ResourceBundle getResourceBundle(String basename, Locale locale) {        if (getCacheMillis() &gt;= 0) {            // Fresh ResourceBundle.getBundle call in order to let ResourceBundle            // do its native caching, at the expense of more extensive lookup steps.            return doGetBundle(basename, locale);        } else {            // Cache forever: prefer locale cache over repeated getBundle calls.            final BasenameLocale basenameLocale = new BasenameLocale(basename, locale);            ResourceBundle resourceBundle = this.cachedResourceBundles.get(basenameLocale);            if (resourceBundle != null) {                return resourceBundle;            }            try {                ResourceBundle bundle = doGetBundle(basename, locale);                this.cachedResourceBundles.put(basenameLocale, bundle);                return bundle;            } catch (MissingResourceException ex) {                if (logger.isWarnEnabled()) {                    logger.warn(&quot;ResourceBundle [&quot; + basename + &quot;] not found for MessageSource: &quot; + ex.getMessage());                }                // Assume bundle not found                // -&gt; do NOT throw the exception to allow for checking parent message source.                return null;            }        }    }    public record BasenameLocale(String basename, Locale locale) {        @Override        public boolean equals(Object o) {            if (this == o) {                return true;            }            if (o == null || getClass() != o.getClass()) {                return false;            }            BasenameLocale that = (BasenameLocale) o;            return basename.equals(that.basename) &amp;&amp; locale.equals(that.locale);        }        @Override        public int hashCode() {            return Objects.hash(basename, locale);        }    }}</code></pre><p>我们可以利用 Map 是通过<code>equals</code>判断 key 是否一致的原理，创建一个包含 basename、locale 的对象<code>BasenameLocale</code>，然后改写<code>cachedResourceBundles</code>为一层 Map，会简化一些判断逻辑。</p><blockquote><p>此处的<code>BasenameLocale</code>是<code>record</code>类型，具体语法可以参考 <a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a> 中的 Record 类型一节。</p></blockquote><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文先介绍了 MessageSource 的配置项，然后通过流程图的方式介绍了<code>ResourceBundleMessageSource</code>和<code>ReloadableResourceBundleMessageSource</code>的执行逻辑，最后分享了两个使用 Map 实现内存缓存的方式。</p><p>下一节我们将扩展 MessageSource，实现从 Nacos 加载配置内容，同时实现动态修改配置内容的功能。</p><p>本文中的实例已经传到 GitHub，关注公众号「看山的小屋」，回复<code>spring</code>获取源码。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/zUrx7duy0-OY1oYn8FeKOw" target="_blank" rel="noopener">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://mp.weixin.qq.com/s/H599Wri3VbjTuLBnf7pD3w" target="_blank" rel="noopener">SpringBoot 实战：如何优雅的处理异常</a></li><li><a href="https://mp.weixin.qq.com/s/fcVE-cE7tDuWKoNNX9rsoQ" target="_blank" rel="noopener">SpringBoot 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://mp.weixin.qq.com/s/xQQbl6VNF2eCgmQPrMyc4w" target="_blank" rel="noopener">SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li><li><a href="https://mp.weixin.qq.com/s/coKjuefWMmCA4bSkRDIRVA" target="_blank" rel="noopener">SpringBoot 实战：优雅的使用枚举参数</a></li><li><a href="https://mp.weixin.qq.com/s/pet_rA7-O1JD3QfQ1fqxAQ" target="_blank" rel="noopener">SpringBoot 实战：优雅的使用枚举参数（原理篇）</a></li><li><a href="https://mp.weixin.qq.com/s/2OXArNObVejXLvMOmE3oqw" target="_blank" rel="noopener">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</a></li><li><a href="https://mp.weixin.qq.com/s/hdioIIwPA2lv2khfRmKhOQ" target="_blank" rel="noopener">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</a></li><li><a href="https://mp.weixin.qq.com/s/vbccn0kTdyOlmznDr3RItw" target="_blank" rel="noopener">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a></li><li><a href="https://mp.weixin.qq.com/s/s8PQXLT8Ni3dLqsOgf3syA" target="_blank" rel="noopener">SpringBoot 实战：加载和读取资源文件内容</a></li><li><a href="https://mp.weixin.qq.com/s/dGPhS5vdbnFdiTxkpr2mLg" target="_blank" rel="noopener">SpringBoot 实战：国际化组件 MessageSource</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/springboot-action-messagesource-principle/">SpringBoot 实战：国际化组件 MessageSource 的执行逻辑与源码</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">SpringBoot 实战：国际化组件 MessageSource 的执行逻辑与源码</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      掌握 MessageSource 的原理，我们才能更好的扩展。
    
    </summary>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/categories/spring/"/>
    
    
      <category term="SpringBoot 实战" scheme="https://www.howardliu.cn/tags/SpringBoot-%E5%AE%9E%E6%88%98/"/>
    
      <category term="SpringBoot" scheme="https://www.howardliu.cn/tags/SpringBoot/"/>
    
      <category term="spring" scheme="https://www.howardliu.cn/tags/spring/"/>
    
      <category term="SpringBoot 手册" scheme="https://www.howardliu.cn/tags/SpringBoot-%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实战：国际化组件 MessageSource</title>
    <link href="https://www.howardliu.cn/springboot-action-messagesource/"/>
    <id>https://www.howardliu.cn/springboot-action-messagesource/</id>
    <published>2022-07-30T03:26:55.000Z</published>
    <updated>2022-07-30T03:26:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/taiwan-3511017.jpeg" alt="SpringBoot 实战：国际化组件 MessageSource"></p><p>你好，我是看山。</p><p>咱们今天一起来聊聊 SpringBoot 中的国际化组件 MessageSource。</p><a id="more"></a><h2 id="初识-MessageSource"><a href="#初识-MessageSource" class="headerlink" title="初识 MessageSource"></a>初识 MessageSource</h2><p>先看一下类图：</p><p><img src="https://static.howardliu.cn/spring/MessageSource.png" alt="MessageSource 类图"></p><p>从类图可以看到，Spring 内置的<code>MessageSource</code>有三个实现类：</p><ul><li>ResourceBundleMessageSource：通过 JDK 提供的 ResourceBundle 加载资源文件；</li><li>ReloadableResourceBundleMessageSource：通过 PropertiesPersister 加载资源，支持 xml、properties 两个格式，优先加载 properties 格式的文件。如果同时存在 properties 和 xml 的文件，会只加载 properties 的内容；</li><li>StaticMessageSource：是手动注入国际化内容，相当于手写代码。因为比较简单，而且实际用处不大，所以暂时不做讨论。</li></ul><p>在 SpringBoot 中，默认创建 ResourceBundleMessageSource 实例实现国际化输出。标准的配置通过<code>MessageSourceProperties</code>类注入：</p><ul><li>basename：加载资源的文件名，可以多个资源名称，通过逗号隔开，默认是“messages”；</li><li>encoding：加载文件的字符集，默认是 UTF-8，这个不多说；</li><li>cacheDuration：文件加载到内存后缓存时间，默认单位是秒。如果没有设置，只会加载一次缓存，不会自动更新。这个参数在 ResourceBundleMessageSource、ReloadableResourceBundleMessageSource 稍微有些差异，会具体说下。</li><li>fallbackToSystemLocale：这是一个兜底开关。默认情况下，如果在指定语言中找不到对应的值，会从 basename 参数（默认是 messages.properties）中查找，如果再找不到可能直接返回或抛错。该参数设置为 true 的话，还会再走一步兜底逻辑，从当前系统语言对应配置文件中查找。该参数默认是 true；</li><li>alwaysUseMessageFormat：MessageSource 组件通过<code>MessageFormat.format</code>函数对国际化信息格式化，如果注入参数，输出结果是经过格式化的。比如<code>MessageFormat.format(&quot;Hello, {0}!&quot;, &quot;Kanshan&quot;)</code>输出结果是“Hello, Kanshan!”。该参数控制的是，当输入参数为空时，是否还是使用<code>MessageFormat.format</code>函数对结果进行格式化，默认是 false；</li><li>useCodeAsDefaultMessage：当没有找到对应信息的时候，是否返回 code。也就是当找了所有能找的配置文件后，还是没有找到对应的信息，是否直接返回 code 值。默认是 false，即不返回 code，抛出<code>NoSuchMessageException</code>异常。</li></ul><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>从上面我们知道了一些简单的配置，但是还是没有办法知道 MessageSource 到底是什么，本节我们举个例子小试牛刀。</p><p>首先从<a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a>创建一个最少依赖<code>spring-boot-starter-web</code>的 SpringBoot 项目。</p><p>然后在 resources 目录下定义一组国际化配置文件，我们这里使用默认配置，所以 basename 是 messages：</p><pre><code class="properties">## messages.propertiesmessage.code1=[DEFAULT]code onemessage.code2=[DEFAULT]code twomessage.code3=[DEFAULT]code threemessage.code4=[DEFAULT]code fourmessage.code5=[DEFAULT]code fivemessage.code6=[DEFAULT]code six## messages_en.propertiesmessage.code2=[en]code two## messages_en_US.propertiesmessage.code3=[en_US]code three## messages_zh.propertiesmessage.code4=[中文] 丁字号## messages_zh_CN.propertiesmessage.code5=[大陆区域中文] 戊字号## messages_zh_Hans.propertiesmessage.code6=[简体中文] 己字号</code></pre><p>一个定义了六个配置文件：</p><ul><li>messages.properties：默认配置文件</li><li>messages_en.properties：英文配置文件</li><li>messages_en_US.properties：英文美国配置文件</li><li>messages_zh.properties：中文配置文件</li><li>messages_zh_CN.properties：中文中国大陆区域配置文件</li><li>messages_zh_Hans.properties：简体中文配置文件</li></ul><p>从上面配置文件的命名可以看出，都是以 basename 开头，后面跟上语系和地区，三个参数以下划线分隔。</p><p>可以支持的语言和国家可以从<code>java.util.Locale</code>查找。</p><p>最后我们定义一个 Controller 实验：</p><pre><code class="java">@RestControllerpublic class HelloController {    @Autowired    private MessageSource messageSource;    @GetMapping(&quot;m1&quot;)    public List&lt;String&gt; m1(Locale locale) {        final List&lt;String&gt; multi = new ArrayList&lt;&gt;();        multi.add(messageSource.getMessage(&quot;message.code1&quot;, null, locale));        multi.add(messageSource.getMessage(&quot;message.code2&quot;, null, locale));        multi.add(messageSource.getMessage(&quot;message.code3&quot;, null, locale));        multi.add(messageSource.getMessage(&quot;message.code4&quot;, null, locale));        multi.add(messageSource.getMessage(&quot;message.code5&quot;, null, locale));        multi.add(messageSource.getMessage(&quot;message.code6&quot;, null, locale));        return multi;    }}</code></pre><p>我们通过不同的请求查看结果：</p><pre><code class="http">### 默认GET http://localhost:8080/m1### 结果是：[  &quot;[DEFAULT]code one&quot;,  &quot;[DEFAULT]code two&quot;,  &quot;[DEFAULT]code three&quot;,  &quot;[中文] 丁字号&quot;,  &quot;[大陆区域中文] 戊字号&quot;,  &quot;[简体中文] 己字号&quot;]### local: enGET http://localhost:8080/m1Accept-Language: en### 结果是：[  &quot;[DEFAULT]code one&quot;,  &quot;[en]code two&quot;,  &quot;[DEFAULT]code three&quot;,  &quot;[DEFAULT]code four&quot;,  &quot;[DEFAULT]code five&quot;,  &quot;[DEFAULT]code six&quot;]### local: en-USGET http://localhost:8080/m1Accept-Language: en-US### 结果是：[  &quot;[DEFAULT]code one&quot;,  &quot;[en]code two&quot;,  &quot;[en_US]code three&quot;,  &quot;[DEFAULT]code four&quot;,  &quot;[DEFAULT]code five&quot;,  &quot;[DEFAULT]code six&quot;]### local: zhGET http://localhost:8080/m1Accept-Language: zh### 结果是：[  &quot;[DEFAULT]code one&quot;,  &quot;[DEFAULT]code two&quot;,  &quot;[DEFAULT]code three&quot;,  &quot;[中文] 丁字号&quot;,  &quot;[DEFAULT]code five&quot;,  &quot;[DEFAULT]code six&quot;]### local: zh-CNGET http://localhost:8080/m1Accept-Language: zh-CN### 结果是：[  &quot;[DEFAULT]code one&quot;,  &quot;[DEFAULT]code two&quot;,  &quot;[DEFAULT]code three&quot;,  &quot;[中文] 丁字号&quot;,  &quot;[大陆区域中文] 戊字号&quot;,  &quot;[DEFAULT]code six&quot;]</code></pre><p>从上面的结果可以看出：</p><ol><li>默认情况下，HTTP 请求没有传语言，所以使用了系统语言组装，相当于传参是<code>zh-Hans</code>，所以结果是简体中文优先；</li><li>HTTP 请求定义的语言越精确，匹配的内容越精确；</li><li>默认情况下，指定语言配置文件找不到，会一次向上查找，地区 &gt; 国家 &gt; 语言 &gt; 默认。</li></ol><h2 id="带参数的国际化信息"><a href="#带参数的国际化信息" class="headerlink" title="带参数的国际化信息"></a>带参数的国际化信息</h2><p>我们在 message.properties 中添加一行配置：</p><pre><code class="properties">message.multiVars=var1={0}, var2={1}</code></pre><p>在刚才的 Controller 中增加一个请求：</p><pre><code class="java">@GetMapping(&quot;m2&quot;)public List&lt;String&gt; m2(Locale locale) {    final List&lt;String&gt; multi = new ArrayList&lt;&gt;();    multi.add(&quot;参数为 null: &quot; + messageSource.getMessage(&quot;message.multiVars&quot;, null, locale));    multi.add(&quot;参数为空：&quot; + messageSource.getMessage(&quot;message.multiVars&quot;, new Object[]{}, locale));    multi.add(&quot;只传一个参数：&quot; + messageSource.getMessage(&quot;message.multiVars&quot;, new Object[]{&quot;第一个参数&quot;}, locale));    multi.add(&quot;传两个参数：&quot; + messageSource.getMessage(&quot;message.multiVars&quot;, new Object[]{&quot;第一个参数&quot;, &quot;第二个参数&quot;}, locale));    multi.add(&quot;传超过两个参数：&quot; + messageSource.getMessage(&quot;message.multiVars&quot;, new Object[]{&quot;第一个参数&quot;, &quot;第二个参数&quot;, &quot;第三个参数&quot;}, locale));    return multi;}</code></pre><p>我们看看结果：</p><pre><code class="http">###GET http://localhost:8080/m2### 结果是：[  &quot;参数为 null: var1={0}, var2={1}&quot;,  &quot;参数为空：var1={0}, var2={1}&quot;,  &quot;只传一个参数：var1=第一个参数，var2={1}&quot;,  &quot;传两个参数：var1=第一个参数，var2=第二个参数&quot;,  &quot;传超过两个参数：var1=第一个参数，var2=第二个参数&quot;]</code></pre><p>我们可以看到，我们在配置文件中定义了带参数的配置信息，此时，我们可以不传参数、传少于指定数量的参数、传符合指定数量的参数、传超过指定数量的参数，都可以正常返回国际化信息。</p><p>此处可以理解为，<code>MessageFormat.format</code>执行过程是<code>for-index</code>循环，从配置值中找格式为<code>{数字}</code>的占位符，然后用对应下标的输入参数替换，如果属于参数没了，就保持原样。</p><h2 id="找不到配置内容"><a href="#找不到配置内容" class="headerlink" title="找不到配置内容"></a>找不到配置内容</h2><p>如果我们的配置文件中没有配置或者对应语言及其父级都没有配置呢？</p><p>这个就要靠前面说的<code>useCodeAsDefaultMessage</code>配置了，如果为 true，就会返回输入的 code，如果为 false，就会抛出异常。默认是 false，所以如果找不到会抛异常。比如：</p><pre><code class="java">@GetMapping(&quot;m3&quot;)public List&lt;String&gt; m3(Locale locale) {    final List&lt;String&gt; multi = new ArrayList&lt;&gt;();    multi.add(&quot;不存在的 code: &quot; + messageSource.getMessage(&quot;message.notExist&quot;, null, locale));    return multi;}</code></pre><p>这个时候我们执行 http 请求：</p><pre><code class="http">###GET http://localhost:8080/m3### 结果是：{  &quot;timestamp&quot;: &quot;2022-06-19T09:14:14.977+00:00&quot;,  &quot;status&quot;: 500,  &quot;error&quot;: &quot;Internal Server Error&quot;,  &quot;path&quot;: &quot;/m3&quot;}</code></pre><p>这是报错了，异常栈是：</p><pre><code class="log">org.springframework.context.NoSuchMessageException: No message found under code &#39;message.notExist&#39; for locale &#39;zh_CN_#Hans&#39;.    at org.springframework.context.support.AbstractMessageSource.getMessage(AbstractMessageSource.java:161) ~[spring-context-5.3.20.jar:5.3.20]    at cn.howardliu.effective.spring.springbootmessages.controller.HelloController.m3(HelloController.java:47) ~[classes/:na]    ……此处省略</code></pre><h2 id="自定义-MessageSource"><a href="#自定义-MessageSource" class="headerlink" title="自定义 MessageSource"></a>自定义 MessageSource</h2><p>本文开头说过，MessageSource 有三种实现，Spring 默认使用了 ResourceBundleMessageSource，我们可以自定义使用 ReloadableResourceBundleMessageSource。</p><p>既然是在 SpringBoot 中，我们可以依靠 SpringBoot 的特性定义：</p><pre><code class="java">@Configuration(proxyBeanMethods = false)@ConditionalOnMissingBean(name = AbstractApplicationContext.MESSAGE_SOURCE_BEAN_NAME, search = SearchStrategy.CURRENT)@ConditionalOnProperty(name = &quot;spring.messages-type&quot;, havingValue = &quot;ReloadableResourceBundleMessageSource&quot;)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Conditional(ReloadResourceBundleCondition.class)@EnableConfigurationPropertiespublic class ReloadMessageSourceAutoConfiguration {    private static final Resource[] NO_RESOURCES = {};    @Bean    @ConfigurationProperties(prefix = &quot;spring.messages&quot;)    public MessageSourceProperties messageSourceProperties() {        return new MessageSourceProperties();    }    @Bean    public MessageSource messageSource(MessageSourceProperties properties) {        ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource();        if (StringUtils.hasText(properties.getBasename())) {            final String[] originBaseNames = StringUtils                    .commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(properties.getBasename()));            final String[] baseNames = new String[originBaseNames.length];            for (int i = 0; i &lt; originBaseNames.length; i++) {                if (originBaseNames[i].startsWith(&quot;classpath:&quot;)) {                    baseNames[i] = originBaseNames[i];                } else {                    baseNames[i] = &quot;classpath:&quot; + originBaseNames[i];                }            }            messageSource.setBasenames(baseNames);        }        if (properties.getEncoding() != null) {            messageSource.setDefaultEncoding(properties.getEncoding().name());        }        messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale());        Duration cacheDuration = properties.getCacheDuration();        if (cacheDuration != null) {            messageSource.setCacheMillis(cacheDuration.toMillis());        }        messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat());        messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage());        return messageSource;    }    protected static class ReloadResourceBundleCondition extends SpringBootCondition {        private static final ConcurrentReferenceHashMap&lt;String, ConditionOutcome&gt; CACHE =                new ConcurrentReferenceHashMap&lt;&gt;();        @Override        public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {            String basename = context.getEnvironment().getProperty(&quot;spring.messages.basename&quot;, &quot;messages&quot;);            ConditionOutcome outcome = CACHE.get(basename);            if (outcome == null) {                outcome = getMatchOutcomeForBasename(context, basename);                CACHE.put(basename, outcome);            }            return outcome;        }        private ConditionOutcome getMatchOutcomeForBasename(ConditionContext context, String basename) {            ConditionMessage.Builder message = ConditionMessage.forCondition(&quot;ResourceBundle&quot;);            for (String name : StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(basename))) {                for (Resource resource : getResources(context.getClassLoader(), name)) {                    if (resource.exists()) {                        return ConditionOutcome.match(message.found(&quot;bundle&quot;).items(resource));                    }                }            }            return ConditionOutcome.noMatch(message.didNotFind(&quot;bundle with basename &quot; + basename).atAll());        }        private Resource[] getResources(ClassLoader classLoader, String name) {            String target = name.replace(&#39;.&#39;, &#39;/&#39;);            try {                return new PathMatchingResourcePatternResolver(classLoader)                        .getResources(&quot;classpath*:&quot; + target + &quot;.properties&quot;);            } catch (Exception ex) {                return NO_RESOURCES;            }        }    }}</code></pre><p>我们可以看到，我们在执行<code>messageSource.setBasenames(baseNames);</code>的时候，<code>baseNames</code>中的值都是设置成<code>classpath:</code>开头的，这是为了使<code>ReloadableResourceBundleMessageSource</code>能够读取 CLASSPATH 下的配置文件。当然也可以使用绝对路径或者相对路径实现，这个是比较灵活的。</p><p>我们可以通过修改配置文件内容，查看变化，这里就不再赘述。纸上得来终觉浅，绝知此事要躬行。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文通过几个小例子介绍了<code>MessageSource</code>的使用。这里做一下预告，下一章我们会从源码角度分析<code>MessageSourc</code>e 的实现类<code>ResourceBundleMessageSource</code>和<code>ReloadableResourceBundleMessageSource</code>的执行逻辑；然后我们自定义扩展，从 Nacos 中读取配置内容，实现更加灵活的配置。</p><p>本文中的实例已经传到 GitHub，关注公众号「看山的小屋」，回复<code>spring</code>获取源码。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/zUrx7duy0-OY1oYn8FeKOw" target="_blank" rel="noopener">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://mp.weixin.qq.com/s/H599Wri3VbjTuLBnf7pD3w" target="_blank" rel="noopener">SpringBoot 实战：如何优雅的处理异常</a></li><li><a href="https://mp.weixin.qq.com/s/fcVE-cE7tDuWKoNNX9rsoQ" target="_blank" rel="noopener">SpringBoot 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://mp.weixin.qq.com/s/xQQbl6VNF2eCgmQPrMyc4w" target="_blank" rel="noopener">SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li><li><a href="https://mp.weixin.qq.com/s/coKjuefWMmCA4bSkRDIRVA" target="_blank" rel="noopener">SpringBoot 实战：优雅的使用枚举参数</a></li><li><a href="https://mp.weixin.qq.com/s/pet_rA7-O1JD3QfQ1fqxAQ" target="_blank" rel="noopener">SpringBoot 实战：优雅的使用枚举参数（原理篇）</a></li><li><a href="https://mp.weixin.qq.com/s/2OXArNObVejXLvMOmE3oqw" target="_blank" rel="noopener">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</a></li><li><a href="https://mp.weixin.qq.com/s/hdioIIwPA2lv2khfRmKhOQ" target="_blank" rel="noopener">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</a></li><li><a href="https://mp.weixin.qq.com/s/vbccn0kTdyOlmznDr3RItw" target="_blank" rel="noopener">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a></li><li><a href="https://mp.weixin.qq.com/s/s8PQXLT8Ni3dLqsOgf3syA" target="_blank" rel="noopener">SpringBoot 实战：加载和读取资源文件内容</a></li><li><a href="https://mp.weixin.qq.com/s/dGPhS5vdbnFdiTxkpr2mLg" target="_blank" rel="noopener">SpringBoot 实战：国际化组件 MessageSource</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/springboot-action-messagesource/">SpringBoot 实战：国际化组件 MessageSource</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/126069965" target="_blank" rel="noopener">SpringBoot 实战：国际化组件 MessageSource</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      咱们今天一起来聊聊 SpringBoot 中的国际化组件 MessageSource。
    
    </summary>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/categories/spring/"/>
    
    
      <category term="SpringBoot 实战" scheme="https://www.howardliu.cn/tags/SpringBoot-%E5%AE%9E%E6%88%98/"/>
    
      <category term="SpringBoot" scheme="https://www.howardliu.cn/tags/SpringBoot/"/>
    
      <category term="spring" scheme="https://www.howardliu.cn/tags/spring/"/>
    
      <category term="SpringBoot 手册" scheme="https://www.howardliu.cn/tags/SpringBoot-%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>小心 transmittable-thread-local 的这个坑</title>
    <link href="https://www.howardliu.cn/transmittable-thread-local-make-trouble/"/>
    <id>https://www.howardliu.cn/transmittable-thread-local-make-trouble/</id>
    <published>2022-07-30T02:55:46.000Z</published>
    <updated>2022-07-30T02:55:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/dog-7330712_1920.jpeg" alt="小心 transmittable-thread-local 的这个坑"></p><p>你好，我是看山。</p><p>transmittable-thread-local 是阿里开源一个线程池复用场景下，处理异步执行时上下文传递数据问题的解决方案。可以从官方文档<a href="https://github.com/alibaba/transmittable-thread-local" target="_blank" rel="noopener">https://github.com/alibaba/transmittable-thread-local</a>获取更多信息。</p><a id="more"></a><p>本文主要是变更 transmittable-thread-local 使用方式时出现的一个异常。</p><h2 id="异常现场"><a href="#异常现场" class="headerlink" title="异常现场"></a>异常现场</h2><p>看异常之前，先简单说下项目大概情况。</p><p>项目是 Java 栈，使用了 SpringBoot+MyBatis 的框架结构，构建工具是 Maven。因为项目中使用了比较多的多线程逻辑，所以引入了 transmittable-thread-local，解决上下文传递数据问题。后来做项目升级，接入公司的监控系统，启动时增加了启动参数<code>-javaagent:/path/to/transmittable-thread-local-2.12.1.jar</code>，通过零侵入的方式解决多线程上下文传值问题。</p><p>于是，有些逻辑出错了。</p><p>我们看看异常栈（日志做了删改，隐藏项目信息）：</p><pre><code class="log">org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#39;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&#39; available: expected single matching bean but found 3: executor1,executor2,executor3    at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1200)    at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveBean(DefaultListableBeanFactory.java:420)    at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:349)    at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:342)    at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1127)    ……    at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)    at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771)    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)    at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)    at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88)    ……</code></pre><p>异常日志很清楚，就是通过<code>AbstractApplicationContext.getBean</code>获取 Bean 的时候，因为存在多个同类型的<code>ThreadPoolTaskExecutor</code>，Spring 容器不知道返回哪个 Bean，就抛出了<code>NoUniqueBeanDefinitionException</code>异常。</p><h2 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h2><p>我们再来看看调用代码：</p><pre><code class="java">public static void doSth(Object subtag, Object extra, long time) {    ApplicationContextContainer.getBean(ThreadPoolTaskExecutor.class)            .execute(() -&gt; {                // 一些业务代码            });}@Componentpublic class ApplicationContextContainer implements ApplicationContextAware {    private static ApplicationContext applicationContext;    public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) {        return applicationContext.getBean(clazz);    }    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {        ApplicationContextContainer.applicationContext = applicationContext;    }}</code></pre><p>可以看出来，<code>applicationContext.getBean</code>时只传入了 class 类型，没有指明 Bean 的名字。推测是项目中定义了多个<code>ThreadPoolTaskExecutor</code>类型的 Bean，名字分别是 executor1、executor2、executor3（名字改过了，大家写代码时尽量使用见名知意的起名方式）。</p><pre><code class="java">@Configurationpublic class ExecutorConfig {    @Bean(value = &quot;executor1&quot;)    public Executor executor1() {        ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();        // 一些初始化方法        taskExecutor.initialize();        return taskExecutor;    }    @Bean(value = &quot;executor2&quot;)    public Executor executor2() {        ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();        // 一些初始化方法        taskExecutor.initialize();        return TtlExecutors.getTtlExecutor(taskExecutor);    }    @Bean(value = &quot;executor3&quot;)    public Executor executor3() {        ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();        // 一些初始化方法        taskExecutor.initialize();        return TtlExecutors.getTtlExecutor(taskExecutor);    }}</code></pre><p>从上面的代码可以发现，确实有 executor1、executor2、executor3 三个<code>Executor</code>，executor1 是<code>ThreadPoolTaskExecutor</code>类型的，executor2 和 executor3 是经过<code>TtlExecutors.getTtlExecutor</code>包装的<code>ThreadPoolTaskExecutor</code>。</p><p>我们来看看<code>TtlExecutors.getTtlExecutor</code>方法：</p><pre><code class="java">public static Executor getTtlExecutor(@Nullable Executor executor) {    if (TtlAgent.isTtlAgentLoaded() || null == executor || executor instanceof TtlEnhanced) {        return executor;    }    return new ExecutorTtlWrapper(executor, true);}</code></pre><p>根据错误反推，经过<code>TtlExecutors.getTtlExecutor</code>之后返回的还是<code>ThreadPoolTaskExecutor</code>类型。也就是上面代码走了<code>if</code>语句，直接返回了输入参数。</p><p>但是，这里就碰到了两个开发十大未解之谜中的两个：</p><ol><li>代码没改，之前好好地，怎么就报错了；</li><li>本地好使，为什么放在服务器上就报错了。</li></ol><h2 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h2><p>首先，我们需要知道，代码的终点不是玄学。我们现在用的计算机还不会撒谎，只要报错了，就一定是有问题。</p><p>我们仔细看看<code>TtlExecutors.getTtlExecutor</code>方法中的<code>if</code>判断：</p><ul><li>TtlAgent.isTtlAgentLoaded()：这个是判断 ttlAgentLoaded 标识，这个后文再说；</li><li>null == executor：输入参数为 null，显然不符合；</li><li>executor instanceof TtlEnhanced：输入参数是<code>TtlEnhanced</code>类型，输入的是<code>ThreadPoolTaskExecutor</code>类型，不符合。</li></ul><p>所以，重点看看 ttlAgentLoaded 标识：</p><pre><code class="java">public static boolean isTtlAgentLoaded() {    return ttlAgentLoaded;}</code></pre><p>从全局找到修改<code>ttlAgentLoaded</code>的地方是：</p><pre><code class="java">public final class TtlAgent {    public static void premain(final String agentArgs, @NonNull final Instrumentation inst) {        kvs = splitCommaColonStringToKV(agentArgs);        Logger.setLoggerImplType(getLogImplTypeFromAgentArgs(kvs));        final Logger logger = Logger.getLogger(TtlAgent.class);        try {            logger.info(&quot;[TtlAgent.premain] begin, agentArgs: &quot; + agentArgs + &quot;, Instrumentation: &quot; + inst);            final boolean disableInheritableForThreadPool = isDisableInheritableForThreadPool();            // 省略非相关代码            ttlAgentLoaded = true;        } catch (Exception e) {            String msg = &quot;Fail to load TtlAgent , cause: &quot; + e.toString();            logger.log(Level.SEVERE, msg, e);            throw new IllegalStateException(msg, e);        }    }    // 省略非相关代码}</code></pre><p>有一定 javaagent 知识的应该知道，<code>premain</code>方法是 java 启动时，加载 javaagent 后执行的方法。</p><p>这就吻合了。</p><p>报错之前的服务器代码，<code>ExecutorConfig</code>类中定义的 executor1 是<code>ThreadPoolTaskExecutor</code>类型，executor2 和 executor3 是<code>ExecutorTtlWrapper</code>类型，使用<code>applicationContext.getBean(clazz)</code>能够得到名字是 executor1 的 Bean。</p><p>然后使用<code>-javaagent:/path/to/transmittable-thread-local-2.12.1.jar</code>方式实现零侵入的<code>transmittable-thread-local</code>注入能力。<code>ExecutorConfig</code>类中定义的 executor2 和 executor3 是<code>ThreadPoolTaskExecutor</code>类型，使用<code>applicationContext.getBean(clazz)</code>就会查到三个<code>ThreadPoolTaskExecutor</code>类型的 Bean，Spring 容器没有办法判断返回哪一个，于是抛出了<code>NoUniqueBeanDefinitionException</code>异常。</p><p>本地启动是加上<code>-javaagent:/path/to/transmittable-thread-local-2.12.1.jar</code>命令，问题复现。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>解决上面的报错比较简单，就是使用<code>applicationContext.getBean(beanName, clazz)</code>方法，通过输入指定的 Bean 的名字和类型，获取确定 Bean，代码修改为：</p><pre><code class="java">public static void doSth(Object subtag, Object extra, long time) {    ApplicationContextContainer.getBean(&quot;executor1&quot;, ThreadPoolTaskExecutor.class)            .execute(() -&gt; {                // 一些业务代码            });}</code></pre><p>流水线发版回归测试，问题解决。</p><p>青山不改，绿水长流，我们下次见。</p><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/transmittable-thread-local-make-trouble/">小心 transmittable-thread-local 的这个坑</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/126069634" target="_blank" rel="noopener">小心 transmittable-thread-local 的这个坑</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文主要是变更 transmittable-thread-local 使用方式时出现的一个异常。
    
    </summary>
    
    
      <category term="debug" scheme="https://www.howardliu.cn/categories/debug/"/>
    
    
      <category term="debug" scheme="https://www.howardliu.cn/tags/debug/"/>
    
      <category term="transmittable" scheme="https://www.howardliu.cn/tags/transmittable/"/>
    
      <category term="ttl" scheme="https://www.howardliu.cn/tags/ttl/"/>
    
  </entry>
  
  <entry>
    <title>Switch 块、Switch 表达式、Switch 模式匹配，越来越好用的 Switch</title>
    <link href="https://www.howardliu.cn/java-switch/"/>
    <id>https://www.howardliu.cn/java-switch/</id>
    <published>2022-06-19T04:00:56.000Z</published>
    <updated>2022-06-19T04:00:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/beach-7262493_1920.jpeg" alt="Switch 块、Switch 表达式、Switch 模式匹配，越来越好用的 Switch"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>与 if-else 一样，switch 语法是用来做条件判断的。当条件清晰简洁时，能够有效地提升代码可读性。switch 语法从 Java5 开始，Java12 增加了 Switch 表达式（Java14 提供正式版），Java17 增加 Switch 模式匹配（预览版）。</p><p>本文的目标是期望读者可以掌握 Switch 语法的所有能力，在需要的时候信手拈来。</p><a id="more"></a><h2 id="if-else-与-switch-语法"><a href="#if-else-与-switch-语法" class="headerlink" title="if-else 与 switch 语法"></a>if-else 与 switch 语法</h2><p>我们先来个简单的例子看看 if-else 和 switch 语法的使用：</p><pre><code class="java">public static void demoOfIf(int num) {    if (num == 0) {        System.out.println(&quot;0&quot;);    } else if (num == 1) {        System.out.println(&quot;1&quot;);    } else if (num == 2) {        System.out.println(&quot;2&quot;);    } else {        System.out.println(&quot;3&quot;);    }}public static void demoOfSwitch(int num) {    switch (num) {        case 0: {            System.out.println(&quot;0&quot;);            break;        }        case 1: {            System.out.println(&quot;1&quot;);            break;        }        case 2: {            System.out.println(&quot;2&quot;);            break;        }        default: {            System.out.println(&quot;3&quot;);        }    }}</code></pre><p>上面的示例很简单，下面我们就来着重学习一下 Swith 语法。</p><h2 id="Switch-块通用语法"><a href="#Switch-块通用语法" class="headerlink" title="Switch 块通用语法"></a>Switch 块通用语法</h2><pre><code class="java">switch(integral-selector) {case value1: statement1; break;case value2: statement2; break;// ……default: default-statement;}</code></pre><p>switch 语句是一种多路选择的简洁表达式，在 Java7 之前，switch 语句的表达式必须是整数值，这样会有很多的限制。于是在 Java7 中增加了 String 格式的支持，使应用场景更加丰富。</p><p>每个 case 执行语句末尾都有一个<code>break</code>关键字，它会让执行流程跳到 switch 的末尾。如果不加<code>break</code>，后面的 case 语句会继续执行，直到第一个<code>break</code>关键字。</p><p>比如：</p><pre><code class="java">public static void noBreak(int num) {    switch (num) {        case 0: {            System.out.println(&quot;0&quot;);        }        case 1: {            System.out.println(&quot;1&quot;);        }        case 2: {            System.out.println(&quot;2&quot;);            break;        }        default: {            System.out.println(&quot;3&quot;);        }    }}</code></pre><p>执行<code>noBreak(0)</code>的结果会是：</p><pre><code class="log">012</code></pre><p>基于这种特性，我们可以合并多个值的执行逻辑，比如下面这种写法：</p><pre><code class="java">public static void noBreak2(int num) {    switch (num) {        case 0:        case 1:        case 2: {            System.out.println(&quot;0 or 1 or 2&quot;);            break;        }        default: {            System.out.println(&quot;3&quot;);        }    }}</code></pre><p>当参数是 0 或 1 或 2 时，结果相同，都是：</p><pre><code class="log">0 or 1 or 2</code></pre><h2 id="Switch-表达式"><a href="#Switch-表达式" class="headerlink" title="Switch 表达式"></a>Switch 表达式</h2><p>Switch 语句出现的姿势是条件判断、流程控制组件，与现在很流行的新语言对比，其写法显得非常笨拙，所以 Java 推出了 Switch 表达式语法，可以让我们写出更加简化的代码。这个扩展在 Java12 中作为预览版首次引入，需要在编译时增加<code>-enable-preview</code>开启，在 Java14 中正式提供，功能编号是 <a href="https://openjdk.java.net/jeps/361" target="_blank" rel="noopener">JEP 361</a>。</p><p>比如，我们通过 switch 语法简单计算工作日、休息日，在 Java12 之前需要这样写：</p><pre><code class="java">@Testvoid testSwitch() {    final DayOfWeek day = DayOfWeek.from(LocalDate.now());    String typeOfDay = &quot;&quot;;    switch (day) {        case MONDAY:        case TUESDAY:        case WEDNESDAY:        case THURSDAY:        case FRIDAY:            typeOfDay = &quot;Working Day&quot;;            break;        case SATURDAY:        case SUNDAY:            typeOfDay = &quot;Rest Day&quot;;            break;    }    Assertions.assertFalse(typeOfDay.isEmpty());}</code></pre><p>在 Java12 中的 Switch 表达式中，我们可以直接简化：</p><pre><code class="java">@Testvoid testSwitchExpression() {    final DayOfWeek day = DayOfWeek.SATURDAY;    final String typeOfDay = switch (day) {        case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; &quot;Working Day&quot;;        case SATURDAY, SUNDAY -&gt; &quot;Day Off&quot;;    };    Assertions.assertEquals(&quot;Day Off&quot;, typeOfDay);}</code></pre><p>是不是很清爽。不过，这里有一点不足的是，如果是需要执行一段业务逻辑，然后返回一个结果呢？于是 Java13 使用<code>yield</code>关键字补齐了这个功能：</p><pre><code class="java">@Testvoid testSwitchExpression13() {    final DayOfWeek day = DayOfWeek.SATURDAY;    final String typeOfDay = switch (day) {        case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; {            System.out.println(&quot;Working Day: &quot; + day);            yield &quot;Working Day&quot;;        }        case SATURDAY, SUNDAY -&gt; {            System.out.println(&quot;Day Off: &quot; + day);            yield &quot;Day Off&quot;;        }    };    Assertions.assertEquals(&quot;Day Off&quot;, typeOfDay);}</code></pre><h2 id="Switch-模式匹配"><a href="#Switch-模式匹配" class="headerlink" title="Switch 模式匹配"></a>Switch 模式匹配</h2><p>到 Java17 时，又提供了 Switch 模式匹配功能。与 instanceof 模式匹配有些类似，是能够在 Switch 表达式实现类型自动转换。</p><p>比如：</p><pre><code class="java">static String formatterPatternSwitch(Object o) {    return switch (o) {        case null -&gt; &quot;null&quot;;        case Integer i -&gt; String.format(&quot;int %d&quot;, i);        case Long l -&gt; String.format(&quot;long %d&quot;, l);        case Double d -&gt; String.format(&quot;double %f&quot;, d);        case String s -&gt; String.format(&quot;String %s&quot;, s);        default -&gt; o.getClass().getSimpleName() + &quot; &quot; + o;    };}public static void main(String[] args) {    System.out.println(formatterPatternSwitch(null));    System.out.println(formatterPatternSwitch(&quot;1&quot;));    System.out.println(formatterPatternSwitch(2));    System.out.println(formatterPatternSwitch(3L));    System.out.println(formatterPatternSwitch(4.0));    System.out.println(formatterPatternSwitch(new AtomicLong(5)));}</code></pre><p>结果是：</p><pre><code class="log">nullString 1int 2long 3double 4.000000AtomicLong 5</code></pre><p>可以看到，不只是类型自动转换，还可以直接判断是否是<code>null</code>，省了前置判断对象是否是<code>null</code>了。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/By2JoZqAHA6U36PG8qvCcg" target="_blank" rel="noopener">Java17 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-switch/">Switch 块、Switch 表达式、Switch 模式匹配，越来越好用的 Switch</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/126069533" target="_blank" rel="noopener">Switch 块、Switch 表达式、Switch 模式匹配，越来越好用的 Switch</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      与 if-else 一样，switch 语法是用来做条件判断的。当条件清晰简洁时，能够有效地提升代码可读性。switch 语法从 Java5 开始，Java12 增加了 Switch 表达式（Java14 提供正式版），Java17 增加 Switch 模式匹配（预览版）。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="switch" scheme="https://www.howardliu.cn/tags/switch/"/>
    
  </entry>
  
  <entry>
    <title>2022 年 Java 行业分析报告</title>
    <link href="https://www.howardliu.cn/java-developer-productivity-report-2022/"/>
    <id>https://www.howardliu.cn/java-developer-productivity-report-2022/</id>
    <published>2022-06-19T03:23:42.000Z</published>
    <updated>2022-06-19T03:23:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/sea-5382487_1920.jpeg" alt="2022 年 Java 行业分析报告"></p><p>你好，我是看山。</p><p>前段时间介绍了从 Java8 到 Java17 每个版本比较有特点的新特性（收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 专栏），今天看到 JRebel 发布了《2022 年 Java 发展趋势和分析》，于是借此分析一下 Java 行业的现状，希望给大家一些参考。</p><a id="more"></a><blockquote><p>JRebel 是通过调研问卷的方式总结的报告，涉及了不同国家、不同岗位、不同公司规模、不同行业，相对来说，该调查报告是有一定参考意义的。</p></blockquote><h2 id="Java-语言及开发趋势"><a href="#Java-语言及开发趋势" class="headerlink" title="Java 语言及开发趋势"></a>Java 语言及开发趋势</h2><h3 id="Java8-的占比还是比较高"><a href="#Java8-的占比还是比较高" class="headerlink" title="Java8 的占比还是比较高"></a>Java8 的占比还是比较高</h3><p>我们先来看下大家都在使用的 Java 版本（包括 JVM 语言：Kotlin、Groovy、Scala）：</p><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/6.png" alt="Java 各版本语言占比"></p><p>从结果我们可以看到，Java8 占比 37%，Java11 占比 29%，甚至有 12%的被调查者使用了高于 Java12 的版本。</p><p>Java8 是 2014 年发布，相较于之前版本，增加了 Lambda 表达式、Stream 流式处理等一种优秀的 API。至今已 8 年时间，Java 版本也是从 8 一直升到了 17。版本号一直在增加，却没有增加特别吸引人的语言特性。</p><p>哪些因素是大家升级的动力呢？</p><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/9.png" alt="升级的动力"></p><p>可以看到，主要的升级因素包括 LTS 版本（25%）、安全性（23%）、性能（20%），新特性（18%）和随大流（14%）占比低一些。</p><p>从这点我们也就知道为什么 Java11 之后的版本占比并不高了，随着 Java17 的发布，可能 Java8 和 Java11 的占比会降低。安全性方面，除非是严重的漏洞，一般 Java 开发团队会通过补丁的方式升级，不会影响大版本号占比。</p><p>性能方面，Java 团队一直在不断优化，随着 G1、ZGC、Shenandoah 等一众优秀的 GC 被添加进来，这也成为大家从 Java8 升级的重要原因。</p><p>就功能特性而言，Java11 之后增加了 Record 类型、密封类、instanceof 模式匹配、Swtich 表达式和模式匹配等一些语法糖。这些新特性，也能够提升升级到 Java17 的意愿。</p><h3 id="升级-Java17-的意愿还是比较强的"><a href="#升级-Java17-的意愿还是比较强的" class="headerlink" title="升级 Java17 的意愿还是比较强的"></a>升级 Java17 的意愿还是比较强的</h3><p>Java17 是 2021 年下半年发布的 LTS 版本（长期支持版）。</p><p>我们看下大家升级的意愿：</p><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/10.png" alt="升级 Java17 的意愿"></p><p>从结果可以看出来，有 37%的人会在未来 6 个月内升级，有 25%的人会在 6-12 个月内升级，不会升级的占比仅占 8%。</p><p>可见，有 62%的人会在未来一年内升级到 Java17，大家的升级意愿还是比较强的。</p><h3 id="OracleJDK-和-OpenJDK-占据过半市场"><a href="#OracleJDK-和-OpenJDK-占据过半市场" class="headerlink" title="OracleJDK 和 OpenJDK 占据过半市场"></a>OracleJDK 和 OpenJDK 占据过半市场</h3><p>我们都知道，市面上有很多的 JDK 版本，在 Oracle 起诉 Google 侵权之前，非企业特供的情况下，我们基本上用的都是 OracleJDK，后来因为容器中使用 JDK 版本的版权问题，容器中大部分使用了 OpenJDK。</p><p>从问卷结果也反映了这种情况：</p><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/13.png" alt="JRE/JDK 各种版本的市场份额"></p><p>OracleJDK 的版本占比 36%，OpenJDK 的版本占比 43%，其中包括标准 OpenJDK 和 AdoptOpenJDK 版本。</p><p>有些同学会疑惑 OracleJDK 和 OpenJDK 的区别在哪？我们日常用到的部分，没有任何区别。</p><h3 id="Java-应用架构趋势"><a href="#Java-应用架构趋势" class="headerlink" title="Java 应用架构趋势"></a>Java 应用架构趋势</h3><p>这个问题的结果有些出乎我的预料：</p><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/14.png" alt="Java 应用架构趋势"></p><p>各种架构风格中，微服务架构仅占 32%，单体架构占比 22%，模块化单体架构占比 13%，SOA 架构占比 12%。</p><p>从结果来看，这个问卷的对架构风格的定义和分类比较细腻。</p><p>很多公司把系统的服务化、模块化也统称为了微服务，这是一种很严重的错误，在之前的文章 <a href="https://mp.weixin.qq.com/s/b7my-EHc0fGOE3veeQyxBg" target="_blank" rel="noopener">《微服务架构的陷阱：从单体到分布式单体》</a> 中介绍过这种错误。</p><p>推荐阅读：</p><ul><li><a href="https://mp.weixin.qq.com/s/09ILTzijUr3knHBj13t_kQ" target="_blank" rel="noopener">《什么是微服务？》</a></li><li><a href="https://mp.weixin.qq.com/s/n1eKTlLP_BbyBkKG4OyLSw" target="_blank" rel="noopener">《微服务编程范式》</a></li><li><a href="https://mp.weixin.qq.com/s/NcftJ1jNAd-DHpzBXKk8RA" target="_blank" rel="noopener">《从单体架构到微服务架构》</a>。</li></ul><blockquote><p>这里不对架构风格做出评价，架构只有合适与否，没有优劣之分。</p></blockquote><h2 id="微服务架构趋势"><a href="#微服务架构趋势" class="headerlink" title="微服务架构趋势"></a>微服务架构趋势</h2><p>既然微服务架构占比高一些，我们就来看一下微服务架构的应用趋势。</p><h3 id="微服务架构的应用状态"><a href="#微服务架构的应用状态" class="headerlink" title="微服务架构的应用状态"></a>微服务架构的应用状态</h3><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/17.png" alt="微服务架构使用状态"></p><p>从结果来看，有 44%的人团队已经是完全微服务架构了，还有 44%的团队在向微服务架构迁移。可见，在 Java 行业中，微服务架构是得到大家普遍认可的。</p><blockquote><p>但是这个结果与上面的架构风格占比结果有出入，可能是问卷题目设计问题，或者问题回答者的主观原因，不能够苛求结果准确性。</p></blockquote><h3 id="每个应用中微服务的数量"><a href="#每个应用中微服务的数量" class="headerlink" title="每个应用中微服务的数量"></a>每个应用中微服务的数量</h3><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/18.png" alt="每个应用中微服务的数量"></p><p>既然是微服务架构，每个应用中服务数量必然超过 1 个。从结果可以看出来，有 54%的应用中少于 10 个服务，还有 22%的应用服务数量超过 20 个。</p><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/18-1.png" alt="微服务数量与公司规模的关系"></p><p>按照公司规模维度，越是大公司，每个应用中服务数量越多，结果符合康威定律的。从大家普遍实践结果看，当团队规模较小时，要尽量减少微服务数量。市面上很多老师会告诉我们，微服务架构要按照业务域拆分，但是你要知道，如果团队规模不大，即使拆分了业务域，可能最终开发调试维护也只有你一个。</p><h3 id="SpringBoot-几乎霸占了整个微服务市场"><a href="#SpringBoot-几乎霸占了整个微服务市场" class="headerlink" title="SpringBoot 几乎霸占了整个微服务市场"></a>SpringBoot 几乎霸占了整个微服务市场</h3><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/22.png" alt="微服务框架的使用度"></p><p>从结果看，SpringBoot 几乎霸占了整个微服务市场。所以，大家在日常工作学习过程中，还是主要看看 SpringBoot 栈吧。</p><p>在国内，SpringBoot 技术栈还会细分为 SpringNetflixCloud 栈、SpringAlibabaCloud 栈、SpringBoot+Dubbo 栈等。</p><p>不同的技术栈中组件有些差异，所以我们需要掌握的不是简单的应用，还要了解其中的原理。原理掌握了，不同的组价只是在应用层面的差异。</p><h3 id="启动时间在增长"><a href="#启动时间在增长" class="headerlink" title="启动时间在增长"></a>启动时间在增长</h3><p>随着公司业务的增长，应用中会增加各种各样的新功能。问卷中有个问题是关于随着时间推移，微服务启动时间的变化：</p><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/24.png" alt="启动时间在增长"></p><p>可见，有 60%的服务启动时间都在增加，甚至有 13%的应用启动时间增长超过 50%，有 30%的应用启动时间增长范围在 10%-50%。</p><p>为什么启动时间会增长呢？这个与公司业务增长后，代码增加了很多新功能有关。随着功能增加、类的增加，系统体积增大、加载类数量增大，启动时间会随之增加。这会引起系统的腐化，当腐化到一定程度，可能就需要重构了。或者随着业务增长，原来的微服务边界划分不合适了，需要重新划分系统边界，拆分微服务。</p><h3 id="启动需要多长时间"><a href="#启动需要多长时间" class="headerlink" title="启动需要多长时间"></a>启动需要多长时间</h3><p>既然微服务总体的启动时间在增长，那启动时间一般是多久呢？</p><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/24.png" alt="启动需要多长时间"></p><p>可以看到，只有 9%的服务在 1 分钟内启动成功，有 26%的服务启动时间需要 10 分钟以上。</p><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/24-1.png" alt="不同公司规模服务启动时间分布"></p><p>从上图可以看出来，人员规模大于 100 人的公司中，服务启动时间普遍长于少于 100 人的公司。产生这种情况的原因有这么几个：</p><ol><li>公司规模大一些，可能业务复杂一些，服务中的代码、类库更多一些；</li><li>公司规模大一些，依赖的组件更多一些，在服务启动时，需要与各种中间件建立链接，然后彼此交换成功心跳，自然需要时间更多。</li></ol><p>采用微服务其中一个好处是服务足够小，启动时间比较少。但是，从上面两个问卷结果来看，普遍情况是启动时间比较长，而且在变得更长。</p><h2 id="Java-技术趋势"><a href="#Java-技术趋势" class="headerlink" title="Java 技术趋势"></a>Java 技术趋势</h2><h3 id="Java-应用超过半数使用了容器部署"><a href="#Java-应用超过半数使用了容器部署" class="headerlink" title="Java 应用超过半数使用了容器部署"></a>Java 应用超过半数使用了容器部署</h3><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/27.png" alt="Java 应用超过半数使用了容器部署"></p><p>从问卷结果可以看到，Docker 使用率是 41%，Kubernetes 使用率是 26%，VMware 使用率是 16%，Vagrant 使用率是 3%，即有 86%已经实现了虚拟化，其中 Docker、Kubernetes 占比最高。</p><p>所以在 Java 升级版本特性中，实现了容器感知的能力，使 Java 服务容器化更容易一些。</p><h3 id="PaaS-平台还得看-AWS"><a href="#PaaS-平台还得看-AWS" class="headerlink" title="PaaS 平台还得看 AWS"></a>PaaS 平台还得看 AWS</h3><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/29.png" alt="PaaS 平台"></p><p>JRebel 的这个问卷调查是全球性质的，从全球范围看，AWS 当之无愧的 NO.1。AWS 作为亚马逊曾经的附属产业，已经成为了亚马逊的重要业务之一。</p><p>与亚马逊的经历类似，阿里巴巴从电商切入，然后布局云服务（阿里云）。如果还是走亚马逊的老路，势必没法超越。不过阿里从很多年前开始布局 CPU 和芯片领域，如果能够有所突破，就可以破开西方技术的封锁，依托我国的发展潜力，未必不能撼动亚马逊的 PaaS 服务商地位。</p><h3 id="近半数服务端使用-Tomcat-容器"><a href="#近半数服务端使用-Tomcat-容器" class="headerlink" title="近半数服务端使用 Tomcat 容器"></a>近半数服务端使用 Tomcat 容器</h3><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/30.png" alt="应用服务器"></p><p>前面关于微服务的问题中，SpringBoot 是众多微服务框架中的首选，SpringBoot 默认的应用容器是 Tomcat。加之 Tomcat 的开源方式，将近半数应用服务器选择 Tomcat 也是预料之中。</p><h3 id="Maven-是主要的构建工具"><a href="#Maven-是主要的构建工具" class="headerlink" title="Maven 是主要的构建工具"></a>Maven 是主要的构建工具</h3><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/31.png" alt="构建共建"></p><p>Maven 和 Gradle 到底该用哪个？这个问题似乎争论许久。从问卷结果看，Maven 占有率是 68%，Gradle 占有率是 23%，Maven 还是有绝对的优势。</p><p>Gradle 采用了约定大于配置的方式，与 SpringBoot 的理念一致。但是从市场接受度和发展而言，并没有形成替换 Maven 的风潮。Android 项目默认使用 Gradle，能够看出 Google 对 Gradle 的推崇，也从侧面印证 Gradle 的优秀。但是，Gradle 并没有绝对优势。</p><h3 id="近半数开发者使用-IntelliJ-IDEA"><a href="#近半数开发者使用-IntelliJ-IDEA" class="headerlink" title="近半数开发者使用 IntelliJ IDEA"></a>近半数开发者使用 IntelliJ IDEA</h3><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/32.png" alt="IDE"></p><p>我是从 2015 年开始使用 IntelliJ IDEA，试用之后立马抛弃了 Eclipse。首先是快捷键的设计，可以很大程度摆脱鼠标。内置的插件市场，可以找到任何需要的插件，提升编程体验。更关键的是，JetBrains 公司出品的 IDE，可以无缝对接，实现不同语言的编程支持。</p><p>Eclips 也不是一无是处，它的插件体系也是相当丰富，很多低代码开发工具都是基于 Eclipse 开发的。如果是普通开发，推荐使用 IntelliJ IDEA；如果想要做低代码工具，可以考虑对 Eclipse 进行二次开发。</p><h2 id="开发者生产力趋势"><a href="#开发者生产力趋势" class="headerlink" title="开发者生产力趋势"></a>开发者生产力趋势</h2><p>这一部分属于 JRebel 有私心的部分，JRebel 一个优势功能是提供热部署能力，所以会在问卷中询问被调查者重新部署应用的时间。</p><h3 id="重新部署应用的时间"><a href="#重新部署应用的时间" class="headerlink" title="重新部署应用的时间"></a>重新部署应用的时间</h3><p>很多时候，我们可能只改动一行代码，然后验证功能是不是正常，这个时候需要重新部署应用。JRebel 统计了重新部署需要花费的时间。</p><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/38.png" alt="重新部署应用的时间"></p><p>从结果上看，重新部署需要超过 3 分钟时间的占 50%，其中 21%的比率需要 10 分钟以上。那这段时间，大家会干什么？</p><h3 id="如果节省重新部署的时间你会做什么？"><a href="#如果节省重新部署的时间你会做什么？" class="headerlink" title="如果节省重新部署的时间你会做什么？"></a>如果节省重新部署的时间你会做什么？</h3><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/41.png" alt="重新部署时大家在做什么"></p><p>有 28%会增加新功能；有 20%会优化系统性能；有 19%会完善测试覆盖。这些都是正向的，大概率的是那些回答其他的：喝咖啡、喝啤酒、开趴、睡觉、钓鱼……</p><p>不过也是符合我们工作的原因：我们工作是为了生活，而不是为了加班。所以，假如每天给你 1 小时的自由时间，你会用来做什么呢？欢迎评论区讨论。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><ol><li>微服务的使用情况来看，启动时间和重新部署时间不是优先考虑的因素。多数选择微服务架构的原因无非有两个：<ol><li>看中微服务架构流行趋势，听说这个很好，那就开始用，至于是微服务架构还是分布式单体架构，就不重要了；</li><li>微服务的优势能够弥补带来的弊端，比如业务迭代速度等；</li></ol></li><li>微服务收康威定律影响比较大；</li><li>技术在不断革新，但是大家会比较理性地接受。公司规模越大，越趋于选择成熟的技术；</li><li>容器已经是大势，需要掌握。</li></ol><p>技术不断发展，我们需要学习的东西越来越多，很多时候感觉学不动了。但既然选择了这个行业，拿着高于其他行业的薪资，也承担着各种裁员的风险，总归是要有一些技能傍身，才不至于被历史的车轮碾成粉末。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.i-programmer.info/news/80-java/15317-wheres-java-going-in-2022.html" target="_blank" rel="noopener">https://www.i-programmer.info/news/80-java/15317-wheres-java-going-in-2022.html</a></li><li><a href="https://www.jrebel.com/resources/java-developer-productivity-report-2022" target="_blank" rel="noopener">https://www.jrebel.com/resources/java-developer-productivity-report-2022</a></li></ul><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/By2JoZqAHA6U36PG8qvCcg" target="_blank" rel="noopener">Java17 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-developer-productivity-report-2022">2022 年 Java 行业分析报告</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/125356270" target="_blank" rel="noopener">2022 年 Java 行业分析报告</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      前段时间介绍了从 Java8 到 Java17 每个版本比较有特点的新特性（收录在《从小工到专家的 Java 进阶之旅》专栏），今天看到 JRebel 发布了《2022 年 Java 发展趋势和分析》，于是借此分析一下 Java 行业的现状，希望给大家一些参考。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java17 的新特性</title>
    <link href="https://www.howardliu.cn/java-17-features/"/>
    <id>https://www.howardliu.cn/java-17-features/</id>
    <published>2022-05-14T02:37:39.000Z</published>
    <updated>2022-05-14T02:37:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/black-redstart-g4e4e89b2d_1920.jpeg" alt="Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java17 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java17 是在 2021 年 9 月发布的一个 LTS 版本（长期支持版本），上一个长期支持版是 Java11，于 2018 年 9 月发布。从目前来看，Java11 在市场占有率已经过半，如果错过了升级 Java11，我们可不要错过这次的升级。接下来我们看看 Java17 为我们带来了哪些新增特性：</p><ul><li>JEP 306：恢复严格的浮点语义</li><li>JEP 356：增强型伪随机数生成器</li><li>JEP 382：新的 macOS 渲染管道</li><li>JEP 391：macOS/AArch64 端口</li><li>JEP 398：弃用 Applet API</li><li>JEP 403：强封装 JDK 内部 API</li><li>JEP 406：Switch 的模式匹配（预览）</li><li>JEP 407：删除 RMI 激活机制</li><li>JEP 409：密封类</li><li>JEP 410：删除实验性的 AOT 和 JIT 编译器</li><li>JEP 411：弃用安全管理器</li><li>JEP 412：外部函数和内存 API（孵化）</li><li>JEP 414：Vector API（第二版孵化）</li><li>JEP 415：上下文特定的反序列化过滤器</li></ul><p>接下来我们一起看看这些特性。</p><h2 id="恢复严格的浮点语义（JEP-306）"><a href="#恢复严格的浮点语义（JEP-306）" class="headerlink" title="恢复严格的浮点语义（JEP 306）"></a>恢复严格的浮点语义（JEP 306）</h2><p>这个特性是利好科学计算中的浮点运算，保证浮点运算中的 strict 或 strictfp 在每个平台上都能够得到相同的结果，也就是可以把 strictfp 扔了。</p><p>在 Java1.2 之前，精确浮点计算是通过迂回的方式实现的。大约从 2001 年开始，奔腾 4 和更高版本的处理器中提供了 SSE2 扩展（数据流单指令多数据扩展指令集 2），可以直接支持严格的 JVM 浮点运算，不需要额外的开销。那个时候 Intel 和 AMD 还不支持这种扩展，于是 Java1.2 的浮点运算就分叉了。</p><p>到后来 Intel 和 AMD 也开始支持 SSE2 和更高版本的扩展指令集，Java 语言就可以恢复到严格的浮点运算了。连 Java 之父 James Gosling 在 Twitter 也发文庆祝：</p><p><img src="https://static.howardliu.cn/java/jep306-jamesgosling-twitter.png" alt="恢复严格的浮点语义（JEP 306）"></p><h2 id="增强伪随机数生成器（JEP-356）"><a href="#增强伪随机数生成器（JEP-356）" class="headerlink" title="增强伪随机数生成器（JEP 356）"></a>增强伪随机数生成器（JEP 356）</h2><p>这个特性是为伪随机数生成器 RPNG（Pseudo-Random Number Generators）增加了新的接口类型和实现，可以更容易地互换使用不同的算法，而且它还为基于流的编程方式提供了更好的支持。这个特性的目标有四个：</p><ul><li>在应用程序中更容易地交替使用各种 PRNG 算法；</li><li>改进了对基于流的编程的支持，提供了 PRNG 对象流；</li><li>消除现有 PRNG 类中的重复代码；</li><li>保留<code>java.util.Random</code>类的现有行为，做好向下兼容。</li></ul><p>新增了<code>java.util.random.RandomGenerator</code>接口，作为所有 PRNG 算法的统一 API，提供了工厂类<code>java.util.random.RandomGeneratorFactory</code>，借助<code>java.util.ServiceLoader.load()</code>的能力加载各种 PRNG 算法实现，可以构造<code>RandomGenerator</code>实例。</p><p>我们遍历一下看看有哪些 PRNG 算法：</p><pre><code class="java">RandomGeneratorFactory.all().forEach(factory -&gt; {    System.out.println(factory.group() + &quot;:&quot; + factory.name());});</code></pre><p>结果是：</p><pre><code class="log">LXM:L32X64MixRandomLXM:L128X128MixRandomLXM:L64X128MixRandomLegacy:SecureRandomLXM:L128X1024MixRandomLXM:L64X128StarStarRandomXoshiro:Xoshiro256PlusPlusLXM:L64X256MixRandomLegacy:RandomXoroshiro:Xoroshiro128PlusPlusLXM:L128X256MixRandomLegacy:SplittableRandomLXM:L64X1024MixRandom</code></pre><p><code>Legacy:Random</code>就是我们常用的<code>java.util.Random</code>，我们来试试看：</p><pre><code class="java">RandomGenerator randomGenerator = RandomGeneratorFactory.of(&quot;Random&quot;)        .create(System.currentTimeMillis());System.out.println(randomGenerator.getClass());System.out.println(randomGenerator.nextInt(10));</code></pre><p>结果是：</p><pre><code class="log">class java.util.Random6 （这个值随不同的运行结果不同）</code></pre><p>我们还可以使用流式编程方式批量获取随机数：</p><pre><code class="java">final IntStream ints = RandomGeneratorFactory.of(&quot;L128X128MixRandom&quot;)        .create()        .ints(10, 0, 100);System.out.println(Arrays.toString(ints.toArray()));</code></pre><p>结果会得到 10 个随机数字数组（每次运行结果不同）：</p><pre><code class="log">[50, 16, 73, 4, 79, 32, 55, 34, 40, 53]</code></pre><h2 id="新的-MacOS-渲染库（JEP-382）"><a href="#新的-MacOS-渲染库（JEP-382）" class="headerlink" title="新的 MacOS 渲染库（JEP 382）"></a>新的 MacOS 渲染库（JEP 382）</h2><p>MacOS 为了提升图形渲染性能，在 2018 年 9 月放弃之前的 OpenGL 渲染库，选用了 Apple Metal。从 Java17 开始，Swing API 内部用于渲染 Java 2D 的 API 开始使用新的 Apple Metal 加速渲染 API。</p><p>默认情况下，这个功能不启用，需要主动开启：</p><pre><code class="sh">-Dsun.java2d.metal=true</code></pre><p>这个特性改动是属于 API 内部实现，使用上没有任何差别。而且对 MacOS 的系统版本有要求，需要在 MacOS10.14 版本或以上，否则还是会使用 OpenGL 渲染图形。</p><h2 id="MacOS-AArch64-端口（JEP-391）"><a href="#MacOS-AArch64-端口（JEP-391）" class="headerlink" title="MacOS/AArch64 端口（JEP 391）"></a>MacOS/AArch64 端口（JEP 391）</h2><p>苹果在 2020 年 6 月的 WWDC 的演讲中宣布，将开启长期将 Macintosh 系列从 x64 过渡到 AArch64 的计划，该特性主要是为了适应这种改变。</p><p>Linux 的 AArch64 支持是在 Java9 提供的（参见 <a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a>），Windows 的 AArch64 支持是在 Java16 提供的（参见 <a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a>）。</p><p>在 Java12 的时候对 AArch64 的支持库进行了统一，只保留了一套维护代码（参见 <a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a>）。</p><h2 id="强封装-JDK-内部-API（JEP-403）"><a href="#强封装-JDK-内部-API（JEP-403）" class="headerlink" title="强封装 JDK 内部 API（JEP 403）"></a>强封装 JDK 内部 API（JEP 403）</h2><p>在 Java16 中为了改进 JDK 的安全性和可维护性，对内部 API 进行了封装，但是也留了后门，可以使用启动参数<code>--illegal-access</code>控制内部 API 的封装程度。（参见 <a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a>）</p><p>到了 Java17 中，除了<code>sun.misc.Unsafe</code>可以使用，其他的内部 API 都变成了强封装模式，而且<code>--illegal-access</code>命令也被移除，如果还在命令中添加该参数，会直接报错：</p><pre><code class="log">~ $ java -versionopenjdk version &quot;17.0.1&quot; 2021-10-19OpenJDK Runtime Environment (build 17.0.1+12-39)OpenJDK 64-Bit Server VM (build 17.0.1+12-39, mixed mode, sharing)~ $ java --illegal-accessUnrecognized option: --illegal-accessError: Could not create the Java Virtual Machine.Error: A fatal exception has occurred. Program will exit.</code></pre><h2 id="密封类（JEP-409）"><a href="#密封类（JEP-409）" class="headerlink" title="密封类（JEP 409）"></a>密封类（JEP 409）</h2><p>密封类特性是在 Java15 提供预览版，Java16 提供第二版预览，终于在 Java17 中成为正式功能。该特性限制哪些其他类或接口可以扩展或实现密封组件。</p><p>JEP 409 并没有对密封类有新的特性，可以参考 <a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a>、<a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a>，这里不再重复。</p><h2 id="上下文特定的反序列化过滤器（JEP-415）"><a href="#上下文特定的反序列化过滤器（JEP-415）" class="headerlink" title="上下文特定的反序列化过滤器（JEP 415）"></a>上下文特定的反序列化过滤器（JEP 415）</h2><p>Java 对象序列化是一个非常重要的功能，可以透明化远程处理，也促进了 JavaEE 的成功。序列化过程没有问题，但是反序列化过程可能存在危险：</p><ul><li>许多情况下传入的数据流内容是通过未知或未经身份验证的客户端获取的；</li><li>序列化数据流中可能携带带有攻击者精心构造的恶意代码。</li></ul><p>终于在 Java17 中增加了反序列化过滤器，允许应用程序使用 JVM 范围的过滤器工厂，配置特定于上下文和动态选择的反序列化过滤器，该工厂用于为每个反序列化操作选择一个过滤器。</p><p>简单点说，就是提前说好可以反序列化哪些类，如果序列化数据流中包含不被允许的类对象，就直接报错。</p><h2 id="预览功能"><a href="#预览功能" class="headerlink" title="预览功能"></a>预览功能</h2><h3 id="Switch-的模式匹配（JEP-406）"><a href="#Switch-的模式匹配（JEP-406）" class="headerlink" title="Switch 的模式匹配（JEP 406）"></a>Switch 的模式匹配（JEP 406）</h3><p>这个特性功能很赞，在 Java14 中正式提供 Switch 表达式特性（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a>），本次提供的是 Switch 模式匹配与 instanceof 模式匹配有些类似，是能够在 Switch 表达式实现类型自动转换。</p><p>比如：</p><pre><code class="java">static String formatterPatternSwitch(Object o) {    return switch (o) {        case null -&gt; &quot;null&quot;;        case Integer i -&gt; String.format(&quot;int %d&quot;, i);        case Long l -&gt; String.format(&quot;long %d&quot;, l);        case Double d -&gt; String.format(&quot;double %f&quot;, d);        case String s -&gt; String.format(&quot;String %s&quot;, s);        default -&gt; o.getClass().getSimpleName() + &quot; &quot; + o;    };}public static void main(String[] args) {    System.out.println(formatterPatternSwitch(null));    System.out.println(formatterPatternSwitch(&quot;1&quot;));    System.out.println(formatterPatternSwitch(2));    System.out.println(formatterPatternSwitch(3L));    System.out.println(formatterPatternSwitch(4.0));    System.out.println(formatterPatternSwitch(new AtomicLong(5)));}</code></pre><p>结果是：</p><pre><code class="log">nullString 1int 2long 3double 4.000000AtomicLong 5</code></pre><p>可以看到，不只是类型自动转换，还可以直接判断是否是<code>null</code>，省了前置判断对象是否是<code>null</code>了。</p><p>期待这个功能早日转正。</p><h2 id="孵化功能"><a href="#孵化功能" class="headerlink" title="孵化功能"></a>孵化功能</h2><h3 id="外部函数和内存-API（JEP-412）"><a href="#外部函数和内存-API（JEP-412）" class="headerlink" title="外部函数和内存 API（JEP 412）"></a>外部函数和内存 API（JEP 412）</h3><p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据互操作。通过有效地调用外部函数（即 JVM 外部的代码），并通过安全地访问外部内存（即不由 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会有 JNI 的脆弱性和危险。</p><p>通过更加优雅的方式访问外部函数是从 Java14 开始的，经历了多个孵化版本：</p><ul><li>Java14 的 JEP 370：外部存储器访问 API（孵化）</li><li>Java15 的 JEP 383：外部存储器访问 API（第二版孵化功能）</li><li>Java16 的 JEP 389：外部链接器 API（孵化功能）</li><li>Java16 的 JEP 393：外部存储器访问 API（第三版孵化功能）</li><li>Java17 的 JEP 412：外部函数和内存 API</li></ul><p>可以看出来，虽然一直在孵化，但是功能越来越强大，这一旦孵出来，岂不是超级神兽了。</p><p>这一系列的功能都是为了能够在 Java 类中调用 C 语言类库：</p><pre><code class="java">private static final SymbolLookup libLookup;static {    // loads a particular C library    var path = JEP412.class.getResource(&quot;/print_name.so&quot;).getPath();    System.load(path);    libLookup = SymbolLookup.loaderLookup();}</code></pre><p>第一步，需要加载我们希望通过 API 调用的目标库。<br>第二步，我们需要指定目标方法的签名，并最终调用它：</p><pre><code class="java">public String getPrintNameFormat(String name) {    var printMethod = libLookup.lookup(&quot;printName&quot;);    if (printMethod.isPresent()) {        var methodReference = CLinker.getInstance()            .downcallHandle(                printMethod.get(),                MethodType.methodType(MemoryAddress.class, MemoryAddress.class),                FunctionDescriptor.of(CLinker.C_POINTER, CLinker.C_POINTER)            );        try {            var nativeString = CLinker.toCString(name, newImplicitScope());            var invokeReturn = methodReference.invoke(nativeString.address());            var memoryAddress = (MemoryAddress) invokeReturn;            return CLinker.toJavaString(memoryAddress);        } catch (Throwable throwable) {            throw new RuntimeException(throwable);        }    }    throw new RuntimeException(&quot;printName function not found.&quot;);}</code></pre><blockquote><p>上面这段代码摘自<a href="https://www.baeldung.com/java-17-new-features" target="_blank" rel="noopener">https://www.baeldung.com/java-17-new-features</a>。</p></blockquote><h3 id="Vector-API（JEP-414，第二版孵化）"><a href="#Vector-API（JEP-414，第二版孵化）" class="headerlink" title="Vector API（JEP 414，第二版孵化）"></a>Vector API（JEP 414，第二版孵化）</h3><p>Vector 向量计算 API 是为了处理 SIMD（Single Instruction Multiple Data，单指令多数据）类型的操作，即并行执行的各种指令集。它利用支持向量指令的专用 CPU 硬件，并允许以管道的形式执行此类指令。这种运算方式可以让开发人员实现更高效的代码，充分利用底层硬件的潜力。日常使用包括科学代数线性应用程序、图像处理、字符处理、繁重的算术应用程序，以及任何需要对多个独立操作数应用一个运算的应用程序。</p><p>Vector 向量计算 API 是在 Java16 引入（参见 <a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a>），可以在运行时借助 CPU 向量运算指令，实现更优的计算能力。在 Java17 中，针对性能和实现进行了改进，包括字节向量与布尔数组之间进行转换。</p><p>原来的向量运算我们需要这样写：</p><pre><code class="java">for (var i = 0; i &lt; a.length; i++) {    c[i] = a[i] * b[i];}</code></pre><p>现在我们可以这样写：</p><pre><code class="java">final VectorSpecies&lt;Float&gt; SPECIES = FloatVector.SPECIES_PREFERRED;for (var i = 0; i &lt; a.length; i += SPECIES.length()) {    var m = SPECIES.indexInRange(i, a.length);    var va = FloatVector.fromArray(SPECIES, a, i, m);    var vb = FloatVector.fromArray(SPECIES, b, i, m);    var vc = va.mul(vb);    vc.intoArray(c, i, m);}</code></pre><h2 id="弃用和删除"><a href="#弃用和删除" class="headerlink" title="弃用和删除"></a>弃用和删除</h2><h3 id="启用-Applet-API（JEP-398）"><a href="#启用-Applet-API（JEP-398）" class="headerlink" title="启用 Applet API（JEP 398）"></a>启用 Applet API（JEP 398）</h3><p>Applet 是用 Java 编写可以嵌入到网页中的小应用，属于已经过时的技术，很多浏览器已经取消支持。Applet API 在 Java9 的时候标记了过期，在 Java17 标记为删除（<code>@Deprecated(since = &quot;9&quot;, forRemoval = true)</code>）。</p><p>记得我上学的时候，课本上还有这部分内容。</p><h3 id="删除-RMI-激活机制（JEP-407）"><a href="#删除-RMI-激活机制（JEP-407）" class="headerlink" title="删除 RMI 激活机制（JEP 407）"></a>删除 RMI 激活机制（JEP 407）</h3><p>RMI 激活机制在 Java15 标记了过期（参见 <a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a>），到 Java17 正式删除。这里只是删除了 RMI 激活机制，对于其他 RMI 功能不受影响。</p><h3 id="删除实验性的-AOT-和-JIT-编译器（JEP-410）"><a href="#删除实验性的-AOT-和-JIT-编译器（JEP-410）" class="headerlink" title="删除实验性的 AOT 和 JIT 编译器（JEP 410）"></a>删除实验性的 AOT 和 JIT 编译器（JEP 410）</h3><p>在 Java9 的 JEP 295 中，引入了实验性的提前编译 jaotc 工具，但是这个特性自从引入依赖用处都不太大，而且需要大量的维护工作，所以在 Java17 中决定删除这个特性。</p><p>但是保留了实验性的 Java 级 JVM 编译器接口（JVMCI），这样开发人员也可以继续使用外部构建的编译器版本，并使用 Graal 编译器（GraalVM）进行 JIT 编译。</p><h3 id="弃用安全管理器（JEP-411）"><a href="#弃用安全管理器（JEP-411）" class="headerlink" title="弃用安全管理器（JEP 411）"></a>弃用安全管理器（JEP 411）</h3><p>Security Manager 在 JDK1.0 时就已经引入，但是它一直都不是保护服务端以及客户端 Java 代码的主要手段，对于如此鸡肋的功能，最终决定标记为删除（<code>@Deprecated(since=&quot;17&quot;, forRemoval=true)</code>）。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java17 新增的特性，完整的特性清单可以从 <a href="https://openjdk.java.net/projects/jdk/17/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/17/</a> 查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>Java17 是 LTS（长期支持版），上个 LTS 版本是 Java11，很多团队已经在生产上切换，相信接下来会有一些团队在测试环境尝鲜。</p><p>有人认为 Java8 是神，有人则喜欢不断地尝鲜，你是哪种呢？欢迎在留言说下你在用哪个版本？</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/By2JoZqAHA6U36PG8qvCcg" target="_blank" rel="noopener">Java17 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/W6Esovb7zzCL_seXgY84jA" target="_blank" rel="noopener">Java18 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/WutbAX_IQNqP4M3rud9f_g" target="_blank" rel="noopener">Java19 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/DvZYrZTtGfdXNsXGzmQN1A" target="_blank" rel="noopener">Java20 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/iiXa9rpJu1Vedpke0XpBzQ" target="_blank" rel="noopener">Java21 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/eHHFaJErH8XH4QSRrfcehQ" target="_blank" rel="noopener">Java22 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/XvB0D2vzhaAvHESupdALag" target="_blank" rel="noopener">Java23 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">Java24 的新特性</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-17-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java17 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/124830768" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java17 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Java17 是在 2021 年 9 月发布的一个 LTS 版本（长期支持版本），上一个长期支持版是 Java11，于 2018 年 9 月发布。从目前来看，Java11 在市场占有率已进过半，如果错过了升级 Java11，我们可不要错过这次的升级。接下来我们看看 Java17 为我们带来了哪些新增特性：JEP 306：恢复严格的浮点语义；JEP 356：增强型伪随机数生成器；JEP 382：新的 macOS 渲染管道；JEP 391：macOS/AArch64 端口；JEP 398：弃用 Applet API；JEP 403：强封装 JDK 内部 API；JEP 406：Switch 的模式匹配（预览）；JEP 407：删除 RMI 激活机制；JEP 409：密封类；JEP 410：删除实验性的 AOT 和 JIT 编译器；JEP 411：弃用安全管理器；JEP 412：外部函数和内存 API（孵化）；JEP 414：Vector API（第二版孵化）；JEP 415：上下文特定的反序列化过滤器；接下来我们一起看看这些特性。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java17" scheme="https://www.howardliu.cn/tags/Java17/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java16 的新特性</title>
    <link href="https://www.howardliu.cn/java-16-features/"/>
    <id>https://www.howardliu.cn/java-16-features/</id>
    <published>2022-04-18T23:48:47.000Z</published>
    <updated>2022-04-18T23:48:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/yellow-5219524_1920.jpeg" alt="Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java16 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java16 是在 2021 年 3 月发布的一个短期版本，新增特性如下：</p><ul><li>JEP 338：向量 API（孵化功能）</li><li>JEP 347：启用 C++ 14 语言特性</li><li>JEP 357：从 Mercurial 迁移到 Git</li><li>JEP 369：迁移到 GitGitHub</li><li>JEP 376：ZGC 的并发线程堆栈处理</li><li>JEP 380：支持 Unix 套接字</li><li>JEP 386：Alpine Linux 移植</li><li>JEP 387：弹性元空间</li><li>JEP 388：Windows/AArch64 移植</li><li>JEP 389：外部链接器 API（孵化功能）</li><li>JEP 390：对基于值的类设置“弃用移除”警告</li><li>JEP 392：打包工具</li><li>JEP 393：外部存储器访问 API（第三版孵化功能）</li><li>JEP 394：instanceof 模式匹配</li><li>JEP 395：Record 类型</li><li>JEP 396：默认强封装 JDK 内部元素</li><li>JEP 397：密封类（第二版预览功能）</li></ul><p>接下来我们一起看看这些特性。</p><h2 id="启用-C-14-语言特性（JEP-347）"><a href="#启用-C-14-语言特性（JEP-347）" class="headerlink" title="启用 C++ 14 语言特性（JEP 347）"></a>启用 C++ 14 语言特性（JEP 347）</h2><p>在 JDK15 之前，JDK 中使用的 C++语言限制在 C++98/03 版本，没有办法使用更高级的特性，从 JDK16 开始，可以支持 C++14 的语言特性。</p><p>这一点更新对应用开发者可能关系不大，但是对于底层组件的开发者意义重大。Java 的版本更新迅速，C++的特性也是飞速更新，如果 JDK 还是限制在 C++98/03 版本，没有办法使用 C++11/14 中的高级特性，也是一种损失。</p><h2 id="从-Mercurial-迁移到-Git（JEP-357、JEP-369）"><a href="#从-Mercurial-迁移到-Git（JEP-357、JEP-369）" class="headerlink" title="从 Mercurial 迁移到 Git（JEP 357、JEP 369）"></a>从 Mercurial 迁移到 Git（JEP 357、JEP 369）</h2><p>这是两个提案，JEP 357 是将 OpenJDK 社区的源代码版本控制工具，从 Mercurial（hg）迁移到 Git，JEP 369 是将 OpenJDK 项目定向到 GitHub 中的仓库，我们可以看到从 OpenJDK 的 JIRA 工具中，代码提交和 Issue 预览的都是在 <a href="https://github.com/openjdk" target="_blank" rel="noopener">https://github.com/openjdk</a> 中，有一部分是从 <a href="https://git.openjdk.java.net" target="_blank" rel="noopener">https://git.openjdk.java.net</a> 重定向到 GitHub。</p><p>Mercurial（hg）是一个 Python 编写的跨平台的分布式版本控制软件，与 Git 是同一时代开始的工具，功能也是很强大，只是在发展过程中，有些方面稍弱于 Git，比如元数据的占用、与现代工具链的集成。所以 OpenJDK 转而投向了 Git 的怀抱。</p><h2 id="ZGC-的并发线程堆栈处理（JEP-376）"><a href="#ZGC-的并发线程堆栈处理（JEP-376）" class="headerlink" title="ZGC 的并发线程堆栈处理（JEP 376）"></a>ZGC 的并发线程堆栈处理（JEP 376）</h2><p>ZGC 是在 Java11 引入的（参见 <a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 新特性</a>），在 Java15 中正式特性（参见 <a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 新特性</a>），可以用命令<code>-XX:+UseZGC</code>启用 ZGC。</p><p>ZGC 是一个并发的垃圾回收器，可以极大地提升 GC 的性能，支持任意堆大小而保持稳定的低延迟。在 128G 堆大小的测试中，ZGC 优势明显，找了一张网上的图片：</p><p><img src="https://static.howardliu.cn/java/java-11-1.png" alt="ZGC：可伸缩低延迟垃圾收集器"></p><p>ZGC 的目标是实现垃圾回收与程序同时运行，将 STW 降低为 0，即不存在中断。目前在标记、重定位、参考处理、类卸载和跟处理阶段删除安全点处理。目前 ZGC 中仍然依靠安全点执行的包括部分的根处理和有时间限制的标记终止操作。这些根处理中有一项就是 Java 线程堆栈处理。随着线程数量增加，停顿时间增长。所以，我们需要实现并发的堆栈处理。目标包括：</p><ul><li>ZGC 的安全点不再包含线程堆栈处理。</li><li>使堆栈处理变得惰性、协作、并发和增量。</li><li>从 ZGC 安全点中删除所有其他线程根处理。</li><li>提供一种机制，其他 HotSpot 子系统（如 Loom 和 JFR）可以通过该机制惰性地处理堆栈。</li></ul><h2 id="支持-Unix-套接字（JEP-380）"><a href="#支持-Unix-套接字（JEP-380）" class="headerlink" title="支持 Unix 套接字（JEP 380）"></a>支持 Unix 套接字（JEP 380）</h2><p>对于本地进程间通信，Unix 套接字比 TCP/IP 更加安全高效。Unix 套接字一直是大多数 Unix 平台的一个特性，现在在 Windows 10 和 Windows Server 2019 也提供了支持。</p><p>所以在 Java16 中为<code>java.nio.channels</code>包的<code>SocketChannel</code>和<code>ServerSocketChannel</code>添加了 Unix（AF_UNIX）套接字支持。Unix 套接字用于同一主机上的进程间通信（IPC）, 在很大程度上类似于 TCP/IP，区别在于套接字是通过文件系统路径名而不是 Internet 协议（IP）地址和端口号寻址的。对于本地进程间通信，Unix 套接字比 TCP/IP 环回连接更安全、更有效。</p><h2 id="Alpine-Linux-移植、Windows-AArch64-移植（JEP-386、JEP-388）"><a href="#Alpine-Linux-移植、Windows-AArch64-移植（JEP-386、JEP-388）" class="headerlink" title="Alpine Linux 移植、Windows/AArch64 移植（JEP 386、JEP 388）"></a>Alpine Linux 移植、Windows/AArch64 移植（JEP 386、JEP 388）</h2><p>这些移植的价值不在于移植本身，而在于支持平台的多样性。Java 的口号是一次编写到处运行。既然要到处运行，就得支持各种平台。而且，针对不同的操作系统支持，还能给我们提供更多的选择。</p><p>Alpine Linux 是一个独立非商业的 Linux 发行版，体系非常小，一个容器需要不超过 8MB 的空间，磁盘最小仅需 130MB 存储。如果我们通过 jlink 生产 JDK，Docket 镜像可以减小到 38MB，这样在微服务部署过程中，可以减少很多磁盘占用，也能减少镜像传输、部署时间。</p><h2 id="弹性元空间（JEP-387）"><a href="#弹性元空间（JEP-387）" class="headerlink" title="弹性元空间（JEP 387）"></a>弹性元空间（JEP 387）</h2><p>这是在 HotSpot 中的空间分配上的优化，将未使用的元空间（metaspace，也叫类的元空间）中的内容存返回给操作系统。</p><p>应用程序如果存在大量类加载和类卸载的动作时，会占用大量的元空间内存，这部分内存得不到释放，造成内存利用率低。现在的应用系统为了应对高并发的流量，动辄部署数十上百台实例，这将造成极大的资源浪费。</p><p>元空间的内存方式使用的是基于区域的内存管理方式（Region-based memory management），也就是每个分配的对象都被分配到一个区域中。这里的区域有不同的叫法：zone（区域）、arena（竞技场）、memory context（内存上下文）等。</p><p>当类被回收后，其元空间区域中的内存块会返回自由列表中，以便以后重新使用。当然，可能很长使用不会被重新使用。这样就会造成元空间中很多的内存碎片，这些都是被标记为占用的内存。如果没有碎片的内存空间，是可以返回给操作系统的。</p><p>在 JEP 387 特性中，提出使用基于伙伴的内存分配算法（Buddy memory allocation）改善元空间的内存使用，这种方式是一种在 Linux 内核中经过验证的成熟算法。这种算法是在很小的块（chunk）中分配内存，这会降低类加载器的开销。</p><p>同时，JEP 387 增加了内存延迟提交给内存区域的特性，这样就会减少那种申请了内存却不使用的情况。</p><p>最后，JEP 387 将元空间的内存区域设计为不同大小，可以满足不同大小需求的内存申请。</p><p>这些操作与 Java13 中对 ZGC 的增强特性很类似（参见 <a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a>）。他山之石可以攻玉，我们不妨学习一下这些方式，对我们在以后的开发中提供思路。</p><h2 id="对基于值的类设置“弃用移除”警告（JEP-390）"><a href="#对基于值的类设置“弃用移除”警告（JEP-390）" class="headerlink" title="对基于值的类设置“弃用移除”警告（JEP 390）"></a>对基于值的类设置“弃用移除”警告（JEP 390）</h2><p>将基于值的类的公共构造函数设置启用移除警告。</p><p>比如<code>Interger</code>的构造函数上设置了<code>@Deprecated(since=&quot;9&quot;, forRemoval = true)</code>。如果某个类使用了<code>Integer integer = new Integer(1);</code>这种写法，通过<code>javac</code>命令编译时，会收到<code>警告：[removal] Integer 中的 Integer(int) 已过时，且标记为待删除</code>这种警告信息。</p><p>基于值的类在类定义上都会有<code>@jdk.internal.ValueBased</code>注解，比如<code>java.lang.Integer</code>、<code>java.lang.Double</code>等。这样的改动是为 Valhalla 项目做准备。</p><h2 id="打包工具（JEP-392）"><a href="#打包工具（JEP-392）" class="headerlink" title="打包工具（JEP 392）"></a>打包工具（JEP 392）</h2><p>打包工具是在 Java14 中引入的孵化功能（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a>），可以打包成自包含的 Java 应用程序，比如 Windows 的 exe 和 msi、Mac 的 pkg 和 dmg、Linux 的 deb 和 rpm 等。</p><p>我们可以使用<code>jlink</code>创建一个最小可运行的模块包，然后使用<code>jpackage</code>将其构建成安装包：</p><pre><code class="shell">jpackage --name myapp --input lib --main-jar main.jar</code></pre><p>这里需要注意一点，因为已经成为正式功能，模块名从<code>jdk.incubator.jpackage</code>改为<code>jdk.jpackage</code>。</p><h2 id="instanceof-模式匹配（JEP-394）"><a href="#instanceof-模式匹配（JEP-394）" class="headerlink" title="instanceof 模式匹配（JEP 394）"></a>instanceof 模式匹配（JEP 394）</h2><p>instanceof 模式匹配首先在 Java14 中提供预览功能（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 特性</a>），可以提供<code>instanceof</code>更加简洁高效的实现，在 Java15 中进行了第二次预览，用于收集反馈，终于是多年的媳妇熬成婆，在 Java16 中成为正式功能。</p><p>我们再简单复习一下<code>instanceof</code>模式匹配的功能（详细使用可以移步 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 特性</a>）：</p><pre><code class="java">@Testvoid test1() {    final Object obj1 = &quot;Hello, World!&quot;;    int result = 0;    if (obj1 instanceof String str) {        result = str.length();    } else if (obj1 instanceof Number num) {        result = num.intValue();    }    Assertions.assertEquals(13, result);}</code></pre><h2 id="Record-类型（JEP-395）"><a href="#Record-类型（JEP-395）" class="headerlink" title="Record 类型（JEP 395）"></a>Record 类型（JEP 395）</h2><p>Record 类型用来增强 Java 语言特性，充当不可变数据载体。与 instanceof 模式匹配一样，Record 类型也是在 Java14 中提供预览功能（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 新特性</a>），在 Java15 中进行了第二次预览，用于收集反馈。</p><p>我们再简单复习一下 Record 类型的功能，比如，我们定义一个<code>Person</code>类：</p><pre><code class="java">public record Person(String name, String address) {}</code></pre><p>我们转换为之前的定义会是一坨下面这种代码：</p><pre><code class="java">public final class PersonBefore14 {    private final String name;    private final String address;    public PersonBefore14(String name, String address) {        this.name = name;        this.address = address;    }    public String name() {        return name;    }    public String address() {        return address;    }    @Override    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        PersonBefore14 that = (PersonBefore14) o;        return Objects.equals(name, that.name) &amp;&amp; Objects.equals(address, that.address);    }    @Override    public int hashCode() {        return Objects.hash(name, address);    }    @Override    public String toString() {        return &quot;PersonBefore14{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +                &#39;}&#39;;    }}</code></pre><p>Record 类型特性有四个特性：</p><ol><li>设计一个面向对象的结构，表达简单的信息聚合；</li><li>帮助开发人员专注于建模不可变数据，而不是可扩展的行为；</li><li>自动实现数据驱动的方法，比如<code>equals</code>、<code>getter</code>、<code>setter</code>等方法；</li><li>保留长期存在的 Java 规范，比如迁移兼容性。</li></ol><p>我们不能将 Record 类型简单的理解为去除“样板化”代码的功能，它不是解决 JavaBean 命名约定的中很多模板化方法的冗余繁杂问题，它的目标不是类似 Lombok 等工具自动生成代码的功能，是从开发人员专注模型的角度出发的。</p><h2 id="默认强封装-JDK-内部元素（JEP-396）"><a href="#默认强封装-JDK-内部元素（JEP-396）" class="headerlink" title="默认强封装 JDK 内部元素（JEP 396）"></a>默认强封装 JDK 内部元素（JEP 396）</h2><p>这个功能特性是为了改进 JDK 的安全性和可维护性，是 Jigsaw 项目的主要目标之一。所以在 Java16 中，默认强封装 JDK 的绝大部分内部 API，有些关键性的 API，比如<code>sun.misc.Unsafe</code>暂时可以放心使用。</p><p>我们可以使用启动参数<code>--illegal-access</code>控制内部 API 的封装程度：</p><ul><li><code>--illegal-access=permit</code>：JDK 8 中存在的每个包对未命名模块中的代码开放。也就是放心大胆地使用。Java9 中默认就是这个等级；</li><li><code>--illegal-access=warn</code>：与许可相同，不同之处在于每次非法反射访问操作都会发出警告消息；</li><li><code>--illegal-access=debug</code>：与 warn 相同，不同的是，每个非法反射访问操作都会发出警告消息和堆栈跟踪；</li><li><code>--illegal-access=deny</code>：禁用所有非法访问操作，但由其他命令行选项（例如<code>--add-opens</code>）启用的操作除外。</li></ul><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><h3 id="密封类-预览第二版（JEP-397）"><a href="#密封类-预览第二版（JEP-397）" class="headerlink" title="密封类-预览第二版（JEP 397）"></a>密封类-预览第二版（JEP 397）</h3><p>密封类首次在 Java15 中预览（参见 <a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 新特性</a>），在 Java16 中进行第二次预览，我们在复习一下功能：</p><pre><code class="java">public sealed interface JungleAnimal permits Monkey, Snake  {}public final class Monkey implements JungleAnimal {}public non-sealed class Snake implements JungleAnimal {}</code></pre><p><code>sealed</code>关键字与<code>permits</code>关键字结合使用，以确定允许哪些类实现此接口。在我们的例子中，是<code>Monkey</code>和<code>Snake</code>。</p><ul><li><code>sealed</code>：必须使用<code>permits</code>关键字定义允许继承的子类；</li><li><code>final</code>：最终类，不再有子类；</li><li><code>non-sealed</code>：普通类，任何类都可以继承它。</li></ul><h2 id="孵化"><a href="#孵化" class="headerlink" title="孵化"></a>孵化</h2><h3 id="向量-API（JEP-338）"><a href="#向量-API（JEP-338）" class="headerlink" title="向量 API（JEP 338）"></a>向量 API（JEP 338）</h3><p>这是为向量计算专门定义的 API，可以在运行时可靠地编译为支持的 CPU 架构上的最佳向量硬件指令，从而获得优于同等标量计算的性能，充分利用单指令多数据（SIMD）技术（大多数现代 CPU 上都可以使用的一种指令）。该 API 将使开发人员能够轻松地用 Java 编写可移植的高性能向量算法。</p><p>尽管 HotSpot 支持自动向量化，但是可转换的标量操作集有限且易受代码更改的影响。</p><pre><code class="java">final int[] a = {1, 2, 3, 4};final int[] b = {5, 6, 7, 8};final int[] c = new int[3];IntVector vectorA = IntVector.fromArray(IntVector.SPECIES_128, a, 0);IntVector vectorB = IntVector.fromArray(IntVector.SPECIES_128, b, 0);IntVector vectorC = vectorA.mul(vectorB);vectorC.intoArray(c, 0);</code></pre><p>这个功能在 Java17 中进行了第二次孵化，基于使用安全的考虑，我们在短时间内用不上这个特性了。</p><h3 id="外部链接器-API（JEP-389）"><a href="#外部链接器-API（JEP-389）" class="headerlink" title="外部链接器 API（JEP 389）"></a>外部链接器 API（JEP 389）</h3><p>这个特性提供了静态类型、纯 Java 访问原生代码的 API，大大简化绑定原生库的原本复杂且容易出错的过程。从 Java1.1 开始，我们可以通过原生接口（JNI）调用原生方法，但是并不好用，现在提供了外部链接器 API，可以不再使用 JNI 粘合代码了。</p><p>和向量 API 一样，暂时用不上了，等啥时候转正了，咱们重点说说怎么玩。</p><h3 id="外部存储器访问-API-孵化第三版（JEP-393）"><a href="#外部存储器访问-API-孵化第三版（JEP-393）" class="headerlink" title="外部存储器访问 API-孵化第三版（JEP 393）"></a>外部存储器访问 API-孵化第三版（JEP 393）</h3><p>外部存储器访问 API 在 Java14 开始孵化（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 新特性</a>），在 Java15 中孵化第二版（参见 <a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 新特性</a>），在 Java16 中进行第三版孵化。</p><p>外部存储器访问 API 使 Java 程序能够安全有效地对各种外部存储器（例如本机存储器、持久性存储器、托管堆存储器等）进行操作。外部内存通常是说那些独立 JVM 之外的内存区域，可以不受 JVM 垃圾收集的影响，通常能够处理较大的内存。</p><p>这次带来的特性包括：</p><ul><li><code>MemorySegment</code>和<code>MemoryAddress</code>接口之间更加清晰的职责分离；</li><li>增加了新接口<code>MemoryAccess</code>，提供了常见的静态内存访问器，以便在简单的情况下尽量减少对<code>VarHandle</code> 的需求；</li><li>支持共享 segments，并提供向清理器注册 segments 的能力。</li></ul><p>这些新的 API 虽然不会直接影响多数的应用类开发人员，但是他们可以在内存的第三方库中提供支持，包括分布式缓存、非结构化文档存储、大型字节缓冲区、内存映射文件等。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java16 新增的特性，完整的特性清单可以从 <a href="https://openjdk.java.net/projects/jdk/16/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/16/</a> 查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/By2JoZqAHA6U36PG8qvCcg" target="_blank" rel="noopener">Java17 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/W6Esovb7zzCL_seXgY84jA" target="_blank" rel="noopener">Java18 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/WutbAX_IQNqP4M3rud9f_g" target="_blank" rel="noopener">Java19 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/DvZYrZTtGfdXNsXGzmQN1A" target="_blank" rel="noopener">Java20 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/iiXa9rpJu1Vedpke0XpBzQ" target="_blank" rel="noopener">Java21 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/eHHFaJErH8XH4QSRrfcehQ" target="_blank" rel="noopener">Java22 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/XvB0D2vzhaAvHESupdALag" target="_blank" rel="noopener">Java23 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">Java24 的新特性</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-16-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java16 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/124264210" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java16 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Java16 是在 2021 年 3 月发布的一个短期版本，新增特性如下：JEP 338：向量 API（孵化功能）、JEP 347：启用 C++ 14 语言特性、JEP 357：从 Mercurial 迁移到 Git、JEP 369：迁移到 GitGitHub、JEP 376：ZGC 的并发线程堆栈处理、JEP 380：支持 Unix 套接字、JEP 386：Alpine Linux 移植、JEP 387：弹性元空间、JEP 388：Windows/AArch64 移植、JEP 389：外部链接器 API（孵化功能）、JEP 390：对基于值的类设置“弃用移除”警告、JEP 392：打包工具、JEP 393：外部存储器访问 API（第三版孵化功能）、JEP 394：instanceof 模式匹配、JEP 395：Record 类型、JEP 396：默认强封装 JDK 内部元素、JEP 397：密封类（第二版预览功能），接下来我们一起看看这些特性。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java16" scheme="https://www.howardliu.cn/tags/Java16/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java15 的新特性</title>
    <link href="https://www.howardliu.cn/java-15-features/"/>
    <id>https://www.howardliu.cn/java-15-features/</id>
    <published>2022-03-07T14:04:28.000Z</published>
    <updated>2022-03-07T14:04:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/eyes-5248678_1920.jpeg" alt="Java15 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java15 是在 2020 年 9 月发布的一个短期版本，新增特性如下：</p><ul><li>JEP 339：Edwards-Curve 数字签名算法</li><li>JEP 360：密封的类和接口（预览功能）</li><li>JEP 371：隐藏类</li><li>JEP 372：移除 Nashorn JavaScript 引擎</li><li>JEP 373：重新实现 DatagramSocket 接口</li><li>JEP 374：禁用偏向锁</li><li>JEP 375：instanceof 匹配模式（第二版预览功能）</li><li>JEP 377：ZGC：可伸缩低延迟垃圾收集器</li><li>JEP 378：文本块</li><li>JEP 379：Shenandoah：低暂停时间垃圾收集器</li><li>JEP 381：移除 Solaris 和 SPARC 端口 API</li><li>JEP 383：外部存储器访问 API（第二版孵化功能）</li><li>JEP 384：Record 类型（第二版预览功能）</li><li>JEP 385：废除 RMI Activation</li></ul><p>接下来我们一起看看这些特性。</p><h2 id="Edwards-Curve-数字签名算法（JEP-339）"><a href="#Edwards-Curve-数字签名算法（JEP-339）" class="headerlink" title="Edwards-Curve 数字签名算法（JEP 339）"></a>Edwards-Curve 数字签名算法（JEP 339）</h2><p>Edwards-Curve 数字签名算法（EdDSA），一种根据 RFC 8032 规范所描述的 Edwards-Curve 数字签名算法（EdDSA）实现加密签名。</p><p>EdDSA 是一种现代的椭圆曲线方案，与 JDK 中的现有签名方案相比，EdDSA 具有更高的安全性和性能，因此备受关注。它已经在 OpenSSL 和 BoringSSL 等加密库中得到支持，目前在区块链领域用的比较多。</p><p>我们看下官方给的例子：</p><pre><code class="java">byte[] msg = &quot;Hello, World!&quot;.getBytes(StandardCharsets.UTF_8);// example: generate a key pair and signKeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;Ed25519&quot;);KeyPair kp = kpg.generateKeyPair();// algorithm is pure Ed25519Signature sig = Signature.getInstance(&quot;Ed25519&quot;);sig.initSign(kp.getPrivate());sig.update(msg);System.out.println(Hex.encodeHexString(sig.sign()));// example: use KeyFactory to contruct a public keyKeyFactory kf = KeyFactory.getInstance(&quot;EdDSA&quot;);NamedParameterSpec paramSpec = new NamedParameterSpec(&quot;Ed25519&quot;);EdECPublicKeySpec pubSpec = new EdECPublicKeySpec(paramSpec, new EdECPoint(true, new BigInteger(&quot;1&quot;)));PublicKey pubKey = kf.generatePublic(pubSpec);System.out.println(pubKey.getAlgorithm());System.out.println(Hex.encodeHexString(pubKey.getEncoded()));System.out.println(pubKey.getFormat());</code></pre><p>例子中 Ed25519 是使用 SHA-512（SHA-2）和 Curve25519 的 EdDSA 签名方案。旨在提供与高质量 128 位对称密码相当的抗攻击能力，公钥长度为 256 位，签名长度为 512 位。</p><h2 id="隐藏类（JEP-371）"><a href="#隐藏类（JEP-371）" class="headerlink" title="隐藏类（JEP 371）"></a>隐藏类（JEP 371）</h2><p>Java15 引入了一个新的特性：隐藏类（Hidden Classes），一个专为框架而设计的特性。大多数开发人员不会直接使用这个特性，一般是通过动态字节码或 JVM 语言来使用隐藏类。</p><p>隐藏类有下面三个特点：</p><ol><li>不可发现：在运行时生成内部类对象；</li><li>访问控制：只能通过反射访问，不能直接被其他字节码访问；</li><li>较短的生命周期：可独立于其他类加载、卸载，且效率很高，能够减少框架的内存占用。</li></ol><p>隐藏类的功能特性还是比较有意思的，会涉及类加载、卸载、不可见、反射等很多内容，后续会开文单独聊，文章会放在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 专栏中。</p><h2 id="重新实现-DatagramSocket-接口（JEP-373）"><a href="#重新实现-DatagramSocket-接口（JEP-373）" class="headerlink" title="重新实现 DatagramSocket 接口（JEP 373）"></a>重新实现 DatagramSocket 接口（JEP 373）</h2><p>老的 DatagramSocket API 在 Java15 中被重写，是继 Java14 重写 Socket API 的后续不走。这个特性是 Loom 项目的先决条件。</p><p>目前，<code>DatagramSocket</code>和<code>MulticastSocket</code>将所有的套接字委托为<code>java.net.DatagramSocketImpl</code>的实现，根据不同的平台，Unix 平台使用<code>PlainDatagramSocketImpl</code>，Windows 平台使用<code>TwoStackPlainDatagramSocketImpl</code>和<code>DualPlainDatagramSocketImpl</code>。抽象类<code>DatagramSocketImpl</code>是 Java1.1 提供的，功能很少且有一些过时方法，阻碍了 NOI 的实现。</p><p>类似于 Java14 中对 Socket API 的重写（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 新特性</a>），会在<code>DatagramSocket</code>内部封装一个<code>DatagramSocket</code>实例，将所有调用直接委托给该实例。包装实例或者使用 NIO 的<code>DatagramChannel::socket</code>创建套接字，或者是使用原始<code>DatagramSocket</code>类的实现<code>DatagramSocketImpl</code>实现功能（用于实现向后兼容）。</p><p>我们可以看下新的依赖图：</p><p><img src="https://static.howardliu.cn/java/ReimplementDS.png" alt="DatagramSocket"></p><h2 id="禁用偏向锁（JEP-374）"><a href="#禁用偏向锁（JEP-374）" class="headerlink" title="禁用偏向锁（JEP 374）"></a>禁用偏向锁（JEP 374）</h2><p>在 Java15 中，默认禁用偏向锁，弃用了所有相关命令行选项。</p><p>偏向锁是 HotSpot 中一种用于减少非竞争锁定开销的优化技术，不过在如今的应用程序中，优化增益不太明显了。</p><p>根据官方说法，使用偏向锁增益最多的是大量使用早期同步组件（比如<code>Hashtable</code>、<code>Vector</code>等），随着新的 API 实现和针对多线程场景引入的支持并发的数据结构，偏向锁的锁定及撤销，会带来性能的开销，从而是优化收益降低。</p><p>而且随着越来越多的功能特性引入，偏向锁在同步子系统中引入的大量代码，侵入 HotSpot 其他组件，带来代码的复杂性和维护成本，成为代码优化的阻碍。所以官方要将其移除。</p><p>不过，有些应用在禁用偏向锁后会出现性能下降，可以使用<code>-XX:+UseBiasedLocking</code>手动开启。</p><h2 id="ZGC：可伸缩低延迟垃圾收集器（JEP-377）"><a href="#ZGC：可伸缩低延迟垃圾收集器（JEP-377）" class="headerlink" title="ZGC：可伸缩低延迟垃圾收集器（JEP 377）"></a>ZGC：可伸缩低延迟垃圾收集器（JEP 377）</h2><p>ZGC 是在 Java11 引入的（参见 <a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 新特性</a>），一直处于试验阶段，想要体验，需要在参数中使用<code>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code>组合启用，在 Java15 中，ZGC 成为正式特性，想要使用可以直接用命令<code>-XX:+UseZGC</code>就行。</p><p>ZGC 是一个重新设计的并发的垃圾回收器，可以极大的提升 GC 的性能，支持任意堆大小而保持稳定的低延迟。从 <a href="https://openjdk.java.net/jeps/333" target="_blank" rel="noopener">https://openjdk.java.net/jeps/333</a> 给出的数据可以看出来，在 128G 堆大小的测试中，ZGC 优势明显，找了一张网上的图片：</p><p><img src="https://static.howardliu.cn/java/java-11-1.png" alt="ZGC：可伸缩低延迟垃圾收集器"></p><p>虽然 ZGC 愿景很好，但是还有很长的路要走，所以默认的垃圾收集器还是 G1。</p><h2 id="Shenandoah：低暂停时间垃圾收集器（JEP-379）"><a href="#Shenandoah：低暂停时间垃圾收集器（JEP-379）" class="headerlink" title="Shenandoah：低暂停时间垃圾收集器（JEP 379）"></a>Shenandoah：低暂停时间垃圾收集器（JEP 379）</h2><p>Shenandoah 是在 Java12 引入的（参见）<a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a>，本次和 ZGC 一起转正。同样的，想要使用 Shenandoah，不再需要参数<code>-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC</code>组合，只使用<code>-XX:+UseShenandoahGC</code>即可。需要注意的是，Shenandoah 只在 OpenJDK 中提供，OracleJDK 中并不包含。</p><h2 id="文本块（JEP-378）"><a href="#文本块（JEP-378）" class="headerlink" title="文本块（JEP 378）"></a>文本块（JEP 378）</h2><p>文本块是千呼万唤终于转正，在 Java13 中首次引入（参见 <a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a>），在 Java14 中又增加了预览特性（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a>），终于在 Java15 确定下来，可以放心使用了。</p><p>我们再复习一下：</p><pre><code class="java">@Testvoid testTextBlock() {    final String singleLine = &quot;你好，我是看山，公众号「看山的小屋」。这行没有换行，而且我的后面多了一个空格 \n 这次换行了&quot;;    final String textBlockSingleLine = &quot;&quot;&quot;            你好，我是看山，公众号「看山的小屋」。\            这行没有换行，而且我的后面多了一个空格、s            这次换行了&quot;&quot;&quot;;    Assertions.assertEquals(singleLine, textBlockSingleLine);}</code></pre><p>这个功能特性是代码可读性的优化。</p><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><h3 id="密封类和接口（JEP-360）"><a href="#密封类和接口（JEP-360）" class="headerlink" title="密封类和接口（JEP 360）"></a>密封类和接口（JEP 360）</h3><p>目前，Java 没有提供对继承的细粒度控制，只有 public、protected、private、包内控制四种非常粗粒度的控制方式。</p><p>为此，密封类的目标是允许单个类声明哪些类型可以用作其子类型。这也适用于接口，并确定哪些类型可以实现它们。该功能特性新增了<code>sealed</code>和<code>non-sealed</code>修饰符和<code>permits</code>关键字。</p><p>我们可以做如下定义：</p><pre><code class="java">public sealed class Person permits Student, Worker, Teacher {}public sealed class Student extends Person        permits Pupil, JuniorSchoolStudent, HighSchoolStudent, CollegeStudent, GraduateStudent {}public final class Pupil extends Student {}public non-sealed class Worker extends Person {}public class OtherClass extends Worker {}public final class Teacher extends Person {}</code></pre><p>我们可以先定义一个<code>sealed</code>修饰的类<code>Person</code>，使用<code>permits</code>指定被继承的子类，这些子类必须是使用<code>final</code>或<code>sealed</code>或<code>non-sealed</code>修饰的类。其中<code>Student</code>是使用<code>sealed</code>修饰，所以也需要使用<code>permits</code>指定被继承的子类。<code>Worker</code>类使用<code>non-sealed</code>修饰，成为普通类，其他类都可以继承它。<code>Teacher</code>使用<code>final</code>修饰，不可再被继承。</p><p>从类图上看没有太多区别：</p><p><img src="https://static.howardliu.cn/java/sealed-class.png" alt="密封类和接口"></p><p>但是从功能特性上，起到了很好的约束作用，我们可以放心大胆的定义可以公开使用，但又不想被非特定类继承的类了。</p><h3 id="instanceof-模式匹配-预览第二版（JEP-375）"><a href="#instanceof-模式匹配-预览第二版（JEP-375）" class="headerlink" title="instanceof 模式匹配-预览第二版（JEP 375）"></a>instanceof 模式匹配-预览第二版（JEP 375）</h3><p>instanceof 模式匹配首先在 Java14 中提供预览功能（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 特性</a>），可以提供<code>instanceof</code>更加简洁高效的实现，在 Java15 中没有新增特性，主要是为了再次收集反馈，根据结果看，大家还是很期待这个功能，在 Java16 中正式提供。</p><p>我们再简单看下<code>instanceof</code>的改进：</p><pre><code class="java">@Testvoid test1() {    final Object obj1 = &quot;Hello, World!&quot;;    int result = 0;    if (obj1 instanceof String str) {        result = str.length();    } else if (obj1 instanceof Number num) {        result = num.intValue();    }    Assertions.assertEquals(13, result);}</code></pre><h3 id="Record-类型-预览第二版（JEP-384）"><a href="#Record-类型-预览第二版（JEP-384）" class="headerlink" title="Record 类型-预览第二版（JEP 384）"></a>Record 类型-预览第二版（JEP 384）</h3><p>Record 类型用来增强 Java 语言特性，充当不可变数据载体。在 Java14 中提供预览功能（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 新特性</a>），在 Java15 中提供第二次预览，这次预览的目标是收集用户反馈。</p><p>比如，我们定义一个<code>Person</code>类：</p><pre><code class="java">public record Person(String name, String address) {}</code></pre><p>我们转换为之前的定义会是一坨下面这种代码：</p><pre><code class="java">public final class PersonBefore14 {    private final String name;    private final String address;    public PersonBefore14(String name, String address) {        this.name = name;        this.address = address;    }    public String name() {        return name;    }    public String address() {        return address;    }    @Override    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        PersonBefore14 that = (PersonBefore14) o;        return Objects.equals(name, that.name) &amp;&amp; Objects.equals(address, that.address);    }    @Override    public int hashCode() {        return Objects.hash(name, address);    }    @Override    public String toString() {        return &quot;PersonBefore14{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +                &#39;}&#39;;    }}</code></pre><p>Record 类型特性有四个特性：</p><ol><li>设计一个面向对象的结构，表达简单的信息聚合；</li><li>帮助开发人员专注于建模不可变数据，而不是可扩展的行为；</li><li>自动实现数据驱动的方法，比如<code>equals</code>、<code>getter</code>、<code>setter</code>等方法；</li><li>保留长期存在的 Java 规范，比如迁移兼容性。</li></ol><p>我们不能将 Record 类型简单的理解为去除“样板化”代码的功能，它不是解决 JavaBean 命名约定的中很多模板化方法的冗余繁杂问题，它的目标不是类似 Lombok 等工具自动生成代码的功能，是从开发人员专注模型的角度出发的。</p><h2 id="孵化"><a href="#孵化" class="headerlink" title="孵化"></a>孵化</h2><h3 id="外部存储器访问-API-孵化第二版（JEP-383）"><a href="#外部存储器访问-API-孵化第二版（JEP-383）" class="headerlink" title="外部存储器访问 API-孵化第二版（JEP 383）"></a>外部存储器访问 API-孵化第二版（JEP 383）</h3><p>外部存储器访问 API 在 Java14 开始孵化（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 新特性</a>），在 Java15 中继续孵化状态，这个版本中增加了几个特性：</p><ul><li>新的<code>VarHandle</code>API，用于定制内存访问句柄；</li><li>支持<code>Spliterator</code>接口实现并行处理内存段；</li><li>增强了对映射内存段的支持；</li><li>能够像本机调用一样操作或间接操作内存地址。</li></ul><p>外部内存通常是说那些独立 JVM 之外的内存区域，可以不受 JVM 垃圾收集的影响，通常能够处理较大的内存。</p><p>这些新的 API 虽然不会直接影响多数的应用类开发人员，但是他们可以在内存的第三方库中提供支持，包括分布式缓存、非结构化文档存储、大型字节缓冲区、内存映射文件等。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="移除-Nashorn-JavaScript-引擎（JEP-372）"><a href="#移除-Nashorn-JavaScript-引擎（JEP-372）" class="headerlink" title="移除 Nashorn JavaScript 引擎（JEP 372）"></a>移除 Nashorn JavaScript 引擎（JEP 372）</h3><p>Nashorn JavaScript 引擎最初在 Java8 中引入（参见 <a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 新特性</a>），在 Java11 被标记为过期，在 Java15 中被删除，包括 Nashorn JavaScript 引擎、API、jjs 工具等内容。</p><p>Nashorn JavaScript 引擎是一个 JavaScript 脚本引擎，用来取代 Rhino 脚本引擎，对 ECMAScript-262 5.1 有完整的支持，增强了 Java 和 JavaScript 的兼容性，而且有很强的性能。</p><p>随着 GraalVM 和其他虚拟机技术最近的引入，Nashorn 引擎不再在 JDK 生态系统中占有一席之地。而且，ECMAScript 脚本语言结构、API 改变速度太快，Nashorn JavaScript 引擎维护成本太高，所以，直接删了。</p><h3 id="移除-Solaris-和-SPARC-端口-API（JEP-381）"><a href="#移除-Solaris-和-SPARC-端口-API（JEP-381）" class="headerlink" title="移除 Solaris 和 SPARC 端口 API（JEP 381）"></a>移除 Solaris 和 SPARC 端口 API（JEP 381）</h3><p>Solaris 和 SPARC 都已被 Linux 操作系统和英特尔处理器取代。放弃对 Solaris 和 SPARC 端口的支持将使 OpenJDK 社区的贡献者能够加速开发新功能，从而推动平台向前发展。</p><p>Solaris 和 SPARC 端口 API 在 Java14 中标记过时，在 Java15 中彻底移除。仅仅半年就痛下杀手，可见社区对于维护这些 API 深受折磨。</p><h3 id="废除-RMI-Activation（JEP-385）"><a href="#废除-RMI-Activation（JEP-385）" class="headerlink" title="废除 RMI Activation（JEP 385）"></a>废除 RMI Activation（JEP 385）</h3><p>RMI Activation 在 Java15 中标记为废除，会在未来版本删除。之所以被删除，是因为在现代的 web 应用中，已经不需要这种激活机制，继续维护，增加了 Java 开发人员的维护负担。在 Java8 的时候，已经将其设置为非必选项。</p><p>从开发系统的角度看，虽然 RMI Activation 是一个还不错的设计，但是已经有其他替代方案，继续维护开发下去，成本收益完全不匹配，及早舍弃，可以选择更加优秀的方案。有些类似于零边际成本的思想。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java15 新增的特性，完整的特性清单可以从 <a href="https://openjdk.java.net/projects/jdk/15/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/15/</a> 查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/By2JoZqAHA6U36PG8qvCcg" target="_blank" rel="noopener">Java17 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/W6Esovb7zzCL_seXgY84jA" target="_blank" rel="noopener">Java18 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/WutbAX_IQNqP4M3rud9f_g" target="_blank" rel="noopener">Java19 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/DvZYrZTtGfdXNsXGzmQN1A" target="_blank" rel="noopener">Java20 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/iiXa9rpJu1Vedpke0XpBzQ" target="_blank" rel="noopener">Java21 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/eHHFaJErH8XH4QSRrfcehQ" target="_blank" rel="noopener">Java22 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/XvB0D2vzhaAvHESupdALag" target="_blank" rel="noopener">Java23 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">Java24 的新特性</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-15-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java15 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/123541149" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java15 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Java15 是在 2020 年 9 月发布的一个短期版本，新增特性如下：Edwards-Curve 数字签名算法；密封的类和接口（预览功能）；隐藏类；移除 Nashorn JavaScript 引擎；重新实现 DatagramSocket 接口；禁用偏向锁；instanceof 匹配模式（第二版预览功能）；ZGC：可伸缩低延迟垃圾收集器；文本块；Shenandoah：低暂停时间垃圾收集器；移除 Solaris 和 SPARC 端口 API；外部存储器访问 API（第二版孵化功能）；Record 类型（第二版预览功能）；废除 RMI Activation；接下来我们一起看看这些特性。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java15" scheme="https://www.howardliu.cn/tags/Java15/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java14 的新特性</title>
    <link href="https://www.howardliu.cn/java-14-features/"/>
    <id>https://www.howardliu.cn/java-14-features/</id>
    <published>2022-03-05T03:37:11.000Z</published>
    <updated>2022-03-05T03:37:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/tree-blossoms-7022041_1920.jpeg" alt="Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java14 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文讲解一下 Java14 的特性，这个版本带来了不少新特性、功能实用性的增强、GC 的尝试、性能优化等：</p><ul><li>JEP 305：instanceof 模式匹配 （预览版）</li><li>JEP 343：打包工具 （孵化）</li><li>JEP 345：G1 的可识别 NUMA 系统的内存分配</li><li>JEP 349：JFR 事件流</li><li>JEP 352：非原子性的字节缓冲区映射</li><li>JEP 358：NullPointerException 的友好提示信息</li><li>JEP 359：Record 声明 （预览版）</li><li>JEP 361：Switch 表达式转正 （第二版预览）</li><li>JEP 362：弃用 Solaris 和 SPARC 端口</li><li>JEP 363：删除 CMS 垃圾回收器</li><li>JEP 364：ZGC 支持 MacOS</li><li>JEP 365：ZGC 支持 Windows</li><li>JEP 366：弃用 ParallelScavenge 和 SerialOld GC 的组合</li><li>JEP 367：移除 Pack200 Tools 和 API</li><li>JEP 368：文本块 （第二版预览）</li><li>JEP 370：外部存储器访问 API（孵化）</li></ul><p>接下来我们一起看看这些特性。</p><h2 id="Switch-表达式转正（JEP-361）"><a href="#Switch-表达式转正（JEP-361）" class="headerlink" title="Switch 表达式转正（JEP 361）"></a>Switch 表达式转正（JEP 361）</h2><p>Switch 表达式在 Java12 和 Java13 都处于功能预览阶段，到 Java14 终于转正了，从另一个角度，我们可以在生产环境中使用这个功能了。</p><p>我们以“判断是否工作日”的例子展示一下，在 Java14 之前：</p><pre><code class="java">@Testvoid testSwitch() {    final DayOfWeek day = DayOfWeek.from(LocalDate.now());    String typeOfDay = &quot;&quot;;    switch (day) {        case MONDAY:        case TUESDAY:        case WEDNESDAY:        case THURSDAY:        case FRIDAY:            typeOfDay = &quot;Working Day&quot;;            break;        case SATURDAY:        case SUNDAY:            typeOfDay = &quot;Rest Day&quot;;            break;    }    Assertions.assertFalse(typeOfDay.isEmpty());}</code></pre><p>在 Java14 中：</p><pre><code class="java">@Testvoid testSwitchExpression() {    final DayOfWeek day = DayOfWeek.SATURDAY;    final String typeOfDay = switch (day) {        case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; {            System.out.println(&quot;Working Day: &quot; + day);            yield &quot;Working Day&quot;;        }        case SATURDAY, SUNDAY -&gt; &quot;Day Off&quot;;    };    Assertions.assertEquals(&quot;Day Off&quot;, typeOfDay);}</code></pre><p>注意看，例子中我们使用了两种写法，一种是通过<code>yield</code>关键字表示返回结果，一种是在<code>-&gt;</code>之后直接返回。</p><h2 id="预览功能"><a href="#预览功能" class="headerlink" title="预览功能"></a>预览功能</h2><p>和前面的版本一样，Java14 中也提供了一些预览功能，我们可以在预览环境中试用一下。</p><p>这次的预览功能包括文本块（第二版预览）、instanceof 模式匹配、Record 声明，接下来我们分别说一下。</p><h3 id="文本块（第二版预览，JEP-368）"><a href="#文本块（第二版预览，JEP-368）" class="headerlink" title="文本块（第二版预览，JEP 368）"></a>文本块（第二版预览，JEP 368）</h3><p>文本块在 Java13 中首次出现（参见 <a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13</a>），本次又提供了两个扩展：</p><ul><li><code>\</code>：表示当前语句未换行，与 shell 脚本中的习惯一致；</li><li><code>\s</code>：表示单个空格。</li></ul><p>我们看个例子：</p><pre><code class="java">@Testvoid testTextBlock() {    final String singleLine = &quot;你好，我是看山，公众号「看山的小屋」。不没有换行，而且我的后面多了一个空格 &quot;;    final String textBlockSingleLine = &quot;&quot;&quot;            你好，我是看山，公众号「看山的小屋」。\            不没有换行，而且我的后面多了一个空格、s&quot;&quot;&quot;;    Assertions.assertEquals(singleLine, textBlockSingleLine);}</code></pre><p>个人感觉、是比较实用的，这个功能在 Java15 中转正，值得期待。</p><h3 id="instanceof-模式匹配（JEP-305）"><a href="#instanceof-模式匹配（JEP-305）" class="headerlink" title="instanceof 模式匹配（JEP 305）"></a>instanceof 模式匹配（JEP 305）</h3><p><code>instanceof</code>主要用来检查对象类型，作为类型强转前的安全检查。</p><p>比如：</p><pre><code class="java">@Testvoid test() {    final Object obj1 = &quot;Hello, World!&quot;;    int result = 0;    if (obj1 instanceof String) {        String str = (String) obj1;        result = str.length();    } else if (obj1 instanceof Number) {        Number num = (Number) obj1;        result = num.intValue();    }    Assertions.assertEquals(13, result);}</code></pre><p>可以看到，我们每次判断类型之后，需要声明一个判断类型的变量，然后将判断参数强制转换类型，赋值给新声明的变量。这种写法显得繁琐且多余。</p><p>于是在 Java14 中对<code>instanceof</code>进行了改进：</p><pre><code class="java">@Testvoid test1() {    final Object obj1 = &quot;Hello, World!&quot;;    int result = 0;    if (obj1 instanceof String str) {        result = str.length();    } else if (obj1 instanceof Number num) {        result = num.intValue();    }    Assertions.assertEquals(13, result);}</code></pre><p>不仅如此，<code>instanceof</code>模式匹配的作用域还可以扩展。在<code>if</code>条件判断中，我们都知道<code>&amp;&amp;</code>与判断是会执行所有的表达式，所以使用<code>instanceof</code>模式匹配定义的局部变量继续判断。</p><p>比如：</p><pre><code class="java">if (obj1 instanceof String str &amp;&amp; str.length() &gt; 20) {    result = str.length();}</code></pre><p>与原来的写法对比，Java14 提供的写法代码更加简洁、可读性更高，能够提出很多冗余繁琐的代码，非常实用的一个特性，这个功能会在 Java16 中转正。</p><h3 id="Record-声明（JEP-359）"><a href="#Record-声明（JEP-359）" class="headerlink" title="Record 声明（JEP 359）"></a>Record 声明（JEP 359）</h3><p>在 Java14 预览功能中新增了一个关键字<code>record</code>，它是定义不可变数据类型封装类的关键字，主要用在特定领域类上。这个关键字最终会在 Java16 中正式提供。</p><p>我们都知道，在 Java 开发中，我们需要定义 POJO 作为数据存储对象，根据规范，POJO 中除了属性是个性化的，其他的比如<code>getter</code>、<code>setter</code>、<code>equals</code>、<code>hashCode</code>、<code>toString</code>都是模板化的写法，所以为了简便，很多类似 Lombok 的组件提供 Java 类编译时增强，通过在类上定义<code>@Data</code>注解自动添加这些模板化方法。在 Java14 中，我们可以直接使用<code>record</code>解决这个问题。</p><p>比如，我们定义一个<code>Person</code>类：</p><pre><code class="java">public record Person(String name, String address) {}</code></pre><p>我们转换为之前的定义会是一坨下面这种代码：</p><pre><code class="java">public final class PersonBefore14 {    private final String name;    private final String address;    public PersonBefore14(String name, String address) {        this.name = name;        this.address = address;    }    public String name() {        return name;    }    public String address() {        return address;    }    @Override    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        PersonBefore14 that = (PersonBefore14) o;        return Objects.equals(name, that.name) &amp;&amp; Objects.equals(address, that.address);    }    @Override    public int hashCode() {        return Objects.hash(name, address);    }    @Override    public String toString() {        return &quot;PersonBefore14{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +                &#39;}&#39;;    }}</code></pre><p>我们可以发现 Record 类有如下特征：</p><ol><li>一个构造方法</li><li>getter 方法名与属性名相同</li><li>有<code>equals()</code>、<code>hashCode()</code>方法</li><li>有<code>toString()</code>方法</li><li>类对象和属性被<code>final</code>修饰，所以构造函数是包含所有属性的，而且没有 setter 方法</li></ol><p>在<code>Class</code>类中也新增了对应的处理方法：</p><ul><li><code>getRecordComponents()</code>：返回一组<code>java.lang.reflect.RecordComponent</code>对象组成的数组，该数组的元素与<code>Record</code>类中的组件相对应，其顺序与在记录声明中出现的顺序相同，可以从该数组中的每个<code>RecordComponent</code>中提取到组件信息，包括其名称、类型、泛型类型、注释及其访问方法。</li><li><code>isRecord()</code>：返回所在类是否是 Record 类型，如果是，则返回 true。</li></ul><p>看起来，Record 类和 Enum 很像，都是一定的模板类，通过语法糖定义，在 Java 编译过程中，将其编译成特定的格式，功能很好，但如果没有习惯使用，可能会觉得限制太多。</p><h2 id="NullPointerException-的友好提示信息（JEP-358）"><a href="#NullPointerException-的友好提示信息（JEP-358）" class="headerlink" title="NullPointerException 的友好提示信息（JEP 358）"></a>NullPointerException 的友好提示信息（JEP 358）</h2><p>在没有考虑完全场景的情况下，很容易碰到空指针异常（NullPointerException，简称 NPE）。一般碰到这个异常，根据异常栈信息我们很容易定位到发生异常的代码行，比如：</p><pre><code class="java">@Testvoid test1() {    Student s = null;    Assertions.assertThrows(NullPointerException.class, ()-&gt; s.getName())            .fillInStackTrace()            .printStackTrace();}</code></pre><p>如果是在 Java14 之前，这个时候打印出来的异常信息是：</p><pre><code class="log">Exception in thread &quot;main&quot; java.lang.NullPointerException    at cn.howardliu.tutorials.java14.NpeTest.test1(NpeTest.java:20)</code></pre><p>对于上面例子，我们可以直接定位到<code>s</code>是<code>null</code>，但是下面这个例子呢：</p><pre><code class="java">@Testvoid test2() {    Student s = new Student();    s.setName(&quot;看山&quot;);    Assertions.assertThrows(NullPointerException.class, ()-&gt; s.getClazz().getNo())            .fillInStackTrace()            .printStackTrace();}</code></pre><p>我们很难判断<code>s</code>或者<code>s</code>中的<code>clazz</code>是<code>null</code>，需要查看上下文代码，或者复杂情况还需要添加日志辅助定位问题。</p><p>在 Java14 中，对 NullPointerException 异常栈信息做了增强，通过分析程序的字节码信息，能够做到准确地定位到出现 NullPointerException 的变量，并且根据实际源代码打印出详细异常信息。此时，上面例子的异常信息是：</p><pre><code class="log">java.lang.NullPointerException: Cannot invoke &quot;cn.howardliu.tutorials.java14.NpeTest$Clazz.getNo()&quot; because the return value of &quot;cn.howardliu.tutorials.java14.NpeTest$Student.getClazz()&quot; is null    at cn.howardliu.tutorials.java14.NpeTest.test2(NpeTest.java:30)</code></pre><p>这样一目了然。</p><h2 id="孵化功能"><a href="#孵化功能" class="headerlink" title="孵化功能"></a>孵化功能</h2><p>孵化功能是 Java 开发团队让我们提前尝鲜、公测的功能，在 Java9 模块化之后，孵化功能会放在<code>jdk.incubator.</code>中。</p><h3 id="外部存储器访问-API（JEP-370）"><a href="#外部存储器访问-API（JEP-370）" class="headerlink" title="外部存储器访问 API（JEP 370）"></a>外部存储器访问 API（JEP 370）</h3><p>Java 对象是驻留在堆上，但是有时候因为其算法或者内存结构的原因，使用效率低下、性能低下、受垃圾收集器 GC 算法影响。所以很多时候我们会使用本机内存或者称为直接内存。</p><p>在 Java14 之前，使用直接内存我们会用到<code>ByteBuffer</code>或者<code>Unsafe</code>，但是这两个都存在一些问题。</p><ul><li><code>ByteBuffer</code>管理内存最大不能够超过 2G；</li><li><code>ByteBuffer</code>管理的这部分内存需要使用垃圾收集器回收内存，使用不当可能造成内存泄漏；</li><li><code>Unsafe</code>是非标准的 Java API，可能会因为不合法的内存使用致使系统崩溃。</li></ul><p>“天下苦秦久矣”，于是在 Java14 中提供了新的 API：</p><ul><li><code>MemorySegment</code>：用来申请内存区域，可以是堆内存，也可以是对外内存；</li><li><code>MemoryAddress</code>：从<code>MemorySegment</code>实例获取已申请内存的内存地址用于执行操作，例如从底层内存段的内存中检索数据；</li><li><code>MemoryLayout</code>：用来描述内存段的内容，它允许我们定义如何将内存分解为元素，并提供每个元素的大小。</li></ul><p>这部分功能截止到 Java17 还是孵化功能，而且内容比较多，后续会单独开一篇介绍。</p><h3 id="打包工具（JEP-343）"><a href="#打包工具（JEP-343）" class="headerlink" title="打包工具（JEP 343）"></a>打包工具（JEP 343）</h3><p>一般来说，Java 程序会以一个 Jar 的形式提供，web 服务可能是 war 或者 ear 包，但是有时候我们的 Java 程序可能是在自己的 PC 机（比如 Windows 或者 MacOS）上运行，期望可以通过双击打开的方式。</p><p>于是 Java14 引入了<code>引入了 jdk.incubator.jpackage.jmod</code>，基于 JavaFX javapackager tool，其目的就是创建一个打包工具，可以将 jar 包构建成 exe、pkg、dmg、deb、rpm 格式的安装文件。</p><p>我们可以使用<code>jlink</code>创建一个最小可运行的模块包，然后使用<code>jpackage</code>将其构建成安装包：</p><pre><code class="shell">jpackage --name myapp --input lib --main-jar main.jar</code></pre><h2 id="JVM-功能"><a href="#JVM-功能" class="headerlink" title="JVM 功能"></a>JVM 功能</h2><h3 id="ZGC-支持-MacOS-和-Windows-系统（JEP-364、JEP-365）"><a href="#ZGC-支持-MacOS-和-Windows-系统（JEP-364、JEP-365）" class="headerlink" title="ZGC 支持 MacOS 和 Windows 系统（JEP 364、JEP 365）"></a>ZGC 支持 MacOS 和 Windows 系统（JEP 364、JEP 365）</h3><p>ZGC 最初是在 Java11 中引入（参见 <a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a>），在后续版本中，不断升级优化，实现可伸缩、低延迟的目标，使用了内存读屏障、染色指针、内存多重映射等技术。在之前，ZGC 只支持 Linux/x64 平台，在 Java14 之后，支持了 macOS/x64 和 Windows/x64 系统中。</p><p>开启参数：</p><pre><code class="shell">-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code></pre><h3 id="G1-的可识别-NUMA-系统的内存分配（JEP-345）"><a href="#G1-的可识别-NUMA-系统的内存分配（JEP-345）" class="headerlink" title="G1 的可识别 NUMA 系统的内存分配（JEP 345）"></a>G1 的可识别 NUMA 系统的内存分配（JEP 345）</h3><p>Java14 改进了非一致性内存访问（Non-uniform Memory Access，NUMA）系统上的 G1 垃圾收集器的整体性能，主要是对年轻代的内存分配做出优化，从而提升 CPU 计算过程中内存访问速度。</p><p>NUMA 主要是指在多插槽物理计算机体系中，处理器一般是多核，且越来越多具备 NUMA 访问体系结构，即内存与每个插槽或内核之间的距离不等。套接字之间的内存访问有不同的性能特征，更远的套接字访问会有更多的时间消耗。这样的结果是，每个核对于某一区域的内存访问速度会随核与物理内存的位置远近有所差异。</p><p>Java 分配内存时，G1 会申请一块 region，作为对象存放区域。如果能够感知 NUMA，就可以优先在当前线程绑定的 NUMA 节点空闲内存执行申请内存操作，用于提升访问速度。</p><p>启用参数是<code>-XX:+UseNUMA</code>。</p><h3 id="JFR-事件流（JEP-349）"><a href="#JFR-事件流（JEP-349）" class="headerlink" title="JFR 事件流（JEP 349）"></a>JFR 事件流（JEP 349）</h3><p>飞行记录器（Flight Recorder）是在 Java11 中引入（参见 <a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a>）。</p><p>本次增强可以实现 JFR 数据的公开访问，可以通过使用<code>jdk.jfr.consumer</code>中的方法持续读取或流式传输读取记录，用于持续监控。这样的话，我们可以与现有监控系统集成，实现 JFR 数据的持续监听，不用非得等着收集完成后再解析分析。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h2 id="非原子性的字节缓冲区映射（JEP-352）"><a href="#非原子性的字节缓冲区映射（JEP-352）" class="headerlink" title="非原子性的字节缓冲区映射（JEP 352）"></a>非原子性的字节缓冲区映射（JEP 352）</h2><p>对<code>FileChannel</code>进行扩展，定义了<code>jdk.nio.mapmode.ExtendedMapMode</code>，用来创建<code>MappedByteBuffer</code>实例，可以对非原子性的字节缓冲区映射（Non-Volatile Mapped Byte Buffers，NVM）实现持久化。</p><h3 id="删除-CMS-垃圾回收器（JEP-363）"><a href="#删除-CMS-垃圾回收器（JEP-363）" class="headerlink" title="删除 CMS 垃圾回收器（JEP 363）"></a>删除 CMS 垃圾回收器（JEP 363）</h3><p>CMS 是老年代垃圾回收算法，通过标记-清除的方式进行内存回收，在内存回收过程中能够与用户线程并行执行。在 G1 之前，CMS 几乎占据了 GC 的全部江山。在使用过程中，一般是 CMS 与 Parallel New 搭配使用。</p><p>CMS 由于其算法特性，会产生内存碎片和浮动垃圾，随着时间推移，可能出现的情况是，虽然老年代还有空间，但是没有办法分配足够内存给大对象。</p><p>所以在 Java9 中开始放弃使用 CMS，在 Java14 中彻底删除，并删除与 CMS 有关的参数。从 Java14 开始，CMS 成为了历史。</p><h3 id="弃用-ParallelScavenge-和-SerialOld-GC-的组合（JEP-366）"><a href="#弃用-ParallelScavenge-和-SerialOld-GC-的组合（JEP-366）" class="headerlink" title="弃用 ParallelScavenge 和 SerialOld GC 的组合（JEP 366）"></a>弃用 ParallelScavenge 和 SerialOld GC 的组合（JEP 366）</h3><p>Parallel Scavenge 是并行收集算法，SerialOld 提供老年代串行收集，这种年轻代使用并行算法、老年代使用串行算法的混搭的方式，使用场景少且有风险。但是却需要大量工作量维护，所以在 Java14 中，删除了这两种 GC 组合。</p><p>删除组合的方式是通过启用组合参数<code>-XX:+UseParallelGC -XX:-UseParallelOldGC</code>，并在单独使用<code>-XX:-UseParallelOldGC</code>时会收到警告信息。</p><h3 id="移除-Pack200-Tools-和-API（JEP-367）"><a href="#移除-Pack200-Tools-和-API（JEP-367）" class="headerlink" title="移除 Pack200 Tools 和 API（JEP 367）"></a>移除 Pack200 Tools 和 API（JEP 367）</h3><p>these were deprecated for removal in Java 11, and now removed</p><p>删除<code>java.util.jar</code>包中的<code>pack200</code>和<code>unpack200</code>工具以及 Pack200 API。这些工具和 API 已在 Java11 时标记弃用，删除也是意料之中。</p><h3 id="弃用-Solaris-和-SPARC-端口（JEP-362）"><a href="#弃用-Solaris-和-SPARC-端口（JEP-362）" class="headerlink" title="弃用 Solaris 和 SPARC 端口（JEP 362）"></a>弃用 Solaris 和 SPARC 端口（JEP 362）</h3><p>Solaris 和 SPARC 都已被 Linux 操作系统和英特尔处理器取代。放弃对 Solaris 和 SPARC 端口的支持将使 OpenJDK 社区的贡献者能够加速开发新功能，从而推动平台向前发展。</p><p>这些 API 在 Java14 中标记弃用，在 Java15 中彻底删除。这样做，也是为了让很多正在进行的项目尽早适应新的架构。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java14 新增的特性，完整的特性清单可以从 <a href="https://openjdk.java.net/projects/jdk/14/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/14/</a> 查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/By2JoZqAHA6U36PG8qvCcg" target="_blank" rel="noopener">Java17 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/W6Esovb7zzCL_seXgY84jA" target="_blank" rel="noopener">Java18 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/WutbAX_IQNqP4M3rud9f_g" target="_blank" rel="noopener">Java19 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/DvZYrZTtGfdXNsXGzmQN1A" target="_blank" rel="noopener">Java20 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/iiXa9rpJu1Vedpke0XpBzQ" target="_blank" rel="noopener">Java21 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/eHHFaJErH8XH4QSRrfcehQ" target="_blank" rel="noopener">Java22 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/XvB0D2vzhaAvHESupdALag" target="_blank" rel="noopener">Java23 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">Java24 的新特性</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-14-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java14 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/123340900" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java14 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文讲解一下 Java14 的特性，这个版本带来了不少新特性、功能实用性的增强、GC 的尝试、性能优化等：JEP 305：instanceof 模式匹配 （预览版）；JEP 343：打包工具 （孵化）；JEP 345：G1 的可识别 NUMA 系统的内存分配；JEP 349：JFR 事件流；JEP 352：非原子性的字节缓冲区映射；JEP 358：NullPointerException 的友好提示信息；JEP 359：Record 声明 （预览版）；JEP 361：Switch 表达式转正 （第二版预览）；JEP 362：弃用 Solaris 和 SPARC 端口；JEP 363：删除 CMS 垃圾回收器；JEP 364：ZGC 支持 MacOS；JEP 365：ZGC 支持 Windows；JEP 366：弃用 ParallelScavenge 和 SerialOld GC 的组合；JEP 367：移除 Pack200 Tools 和 API；JEP 368：文本块 （第二版预览）；JEP 370：外部存储器访问 API（孵化）。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java14" scheme="https://www.howardliu.cn/tags/Java14/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java13 的新特性</title>
    <link href="https://www.howardliu.cn/java-13-features/"/>
    <id>https://www.howardliu.cn/java-13-features/</id>
    <published>2022-02-14T13:41:37.000Z</published>
    <updated>2022-02-14T13:41:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/bird-6965228_1920.jpeg" alt="Java13 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文讲解一下 Java13 的特性，这个版本在语法特性上增加不多，值得关注的是两个预览功能：Switch 表达式和文本块，另外可以关乎的是性能优化方面的：动态类数据共享（CDS）存档、ZGC 动态释放未使用内存、Socket API 重构。这些方面可以看出，Java 的升级方向有两个，一是增加功能，增加新的语法特性；二是增强功能，提升已有功能性能。</p><h2 id="预览功能"><a href="#预览功能" class="headerlink" title="预览功能"></a>预览功能</h2><p>Java13 引入了两个新的语法特性：Switch 表达式和文本块。这些预览功能是为了让开发者尝鲜的同时，可以快速调整，反馈好就留下，不好就移除。目前来看，这些特性还是挺香的。</p><p><img src="https://static.howardliu.cn/Illustration/zhenxiangdinglv.jpeg" alt="真香定律"></p><h3 id="Switch-表达式"><a href="#Switch-表达式" class="headerlink" title="Switch 表达式"></a>Switch 表达式</h3><p>在 Java12 中 Switch 表达式首次以预览版的身份出现，在 Java13 中又做了增强，在 Java14 正式提供。Java13 添加了<code>yield</code>关键字，用来返回值。</p><p><code>yield</code>与<code>return</code>的区别在于，<code>yield</code>只会跳出<code>switch</code>块，<code>return</code>是跳出当前方法或循环。</p><p>比如下面的例子，在 Java12 之前，要判断日期可以这样写：</p><pre><code class="java">@Testvoid testSwitch() {    final DayOfWeek day = DayOfWeek.from(LocalDate.now());    String typeOfDay = &quot;&quot;;    switch (day) {        case MONDAY:        case TUESDAY:        case WEDNESDAY:        case THURSDAY:        case FRIDAY:            typeOfDay = &quot;Working Day&quot;;            break;        case SATURDAY:        case SUNDAY:            typeOfDay = &quot;Rest Day&quot;;            break;    }    Assertions.assertFalse(typeOfDay.isEmpty());}</code></pre><p>在 Java12 提供的 Switch 表达式预览功能，我们可以简化一下：</p><pre><code class="java">@Testvoid testSwitchExpression() {    final DayOfWeek day = DayOfWeek.SATURDAY;    final String typeOfDay = switch (day) {        case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; &quot;Working Day&quot;;        case SATURDAY, SUNDAY -&gt; &quot;Day Off&quot;;    };    Assertions.assertEquals(&quot;Day Off&quot;, typeOfDay);}</code></pre><p>这样可以实现判断，但是没有办法在表达式中实现其他逻辑了。于是 Java13 补齐了这个功能：</p><pre><code class="java">@Testvoid testSwitchExpression13() {    final DayOfWeek day = DayOfWeek.SATURDAY;    final String typeOfDay = switch (day) {        case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; {            System.out.println(&quot;Working Day: &quot; + day);            yield &quot;Working Day&quot;;        }        case SATURDAY, SUNDAY -&gt; {            System.out.println(&quot;Day Off: &quot; + day);            yield &quot;Day Off&quot;;        }    };    Assertions.assertEquals(&quot;Day Off&quot;, typeOfDay);}</code></pre><p>这里需要说明一下，既然是预览功能，会与正式提供功能有些出入。上面的代码是在 Java14 环境中编写，与 Java13 发布的功能描述有些差异，这点不必深究，已经废弃的约束就是不存在。</p><h3 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h3><p>一直以来，Java 中的字符串定义都是以双引号括起来的形式，不支持多行书写，所以在需要多行字符串中，需要使用转义符表示，既不好看、还不好读，更不好维护。</p><p>千呼万唤始出来，终于有了文本块功能。</p><p>比如，我们想要写一段 Json 格式的数据，Java13 之前需要写成：</p><pre><code class="java">String json = &quot;{\n&quot;        + &quot;  \&quot;wechat\&quot;: \&quot;hellokanshan\&quot;,\n&quot;        + &quot;  \&quot;wechatName\&quot;: \&quot;看山、&quot;,\n&quot;        + &quot;  \&quot;mp\&quot;: \&quot;kanshanshuo\&quot;,\n&quot;        + &quot;  \&quot;mpName\&quot;: \&quot;看山的小屋、&quot;\n&quot;        + &quot;}\n&quot;;</code></pre><p>但是在 Java13 预览版中可以写作：</p><pre><code class="java">String json2 = &quot;&quot;&quot;        {          &quot;wechat&quot;: &quot;hellokanshan&quot;,          &quot;wechatName&quot;: &quot;看山&quot;,          &quot;mp&quot;: &quot;kanshanshuo&quot;,          &quot;mpName&quot;: &quot;看山的小屋&quot;        }        &quot;&quot;&quot;;</code></pre><p>少了很多的+、换行、转移等字符，看着更加直观。</p><p>这个功能在 Java15 中正式提供。</p><h2 id="动态类数据共享（CDS）存档"><a href="#动态类数据共享（CDS）存档" class="headerlink" title="动态类数据共享（CDS）存档"></a>动态类数据共享（CDS）存档</h2><p>CDS 是 Java5 引入的一种类预处理方式，可以将一组类共享到一个归档文件中，借助内存映射加载类数据，减少启动时间，并可实现在多 JVM 之间共享的功能。在 Java10 对其进行扩展，增大了 CDS 使用范围，即 AppCDS（参见 <a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 新特性</a>）。到了 Java12，将 CDS 归档文件作为了默认功能开放出来（参见 <a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 新特性</a>）。</p><p>但是这个功能在使用的时候还是有些麻烦。为了生成归档文件，开发人员必须先对应用程序进行试运行，创建一个类列表，然后将其转储到归档文件中。然后，这个归档才可以用来在 JVM 之间共享元数据。</p><p>Java13 简化了这个过程：允许 Java 应用在运行结束后动态归档，即将已被加载但不属于 CDS 的类（包括自定义类和引用库的类）动态添加到 CDS 归档文件中。不用再提供归档类的列表，通过更加简洁的方式创建包含应用程序的归档。</p><p>我们可以使用<code>-XX:ArchiveClassesAtExit</code>参数控制应用程序退出时创建 CDS 归档文件：</p><pre><code class="shell">java -XX:ArchiveClassesAtExit=&lt;archive filename&gt; -cp &lt;app jar&gt; AppName</code></pre><p>也可以使用<code>-XX:SharedArchiveFile</code>来使用动态存档功能：</p><pre><code class="shell">java -XX:SharedArchiveFile=&lt;archive filename&gt; -cp &lt;app jar&gt; AppName</code></pre><h2 id="ZGC-增强：释放未使用内存"><a href="#ZGC-增强：释放未使用内存" class="headerlink" title="ZGC 增强：释放未使用内存"></a>ZGC 增强：释放未使用内存</h2><p>ZGC 是 Java11 中引入的一个可伸缩、低延迟的垃圾收集器，主要目标包括：GC 停顿时间不超过 10ms；可以处理从几百 MB 的小堆，到几个 TB 的大堆；应用吞吐能力不会下降超过 15%等（参见 <a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a>）。</p><p>但是 ZGC 并没有像 Hotspot 中的 G1 和 Shenandoah 那样，可以主动释放未使用的内存，对于多数应用程序来说，CPU 和内存都是稀缺资源，尤其是现在云上环境和虚拟化技术，如果应用程序占用的内存长期处于空闲状态，还紧握住不释放，就是极大的浪费。</p><p>在 Java13 中对其进行改进，包括：</p><ul><li>可释放空闲内存</li><li>支持的最大堆大小从 4TB 扩大到 16TB</li></ul><p>我们来看下 ZGC 的内部逻辑。</p><p>ZGC 堆由一组称为 ZPages 的堆区域组成，每个 ZPage 都与提交的堆内存的可变数量相关联。当 ZGC 压缩堆时，ZPages 被释放并插入到页面缓存 ZPageCache 中，页面缓存中的 ZPages 可以重新使用，以满足新的堆分配。</p><p>ZPageCache 中的 ZPages 集合代表堆中未使用的部分，这部分可以释放回操作系统。ZPageCache 中的 ZPages 根据 LRU（最近最少使用）排序，并按照大中小进行分组。这样的话就可以根据算法按顺序释放未使用的内存。</p><p>Java13 还提供了<code>-XX:ZUncommitDelay=&lt;seconds&gt;</code>命令，用于指定释放多长时间（默认是 5 分钟）未使用的内存，这个参数类似于 Shenandoah 中的<code>-XX:ShenandoahUncommitDelay=&lt;milliseconds&gt;</code>。</p><p>在 Java13 中，ZGC 内存释放功能默认开启，可通过参数<code>-XX:-ZUncommit</code>关闭该功能。由于 ZGC 释放内存时，不会低于最小堆内存，即当最小堆内存（-Xms）与最大堆内存（-Xmx）一样时，不会自动释放。</p><h2 id="Socket-API-重构"><a href="#Socket-API-重构" class="headerlink" title="Socket API 重构"></a>Socket API 重构</h2><p>Java 中的 Socket 是从 Java1.0 开始就有的，是 Java 中不可或缺的网络 API，算起来已经服役 20 多年了。在这段时间内，信息技术已经发生了很多变化，这些上古 API 有一定的局限性，而且不容易维护和调试。</p><p>Java 的 Socket API 主要包括<code>java.net.ServerSocket</code>和<code>java.net.Socket</code>，<code>ServerSocket</code>用来监听连接请求的端口，连接成功后返回的是<code>Socket</code>对象，可以通过操作<code>Socket</code>对象实现数据发送和读取。Java 是通过<code>SocketImpl</code>实现这些功能。</p><p>在 Java13 之前，通过<code>SocketImpl</code>的子类<code>PlainSocketImpl</code>实现。在 Java13 中，引入<code>NioSocketImpl</code>实现，该实现以 NIO 为基础，与高速缓冲机制集成，实现非阻塞式网络。</p><p>如果想用回<code>PlainSocketImpl</code>，可以设置启动参数<code>-Djdk.net.usePlainSocketImpl=true</code>即可。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java13 新增的特性，完整的特性清单可以从<a href="https://openjdk.java.net/projects/jdk/13/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/13/</a>查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/By2JoZqAHA6U36PG8qvCcg" target="_blank" rel="noopener">Java17 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/W6Esovb7zzCL_seXgY84jA" target="_blank" rel="noopener">Java18 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/WutbAX_IQNqP4M3rud9f_g" target="_blank" rel="noopener">Java19 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/DvZYrZTtGfdXNsXGzmQN1A" target="_blank" rel="noopener">Java20 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/iiXa9rpJu1Vedpke0XpBzQ" target="_blank" rel="noopener">Java21 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/eHHFaJErH8XH4QSRrfcehQ" target="_blank" rel="noopener">Java22 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/XvB0D2vzhaAvHESupdALag" target="_blank" rel="noopener">Java23 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">Java24 的新特性</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-13-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java13 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122932951" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java13 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文讲解一下 Java13 的特性，这个版本在语法特性上增加不多，值得关注的是两个预览功能：Switch 表达式和文本块，另外可以关乎的是性能优化方面的：动态类数据共享（CDS）存档、ZGC 动态释放未使用内存、Socket API 重构。这些方面可以看出，Java 的升级方向有两个，一是增加功能，增加新的语法特性；二是增强功能，提升已有功能性能。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java13" scheme="https://www.howardliu.cn/tags/Java13/"/>
    
  </entry>
  
  <entry>
    <title>从春运迁徙图看到的一些东西</title>
    <link href="https://www.howardliu.cn/2022-spring-festival/"/>
    <id>https://www.howardliu.cn/2022-spring-festival/</id>
    <published>2022-01-29T11:51:31.000Z</published>
    <updated>2022-01-29T11:51:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/bird-g81ab0101d_1920_20220129150731.jpeg" alt="从春运迁徙图看到的一些东西"></p><p>你好，我是看山。</p><p>腊月二十七宰鸡赶大集，响应国家号召，就地过年。</p><p>难免思乡，于是翻了翻百度地图提供的迁徙数据。我们从迁出地和迁徙趋势看一看这几年的春运变化。</p><a id="more"></a><p>我们先来看看从 2020 年到现在（2022 年）的春运迁徙图：</p><p><img src="https://static.howardliu.cn/raving/2020-spring-festival-travel-rush.png" alt="2020 年春运迁徙图"></p><p><img src="https://static.howardliu.cn/raving/2021-spring-festival-travel-rush.png" alt="2021 年春运迁徙图"></p><p><img src="https://static.howardliu.cn/raving/2022-spring-festival-travel-rush.png" alt="2022 年春运迁徙图"></p><p>从三张图中，我们不难看出一些规律，待我慢慢道来。</p><h2 id="春运热门迁出地"><a href="#春运热门迁出地" class="headerlink" title="春运热门迁出地"></a>春运热门迁出地</h2><p>这几年中，比较热门的迁出地有北京、上海、广州、深圳，稍微热门的是杭州、武汉、重庆、长沙、西安等。不难看出，热门迁出地对应着一线、新一线城市。这些城市的外来务工人员比较多，在春节选择回家过年。</p><p><img src="https://static.howardliu.cn/raving/bsgs.jpg" alt="北上广深"></p><p>其中，北上广深是一线城市，很多人或为生活、或为梦想，选择了一线城市打拼。辛苦一年，趁着年关回到家，无论家乡是好是孬，总归是一个平静的港湾。至于年后，是选择以梦为马潇洒天涯，还是选择背起行囊漂泊他乡，都是年后的事情。</p><p><img src="https://static.howardliu.cn/raving/2020city.jpg" alt="2020 年城市购买排行"></p><p>当人们在寻找工作和生活的平衡点时，很多城市也是快速发展，成为了新一线城市，成为了中国发展的新兴动力城市，也给了我们更多的选择。人们不在单纯的考虑收入，会更多的考虑感受、家人，更多的考虑幸福。</p><p>无论我们在哪，做什么，都是为了追求幸福，幸福才是我们心底最期望的东西。</p><p><img src="https://static.howardliu.cn/raving/happy.jpg" alt="幸福"></p><h2 id="疫情对迁徙的影响在减弱"><a href="#疫情对迁徙的影响在减弱" class="headerlink" title="疫情对迁徙的影响在减弱"></a>疫情对迁徙的影响在减弱</h2><p><img src="https://static.howardliu.cn/raving/2019-spring-festival-line-chart.png" alt="2019 年春运迁徙趋势图"></p><p>疫情发生前（2019 年），我们可以看到，年前迁移流量持续增长，大年初一稍微少了一点，到初六假期结束，迁移量达到峰值。我们以此为参照，看下疫情的影响。</p><p><img src="https://static.howardliu.cn/raving/2020-spring-festival-line-chart.png" alt="2020 年春运迁徙趋势图"></p><p>2020 年疫情爆发，武汉封城，春节期间全国人民上下齐心，共抗疫情。这个时候，春运流动基本上停止。作为普通民众，我们能够做到，就是待在家里，不给国家添麻烦。</p><p><img src="https://static.howardliu.cn/raving/2021-spring-festival-line-chart.png" alt="2021 年春运迁徙趋势图"></p><p>2021 年是疫情第二年，咱们国家提出的“清零”政策取得了好成绩，生活工作基本上恢复正常，也有了十一小长假出行旅游复苏的场景。外国友人们躲在家里看我们堵在路上，心里一定是各种羡慕。而且，在年底开始全员接种疫苗，给我们增加一层保障。</p><p>不过由于冬天天气转冷，病毒的存活能力增强，为了保住来之不易的战果。各地倡导就地过年。所以能够看到，春运的流量比 2019 年减少了将近一半。</p><p><img src="https://static.howardliu.cn/raving/2022-spring-festival-line-chart.png" alt="2022 年春运迁徙趋势图"></p><p>今年的春运刚刚开始，我们只能够根据趋势推测一下，到今天为止，迁徙流量的发展基本上和 2019 年相似。这不得不说在抗疫方面，2021 年取得了好成绩。全民接种加强针疫苗，各地的清零政策也是严格执行。虽然年底有些地方出现了本土疫情，但是都是在控制范围内，没有爆发的征兆。有了 2021 年春运、五一、十一等各种假期迁徙的经验，各地采取“有温度的严格控制”，让远在他乡想在春节回家的游子们，一解乡愁。</p><p>可以预见，等到了 2023 年春运的时候，我们可能就不再纠结能不能回、让不让回，只需要带着必要的证明，正常计划归乡日期就好。</p><p>按照习俗，给大家拜个早年，愿大家新年胜旧年，欢愉且胜意，万事尽可期。</p><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/2022-spring-festival/">从春运迁徙图看到的一些东西</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">从春运迁徙图看到的一些东西</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      腊月二十七宰鸡赶大集，响应国家号召，就地过年。难免思乡，于是翻了翻百度地图提供的迁徙数据。我们从迁出地和迁徙趋势看一看这几年的春运变化。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="春运" scheme="https://www.howardliu.cn/tags/%E6%98%A5%E8%BF%90/"/>
    
      <category term="迁徙" scheme="https://www.howardliu.cn/tags/%E8%BF%81%E5%BE%99/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java12 的新特性</title>
    <link href="https://www.howardliu.cn/java-12-features/"/>
    <id>https://www.howardliu.cn/java-12-features/</id>
    <published>2022-01-15T05:10:35.000Z</published>
    <updated>2022-01-15T05:10:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/lily-gf02d5baa4_1920.jpg" alt="Java12 的新特性"></p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>你好，我是看山。</p><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文讲解一下 Java12 的特性，作为第一个长期支持版 Java11 之后的第一个版本，增加的功能也不少，除了一些小幅度的 API 增强，增加了另一个试验阶段的垃圾收集器 Shenandoah、对 G1 做了优化、增加微基准套件等。</p><h2 id="语法特性"><a href="#语法特性" class="headerlink" title="语法特性"></a>语法特性</h2><p>Java12 提供了很多的语法特性，既有小而美的增强 API，又有特别方便的工具扩展。本节我们跟着代码看看比较好玩的功能。</p><h3 id="String-的增强方法：indent-和-transform"><a href="#String-的增强方法：indent-和-transform" class="headerlink" title="String 的增强方法：indent 和 transform"></a>String 的增强方法：indent 和 transform</h3><p>在 Java12 中，String 又增强了两个方法。之所以说又，是因为在 Java11 中已经增加过小而美的方法，想要详细了解的可以查看 <a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 新特性</a>。</p><p>这次增加的方法是<code>indent</code>（缩进）和<code>transform</code>（转换）。</p><p>顾名思义，<code>indent</code>方法是对字符串每行（使用<code>\r</code>或<code>\n</code>分隔）数据缩进指定空白字符，参数是 int 类型。</p><p>如果参数大于 0，就缩进指定数量的空格；如果参数小于 0，就将左侧的空字符删除指定数量，即右移。</p><p>我们看下源码：</p><pre><code class="java">public String indent(int n) {    if (isEmpty()) {        return &quot;&quot;;    }    Stream&lt;String&gt; stream = lines();    if (n &gt; 0) {        final String spaces = &quot; &quot;.repeat(n);        stream = stream.map(s -&gt; spaces + s);    } else if (n == Integer.MIN_VALUE) {        stream = stream.map(s -&gt; s.stripLeading());    } else if (n &lt; 0) {        stream = stream.map(s -&gt; s.substring(Math.min(-n, s.indexOfNonWhitespace())));    }    return stream.collect(Collectors.joining(&quot;\n&quot;, &quot;&quot;, &quot;\n&quot;));}</code></pre><p>这里会使用到 Java11 增加的<code>lines</code>、<code>repeat</code>、<code>stripLeading</code>等方法。<code>indent</code>最后会将多行数据通过<code>Collectors.joining(&quot;\n&quot;, &quot;&quot;, &quot;\n&quot;)</code>方法拼接，结果会有两点需要注意：</p><ul><li><code>\r</code>会被替换成<code>\n</code>；</li><li>如果原字符串是多行数据，最后一行的结尾没有<code>\n</code>，最后会补上一个<code>\n</code>，即多了一个空行。</li></ul><p>我们看下测试代码：</p><pre><code class="java">@Testvoid testIndent() {    final String text = &quot;\t\t\t 你好，我是看山。\n \u0020\u2005Java12 的 新特性。\r 欢迎三连+关注哟&quot;;    assertEquals(&quot;    \t\t\t 你好，我是看山。\n     \u0020\u2005Java12 的 新特性。\n    欢迎三连+关注哟、n&quot;, text.indent(4));    assertEquals(&quot;\t 你好，我是看山。\n\u2005Java12 的 新特性。\n 欢迎三连+关注哟、n&quot;, text.indent(-2));    final String text2 = &quot;山水有相逢&quot;;    assertEquals(&quot;山水有相逢&quot;, text2);}</code></pre><p>我们再来看看<code>transform</code>方法，源码一目了然：</p><pre><code class="java">public &lt;R&gt; R transform(Function&lt;? super String, ? extends R&gt; f) {    return f.apply(this);}</code></pre><p>通过传入的<code>Function</code>对当前字符串进行转换，转换结果由<code>Function</code>决定。比如，我们要对字符串反转：</p><pre><code class="java">@Testvoid testTransform() {    final String text = &quot;看山是山&quot;;    final String reverseText = text.transform(s -&gt; new StringBuilder(s).reverse().toString());    assertEquals(&quot;山是山看&quot;, reverseText);}</code></pre><p>其实这个方法在 Java8 中提供的<code>Optional</code>实现类似的功能（完整的 Optional 功能可以查看 <a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">Optional 的 6 种操作</a>）：</p><pre><code class="java">@Testvoid testTransform() {    final String text = &quot;看山是山&quot;;    final String reverseText2 = Optional.of(text)            .map(s -&gt; new StringBuilder(s).reverse().toString())            .orElse(&quot;&quot;);    assertEquals(&quot;山是山看&quot;, reverseText2);}</code></pre><h3 id="Files-的增强方法：mismatch"><a href="#Files-的增强方法：mismatch" class="headerlink" title="Files 的增强方法：mismatch"></a>Files 的增强方法：mismatch</h3><p>在 Java12 中，<code>Files</code>增加了<code>mismatch</code>方法，用于对比两个文件中的不相同字符的位置，如果内容相同，返回<code>-1L</code>，是<code>long</code>类型的。</p><p>我们来简单看下怎么用：</p><pre><code class="java">@Testvoid testMismatch() throws IOException {    final Path pathA = Files.createFile(Paths.get(&quot;a.txt&quot;));    final Path pathB = Files.createFile(Paths.get(&quot;b.txt&quot;));    // 写入相同内容    Files.write(pathA, &quot;看山&quot;.getBytes(), StandardOpenOption.WRITE);    Files.write(pathB, &quot;看山&quot;.getBytes(), StandardOpenOption.WRITE);    final long mismatch1 = Files.mismatch(pathA, pathB);    Assertions.assertEquals(-1L, mismatch1);    // 追加不同内容    Files.write(pathA, &quot;是山&quot;.getBytes(), StandardOpenOption.APPEND);    Files.write(pathB, &quot;不是山&quot;.getBytes(), StandardOpenOption.APPEND);    final long mismatch2 = Files.mismatch(pathA, pathB);    Assertions.assertEquals(6L, mismatch2);    Files.deleteIfExists(pathA);    Files.deleteIfExists(pathB);}</code></pre><p>我们可以看到，当第一次在两个文件中写入相同内容，执行<code>mismatch</code>方法返回的是<code>-1L</code>。当第二次追加进去不同的内容后，返回的是<code>6L</code>。之所以是 6，是因为测试代码中使用的字符集是<code>UTF-8</code>，大部分汉子是占用 3 个字符，前两个字相同，从第三个字开始不同，下标从 0 开始，所以开始位置是 6。</p><h3 id="Collectors-的增强方法：teeing"><a href="#Collectors-的增强方法：teeing" class="headerlink" title="Collectors 的增强方法：teeing"></a>Collectors 的增强方法：teeing</h3><p>我们看下<code>teeing</code>的定义：</p><pre><code class="java">public static &lt;T, R1, R2, R&gt; Collector&lt;T, ?, R&gt; teeing(    Collector&lt;? super T, ?, R1&gt; downstream1,    Collector&lt;? super T, ?, R2&gt; downstream2,    BiFunction&lt;? super R1, ? super R2, R&gt; merger)</code></pre><p>这个方法有三个参数，前两个是<code>Collector</code>对象，用于对输入数据进行预处理，第三个参数是<code>BiFunction</code>，用于将前两个处理后的结果作为参数传入<code>BiFunction</code>中，运算得到结果。</p><p>我们来看下例子：</p><pre><code class="java">@Testvoid testTeeing() {    var result = Stream.of(&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;)            .collect(Collectors.teeing(                    Collectors.filtering(n -&gt; n.contains(&quot;u&quot;), Collectors.toList()),                    Collectors.filtering(n -&gt; n.contains(&quot;n&quot;), Collectors.toList()),                    (list1, list2) -&gt; List.of(list1, list2)            ));    assertEquals(2, result.size());    assertTrue(isEqualCollection(List.of(&quot;Sunday&quot;, &quot;Tuesday&quot;), result.get(0)));    assertTrue(isEqualCollection(List.of(&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Wednesday&quot;), result.get(1)));}</code></pre><p>我们对输入的几个字符串进行过滤，然后将过滤结果组成一个新的队列。</p><h3 id="新工具：CompactNumberFormat"><a href="#新工具：CompactNumberFormat" class="headerlink" title="新工具：CompactNumberFormat"></a>新工具：CompactNumberFormat</h3><p>这个工具比较好玩，可以对数字进行按需格式化。提供了<code>public static NumberFormat getCompactNumberInstance(Locale locale, NumberFormat.Style formatStyle)</code>方法用于初始化：</p><ul><li>第一个参数是指定区域，不同区域展示的结果不同，比如中国展示汉字、美国展示英文；</li><li>第二个参数是指定展示结果的模式，分为<code>SHORT</code>和<code>LONG</code>，不过对于中文展示，似乎没啥区别。</li></ul><p>我们一起看下例子：</p><pre><code class="java">@Testvoid testFormat() {    final NumberFormat zhShort = NumberFormat.getCompactNumberInstance(Locale.CHINA, Style.SHORT);    assertEquals(&quot;1 万&quot;, zhShort.format(10_000));    assertEquals(&quot;1 兆&quot;, zhShort.format(1L &lt;&lt; 40));    final NumberFormat zhLong = NumberFormat.getCompactNumberInstance(Locale.CHINA, Style.LONG);    assertEquals(&quot;1 万&quot;, zhLong.format(10_000));    assertEquals(&quot;1 兆&quot;, zhLong.format(1L &lt;&lt; 40));    final NumberFormat usShort = NumberFormat.getCompactNumberInstance(Locale.US, Style.SHORT);    usShort.setMaximumFractionDigits(2);    assertEquals(&quot;10K&quot;, usShort.format(10_000));    assertEquals(&quot;1.1T&quot;, usShort.format(1L &lt;&lt; 40));    final NumberFormat usLong = NumberFormat.getCompactNumberInstance(Locale.US, Style.LONG);    usLong.setMaximumFractionDigits(2);    assertEquals(&quot;10 thousand&quot;, usLong.format(10_000));    assertEquals(&quot;1.1 trillion&quot;, usLong.format(1L &lt;&lt; 40));}</code></pre><p>我们也可以继续使用<code>NumberFormat</code>中的方法定义，比如示例中保留小数点后 2 位。</p><h2 id="Shenandoah：一个低停顿垃圾收集器"><a href="#Shenandoah：一个低停顿垃圾收集器" class="headerlink" title="Shenandoah：一个低停顿垃圾收集器"></a>Shenandoah：一个低停顿垃圾收集器</h2><p>Java12 引入了一个实验阶段的垃圾收集器：Shenandoah，作为一个低停顿的垃圾收集器。</p><p>Shenandoah 垃圾收集器是 RedHat 在 2014 年宣布进行的垃圾收集器研究项目，其工作原理是通过与 Java 应用执行线程同时运行来降低停顿时间。简单的说就是，Shenandoah 工作时与应用程序线程并发，通过交换 CPU 并发周期和空间以改善停顿时间，使得垃圾回收器执行线程能够在 Java 线程运行时进行堆压缩，并且标记和整理能够同时进行，因此避免了在大多数 JVM 垃圾收集器中所遇到的问题。</p><p><img src="https://static.howardliu.cn/java/shenandoah-gc-cycle.png" alt="Shenandoah GC"></p><p>Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200MB 还是 200GB，都将拥有一致的系统暂停时间，不过实际使用性能将取决于实际工作堆的大小和工作负载。</p><p>Java12 中 Shenandoah 处于实验阶段，想要使用需要编译时添加<code>--with-jvm-features=shenandoahgc</code>，然后启动时使用<code>-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC</code>以开启。</p><p>后续会补充 Java 中各种垃圾收集器的文章，其中会有介绍 Shenandoah 的，敬请关注公众号「看山的小屋」。如果想要提前了解，欢迎访问<a href="https://wiki.openjdk.java.net/display/shenandoah" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/shenandoah</a>。</p><h2 id="增加一套基准测试套件"><a href="#增加一套基准测试套件" class="headerlink" title="增加一套基准测试套件"></a>增加一套基准测试套件</h2><p>Java12 中添加一套基准测试套件，该基准测试套件基于 JMH（Java Microbenchmark Harness），使开发人员可以轻松运行现有的基准测试并创建新的基准测试，其目标是提供一个稳定且优化的基准。</p><p>在这套基准测试套件中包括将近 100 个基准测试的初始集合，并且能够轻松添加新基准、更新基准测试和提高查找已有基准测试的便利性。</p><p>微基准套件与 JDK 源代码位于同一个目录中，并且在构建后将生成单个 Jar 文件。它是一个单独的项目，在支持构建期间不会执行，以方便开发人员和其他对构建微基准套件不感兴趣的人在构建时花费比较少的构建时间。</p><h2 id="Switch-表达式扩展（预览版）"><a href="#Switch-表达式扩展（预览版）" class="headerlink" title="Switch 表达式扩展（预览版）"></a>Switch 表达式扩展（预览版）</h2><p>Switch 语句出现的姿势是条件判断、流程控制组件，与现在很流行的新语言对比，其写法显得非常笨拙，所以 Java 推出了 Switch 表达式语法，可以让我们写出更加简化的代码。这个扩展在 Java12 中作为预览版首次引入，需要在编译时增加<code>-enable-preview</code>开启，在 Java14 中正式提供，功能编号是 <a href="https://openjdk.java.net/jeps/361" target="_blank" rel="noopener">JEP 361</a>。</p><p>比如，我们通过 switch 语法简单计算工作日、休息日，在 Java12 之前需要这样写：</p><pre><code class="java">@Testvoid testSwitch() {    final DayOfWeek day = DayOfWeek.from(LocalDate.now());    String typeOfDay = &quot;&quot;;    switch (day) {        case MONDAY:        case TUESDAY:        case WEDNESDAY:        case THURSDAY:        case FRIDAY:            typeOfDay = &quot;Working Day&quot;;            break;        case SATURDAY:        case SUNDAY:            typeOfDay = &quot;Rest Day&quot;;            break;    }    Assertions.assertFalse(typeOfDay.isEmpty());}</code></pre><p>在 Java12 中的 Switch 表达式中，我们可以直接简化：</p><pre><code class="java">@Testvoid testSwitchExpression() {    final DayOfWeek day = DayOfWeek.SATURDAY;    final String typeOfDay = switch (day) {        case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; &quot;Working Day&quot;;        case SATURDAY, SUNDAY -&gt; &quot;Day Off&quot;;    };    Assertions.assertEquals(&quot;Day Off&quot;, typeOfDay);}</code></pre><p>是不是很清爽。文末提供的源码中，<code>pom.xml</code>定义的<code>maven.compiler</code>版本写的是<code>14</code>，这是因为 Switch 表达式是 Java14 正式提供，我没有重新编译 Java，所以只能指定 Java14 来实现这个功能代码的演示。</p><h2 id="引入-JVM-常量-API"><a href="#引入-JVM-常量-API" class="headerlink" title="引入 JVM 常量 API"></a>引入 JVM 常量 API</h2><p>Java12 中引入 JVM 常量 API，用来更容易地对关键类文件和运行时构件的描述信息进行建模，特别是对那些从常量池加载的常量，这是一项非常技术性的变化，能够以更简单、标准的方式处理可加载常量。</p><p>具体来说就是<code>java.base</code>模块新增了<code>java.lang.constant</code>包，引入了<code>ConstantDesc</code>接口以及<code>Constable</code>接口。<code>ConstantDesc</code>的子接口包括：</p><ul><li><code>ClassDesc</code>：Class 的可加载常量标称描述符；</li><li><code>MethodTypeDesc</code>：方法类型常量标称描述符；</li><li><code>MethodHandleDesc</code>：方法句柄常量标称描述符；</li><li><code>DynamicConstantDesc</code>：动态常量标称描述符。</li></ul><p>继续挖坑，这部分内容会在进阶篇再详细介绍，敬请关注公众号「看山的小屋」。</p><h2 id="改进-AArch64-实现"><a href="#改进-AArch64-实现" class="headerlink" title="改进 AArch64 实现"></a>改进 AArch64 实现</h2><p>Java12 中将只保留一套 AArch64 实现，之前版本中，有两个关于 aarch64 的实现，分别是<code>ope/src/hotspot/cpu/arm</code>以及<code>open/src/hotspot/cpu/aarch64</code>，它们的实现重复了。为了集中精力更好地实现 aarch64，删除了<code>open/src/hotspot/cpu/arm</code>中与 arm64（64-bit Arm platform）实现相关的代码，只保留 32 位 ARM 端口和 64 位 aarch64 的端口。</p><p>这样做，可以让开发人员将目标集中在剩下的这个 64 位 ARM 实现上，消除维护两套端口所需的重复工作。</p><p>目标聚焦，力量集中。</p><h2 id="默认使用类数据共享（CDS）存档"><a href="#默认使用类数据共享（CDS）存档" class="headerlink" title="默认使用类数据共享（CDS）存档"></a>默认使用类数据共享（CDS）存档</h2><p>在 <a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a> 中我们介绍过类数据共享（CDS，Class Data Sharing），其作用是通过构建时生成默认类列表，在运行时使用内存映射，减少 Java 的启动时间和减少动态内存占用量，也能在多个 Java 虚拟机之间共享相同的归档文件，减少运行时的资源占用。</p><p>在 Java12 之前，想要使用需要三步走手动开启，到了 Java12，将默认开启 CDS 功能，想要关闭，需要使用参数<code>-Xshare:off</code>。</p><h2 id="改善-G1-垃圾收集器"><a href="#改善-G1-垃圾收集器" class="headerlink" title="改善 G1 垃圾收集器"></a>改善 G1 垃圾收集器</h2><h3 id="能够中止收集"><a href="#能够中止收集" class="headerlink" title="能够中止收集"></a>能够中止收集</h3><p>G1 垃圾收集器可以在大内存多处理器的工作场景中提升回收效率，能够满足用户预期降低 STW 停顿时间。</p><p>其内部是采用一个高级分析引擎来选择在收集期间要处理的工作量，此选择过程的结果是一组称为 GC 回收集（collection set，CSet）的区域。一旦收集器确定了 GC 回收集 并且 GC 回收、整理工作已经开始，则 G1 收集器必须完成收集集合集的所有区域中的所有活动对象之后才能停止；但是如果收集器选择过大的 GC 回收集，可能会导致 G1 回收器停顿时间超过预期时间。</p><p>在 Java12 中，GC 回收集拆分为必需和可选两部分，使 G1 垃圾回收器能中止垃圾回收过程。其中必需处理的部分包括 G1 垃圾收集器不能递增处理的 GC 回收集的部分，同时也可以包含老年代以提高处理效率。在 G1 垃圾回收器完成收集需要必需回收的部分之后，G1 垃圾回收器可以根据剩余时间决定是否停止收集。</p><h3 id="向操作系统自动返回未用堆内存"><a href="#向操作系统自动返回未用堆内存" class="headerlink" title="向操作系统自动返回未用堆内存"></a>向操作系统自动返回未用堆内存</h3><p>在 Java11 中，G1 仅在进行 Full GC 或并发处理周期时才能向操作系统返还堆内存，但是这两种场景都是 G1 极力避免的，所以如果我们使用 G1 收集器，基本上很难返还 Java 堆内存，这样对于那种周期性执行大量占用内存的应用，会造成比较多的内存浪费。</p><p>Java12 中，G1 垃圾收集器将在应用程序不活动期间定期生成或持续循环检查整体 Java 堆使用情况，以便 G1 垃圾收集器能够更及时的将 Java 堆中不使用内存部分返还给操作系统。对于长时间处于空闲状态的应用程序，此项改进将使 JVM 的内存利用率更加高效。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java12 新增的特性，完整的特性清单可以从<a href="https://openjdk.java.net/projects/jdk/12/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/12/</a>查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/By2JoZqAHA6U36PG8qvCcg" target="_blank" rel="noopener">Java17 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/W6Esovb7zzCL_seXgY84jA" target="_blank" rel="noopener">Java18 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/WutbAX_IQNqP4M3rud9f_g" target="_blank" rel="noopener">Java19 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/DvZYrZTtGfdXNsXGzmQN1A" target="_blank" rel="noopener">Java20 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/iiXa9rpJu1Vedpke0XpBzQ" target="_blank" rel="noopener">Java21 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/eHHFaJErH8XH4QSRrfcehQ" target="_blank" rel="noopener">Java22 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/XvB0D2vzhaAvHESupdALag" target="_blank" rel="noopener">Java23 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378" target="_blank" rel="noopener">Java24 的新特性</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-12-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java12 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122530460" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java12 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文讲解一下 Java12 的特性，作为第一个长期支持版 Java11 之后的第一个版本，增加的功能也不少，除了一些小幅度的 API 增强，增加了另一个试验阶段的垃圾收集器 Shenandoah、对 G1 做了优化、增加微基准套件等。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java12" scheme="https://www.howardliu.cn/tags/Java12/"/>
    
  </entry>
  
</feed>
