<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沉潜飞动</title>
  
  <subtitle>君子藏器于身，待时而动。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.howardliu.cn/"/>
  <updated>2023-01-07T14:40:56.000Z</updated>
  <id>https://www.howardliu.cn/</id>
  
  <author>
    <name>Howard Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>羊不羊的关我什么事？</title>
    <link href="https://www.howardliu.cn/what-i-think-of-covid-19/"/>
    <id>https://www.howardliu.cn/what-i-think-of-covid-19/</id>
    <published>2023-01-07T14:40:56.000Z</published>
    <updated>2023-01-07T14:40:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/raving/b919bbc6863c45cb94c7f5a0ce376f18.jpg" alt="这段经历终将成为历史"></p><p>你好，我是看山。</p><p>不出意外，看到这篇文章的人八成阳了。</p><p>先放个统计，12月23号的时候，部门发起了一次投票，480人参与，只有20%的壮士还没阳。</p><a id="more"></a><p><img src="https://static.howardliu.cn/raving/1.jpeg" alt="是否感染新冠统计"></p><p>在这一波高峰期前，我们公司已经居家好几个周了，所以投票结果基本上能够反应社会情况。</p><p>今天就想聊两件事：</p><ol><li>为啥突然放开了？</li><li>我对放开的看法。</li></ol><h2 id="为啥放开"><a href="#为啥放开" class="headerlink" title="为啥放开"></a>为啥放开</h2><p>什么情况下可以放开？基本上有三种情况：</p><ol><li>第一种情况是大家希望的，像SARS一样，新冠病毒消失了；</li><li>第二种情况是不需要防，新冠病毒致死率重症率降低到可容忍范围（比如无限接近0），我们与病毒共生了；</li><li>第三种情况是防不住，虽然病毒致死率还很高，但一个眼神交流就会传染，防不胜防了。</li></ol><p>现在显然不是第一种情况。</p><p>我们先来看个数据：</p><p>新冠病毒原始毒株的R0值在3-5；德尔塔毒株的R0值为6-8；奥密克戎BA.1的R0值约为9.5；奥密克戎BA.2的R0值约为13.3；奥密克戎BA.4/5的R0值可能达到18.6……</p><p>R0值（R naught）是基本传染数（basic reproductive number）的简称，又译作基本再生数，指的是在没有采取任何干预措施的情况下，平均每位感染者在传染期内使易感者个体致病的数量。数字越大说明传播能力越强，控制难度越大。</p><p>简单说就是，R0是2时，一个传染俩，两个传四个，四个传八个，以此类推……经过4个循环，病例数就增加到64人。</p><p>咱们把新冠病毒的R0值做个图：</p><p><img src="https://static.howardliu.cn/raving/B1234E4F-0095-4002-99A4-74530209393F.png" alt="新冠集中毒株的R0值曲线"></p><p>这就是所谓的指数爆炸：</p><ul><li>当R0等于3的时候，经过4次传播，结果是81；</li><li>当R0等于6的时候，经过4次传播，结果是1296；</li><li>当R0等于9的时候，经过4次传播，结果是6561；</li><li>当R0等于13的时候，经过4次传播，结果是28561；</li><li>……</li></ul><p>当R0超过一定范围，不是我们想防就能防得住的。就比如年初的上海，奥密克戎的高传播性迅速击溃了精准防控，演变成后来的封城。</p><p>奥密克戎的变异株的传染能力还在增强，据说现在是21了（没有查到官方数据）。</p><p>这个时候，我们如果还想像前几年似的，想通过封控来阻断传染，就要举全国之力了。那种情况下，大家就只能待在家里，各种行业停摆。显然是不现实的，不是每家都有能够吃一个月的战略储备粮，也不是每家都能够啥也不干白来一个月钱的。</p><p>也就是说，现在是防不住了。</p><p><img src="https://static.howardliu.cn/raving/1BE20C5B-4E99-462F-A95C-60550E27304A.png" alt="不用下楼会感染了新冠"></p><p>然后我们再看看致病性，鉴于大家或者周围人都阳过，就算是有经验。我身边人阳了之后的征兆基本上这这几种：</p><ol><li>发烧，有的低烧好几天（免疫力差）、有的高烧一两天（免疫力强）；</li><li>咳嗽，干咳或者湿咳，因人而异；</li><li>嗓子疼，戏称宝娟嗓，严重的说不出话，感觉像是吞刀片一样；</li><li>浑身疼，主要变现是肌肉酸疼，浑身没劲；</li></ol><p>可以看到，这些症状和普通的流感很像。甚至没有抗原的情况下，都不能断定自己是流感还是新冠。</p><p>也就是说，大部分人阳了之后症状都很轻，且属于上呼吸道的症状，基本上对肺部没啥影响。</p><p>这样就符合第二种情况了，我们大多数人可以与新冠病毒共生了。</p><p>从经济的角度看，我们不可能无限期的收紧防控措施，很多企业在这段封控期间艰难度日，每一次收紧，企业都会受到冲击，我们没有办法不计成本的封控，孩子要长大，成人要工作，企业要发展，人们要生活。时移世易，当封控成本远远大于收益时，当感染后对身体影响很小时，我们就要选择更适合的方式。</p><h2 id="我的看法"><a href="#我的看法" class="headerlink" title="我的看法"></a>我的看法</h2><p>再来说下我对放开的看法：坚决拥护，但也会做好个人防护。</p><p>首先说个人防护，相信大家从各种渠道了解过，病毒是RNA复制，变异方向多变且速度快，就有概率出现传染性强且致死率高的毒株。只要我们做好防护，别让病毒在我们体内有复制的机会，那变异的机会就会少很多。</p><p>然后说坚决拥护，就这几周看过来，商场在渐渐恢复，大家生活轻松很多，连前几天几乎瘫痪的物流快递业，现在也逐渐恢复了。一切都在向好的方向发展，有什么理由不拥护呢？</p><p>给大家看一下北京地铁最近15日客流量和往年日均客流量图。</p><p><img src="https://static.howardliu.cn/raving/B5237931-A4EE-47B1-8E68-0B1A7399572C.png" alt="北京地铁最近15日客流量"></p><p><img src="https://static.howardliu.cn/raving/375EB016-DA3D-4D34-A161-CCF332189190.png" alt="北京地铁往年日均客流量"></p><p>最近15日客流量每个工作日都在递增，在1月6日已经达到769万。再看年日均客流，2023年刚开始7天，日均客流量已经达到去年平均水平。</p><p>回想前段时间，2022年11月25日客流量跌到了108万，在放开之后，逐步恢复生机。</p><p>从上帝视角看，中央踩刹车打方向盘的举措是正确的。就这几天复工经历看，同事们带着口罩，偶尔听到几声咳嗽，也都没人在意，我们以较小的成本实现了与新冠共存。</p><p>放一个新华社的<a href="https://h5.xinhuaxmt.com/h5/m1/covid19/index.html" target="_blank" rel="noopener">新冠防疫手册</a>，虽然病毒毒性弱了，但是阳的时候还是很难受的，能不重阳就不重阳吧。</p><p>最后，多年之后，当我们回忆起这三年，可能有感慨、有怀念、有悲伤，更多的可能是对当下美好生活的珍惜。</p><p>祝大家身体健康。</p><p><img src="https://static.howardliu.cn/raving/1FE35223-7DD2-4910-89C7-081ACCF12BE3.jpg" alt="护体金钟罩"></p><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/what-i-think-of-covid-19/">羊不羊的关我什么事？</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://static.howardliu.cn/raving/b919bbc6863c45cb94c7f5a0ce376f18.jpg&quot; alt=&quot;这段经历终将成为历史&quot;&gt;&lt;/p&gt;
&lt;p&gt;你好，我是看山。&lt;/p&gt;
&lt;p&gt;不出意外，看到这篇文章的人八成阳了。&lt;/p&gt;
&lt;p&gt;先放个统计，12月23号的时候，部门发起了一次投票，480人参与，只有20%的壮士还没阳。&lt;/p&gt;
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="新冠" scheme="https://www.howardliu.cn/tags/%E6%96%B0%E5%86%A0/"/>
    
      <category term="covid-19" scheme="https://www.howardliu.cn/tags/covid-19/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实战：国际化组件 MessageSource 与 Nacos 组合实现动态配置能力</title>
    <link href="https://www.howardliu.cn/springboot-action-messagesource-nacos/"/>
    <id>https://www.howardliu.cn/springboot-action-messagesource-nacos/</id>
    <published>2022-08-14T02:52:50.000Z</published>
    <updated>2022-08-14T02:52:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/jellyfish-g1ec9e22b7_1920.jpeg" alt="SpringBoot 实战：国际化组件 MessageSource 与 Nacos 组合实现动态配置能力"></p><p>你好，我是看山。</p><p>前面介绍了 Spring 的 MessageSource 组件的用法、执行逻辑和源码，本文我们将根据前面的知识，实现自己的动态刷新的国际化组件。</p><a id="more"></a><p>现在大家都用的是微服务，为了高可用，每个服务部署时最少两个实例。</p><ul><li>如果使用<code>ResourceBundleMessageSource</code>实现国际化，每次修改配置文件，都需要重启服务。</li><li>如果使用<code>ReloadableResourceBundleMessageSource</code>，我们可以借助多个服务挂在同一个磁盘或同一个卷读取同一个配置文件，借助远程工具，修改文件实现动态配置内容的修改。但是这就涉及到文本编辑，不能很好的实现审计记录和文件管控。</li></ul><p>所以，我们要实现一个适用于微服务架构、方便修改、具备审计功能的动态的国际化配置组件。本文选择 Nacos 实现，Nacos 有配置中心的能力，适合在微服务架构中使用，同时也具备方便修改和审计能力，只要我们实现从 Nacos 加载国际化配置的能力，就可以轻松实现目标。</p><h2 id="几个关键点"><a href="#几个关键点" class="headerlink" title="几个关键点"></a>几个关键点</h2><p>Spring 提供的默认实现中，<code>ReloadableResourceBundleMessageSource</code>实现了动态刷新的能力，只不过是从文件读取内容，我们可以借助<code>ReloadableResourceBundleMessageSource</code>的逻辑实现，只是将其改为从 Nacos 读取内容。</p><p>这个实现，通常可以有两种方案（假设我们新实现的类命名为<code>NacosBundleMessageSource</code>）：</p><ol><li>继承<code>ReloadableResourceBundleMessageSource</code>：重写读取配置的方法，然后通过 Spring 注入新的方法。这种方式有优点和缺点：<ol><li>优点 1：我们可以保持与<code>ReloadableResourceBundleMessageSource</code>相似的结构和执行逻辑，当 Spring 进行升级的时候，我们直接通过继承获取了能力；</li><li>优点 2：我们只需要覆盖几个关键方法，需要重写的方法比较少；</li><li>缺点 1：当我们期望在系统中引入多种类型的 MessageSource 组件时，就不能简单的通过类型加载了。比如<code>applicationContext.getBean(ReloadableResourceBundleMessageSource.class)</code>会找到<code>ReloadableResourceBundleMessageSource</code>和<code>NacosBundleMessageSource</code>两个 Bean，Spring 容器就不知道该返回哪个了；</li><li>缺点 2：虽然继承能够少写代码，但是一旦 Spring 修改了执行逻辑，我们的<code>NacosBundleMessageSource</code>就可能需要重写。</li></ol></li><li>模仿<code>ReloadableResourceBundleMessageSource</code>：完全实现自己的一个动态加载类。与第一种的优缺点正好相反：<ol><li>优点 1：完全不同的类，Bean 对应的 class 类型不同，<code>applicationContext.getBean</code>可以通过 class 类型获取；</li><li>优点 2：与<code>ReloadableResourceBundleMessageSource</code>的类定义没有关系，除非 Spring 修改底层逻辑，否则不会因为<code>ReloadableResourceBundleMessageSource</code>的变动出现不兼容的情况；</li><li>缺点 1：当 Spring 对<code>ReloadableResourceBundleMessageSource</code>进行升级，提出更加优化的写法，我们就需要重写<code>NacosBundleMessageSource</code>了；</li><li>缺点 2：既然是仿写，很多方法都是与<code>ReloadableResourceBundleMessageSource</code>完全相同的重复代码。</li></ol></li></ol><p>考虑到两种方案的优缺点，结合业务中的逻辑，最终选择方案二。</p><h2 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h2><p>我们要实现的国际化组件，在 Spring 的实现中，使用的是<code>Locale</code>表示指定的区域，在这个类中，定义了三个不同的维度<code>language</code>、<code>country</code>、<code>variant</code>，翻译过来是<code>语言</code>、<code>国家</code>、<code>变种</code>，结合<code>BaseLocale</code>的定义，可以将<code>country</code>看做是语言大类。</p><p>根据前面的介绍，我们的国际化配置文件定义格式是根据<code>Locale</code>格式定义的。比如，basename 是 messages，Locale 是 de_AT_oo 的话，对应的配置文件可以是“messages_de_AT_OO”、“messages_de_AT”、“messages_de”。</p><p>所以我们需要用到递归的方式获取文件名：</p><pre><code class="java">protected List&lt;String&gt; calculateFilenamesForLocale(String basename, Locale locale) {    List&lt;String&gt; result = new ArrayList&lt;&gt;(3);    String language = locale.getLanguage();    String country = locale.getCountry();    String variant = locale.getVariant();    StringBuilder temp = new StringBuilder(basename);    temp.append(&#39;_&#39;);    if (language.length() &gt; 0) {        temp.append(language);        result.add(0, temp.toString());    }    temp.append(&#39;_&#39;);    if (country.length() &gt; 0) {        temp.append(country);        result.add(0, temp.toString());    }    if (variant.length() &gt; 0 &amp;&amp; (language.length() &gt; 0 || country.length() &gt; 0)) {        temp.append(&#39;_&#39;).append(variant);        result.add(0, temp.toString());    }    return result;}</code></pre><h2 id="加载方式"><a href="#加载方式" class="headerlink" title="加载方式"></a>加载方式</h2><p>既然是从 Nacos 读取配置，那配置文件的内容就需要通过 Nacos 获取。这里使用了<code>NacosConfigManager</code>获取：</p><pre><code class="java">protected Properties loadProperties(String filename) throws IOException, NacosException {    final Properties props = newProperties();    final String dataId = filename + NacosConstants.PROPERTIES_SUFFIX;    logger.info(&quot;Loading properties for &quot; + dataId);    final String config = nacosConfigManager.getConfigService().getConfig(dataId, nacosGroup, 5000);    if (StringUtils.hasText(config)) {        logger.info(&quot;No properties found for &quot; + dataId);        throw new NoSuchFileException(dataId);    }    try (Reader reader = new StringReader(config)) {        this.propertiesPersister.load(props, reader);        logger.info(&quot;Loaded properties for &quot; + dataId);    }    return props;}</code></pre><p>方法传入的<code>filename</code>就是从上一节中获取的文件名。当然，文件名是我们计算出来的，可能不存在，此处直接抛出<code>NoSuchFileException</code>，由上层逻辑捕捉处理：</p><pre><code class="java">protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder) {    long refreshTimestamp = (getCacheMillis() &lt; 0 ? -1 : System.currentTimeMillis());    try {        Properties props = loadProperties(filename);        propHolder = new PropertiesHolder(props, -1);    } catch (NacosException ex) {        if (logger.isWarnEnabled()) {            logger.warn(&quot;Could not get properties form nacos &quot;, ex);        }        // Empty holder representing &quot;not valid&quot;.        propHolder = new PropertiesHolder();    } catch (IOException ex) {        if (logger.isInfoEnabled()) {            logger.info(&quot;Could not get properties form nacos, the message is &quot; + ex.getMessage());        }        // Empty holder representing &quot;not valid&quot;.        propHolder = new PropertiesHolder();    }    propHolder.setRefreshTimestamp(refreshTimestamp);    this.cachedProperties.put(filename, propHolder);    logger.info(&quot;Refreshed properties for &quot; + filename);    return propHolder;}</code></pre><p>我们可以看到，从 Nacos 中读取配置逻辑的上层会捕捉<code>Exception</code>，然后创建一个空的配置管理器。此处会有两个异常：</p><ul><li><code>NacosException</code>：读取 Nacos 失败抛出的异常，包括 Nacos 链接不正确或者是读取失败等；</li><li><code>IOException</code>：没有指定文件名的配置时会抛出 IOException。</li></ul><h2 id="动态刷新"><a href="#动态刷新" class="headerlink" title="动态刷新"></a>动态刷新</h2><p>前一节讲了加载 Nacos 配置文件的方式，本节说一下怎么实现 Nacos 配置文件的监听，动态刷新配置内容。</p><p>我们先介绍一下实现 Nacos 监听的几个类：</p><ul><li>NacosRefreshHistory：nacos 配置文件刷新的历史记录，会保存 Nacos 配置文件的刷新历史，最多存储 20 个；</li><li>ConfigService：一般使用的时候是 NacosConfigService 类，这个类是使用<code>NacosConfigManager#getConfigService</code>通过反射创建的，用于存储 Nacos 监听器，实现监听逻辑；</li><li>Listener：这个就是具体的监听器了，在我们的例子中，使用的是<code>AbstractSharedListener</code>的匿名子类，实现动态刷新的逻辑就在这个类里。</li></ul><p>首先，我们当前组件是 MessageSource，用于实现国际化的组件。这个组件是在整个应用就绪后再加载就行，所以，我们监听 Spring 的<code>ApplicationReadyEvent</code>事件即可。</p><pre><code class="java">@Overridepublic void onApplicationEvent(ApplicationReadyEvent event) {    // many Spring context    if (this.ready.compareAndSet(false, true)) {        for (Locale defaultLocale : this.nacosBundleMessageSource.defaultLocales()) {            this.nacosBundleMessageSource.getMergedProperties(defaultLocale);        }        this.registerNacosListenersForApplications();    }}</code></pre><p>然后是我们需要对所有可能的配置文件进行监听，就需要用到前文的<code>calculateFilenamesForLocale</code>方法，计算所有可能出现的名字。</p><pre><code class="java">private void registerNacosListenersForApplications() {    if (!isRefreshEnabled()) {        return;    }    this.nacosBundleMessageSource.getBasenameSet().stream()            .map(basename -&gt; this.nacosBundleMessageSource.defaultLocales().stream()                    .map(locale -&gt; this.nacosBundleMessageSource.calculateAllFilenames(basename, locale))                    .flatMap(List::stream)                    .collect(Collectors.toList())            )            .flatMap(List::stream)            .forEach(x -&gt; registerNacosListener(nacosBundleMessageSource.getNacosGroup(), x + NacosConstants.PROPERTIES_SUFFIX));}</code></pre><p>最后，我们需要向 Nacos 的运行管理器中注册文件监听，实现动态刷新的能力。</p><pre><code class="java">private void registerNacosListener(final String groupKey, final String dataKey) {    final String key = NacosPropertySourceRepository.getMapKey(dataKey, groupKey);    final Listener listener = listenerMap.computeIfAbsent(key, lst -&gt; new AbstractSharedListener() {        @Override        public void innerReceive(String dataId, String group, String configInfo) {            refreshCountIncrement();            nacosRefreshHistory.addRefreshRecord(dataId, group, configInfo);            try {                nacosBundleMessageSource.forceRefresh(dataId, configInfo);                if (log.isDebugEnabled()) {                    log.debug(&quot;Refresh Nacos config group={},dataId={},configInfo={}&quot;, group, dataId, configInfo);                }            } catch (IOException e) {                log.warn(&quot;Nacos refresh failed, dataId: {}, group: {}, configInfo: {}&quot;,                        dataId, group, configInfo, e);            }        }    });    try {        configService.addListener(dataKey, groupKey, listener);    } catch (NacosException e) {        log.warn(&quot;register fail for nacos listener ,dataId=[{}],group=[{}]&quot;, dataKey, groupKey, e);    }}</code></pre><p>至此，我们获取了国际化组件 MessageSource 与 Nacos 组合实现动态配置能力。本文中的实例已经传到 GitHub，关注公众号「看山的小屋」，回复<code>spring</code>获取源码。</p><h2 id="发散一下"><a href="#发散一下" class="headerlink" title="发散一下"></a>发散一下</h2><p>接下来，我们再重头想一下，我们最初想要实现一个适用于微服务架构、方便修改、具备审计功能的动态的国际化配置组件。选择 Nacos 作为例子，是因为 Nacos 本身实现了动态监听的能力，可以快速复刻<code>ReloadableResourceBundleMessageSource</code>的能力。那 Nacos 具备什么能力呢？</p><ol><li>中心化存储：因为我们想在微服务架构中使用，就不能采用与独立服务耦合的方式，需要所有服务可以读取的方式。比如数据库（包括关系型数据库、非关系型数据库等）、分布式缓存、远程磁盘（或者 Docker 的卷）等；</li><li>可监听：任何配置的修改能够被服务感知，想要做到这个，就是在配置发生修改时，发送一个修改时间，通知监听服务配置被修改。可以采用被动和主动两种方式：<ol><li>被动方式：这个比较简单，只要将组件中的缓存逻辑删除就可以了，每次查询配置都直接存储器中读取，但是这又与性能相悖，一般不采用这个方案；</li><li>主动方式：通过发送事件或者消息的方式，比如采用 CQRS 模式，发生修改时，发送一条消息，各个微服务监听这个消息，重新加载配置；</li></ol></li><li>可审计：这个能力简单说就是要记录每次修改的时间、人物、动作等信息，这个功能是常用功能，这里就不赘述了。</li></ol><p>只要具备上面三个特性，我们可以通过各种组合实现，比如：</p><ol><li>可挂在磁盘</li><li>Git+Hook</li><li>MySQL+Redis+MQ</li><li>……</li></ol><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文从实践角度出发，实现了一个适用于微服务架构、方便修改、具备审计功能的动态的国际化配置组件。文中的实例已经传到 GitHub，关注公众号「看山的小屋」，回复<code>spring</code>获取源码。如果是你，你会采用哪种方案呢？欢迎一起讨论。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/zUrx7duy0-OY1oYn8FeKOw" target="_blank" rel="noopener">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://mp.weixin.qq.com/s/H599Wri3VbjTuLBnf7pD3w" target="_blank" rel="noopener">SpringBoot 实战：如何优雅地处理异常</a></li><li><a href="https://mp.weixin.qq.com/s/fcVE-cE7tDuWKoNNX9rsoQ" target="_blank" rel="noopener">SpringBoot 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://mp.weixin.qq.com/s/xQQbl6VNF2eCgmQPrMyc4w" target="_blank" rel="noopener">SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li><li><a href="https://mp.weixin.qq.com/s/coKjuefWMmCA4bSkRDIRVA" target="_blank" rel="noopener">SpringBoot 实战：优雅地使用枚举参数</a></li><li><a href="https://mp.weixin.qq.com/s/pet_rA7-O1JD3QfQ1fqxAQ" target="_blank" rel="noopener">SpringBoot 实战：优雅地使用枚举参数（原理篇）</a></li><li><a href="https://mp.weixin.qq.com/s/2OXArNObVejXLvMOmE3oqw" target="_blank" rel="noopener">SpringBoot 实战：在 RequestBody 中优雅地使用枚举参数</a></li><li><a href="https://mp.weixin.qq.com/s/hdioIIwPA2lv2khfRmKhOQ" target="_blank" rel="noopener">SpringBoot 实战：在 RequestBody 中优雅地使用枚举参数（原理篇）</a></li><li><a href="https://mp.weixin.qq.com/s/vbccn0kTdyOlmznDr3RItw" target="_blank" rel="noopener">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a></li><li><a href="https://mp.weixin.qq.com/s/s8PQXLT8Ni3dLqsOgf3syA" target="_blank" rel="noopener">SpringBoot 实战：加载和读取资源文件内容</a></li><li><a href="https://mp.weixin.qq.com/s/dGPhS5vdbnFdiTxkpr2mLg" target="_blank" rel="noopener">SpringBoot 实战：国际化组件 MessageSource</a></li><li><a href="https://mp.weixin.qq.com/s/FzX-nVMl96RwI6ITULhQcQ" target="_blank" rel="noopener">SpringBoot 实战：国际化组件MessageSource的执行逻辑与源码</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/springboot-action-messagesource-nacos/">SpringBoot 实战：国际化组件 MessageSource 与 Nacos 组合实现动态配置能力</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">SpringBoot 实战：国际化组件 MessageSource 与 Nacos 组合实现动态配置能力</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      前面介绍了 Spring 的 MessageSource 组件的用法、执行逻辑和源码，本文我们将根据前面的知识，实现自己的动态刷新的国际化组件。
    
    </summary>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/categories/spring/"/>
    
    
      <category term="SpringBoot 实战" scheme="https://www.howardliu.cn/tags/SpringBoot-%E5%AE%9E%E6%88%98/"/>
    
      <category term="SpringBoot" scheme="https://www.howardliu.cn/tags/SpringBoot/"/>
    
      <category term="spring" scheme="https://www.howardliu.cn/tags/spring/"/>
    
      <category term="SpringBoot 手册" scheme="https://www.howardliu.cn/tags/SpringBoot-%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实战：国际化组件 MessageSource 的执行逻辑与源码</title>
    <link href="https://www.howardliu.cn/springboot-action-messagesource-principle/"/>
    <id>https://www.howardliu.cn/springboot-action-messagesource-principle/</id>
    <published>2022-08-07T13:04:19.000Z</published>
    <updated>2022-08-07T13:04:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/squirrel-7025721_1920.jpeg" alt="SpringBoot 实战：国际化组件 MessageSource 的执行逻辑与源码"></p><p>你好，我是看山。</p><p>前文介绍了 SpringBoot 中的国际化组件<code>MessageSource</code>的使用，本章我们一起看下<code>ResourceBundleMessageSource</code>和<code>ReloadableResourceBundleMessageSource</code>的执行逻辑。SpringBoot 的 MessageSource 组件有很多抽象化，源码看起来比较分散，所以本文会通过流程图的方式进行讲解。</p><a id="more"></a><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>配置文件是基础，会影响执行逻辑，我们先来看下配置项：</p><ul><li>basename：加载资源的文件名，可以多个资源名称，通过逗号隔开，默认是“messages”；</li><li>encoding：加载文件的字符集，默认是 UTF-8，这个不多说；</li><li>cacheDuration：文件加载到内存后缓存时间，默认单位是秒。如果没有设置，只会加载一次缓存，不会自动更新。这个参数在 ResourceBundleMessageSource、ReloadableResourceBundleMessageSource 稍微有些差异，会具体说下。</li><li>fallbackToSystemLocale：这是一个兜底开关。默认情况下，如果在指定语言中找不到对应的值，会从 basename 参数（默认是 messages.properties）中查找，如果再找不到可能直接返回或抛错。该参数设置为 true 的话，还会再走一步兜底逻辑，从当前系统语言对应配置文件中查找。该参数默认是 true；</li><li>alwaysUseMessageFormat：MessageSource 组件通过<code>MessageFormat.format</code>函数对国际化信息格式化，如果注入参数，输出结果是经过格式化的。比如<code>MessageFormat.format(&quot;Hello, {0}!&quot;, &quot;Kanshan&quot;)</code>输出结果是“Hello, Kanshan!”。该参数控制的是，当输入参数为空时，是否还是使用<code>MessageFormat.format</code>函数对结果进行格式化，默认是 false；</li><li>useCodeAsDefaultMessage：当没有找到对应信息的时候，是否返回 code。也就是当找了所有能找的配置文件后，还是没有找到对应的信息，是否直接返回 code 值。默认是 false，即不返回 code，抛出<code>NoSuchMessageException</code>异常。</li></ul><p>这些配置参数都有各自的默认值。如果没有特殊的需求，可以直接直接按照默认约定使用。</p><h2 id="执行逻辑"><a href="#执行逻辑" class="headerlink" title="执行逻辑"></a>执行逻辑</h2><p>接下来我们看下流程图，下面的流程图绿色部分是 cacheDuration 没有配置的情况。对于 ResourceBundleMessageSource 是只加载一次配置文件，ReloadableResourceBundleMessageSource 会根据文件修改时间判断是否需要重新加载。</p><h3 id="ResourceBundleMessageSource-的流程图"><a href="#ResourceBundleMessageSource-的流程图" class="headerlink" title="ResourceBundleMessageSource 的流程图"></a>ResourceBundleMessageSource 的流程图</h3><p><img src="https://static.howardliu.cn/spring/springboot-messagesource-ResourceBundleMessageSource.png" alt="ResourceBundleMessageSource"></p><h3 id="ReloadableResourceBundleMessageSource-的流程图"><a href="#ReloadableResourceBundleMessageSource-的流程图" class="headerlink" title="ReloadableResourceBundleMessageSource 的流程图"></a>ReloadableResourceBundleMessageSource 的流程图</h3><p><img src="https://static.howardliu.cn/spring/springboot-messagesource-ReloadableResourceBundleMessageSource.png" alt="ReloadableResourceBundleMessageSource"></p><h3 id="AbstractMessageSource-的几个-getMessage-方法源码"><a href="#AbstractMessageSource-的几个-getMessage-方法源码" class="headerlink" title="AbstractMessageSource 的几个 getMessage 方法源码"></a>AbstractMessageSource 的几个 getMessage 方法源码</h3><pre><code class="java">@Overridepublic final String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale) {    String msg = getMessageInternal(code, args, locale);    if (msg != null) {        return msg;    }    if (defaultMessage == null) {        return getDefaultMessage(code);    }    return renderDefaultMessage(defaultMessage, args, locale);}@Overridepublic final String getMessage(String code, @Nullable Object[] args, Locale locale) throws NoSuchMessageException {    String msg = getMessageInternal(code, args, locale);    if (msg != null) {        return msg;    }    String fallback = getDefaultMessage(code);    if (fallback != null) {        return fallback;    }    throw new NoSuchMessageException(code, locale);}@Overridepublic final String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException {    String[] codes = resolvable.getCodes();    if (codes != null) {        for (String code : codes) {            String message = getMessageInternal(code, resolvable.getArguments(), locale);            if (message != null) {                return message;            }        }    }    String defaultMessage = getDefaultMessage(resolvable, locale);    if (defaultMessage != null) {        return defaultMessage;    }    throw new NoSuchMessageException(!ObjectUtils.isEmpty(codes) ? codes[codes.length - 1] : &quot;&quot;, locale);}</code></pre><p>第一个<code>getMessage</code>方法，是可以传入默认值<code>defaultMessage</code>的，也就是当所有 basename 的配置文件中不存在 code 指定的值，就会使用<code>defaultMessage</code>值进行格式化返回。</p><p>第二个<code>getMessage</code>方法，是通过判断<code>useCodeAsDefaultMessage</code>配置，如果设置了 true，在所有 basename 的配置文件中不存在 code 指定的值的情况下，会返回 code 作为返回值。但是当设置为 false 时，code 不存在的情况下，会抛出<code>NoSuchMessageException</code>异常。</p><p>第三个<code>getMessage</code>方法，传入的是<code>MessageSourceResolvable</code>接口对象，查找的 code 更加多种多样。不过如果最后还是找不到，会抛出<code>NoSuchMessageException</code>异常。</p><h2 id="缓存的使用"><a href="#缓存的使用" class="headerlink" title="缓存的使用"></a>缓存的使用</h2><p>我们看源码不仅仅是为了看功能组件的实现，还是学习更加优秀的编程方式。比如下面这段内存缓存的使用，Spring 源码中很多地方都用到了这种内存缓存的使用方式：</p><pre><code class="java">// 两层 Map，第一层是 basename，第二层是 localeprivate final Map&lt;String, Map&lt;Locale, ResourceBundle&gt;&gt; cachedResourceBundles =        new ConcurrentHashMap&lt;&gt;();@Nullableprotected ResourceBundle getResourceBundle(String basename, Locale locale) {    if (getCacheMillis() &gt;= 0) {        // Fresh ResourceBundle.getBundle call in order to let ResourceBundle        // do its native caching, at the expense of more extensive lookup steps.        return doGetBundle(basename, locale);    }    else {        // Cache forever: prefer locale cache over repeated getBundle calls.        // 先从缓存中获取第一层 basename 的缓存        Map&lt;Locale, ResourceBundle&gt; localeMap = this.cachedResourceBundles.get(basename);        if (localeMap != null) {            // 如果命中第一层，在通过 locale 获取第二层的值            ResourceBundle bundle = localeMap.get(locale);            if (bundle != null) {                // 如果命中第二层缓存，直接返回                return bundle;            }        }        try {            // 走到这里，说明没有命中缓存，就根据 basename 和 locale 创建对象            ResourceBundle bundle = doGetBundle(basename, locale);            if (localeMap == null) {                // 如果 localeMap 为空，说明第一级就不存在，通过 Map 的 computeIfAbsent 方法初始化                localeMap = this.cachedResourceBundles.computeIfAbsent(basename, bn -&gt; new ConcurrentHashMap&lt;&gt;());            }            // 将新建的 ResourceBundle 对象放入 localeMap 中            localeMap.put(locale, bundle);            return bundle;        }        catch (MissingResourceException ex) {            if (logger.isWarnEnabled()) {                logger.warn(&quot;ResourceBundle [&quot; + basename + &quot;] not found for MessageSource: &quot; + ex.getMessage());            }            // Assume bundle not found            // -&gt; do NOT throw the exception to allow for checking parent message source.            return null;        }    }}</code></pre><p>还有一种使用 Map 实现内存缓存的写法，比如我们就对上面的这个方法进行改写：</p><pre><code class="java">public class ResourceBundleMessageSourceExt extends ResourceBundleMessageSource {    private final Map&lt;BasenameLocale, ResourceBundle&gt; cachedResourceBundles = new ConcurrentHashMap&lt;&gt;();    @Override    protected ResourceBundle getResourceBundle(String basename, Locale locale) {        if (getCacheMillis() &gt;= 0) {            // Fresh ResourceBundle.getBundle call in order to let ResourceBundle            // do its native caching, at the expense of more extensive lookup steps.            return doGetBundle(basename, locale);        } else {            // Cache forever: prefer locale cache over repeated getBundle calls.            final BasenameLocale basenameLocale = new BasenameLocale(basename, locale);            ResourceBundle resourceBundle = this.cachedResourceBundles.get(basenameLocale);            if (resourceBundle != null) {                return resourceBundle;            }            try {                ResourceBundle bundle = doGetBundle(basename, locale);                this.cachedResourceBundles.put(basenameLocale, bundle);                return bundle;            } catch (MissingResourceException ex) {                if (logger.isWarnEnabled()) {                    logger.warn(&quot;ResourceBundle [&quot; + basename + &quot;] not found for MessageSource: &quot; + ex.getMessage());                }                // Assume bundle not found                // -&gt; do NOT throw the exception to allow for checking parent message source.                return null;            }        }    }    public record BasenameLocale(String basename, Locale locale) {        @Override        public boolean equals(Object o) {            if (this == o) {                return true;            }            if (o == null || getClass() != o.getClass()) {                return false;            }            BasenameLocale that = (BasenameLocale) o;            return basename.equals(that.basename) &amp;&amp; locale.equals(that.locale);        }        @Override        public int hashCode() {            return Objects.hash(basename, locale);        }    }}</code></pre><p>我们可以利用 Map 是通过<code>equals</code>判断 key 是否一致的原理，创建一个包含 basename、locale 的对象<code>BasenameLocale</code>，然后改写<code>cachedResourceBundles</code>为一层 Map，会简化一些判断逻辑。</p><blockquote><p>此处的<code>BasenameLocale</code>是<code>record</code>类型，具体语法可以参考 <a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a> 中的 Record 类型一节。</p></blockquote><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文先介绍了 MessageSource 的配置项，然后通过流程图的方式介绍了<code>ResourceBundleMessageSource</code>和<code>ReloadableResourceBundleMessageSource</code>的执行逻辑，最后分享了两个使用 Map 实现内存缓存的方式。</p><p>下一节我们将扩展 MessageSource，实现从 Nacos 加载配置内容，同时实现动态修改配置内容的功能。</p><p>本文中的实例已经传到 GitHub，关注公众号「看山的小屋」，回复<code>spring</code>获取源码。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/zUrx7duy0-OY1oYn8FeKOw" target="_blank" rel="noopener">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://mp.weixin.qq.com/s/H599Wri3VbjTuLBnf7pD3w" target="_blank" rel="noopener">SpringBoot 实战：如何优雅的处理异常</a></li><li><a href="https://mp.weixin.qq.com/s/fcVE-cE7tDuWKoNNX9rsoQ" target="_blank" rel="noopener">SpringBoot 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://mp.weixin.qq.com/s/xQQbl6VNF2eCgmQPrMyc4w" target="_blank" rel="noopener">SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li><li><a href="https://mp.weixin.qq.com/s/coKjuefWMmCA4bSkRDIRVA" target="_blank" rel="noopener">SpringBoot 实战：优雅的使用枚举参数</a></li><li><a href="https://mp.weixin.qq.com/s/pet_rA7-O1JD3QfQ1fqxAQ" target="_blank" rel="noopener">SpringBoot 实战：优雅的使用枚举参数（原理篇）</a></li><li><a href="https://mp.weixin.qq.com/s/2OXArNObVejXLvMOmE3oqw" target="_blank" rel="noopener">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</a></li><li><a href="https://mp.weixin.qq.com/s/hdioIIwPA2lv2khfRmKhOQ" target="_blank" rel="noopener">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</a></li><li><a href="https://mp.weixin.qq.com/s/vbccn0kTdyOlmznDr3RItw" target="_blank" rel="noopener">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a></li><li><a href="https://mp.weixin.qq.com/s/s8PQXLT8Ni3dLqsOgf3syA" target="_blank" rel="noopener">SpringBoot 实战：加载和读取资源文件内容</a></li><li><a href="https://mp.weixin.qq.com/s/dGPhS5vdbnFdiTxkpr2mLg" target="_blank" rel="noopener">SpringBoot 实战：国际化组件 MessageSource</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/springboot-action-messagesource-principle/">SpringBoot 实战：国际化组件 MessageSource 的执行逻辑与源码</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">SpringBoot 实战：国际化组件 MessageSource 的执行逻辑与源码</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      掌握 MessageSource 的原理，我们才能更好的扩展。
    
    </summary>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/categories/spring/"/>
    
    
      <category term="SpringBoot 实战" scheme="https://www.howardliu.cn/tags/SpringBoot-%E5%AE%9E%E6%88%98/"/>
    
      <category term="SpringBoot" scheme="https://www.howardliu.cn/tags/SpringBoot/"/>
    
      <category term="spring" scheme="https://www.howardliu.cn/tags/spring/"/>
    
      <category term="SpringBoot 手册" scheme="https://www.howardliu.cn/tags/SpringBoot-%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实战：国际化组件 MessageSource</title>
    <link href="https://www.howardliu.cn/springboot-action-messagesource/"/>
    <id>https://www.howardliu.cn/springboot-action-messagesource/</id>
    <published>2022-07-30T03:26:55.000Z</published>
    <updated>2022-07-30T03:26:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/taiwan-3511017.jpeg" alt="SpringBoot 实战：国际化组件 MessageSource"></p><p>你好，我是看山。</p><p>咱们今天一起来聊聊 SpringBoot 中的国际化组件 MessageSource。</p><a id="more"></a><h2 id="初识-MessageSource"><a href="#初识-MessageSource" class="headerlink" title="初识 MessageSource"></a>初识 MessageSource</h2><p>先看一下类图：</p><p><img src="https://static.howardliu.cn/spring/MessageSource.png" alt="MessageSource 类图"></p><p>从类图可以看到，Spring 内置的<code>MessageSource</code>有三个实现类：</p><ul><li>ResourceBundleMessageSource：通过 JDK 提供的 ResourceBundle 加载资源文件；</li><li>ReloadableResourceBundleMessageSource：通过 PropertiesPersister 加载资源，支持 xml、properties 两个格式，优先加载 properties 格式的文件。如果同时存在 properties 和 xml 的文件，会只加载 properties 的内容；</li><li>StaticMessageSource：是手动注入国际化内容，相当于手写代码。因为比较简单，而且实际用处不大，所以暂时不做讨论。</li></ul><p>在 SpringBoot 中，默认创建 ResourceBundleMessageSource 实例实现国际化输出。标准的配置通过<code>MessageSourceProperties</code>类注入：</p><ul><li>basename：加载资源的文件名，可以多个资源名称，通过逗号隔开，默认是“messages”；</li><li>encoding：加载文件的字符集，默认是 UTF-8，这个不多说；</li><li>cacheDuration：文件加载到内存后缓存时间，默认单位是秒。如果没有设置，只会加载一次缓存，不会自动更新。这个参数在 ResourceBundleMessageSource、ReloadableResourceBundleMessageSource 稍微有些差异，会具体说下。</li><li>fallbackToSystemLocale：这是一个兜底开关。默认情况下，如果在指定语言中找不到对应的值，会从 basename 参数（默认是 messages.properties）中查找，如果再找不到可能直接返回或抛错。该参数设置为 true 的话，还会再走一步兜底逻辑，从当前系统语言对应配置文件中查找。该参数默认是 true；</li><li>alwaysUseMessageFormat：MessageSource 组件通过<code>MessageFormat.format</code>函数对国际化信息格式化，如果注入参数，输出结果是经过格式化的。比如<code>MessageFormat.format(&quot;Hello, {0}!&quot;, &quot;Kanshan&quot;)</code>输出结果是“Hello, Kanshan!”。该参数控制的是，当输入参数为空时，是否还是使用<code>MessageFormat.format</code>函数对结果进行格式化，默认是 false；</li><li>useCodeAsDefaultMessage：当没有找到对应信息的时候，是否返回 code。也就是当找了所有能找的配置文件后，还是没有找到对应的信息，是否直接返回 code 值。默认是 false，即不返回 code，抛出<code>NoSuchMessageException</code>异常。</li></ul><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>从上面我们知道了一些简单的配置，但是还是没有办法知道 MessageSource 到底是什么，本节我们举个例子小试牛刀。</p><p>首先从<a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a>创建一个最少依赖<code>spring-boot-starter-web</code>的 SpringBoot 项目。</p><p>然后在 resources 目录下定义一组国际化配置文件，我们这里使用默认配置，所以 basename 是 messages：</p><pre><code class="properties">## messages.propertiesmessage.code1=[DEFAULT]code onemessage.code2=[DEFAULT]code twomessage.code3=[DEFAULT]code threemessage.code4=[DEFAULT]code fourmessage.code5=[DEFAULT]code fivemessage.code6=[DEFAULT]code six## messages_en.propertiesmessage.code2=[en]code two## messages_en_US.propertiesmessage.code3=[en_US]code three## messages_zh.propertiesmessage.code4=[中文] 丁字号## messages_zh_CN.propertiesmessage.code5=[大陆区域中文] 戊字号## messages_zh_Hans.propertiesmessage.code6=[简体中文] 己字号</code></pre><p>一个定义了六个配置文件：</p><ul><li>messages.properties：默认配置文件</li><li>messages_en.properties：英文配置文件</li><li>messages_en_US.properties：英文美国配置文件</li><li>messages_zh.properties：中文配置文件</li><li>messages_zh_CN.properties：中文中国大陆区域配置文件</li><li>messages_zh_Hans.properties：简体中文配置文件</li></ul><p>从上面配置文件的命名可以看出，都是以 basename 开头，后面跟上语系和地区，三个参数以下划线分隔。</p><p>可以支持的语言和国家可以从<code>java.util.Locale</code>查找。</p><p>最后我们定义一个 Controller 实验：</p><pre><code class="java">@RestControllerpublic class HelloController {    @Autowired    private MessageSource messageSource;    @GetMapping(&quot;m1&quot;)    public List&lt;String&gt; m1(Locale locale) {        final List&lt;String&gt; multi = new ArrayList&lt;&gt;();        multi.add(messageSource.getMessage(&quot;message.code1&quot;, null, locale));        multi.add(messageSource.getMessage(&quot;message.code2&quot;, null, locale));        multi.add(messageSource.getMessage(&quot;message.code3&quot;, null, locale));        multi.add(messageSource.getMessage(&quot;message.code4&quot;, null, locale));        multi.add(messageSource.getMessage(&quot;message.code5&quot;, null, locale));        multi.add(messageSource.getMessage(&quot;message.code6&quot;, null, locale));        return multi;    }}</code></pre><p>我们通过不同的请求查看结果：</p><pre><code class="http">### 默认GET http://localhost:8080/m1### 结果是：[  &quot;[DEFAULT]code one&quot;,  &quot;[DEFAULT]code two&quot;,  &quot;[DEFAULT]code three&quot;,  &quot;[中文] 丁字号&quot;,  &quot;[大陆区域中文] 戊字号&quot;,  &quot;[简体中文] 己字号&quot;]### local: enGET http://localhost:8080/m1Accept-Language: en### 结果是：[  &quot;[DEFAULT]code one&quot;,  &quot;[en]code two&quot;,  &quot;[DEFAULT]code three&quot;,  &quot;[DEFAULT]code four&quot;,  &quot;[DEFAULT]code five&quot;,  &quot;[DEFAULT]code six&quot;]### local: en-USGET http://localhost:8080/m1Accept-Language: en-US### 结果是：[  &quot;[DEFAULT]code one&quot;,  &quot;[en]code two&quot;,  &quot;[en_US]code three&quot;,  &quot;[DEFAULT]code four&quot;,  &quot;[DEFAULT]code five&quot;,  &quot;[DEFAULT]code six&quot;]### local: zhGET http://localhost:8080/m1Accept-Language: zh### 结果是：[  &quot;[DEFAULT]code one&quot;,  &quot;[DEFAULT]code two&quot;,  &quot;[DEFAULT]code three&quot;,  &quot;[中文] 丁字号&quot;,  &quot;[DEFAULT]code five&quot;,  &quot;[DEFAULT]code six&quot;]### local: zh-CNGET http://localhost:8080/m1Accept-Language: zh-CN### 结果是：[  &quot;[DEFAULT]code one&quot;,  &quot;[DEFAULT]code two&quot;,  &quot;[DEFAULT]code three&quot;,  &quot;[中文] 丁字号&quot;,  &quot;[大陆区域中文] 戊字号&quot;,  &quot;[DEFAULT]code six&quot;]</code></pre><p>从上面的结果可以看出：</p><ol><li>默认情况下，HTTP 请求没有传语言，所以使用了系统语言组装，相当于传参是<code>zh-Hans</code>，所以结果是简体中文优先；</li><li>HTTP 请求定义的语言越精确，匹配的内容越精确；</li><li>默认情况下，指定语言配置文件找不到，会一次向上查找，地区 &gt; 国家 &gt; 语言 &gt; 默认。</li></ol><h2 id="带参数的国际化信息"><a href="#带参数的国际化信息" class="headerlink" title="带参数的国际化信息"></a>带参数的国际化信息</h2><p>我们在 message.properties 中添加一行配置：</p><pre><code class="properties">message.multiVars=var1={0}, var2={1}</code></pre><p>在刚才的 Controller 中增加一个请求：</p><pre><code class="java">@GetMapping(&quot;m2&quot;)public List&lt;String&gt; m2(Locale locale) {    final List&lt;String&gt; multi = new ArrayList&lt;&gt;();    multi.add(&quot;参数为 null: &quot; + messageSource.getMessage(&quot;message.multiVars&quot;, null, locale));    multi.add(&quot;参数为空：&quot; + messageSource.getMessage(&quot;message.multiVars&quot;, new Object[]{}, locale));    multi.add(&quot;只传一个参数：&quot; + messageSource.getMessage(&quot;message.multiVars&quot;, new Object[]{&quot;第一个参数&quot;}, locale));    multi.add(&quot;传两个参数：&quot; + messageSource.getMessage(&quot;message.multiVars&quot;, new Object[]{&quot;第一个参数&quot;, &quot;第二个参数&quot;}, locale));    multi.add(&quot;传超过两个参数：&quot; + messageSource.getMessage(&quot;message.multiVars&quot;, new Object[]{&quot;第一个参数&quot;, &quot;第二个参数&quot;, &quot;第三个参数&quot;}, locale));    return multi;}</code></pre><p>我们看看结果：</p><pre><code class="http">###GET http://localhost:8080/m2### 结果是：[  &quot;参数为 null: var1={0}, var2={1}&quot;,  &quot;参数为空：var1={0}, var2={1}&quot;,  &quot;只传一个参数：var1=第一个参数，var2={1}&quot;,  &quot;传两个参数：var1=第一个参数，var2=第二个参数&quot;,  &quot;传超过两个参数：var1=第一个参数，var2=第二个参数&quot;]</code></pre><p>我们可以看到，我们在配置文件中定义了带参数的配置信息，此时，我们可以不传参数、传少于指定数量的参数、传符合指定数量的参数、传超过指定数量的参数，都可以正常返回国际化信息。</p><p>此处可以理解为，<code>MessageFormat.format</code>执行过程是<code>for-index</code>循环，从配置值中找格式为<code>{数字}</code>的占位符，然后用对应下标的输入参数替换，如果属于参数没了，就保持原样。</p><h2 id="找不到配置内容"><a href="#找不到配置内容" class="headerlink" title="找不到配置内容"></a>找不到配置内容</h2><p>如果我们的配置文件中没有配置或者对应语言及其父级都没有配置呢？</p><p>这个就要靠前面说的<code>useCodeAsDefaultMessage</code>配置了，如果为 true，就会返回输入的 code，如果为 false，就会抛出异常。默认是 false，所以如果找不到会抛异常。比如：</p><pre><code class="java">@GetMapping(&quot;m3&quot;)public List&lt;String&gt; m3(Locale locale) {    final List&lt;String&gt; multi = new ArrayList&lt;&gt;();    multi.add(&quot;不存在的 code: &quot; + messageSource.getMessage(&quot;message.notExist&quot;, null, locale));    return multi;}</code></pre><p>这个时候我们执行 http 请求：</p><pre><code class="http">###GET http://localhost:8080/m3### 结果是：{  &quot;timestamp&quot;: &quot;2022-06-19T09:14:14.977+00:00&quot;,  &quot;status&quot;: 500,  &quot;error&quot;: &quot;Internal Server Error&quot;,  &quot;path&quot;: &quot;/m3&quot;}</code></pre><p>这是报错了，异常栈是：</p><pre><code class="log">org.springframework.context.NoSuchMessageException: No message found under code &#39;message.notExist&#39; for locale &#39;zh_CN_#Hans&#39;.    at org.springframework.context.support.AbstractMessageSource.getMessage(AbstractMessageSource.java:161) ~[spring-context-5.3.20.jar:5.3.20]    at cn.howardliu.effective.spring.springbootmessages.controller.HelloController.m3(HelloController.java:47) ~[classes/:na]    ……此处省略</code></pre><h2 id="自定义-MessageSource"><a href="#自定义-MessageSource" class="headerlink" title="自定义 MessageSource"></a>自定义 MessageSource</h2><p>本文开头说过，MessageSource 有三种实现，Spring 默认使用了 ResourceBundleMessageSource，我们可以自定义使用 ReloadableResourceBundleMessageSource。</p><p>既然是在 SpringBoot 中，我们可以依靠 SpringBoot 的特性定义：</p><pre><code class="java">@Configuration(proxyBeanMethods = false)@ConditionalOnMissingBean(name = AbstractApplicationContext.MESSAGE_SOURCE_BEAN_NAME, search = SearchStrategy.CURRENT)@ConditionalOnProperty(name = &quot;spring.messages-type&quot;, havingValue = &quot;ReloadableResourceBundleMessageSource&quot;)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Conditional(ReloadResourceBundleCondition.class)@EnableConfigurationPropertiespublic class ReloadMessageSourceAutoConfiguration {    private static final Resource[] NO_RESOURCES = {};    @Bean    @ConfigurationProperties(prefix = &quot;spring.messages&quot;)    public MessageSourceProperties messageSourceProperties() {        return new MessageSourceProperties();    }    @Bean    public MessageSource messageSource(MessageSourceProperties properties) {        ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource();        if (StringUtils.hasText(properties.getBasename())) {            final String[] originBaseNames = StringUtils                    .commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(properties.getBasename()));            final String[] baseNames = new String[originBaseNames.length];            for (int i = 0; i &lt; originBaseNames.length; i++) {                if (originBaseNames[i].startsWith(&quot;classpath:&quot;)) {                    baseNames[i] = originBaseNames[i];                } else {                    baseNames[i] = &quot;classpath:&quot; + originBaseNames[i];                }            }            messageSource.setBasenames(baseNames);        }        if (properties.getEncoding() != null) {            messageSource.setDefaultEncoding(properties.getEncoding().name());        }        messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale());        Duration cacheDuration = properties.getCacheDuration();        if (cacheDuration != null) {            messageSource.setCacheMillis(cacheDuration.toMillis());        }        messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat());        messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage());        return messageSource;    }    protected static class ReloadResourceBundleCondition extends SpringBootCondition {        private static final ConcurrentReferenceHashMap&lt;String, ConditionOutcome&gt; CACHE =                new ConcurrentReferenceHashMap&lt;&gt;();        @Override        public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {            String basename = context.getEnvironment().getProperty(&quot;spring.messages.basename&quot;, &quot;messages&quot;);            ConditionOutcome outcome = CACHE.get(basename);            if (outcome == null) {                outcome = getMatchOutcomeForBasename(context, basename);                CACHE.put(basename, outcome);            }            return outcome;        }        private ConditionOutcome getMatchOutcomeForBasename(ConditionContext context, String basename) {            ConditionMessage.Builder message = ConditionMessage.forCondition(&quot;ResourceBundle&quot;);            for (String name : StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(basename))) {                for (Resource resource : getResources(context.getClassLoader(), name)) {                    if (resource.exists()) {                        return ConditionOutcome.match(message.found(&quot;bundle&quot;).items(resource));                    }                }            }            return ConditionOutcome.noMatch(message.didNotFind(&quot;bundle with basename &quot; + basename).atAll());        }        private Resource[] getResources(ClassLoader classLoader, String name) {            String target = name.replace(&#39;.&#39;, &#39;/&#39;);            try {                return new PathMatchingResourcePatternResolver(classLoader)                        .getResources(&quot;classpath*:&quot; + target + &quot;.properties&quot;);            } catch (Exception ex) {                return NO_RESOURCES;            }        }    }}</code></pre><p>我们可以看到，我们在执行<code>messageSource.setBasenames(baseNames);</code>的时候，<code>baseNames</code>中的值都是设置成<code>classpath:</code>开头的，这是为了使<code>ReloadableResourceBundleMessageSource</code>能够读取 CLASSPATH 下的配置文件。当然也可以使用绝对路径或者相对路径实现，这个是比较灵活的。</p><p>我们可以通过修改配置文件内容，查看变化，这里就不再赘述。纸上得来终觉浅，绝知此事要躬行。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文通过几个小例子介绍了<code>MessageSource</code>的使用。这里做一下预告，下一章我们会从源码角度分析<code>MessageSourc</code>e 的实现类<code>ResourceBundleMessageSource</code>和<code>ReloadableResourceBundleMessageSource</code>的执行逻辑；然后我们自定义扩展，从 Nacos 中读取配置内容，实现更加灵活的配置。</p><p>本文中的实例已经传到 GitHub，关注公众号「看山的小屋」，回复<code>spring</code>获取源码。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/zUrx7duy0-OY1oYn8FeKOw" target="_blank" rel="noopener">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://mp.weixin.qq.com/s/H599Wri3VbjTuLBnf7pD3w" target="_blank" rel="noopener">SpringBoot 实战：如何优雅的处理异常</a></li><li><a href="https://mp.weixin.qq.com/s/fcVE-cE7tDuWKoNNX9rsoQ" target="_blank" rel="noopener">SpringBoot 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://mp.weixin.qq.com/s/xQQbl6VNF2eCgmQPrMyc4w" target="_blank" rel="noopener">SpringBoot 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li><li><a href="https://mp.weixin.qq.com/s/coKjuefWMmCA4bSkRDIRVA" target="_blank" rel="noopener">SpringBoot 实战：优雅的使用枚举参数</a></li><li><a href="https://mp.weixin.qq.com/s/pet_rA7-O1JD3QfQ1fqxAQ" target="_blank" rel="noopener">SpringBoot 实战：优雅的使用枚举参数（原理篇）</a></li><li><a href="https://mp.weixin.qq.com/s/2OXArNObVejXLvMOmE3oqw" target="_blank" rel="noopener">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数</a></li><li><a href="https://mp.weixin.qq.com/s/hdioIIwPA2lv2khfRmKhOQ" target="_blank" rel="noopener">SpringBoot 实战：在 RequestBody 中优雅的使用枚举参数（原理篇）</a></li><li><a href="https://mp.weixin.qq.com/s/vbccn0kTdyOlmznDr3RItw" target="_blank" rel="noopener">SpringBoot 实战：JUnit5+MockMvc+Mockito 做好单元测试</a></li><li><a href="https://mp.weixin.qq.com/s/s8PQXLT8Ni3dLqsOgf3syA" target="_blank" rel="noopener">SpringBoot 实战：加载和读取资源文件内容</a></li><li><a href="https://mp.weixin.qq.com/s/dGPhS5vdbnFdiTxkpr2mLg" target="_blank" rel="noopener">SpringBoot 实战：国际化组件 MessageSource</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/springboot-action-messagesource/">SpringBoot 实战：国际化组件 MessageSource</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/126069965" target="_blank" rel="noopener">SpringBoot 实战：国际化组件 MessageSource</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      咱们今天一起来聊聊 SpringBoot 中的国际化组件 MessageSource。
    
    </summary>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/categories/spring/"/>
    
    
      <category term="SpringBoot 实战" scheme="https://www.howardliu.cn/tags/SpringBoot-%E5%AE%9E%E6%88%98/"/>
    
      <category term="SpringBoot" scheme="https://www.howardliu.cn/tags/SpringBoot/"/>
    
      <category term="spring" scheme="https://www.howardliu.cn/tags/spring/"/>
    
      <category term="SpringBoot 手册" scheme="https://www.howardliu.cn/tags/SpringBoot-%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>小心 transmittable-thread-local 的这个坑</title>
    <link href="https://www.howardliu.cn/transmittable-thread-local-make-trouble/"/>
    <id>https://www.howardliu.cn/transmittable-thread-local-make-trouble/</id>
    <published>2022-07-30T02:55:46.000Z</published>
    <updated>2022-07-30T02:55:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/dog-7330712_1920.jpeg" alt="小心 transmittable-thread-local 的这个坑"></p><p>你好，我是看山。</p><p>transmittable-thread-local 是阿里开源一个线程池复用场景下，处理异步执行时上下文传递数据问题的解决方案。可以从官方文档<a href="https://github.com/alibaba/transmittable-thread-local" target="_blank" rel="noopener">https://github.com/alibaba/transmittable-thread-local</a>获取更多信息。</p><a id="more"></a><p>本文主要是变更 transmittable-thread-local 使用方式时出现的一个异常。</p><h2 id="异常现场"><a href="#异常现场" class="headerlink" title="异常现场"></a>异常现场</h2><p>看异常之前，先简单说下项目大概情况。</p><p>项目是 Java 栈，使用了 SpringBoot+MyBatis 的框架结构，构建工具是 Maven。因为项目中使用了比较多的多线程逻辑，所以引入了 transmittable-thread-local，解决上下文传递数据问题。后来做项目升级，接入公司的监控系统，启动时增加了启动参数<code>-javaagent:/path/to/transmittable-thread-local-2.12.1.jar</code>，通过零侵入的方式解决多线程上下文传值问题。</p><p>于是，有些逻辑出错了。</p><p>我们看看异常栈（日志做了删改，隐藏项目信息）：</p><pre><code class="log">org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#39;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&#39; available: expected single matching bean but found 3: executor1,executor2,executor3    at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1200)    at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveBean(DefaultListableBeanFactory.java:420)    at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:349)    at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:342)    at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1127)    ……    at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)    at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771)    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)    at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)    at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88)    ……</code></pre><p>异常日志很清楚，就是通过<code>AbstractApplicationContext.getBean</code>获取 Bean 的时候，因为存在多个同类型的<code>ThreadPoolTaskExecutor</code>，Spring 容器不知道返回哪个 Bean，就抛出了<code>NoUniqueBeanDefinitionException</code>异常。</p><h2 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h2><p>我们再来看看调用代码：</p><pre><code class="java">public static void doSth(Object subtag, Object extra, long time) {    ApplicationContextContainer.getBean(ThreadPoolTaskExecutor.class)            .execute(() -&gt; {                // 一些业务代码            });}@Componentpublic class ApplicationContextContainer implements ApplicationContextAware {    private static ApplicationContext applicationContext;    public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) {        return applicationContext.getBean(clazz);    }    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {        ApplicationContextContainer.applicationContext = applicationContext;    }}</code></pre><p>可以看出来，<code>applicationContext.getBean</code>时只传入了 class 类型，没有指明 Bean 的名字。推测是项目中定义了多个<code>ThreadPoolTaskExecutor</code>类型的 Bean，名字分别是 executor1、executor2、executor3（名字改过了，大家写代码时尽量使用见名知意的起名方式）。</p><pre><code class="java">@Configurationpublic class ExecutorConfig {    @Bean(value = &quot;executor1&quot;)    public Executor executor1() {        ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();        // 一些初始化方法        taskExecutor.initialize();        return taskExecutor;    }    @Bean(value = &quot;executor2&quot;)    public Executor executor2() {        ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();        // 一些初始化方法        taskExecutor.initialize();        return TtlExecutors.getTtlExecutor(taskExecutor);    }    @Bean(value = &quot;executor3&quot;)    public Executor executor3() {        ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();        // 一些初始化方法        taskExecutor.initialize();        return TtlExecutors.getTtlExecutor(taskExecutor);    }}</code></pre><p>从上面的代码可以发现，确实有 executor1、executor2、executor3 三个<code>Executor</code>，executor1 是<code>ThreadPoolTaskExecutor</code>类型的，executor2 和 executor3 是经过<code>TtlExecutors.getTtlExecutor</code>包装的<code>ThreadPoolTaskExecutor</code>。</p><p>我们来看看<code>TtlExecutors.getTtlExecutor</code>方法：</p><pre><code class="java">public static Executor getTtlExecutor(@Nullable Executor executor) {    if (TtlAgent.isTtlAgentLoaded() || null == executor || executor instanceof TtlEnhanced) {        return executor;    }    return new ExecutorTtlWrapper(executor, true);}</code></pre><p>根据错误反推，经过<code>TtlExecutors.getTtlExecutor</code>之后返回的还是<code>ThreadPoolTaskExecutor</code>类型。也就是上面代码走了<code>if</code>语句，直接返回了输入参数。</p><p>但是，这里就碰到了两个开发十大未解之谜中的两个：</p><ol><li>代码没改，之前好好地，怎么就报错了；</li><li>本地好使，为什么放在服务器上就报错了。</li></ol><h2 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h2><p>首先，我们需要知道，代码的终点不是玄学。我们现在用的计算机还不会撒谎，只要报错了，就一定是有问题。</p><p>我们仔细看看<code>TtlExecutors.getTtlExecutor</code>方法中的<code>if</code>判断：</p><ul><li>TtlAgent.isTtlAgentLoaded()：这个是判断 ttlAgentLoaded 标识，这个后文再说；</li><li>null == executor：输入参数为 null，显然不符合；</li><li>executor instanceof TtlEnhanced：输入参数是<code>TtlEnhanced</code>类型，输入的是<code>ThreadPoolTaskExecutor</code>类型，不符合。</li></ul><p>所以，重点看看 ttlAgentLoaded 标识：</p><pre><code class="java">public static boolean isTtlAgentLoaded() {    return ttlAgentLoaded;}</code></pre><p>从全局找到修改<code>ttlAgentLoaded</code>的地方是：</p><pre><code class="java">public final class TtlAgent {    public static void premain(final String agentArgs, @NonNull final Instrumentation inst) {        kvs = splitCommaColonStringToKV(agentArgs);        Logger.setLoggerImplType(getLogImplTypeFromAgentArgs(kvs));        final Logger logger = Logger.getLogger(TtlAgent.class);        try {            logger.info(&quot;[TtlAgent.premain] begin, agentArgs: &quot; + agentArgs + &quot;, Instrumentation: &quot; + inst);            final boolean disableInheritableForThreadPool = isDisableInheritableForThreadPool();            // 省略非相关代码            ttlAgentLoaded = true;        } catch (Exception e) {            String msg = &quot;Fail to load TtlAgent , cause: &quot; + e.toString();            logger.log(Level.SEVERE, msg, e);            throw new IllegalStateException(msg, e);        }    }    // 省略非相关代码}</code></pre><p>有一定 javaagent 知识的应该知道，<code>premain</code>方法是 java 启动时，加载 javaagent 后执行的方法。</p><p>这就吻合了。</p><p>报错之前的服务器代码，<code>ExecutorConfig</code>类中定义的 executor1 是<code>ThreadPoolTaskExecutor</code>类型，executor2 和 executor3 是<code>ExecutorTtlWrapper</code>类型，使用<code>applicationContext.getBean(clazz)</code>能够得到名字是 executor1 的 Bean。</p><p>然后使用<code>-javaagent:/path/to/transmittable-thread-local-2.12.1.jar</code>方式实现零侵入的<code>transmittable-thread-local</code>注入能力。<code>ExecutorConfig</code>类中定义的 executor2 和 executor3 是<code>ThreadPoolTaskExecutor</code>类型，使用<code>applicationContext.getBean(clazz)</code>就会查到三个<code>ThreadPoolTaskExecutor</code>类型的 Bean，Spring 容器没有办法判断返回哪一个，于是抛出了<code>NoUniqueBeanDefinitionException</code>异常。</p><p>本地启动是加上<code>-javaagent:/path/to/transmittable-thread-local-2.12.1.jar</code>命令，问题复现。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>解决上面的报错比较简单，就是使用<code>applicationContext.getBean(beanName, clazz)</code>方法，通过输入指定的 Bean 的名字和类型，获取确定 Bean，代码修改为：</p><pre><code class="java">public static void doSth(Object subtag, Object extra, long time) {    ApplicationContextContainer.getBean(&quot;executor1&quot;, ThreadPoolTaskExecutor.class)            .execute(() -&gt; {                // 一些业务代码            });}</code></pre><p>流水线发版回归测试，问题解决。</p><p>青山不改，绿水长流，我们下次见。</p><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/transmittable-thread-local-make-trouble/">小心 transmittable-thread-local 的这个坑</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/126069634" target="_blank" rel="noopener">小心 transmittable-thread-local 的这个坑</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文主要是变更 transmittable-thread-local 使用方式时出现的一个异常。
    
    </summary>
    
    
      <category term="debug" scheme="https://www.howardliu.cn/categories/debug/"/>
    
    
      <category term="debug" scheme="https://www.howardliu.cn/tags/debug/"/>
    
      <category term="transmittable" scheme="https://www.howardliu.cn/tags/transmittable/"/>
    
      <category term="ttl" scheme="https://www.howardliu.cn/tags/ttl/"/>
    
  </entry>
  
  <entry>
    <title>Switch 块、Switch 表达式、Switch 模式匹配，越来越好用的 Switch</title>
    <link href="https://www.howardliu.cn/java-switch/"/>
    <id>https://www.howardliu.cn/java-switch/</id>
    <published>2022-06-19T04:00:56.000Z</published>
    <updated>2022-06-19T04:00:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/beach-7262493_1920.jpeg" alt="Switch 块、Switch 表达式、Switch 模式匹配，越来越好用的 Switch"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>与 if-else 一样，switch 语法是用来做条件判断的。当条件清晰简洁时，能够有效地提升代码可读性。switch 语法从 Java5 开始，Java12 增加了 Switch 表达式（Java14 提供正式版），Java17 增加 Switch 模式匹配（预览版）。</p><p>本文的目标是期望读者可以掌握 Switch 语法的所有能力，在需要的时候信手拈来。</p><a id="more"></a><h2 id="if-else-与-switch-语法"><a href="#if-else-与-switch-语法" class="headerlink" title="if-else 与 switch 语法"></a>if-else 与 switch 语法</h2><p>我们先来个简单的例子看看 if-else 和 switch 语法的使用：</p><pre><code class="java">public static void demoOfIf(int num) {    if (num == 0) {        System.out.println(&quot;0&quot;);    } else if (num == 1) {        System.out.println(&quot;1&quot;);    } else if (num == 2) {        System.out.println(&quot;2&quot;);    } else {        System.out.println(&quot;3&quot;);    }}public static void demoOfSwitch(int num) {    switch (num) {        case 0: {            System.out.println(&quot;0&quot;);            break;        }        case 1: {            System.out.println(&quot;1&quot;);            break;        }        case 2: {            System.out.println(&quot;2&quot;);            break;        }        default: {            System.out.println(&quot;3&quot;);        }    }}</code></pre><p>上面的示例很简单，下面我们就来着重学习一下 Swith 语法。</p><h2 id="Switch-块通用语法"><a href="#Switch-块通用语法" class="headerlink" title="Switch 块通用语法"></a>Switch 块通用语法</h2><pre><code class="java">switch(integral-selector) {case value1: statement1; break;case value2: statement2; break;// ……default: default-statement;}</code></pre><p>switch 语句是一种多路选择的简洁表达式，在 Java7 之前，switch 语句的表达式必须是整数值，这样会有很多的限制。于是在 Java7 中增加了 String 格式的支持，使应用场景更加丰富。</p><p>每个 case 执行语句末尾都有一个<code>break</code>关键字，它会让执行流程跳到 switch 的末尾。如果不加<code>break</code>，后面的 case 语句会继续执行，直到第一个<code>break</code>关键字。</p><p>比如：</p><pre><code class="java">public static void noBreak(int num) {    switch (num) {        case 0: {            System.out.println(&quot;0&quot;);        }        case 1: {            System.out.println(&quot;1&quot;);        }        case 2: {            System.out.println(&quot;2&quot;);            break;        }        default: {            System.out.println(&quot;3&quot;);        }    }}</code></pre><p>执行<code>noBreak(0)</code>的结果会是：</p><pre><code class="log">012</code></pre><p>基于这种特性，我们可以合并多个值的执行逻辑，比如下面这种写法：</p><pre><code class="java">public static void noBreak2(int num) {    switch (num) {        case 0:        case 1:        case 2: {            System.out.println(&quot;0 or 1 or 2&quot;);            break;        }        default: {            System.out.println(&quot;3&quot;);        }    }}</code></pre><p>当参数是 0 或 1 或 2 时，结果相同，都是：</p><pre><code class="log">0 or 1 or 2</code></pre><h2 id="Switch-表达式"><a href="#Switch-表达式" class="headerlink" title="Switch 表达式"></a>Switch 表达式</h2><p>Switch 语句出现的姿势是条件判断、流程控制组件，与现在很流行的新语言对比，其写法显得非常笨拙，所以 Java 推出了 Switch 表达式语法，可以让我们写出更加简化的代码。这个扩展在 Java12 中作为预览版首次引入，需要在编译时增加<code>-enable-preview</code>开启，在 Java14 中正式提供，功能编号是 <a href="https://openjdk.java.net/jeps/361" target="_blank" rel="noopener">JEP 361</a>。</p><p>比如，我们通过 switch 语法简单计算工作日、休息日，在 Java12 之前需要这样写：</p><pre><code class="java">@Testvoid testSwitch() {    final DayOfWeek day = DayOfWeek.from(LocalDate.now());    String typeOfDay = &quot;&quot;;    switch (day) {        case MONDAY:        case TUESDAY:        case WEDNESDAY:        case THURSDAY:        case FRIDAY:            typeOfDay = &quot;Working Day&quot;;            break;        case SATURDAY:        case SUNDAY:            typeOfDay = &quot;Rest Day&quot;;            break;    }    Assertions.assertFalse(typeOfDay.isEmpty());}</code></pre><p>在 Java12 中的 Switch 表达式中，我们可以直接简化：</p><pre><code class="java">@Testvoid testSwitchExpression() {    final DayOfWeek day = DayOfWeek.SATURDAY;    final String typeOfDay = switch (day) {        case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; &quot;Working Day&quot;;        case SATURDAY, SUNDAY -&gt; &quot;Day Off&quot;;    };    Assertions.assertEquals(&quot;Day Off&quot;, typeOfDay);}</code></pre><p>是不是很清爽。不过，这里有一点不足的是，如果是需要执行一段业务逻辑，然后返回一个结果呢？于是 Java13 使用<code>yield</code>关键字补齐了这个功能：</p><pre><code class="java">@Testvoid testSwitchExpression13() {    final DayOfWeek day = DayOfWeek.SATURDAY;    final String typeOfDay = switch (day) {        case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; {            System.out.println(&quot;Working Day: &quot; + day);            yield &quot;Working Day&quot;;        }        case SATURDAY, SUNDAY -&gt; {            System.out.println(&quot;Day Off: &quot; + day);            yield &quot;Day Off&quot;;        }    };    Assertions.assertEquals(&quot;Day Off&quot;, typeOfDay);}</code></pre><h2 id="Switch-模式匹配"><a href="#Switch-模式匹配" class="headerlink" title="Switch 模式匹配"></a>Switch 模式匹配</h2><p>到 Java17 时，又提供了 Switch 模式匹配功能。与 instanceof 模式匹配有些类似，是能够在 Switch 表达式实现类型自动转换。</p><p>比如：</p><pre><code class="java">static String formatterPatternSwitch(Object o) {    return switch (o) {        case null -&gt; &quot;null&quot;;        case Integer i -&gt; String.format(&quot;int %d&quot;, i);        case Long l -&gt; String.format(&quot;long %d&quot;, l);        case Double d -&gt; String.format(&quot;double %f&quot;, d);        case String s -&gt; String.format(&quot;String %s&quot;, s);        default -&gt; o.getClass().getSimpleName() + &quot; &quot; + o;    };}public static void main(String[] args) {    System.out.println(formatterPatternSwitch(null));    System.out.println(formatterPatternSwitch(&quot;1&quot;));    System.out.println(formatterPatternSwitch(2));    System.out.println(formatterPatternSwitch(3L));    System.out.println(formatterPatternSwitch(4.0));    System.out.println(formatterPatternSwitch(new AtomicLong(5)));}</code></pre><p>结果是：</p><pre><code class="log">nullString 1int 2long 3double 4.000000AtomicLong 5</code></pre><p>可以看到，不只是类型自动转换，还可以直接判断是否是<code>null</code>，省了前置判断对象是否是<code>null</code>了。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/By2JoZqAHA6U36PG8qvCcg" target="_blank" rel="noopener">Java17 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-switch/">Switch 块、Switch 表达式、Switch 模式匹配，越来越好用的 Switch</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/126069533" target="_blank" rel="noopener">Switch 块、Switch 表达式、Switch 模式匹配，越来越好用的 Switch</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      与 if-else 一样，switch 语法是用来做条件判断的。当条件清晰简洁时，能够有效地提升代码可读性。switch 语法从 Java5 开始，Java12 增加了 Switch 表达式（Java14 提供正式版），Java17 增加 Switch 模式匹配（预览版）。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="switch" scheme="https://www.howardliu.cn/tags/switch/"/>
    
  </entry>
  
  <entry>
    <title>2022 年 Java 行业分析报告</title>
    <link href="https://www.howardliu.cn/java-developer-productivity-report-2022/"/>
    <id>https://www.howardliu.cn/java-developer-productivity-report-2022/</id>
    <published>2022-06-19T03:23:42.000Z</published>
    <updated>2022-06-19T03:23:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/sea-5382487_1920.jpeg" alt="2022 年 Java 行业分析报告"></p><p>你好，我是看山。</p><p>前段时间介绍了从 Java8 到 Java17 每个版本比较有特点的新特性（收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 专栏），今天看到 JRebel 发布了《2022 年 Java 发展趋势和分析》，于是借此分析一下 Java 行业的现状，希望给大家一些参考。</p><a id="more"></a><blockquote><p>JRebel 是通过调研问卷的方式总结的报告，涉及了不同国家、不同岗位、不同公司规模、不同行业，相对来说，该调查报告是有一定参考意义的。</p></blockquote><h2 id="Java-语言及开发趋势"><a href="#Java-语言及开发趋势" class="headerlink" title="Java 语言及开发趋势"></a>Java 语言及开发趋势</h2><h3 id="Java8-的占比还是比较高"><a href="#Java8-的占比还是比较高" class="headerlink" title="Java8 的占比还是比较高"></a>Java8 的占比还是比较高</h3><p>我们先来看下大家都在使用的 Java 版本（包括 JVM 语言：Kotlin、Groovy、Scala）：</p><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/6.png" alt="Java 各版本语言占比"></p><p>从结果我们可以看到，Java8 占比 37%，Java11 占比 29%，甚至有 12%的被调查者使用了高于 Java12 的版本。</p><p>Java8 是 2014 年发布，相较于之前版本，增加了 Lambda 表达式、Stream 流式处理等一种优秀的 API。至今已 8 年时间，Java 版本也是从 8 一直升到了 17。版本号一直在增加，却没有增加特别吸引人的语言特性。</p><p>哪些因素是大家升级的动力呢？</p><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/9.png" alt="升级的动力"></p><p>可以看到，主要的升级因素包括 LTS 版本（25%）、安全性（23%）、性能（20%），新特性（18%）和随大流（14%）占比低一些。</p><p>从这点我们也就知道为什么 Java11 之后的版本占比并不高了，随着 Java17 的发布，可能 Java8 和 Java11 的占比会降低。安全性方面，除非是严重的漏洞，一般 Java 开发团队会通过补丁的方式升级，不会影响大版本号占比。</p><p>性能方面，Java 团队一直在不断优化，随着 G1、ZGC、Shenandoah 等一众优秀的 GC 被添加进来，这也成为大家从 Java8 升级的重要原因。</p><p>就功能特性而言，Java11 之后增加了 Record 类型、密封类、instanceof 模式匹配、Swtich 表达式和模式匹配等一些语法糖。这些新特性，也能够提升升级到 Java17 的意愿。</p><h3 id="升级-Java17-的意愿还是比较强的"><a href="#升级-Java17-的意愿还是比较强的" class="headerlink" title="升级 Java17 的意愿还是比较强的"></a>升级 Java17 的意愿还是比较强的</h3><p>Java17 是 2021 年下半年发布的 LTS 版本（长期支持版）。</p><p>我们看下大家升级的意愿：</p><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/10.png" alt="升级 Java17 的意愿"></p><p>从结果可以看出来，有 37%的人会在未来 6 个月内升级，有 25%的人会在 6-12 个月内升级，不会升级的占比仅占 8%。</p><p>可见，有 62%的人会在未来一年内升级到 Java17，大家的升级意愿还是比较强的。</p><h3 id="OracleJDK-和-OpenJDK-占据过半市场"><a href="#OracleJDK-和-OpenJDK-占据过半市场" class="headerlink" title="OracleJDK 和 OpenJDK 占据过半市场"></a>OracleJDK 和 OpenJDK 占据过半市场</h3><p>我们都知道，市面上有很多的 JDK 版本，在 Oracle 起诉 Google 侵权之前，非企业特供的情况下，我们基本上用的都是 OracleJDK，后来因为容器中使用 JDK 版本的版权问题，容器中大部分使用了 OpenJDK。</p><p>从问卷结果也反映了这种情况：</p><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/13.png" alt="JRE/JDK 各种版本的市场份额"></p><p>OracleJDK 的版本占比 36%，OpenJDK 的版本占比 43%，其中包括标准 OpenJDK 和 AdoptOpenJDK 版本。</p><p>有些同学会疑惑 OracleJDK 和 OpenJDK 的区别在哪？我们日常用到的部分，没有任何区别。</p><h3 id="Java-应用架构趋势"><a href="#Java-应用架构趋势" class="headerlink" title="Java 应用架构趋势"></a>Java 应用架构趋势</h3><p>这个问题的结果有些出乎我的预料：</p><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/14.png" alt="Java 应用架构趋势"></p><p>各种架构风格中，微服务架构仅占 32%，单体架构占比 22%，模块化单体架构占比 13%，SOA 架构占比 12%。</p><p>从结果来看，这个问卷的对架构风格的定义和分类比较细腻。</p><p>很多公司把系统的服务化、模块化也统称为了微服务，这是一种很严重的错误，在之前的文章 <a href="https://mp.weixin.qq.com/s/b7my-EHc0fGOE3veeQyxBg" target="_blank" rel="noopener">《微服务架构的陷阱：从单体到分布式单体》</a> 中介绍过这种错误。</p><p>推荐阅读：</p><ul><li><a href="https://mp.weixin.qq.com/s/09ILTzijUr3knHBj13t_kQ" target="_blank" rel="noopener">《什么是微服务？》</a></li><li><a href="https://mp.weixin.qq.com/s/n1eKTlLP_BbyBkKG4OyLSw" target="_blank" rel="noopener">《微服务编程范式》</a></li><li><a href="https://mp.weixin.qq.com/s/NcftJ1jNAd-DHpzBXKk8RA" target="_blank" rel="noopener">《从单体架构到微服务架构》</a>。</li></ul><blockquote><p>这里不对架构风格做出评价，架构只有合适与否，没有优劣之分。</p></blockquote><h2 id="微服务架构趋势"><a href="#微服务架构趋势" class="headerlink" title="微服务架构趋势"></a>微服务架构趋势</h2><p>既然微服务架构占比高一些，我们就来看一下微服务架构的应用趋势。</p><h3 id="微服务架构的应用状态"><a href="#微服务架构的应用状态" class="headerlink" title="微服务架构的应用状态"></a>微服务架构的应用状态</h3><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/17.png" alt="微服务架构使用状态"></p><p>从结果来看，有 44%的人团队已经是完全微服务架构了，还有 44%的团队在向微服务架构迁移。可见，在 Java 行业中，微服务架构是得到大家普遍认可的。</p><blockquote><p>但是这个结果与上面的架构风格占比结果有出入，可能是问卷题目设计问题，或者问题回答者的主观原因，不能够苛求结果准确性。</p></blockquote><h3 id="每个应用中微服务的数量"><a href="#每个应用中微服务的数量" class="headerlink" title="每个应用中微服务的数量"></a>每个应用中微服务的数量</h3><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/18.png" alt="每个应用中微服务的数量"></p><p>既然是微服务架构，每个应用中服务数量必然超过 1 个。从结果可以看出来，有 54%的应用中少于 10 个服务，还有 22%的应用服务数量超过 20 个。</p><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/18-1.png" alt="微服务数量与公司规模的关系"></p><p>按照公司规模维度，越是大公司，每个应用中服务数量越多，结果符合康威定律的。从大家普遍实践结果看，当团队规模较小时，要尽量减少微服务数量。市面上很多老师会告诉我们，微服务架构要按照业务域拆分，但是你要知道，如果团队规模不大，即使拆分了业务域，可能最终开发调试维护也只有你一个。</p><h3 id="SpringBoot-几乎霸占了整个微服务市场"><a href="#SpringBoot-几乎霸占了整个微服务市场" class="headerlink" title="SpringBoot 几乎霸占了整个微服务市场"></a>SpringBoot 几乎霸占了整个微服务市场</h3><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/22.png" alt="微服务框架的使用度"></p><p>从结果看，SpringBoot 几乎霸占了整个微服务市场。所以，大家在日常工作学习过程中，还是主要看看 SpringBoot 栈吧。</p><p>在国内，SpringBoot 技术栈还会细分为 SpringNetflixCloud 栈、SpringAlibabaCloud 栈、SpringBoot+Dubbo 栈等。</p><p>不同的技术栈中组件有些差异，所以我们需要掌握的不是简单的应用，还要了解其中的原理。原理掌握了，不同的组价只是在应用层面的差异。</p><h3 id="启动时间在增长"><a href="#启动时间在增长" class="headerlink" title="启动时间在增长"></a>启动时间在增长</h3><p>随着公司业务的增长，应用中会增加各种各样的新功能。问卷中有个问题是关于随着时间推移，微服务启动时间的变化：</p><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/24.png" alt="启动时间在增长"></p><p>可见，有 60%的服务启动时间都在增加，甚至有 13%的应用启动时间增长超过 50%，有 30%的应用启动时间增长范围在 10%-50%。</p><p>为什么启动时间会增长呢？这个与公司业务增长后，代码增加了很多新功能有关。随着功能增加、类的增加，系统体积增大、加载类数量增大，启动时间会随之增加。这会引起系统的腐化，当腐化到一定程度，可能就需要重构了。或者随着业务增长，原来的微服务边界划分不合适了，需要重新划分系统边界，拆分微服务。</p><h3 id="启动需要多长时间"><a href="#启动需要多长时间" class="headerlink" title="启动需要多长时间"></a>启动需要多长时间</h3><p>既然微服务总体的启动时间在增长，那启动时间一般是多久呢？</p><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/24.png" alt="启动需要多长时间"></p><p>可以看到，只有 9%的服务在 1 分钟内启动成功，有 26%的服务启动时间需要 10 分钟以上。</p><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/24-1.png" alt="不同公司规模服务启动时间分布"></p><p>从上图可以看出来，人员规模大于 100 人的公司中，服务启动时间普遍长于少于 100 人的公司。产生这种情况的原因有这么几个：</p><ol><li>公司规模大一些，可能业务复杂一些，服务中的代码、类库更多一些；</li><li>公司规模大一些，依赖的组件更多一些，在服务启动时，需要与各种中间件建立链接，然后彼此交换成功心跳，自然需要时间更多。</li></ol><p>采用微服务其中一个好处是服务足够小，启动时间比较少。但是，从上面两个问卷结果来看，普遍情况是启动时间比较长，而且在变得更长。</p><h2 id="Java-技术趋势"><a href="#Java-技术趋势" class="headerlink" title="Java 技术趋势"></a>Java 技术趋势</h2><h3 id="Java-应用超过半数使用了容器部署"><a href="#Java-应用超过半数使用了容器部署" class="headerlink" title="Java 应用超过半数使用了容器部署"></a>Java 应用超过半数使用了容器部署</h3><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/27.png" alt="Java 应用超过半数使用了容器部署"></p><p>从问卷结果可以看到，Docker 使用率是 41%，Kubernetes 使用率是 26%，VMware 使用率是 16%，Vagrant 使用率是 3%，即有 86%已经实现了虚拟化，其中 Docker、Kubernetes 占比最高。</p><p>所以在 Java 升级版本特性中，实现了容器感知的能力，使 Java 服务容器化更容易一些。</p><h3 id="PaaS-平台还得看-AWS"><a href="#PaaS-平台还得看-AWS" class="headerlink" title="PaaS 平台还得看 AWS"></a>PaaS 平台还得看 AWS</h3><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/29.png" alt="PaaS 平台"></p><p>JRebel 的这个问卷调查是全球性质的，从全球范围看，AWS 当之无愧的 NO.1。AWS 作为亚马逊曾经的附属产业，已经成为了亚马逊的重要业务之一。</p><p>与亚马逊的经历类似，阿里巴巴从电商切入，然后布局云服务（阿里云）。如果还是走亚马逊的老路，势必没法超越。不过阿里从很多年前开始布局 CPU 和芯片领域，如果能够有所突破，就可以破开西方技术的封锁，依托我国的发展潜力，未必不能撼动亚马逊的 PaaS 服务商地位。</p><h3 id="近半数服务端使用-Tomcat-容器"><a href="#近半数服务端使用-Tomcat-容器" class="headerlink" title="近半数服务端使用 Tomcat 容器"></a>近半数服务端使用 Tomcat 容器</h3><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/30.png" alt="应用服务器"></p><p>前面关于微服务的问题中，SpringBoot 是众多微服务框架中的首选，SpringBoot 默认的应用容器是 Tomcat。加之 Tomcat 的开源方式，将近半数应用服务器选择 Tomcat 也是预料之中。</p><h3 id="Maven-是主要的构建工具"><a href="#Maven-是主要的构建工具" class="headerlink" title="Maven 是主要的构建工具"></a>Maven 是主要的构建工具</h3><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/31.png" alt="构建共建"></p><p>Maven 和 Gradle 到底该用哪个？这个问题似乎争论许久。从问卷结果看，Maven 占有率是 68%，Gradle 占有率是 23%，Maven 还是有绝对的优势。</p><p>Gradle 采用了约定大于配置的方式，与 SpringBoot 的理念一致。但是从市场接受度和发展而言，并没有形成替换 Maven 的风潮。Android 项目默认使用 Gradle，能够看出 Google 对 Gradle 的推崇，也从侧面印证 Gradle 的优秀。但是，Gradle 并没有绝对优势。</p><h3 id="近半数开发者使用-IntelliJ-IDEA"><a href="#近半数开发者使用-IntelliJ-IDEA" class="headerlink" title="近半数开发者使用 IntelliJ IDEA"></a>近半数开发者使用 IntelliJ IDEA</h3><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/32.png" alt="IDE"></p><p>我是从 2015 年开始使用 IntelliJ IDEA，试用之后立马抛弃了 Eclipse。首先是快捷键的设计，可以很大程度摆脱鼠标。内置的插件市场，可以找到任何需要的插件，提升编程体验。更关键的是，JetBrains 公司出品的 IDE，可以无缝对接，实现不同语言的编程支持。</p><p>Eclips 也不是一无是处，它的插件体系也是相当丰富，很多低代码开发工具都是基于 Eclipse 开发的。如果是普通开发，推荐使用 IntelliJ IDEA；如果想要做低代码工具，可以考虑对 Eclipse 进行二次开发。</p><h2 id="开发者生产力趋势"><a href="#开发者生产力趋势" class="headerlink" title="开发者生产力趋势"></a>开发者生产力趋势</h2><p>这一部分属于 JRebel 有私心的部分，JRebel 一个优势功能是提供热部署能力，所以会在问卷中询问被调查者重新部署应用的时间。</p><h3 id="重新部署应用的时间"><a href="#重新部署应用的时间" class="headerlink" title="重新部署应用的时间"></a>重新部署应用的时间</h3><p>很多时候，我们可能只改动一行代码，然后验证功能是不是正常，这个时候需要重新部署应用。JRebel 统计了重新部署需要花费的时间。</p><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/38.png" alt="重新部署应用的时间"></p><p>从结果上看，重新部署需要超过 3 分钟时间的占 50%，其中 21%的比率需要 10 分钟以上。那这段时间，大家会干什么？</p><h3 id="如果节省重新部署的时间你会做什么？"><a href="#如果节省重新部署的时间你会做什么？" class="headerlink" title="如果节省重新部署的时间你会做什么？"></a>如果节省重新部署的时间你会做什么？</h3><p><img src="https://static.howardliu.cn/jrebel-2022-java-developer-productivity-report/41.png" alt="重新部署时大家在做什么"></p><p>有 28%会增加新功能；有 20%会优化系统性能；有 19%会完善测试覆盖。这些都是正向的，大概率的是那些回答其他的：喝咖啡、喝啤酒、开趴、睡觉、钓鱼……</p><p>不过也是符合我们工作的原因：我们工作是为了生活，而不是为了加班。所以，假如每天给你 1 小时的自由时间，你会用来做什么呢？欢迎评论区讨论。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><ol><li>微服务的使用情况来看，启动时间和重新部署时间不是优先考虑的因素。多数选择微服务架构的原因无非有两个：<ol><li>看中微服务架构流行趋势，听说这个很好，那就开始用，至于是微服务架构还是分布式单体架构，就不重要了；</li><li>微服务的优势能够弥补带来的弊端，比如业务迭代速度等；</li></ol></li><li>微服务收康威定律影响比较大；</li><li>技术在不断革新，但是大家会比较理性地接受。公司规模越大，越趋于选择成熟的技术；</li><li>容器已经是大势，需要掌握。</li></ol><p>技术不断发展，我们需要学习的东西越来越多，很多时候感觉学不动了。但既然选择了这个行业，拿着高于其他行业的薪资，也承担着各种裁员的风险，总归是要有一些技能傍身，才不至于被历史的车轮碾成粉末。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.i-programmer.info/news/80-java/15317-wheres-java-going-in-2022.html" target="_blank" rel="noopener">https://www.i-programmer.info/news/80-java/15317-wheres-java-going-in-2022.html</a></li><li><a href="https://www.jrebel.com/resources/java-developer-productivity-report-2022" target="_blank" rel="noopener">https://www.jrebel.com/resources/java-developer-productivity-report-2022</a></li></ul><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/By2JoZqAHA6U36PG8qvCcg" target="_blank" rel="noopener">Java17 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-developer-productivity-report-2022">2022 年 Java 行业分析报告</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/125356270" target="_blank" rel="noopener">2022 年 Java 行业分析报告</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      前段时间介绍了从 Java8 到 Java17 每个版本比较有特点的新特性（收录在《从小工到专家的 Java 进阶之旅》专栏），今天看到 JRebel 发布了《2022 年 Java 发展趋势和分析》，于是借此分析一下 Java 行业的现状，希望给大家一些参考。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java17 的新特性</title>
    <link href="https://www.howardliu.cn/java-17-features/"/>
    <id>https://www.howardliu.cn/java-17-features/</id>
    <published>2022-05-14T02:37:39.000Z</published>
    <updated>2022-05-14T02:37:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/black-redstart-g4e4e89b2d_1920.jpeg" alt="Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java17 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java17 是在 2021 年 9 月发布的一个 LTS 版本（长期支持版本），上一个长期支持版是 Java11，于 2018 年 9 月发布。从目前来看，Java11 在市场占有率已经过半，如果错过了升级 Java11，我们可不要错过这次的升级。接下来我们看看 Java17 为我们带来了哪些新增特性：</p><ul><li>JEP 306：恢复严格的浮点语义</li><li>JEP 356：增强型伪随机数生成器</li><li>JEP 382：新的 macOS 渲染管道</li><li>JEP 391：macOS/AArch64 端口</li><li>JEP 398：弃用 Applet API</li><li>JEP 403：强封装 JDK 内部 API</li><li>JEP 406：Switch 的模式匹配（预览）</li><li>JEP 407：删除 RMI 激活机制</li><li>JEP 409：密封类</li><li>JEP 410：删除实验性的 AOT 和 JIT 编译器</li><li>JEP 411：弃用安全管理器</li><li>JEP 412：外部函数和内存 API（孵化）</li><li>JEP 414：Vector API（第二版孵化）</li><li>JEP 415：上下文特定的反序列化过滤器</li></ul><p>接下来我们一起看看这些特性。</p><h2 id="恢复严格的浮点语义（JEP-306）"><a href="#恢复严格的浮点语义（JEP-306）" class="headerlink" title="恢复严格的浮点语义（JEP 306）"></a>恢复严格的浮点语义（JEP 306）</h2><p>这个特性是利好科学计算中的浮点运算，保证浮点运算中的 strict 或 strictfp 在每个平台上都能够得到相同的结果，也就是可以把 strictfp 扔了。</p><p>在 Java1.2 之前，精确浮点计算是通过迂回的方式实现的。大约从 2001 年开始，奔腾 4 和更高版本的处理器中提供了 SSE2 扩展（数据流单指令多数据扩展指令集 2），可以直接支持严格的 JVM 浮点运算，不需要额外的开销。那个时候 Intel 和 AMD 还不支持这种扩展，于是 Java1.2 的浮点运算就分叉了。</p><p>到后来 Intel 和 AMD 也开始支持 SSE2 和更高版本的扩展指令集，Java 语言就可以恢复到严格的浮点运算了。连 Java 之父 James Gosling 在 Twitter 也发文庆祝：</p><p><img src="https://static.howardliu.cn/java/jep306-jamesgosling-twitter.png" alt="恢复严格的浮点语义（JEP 306）"></p><h2 id="增强伪随机数生成器（JEP-356）"><a href="#增强伪随机数生成器（JEP-356）" class="headerlink" title="增强伪随机数生成器（JEP 356）"></a>增强伪随机数生成器（JEP 356）</h2><p>这个特性是为伪随机数生成器 RPNG（Pseudo-Random Number Generators）增加了新的接口类型和实现，可以更容易地互换使用不同的算法，而且它还为基于流的编程方式提供了更好的支持。这个特性的目标有四个：</p><ul><li>在应用程序中更容易地交替使用各种 PRNG 算法；</li><li>改进了对基于流的编程的支持，提供了 PRNG 对象流；</li><li>消除现有 PRNG 类中的重复代码；</li><li>保留<code>java.util.Random</code>类的现有行为，做好向下兼容。</li></ul><p>新增了<code>java.util.random.RandomGenerator</code>接口，作为所有 PRNG 算法的统一 API，提供了工厂类<code>java.util.random.RandomGeneratorFactory</code>，借助<code>java.util.ServiceLoader.load()</code>的能力加载各种 PRNG 算法实现，可以构造<code>RandomGenerator</code>实例。</p><p>我们遍历一下看看有哪些 PRNG 算法：</p><pre><code class="java">RandomGeneratorFactory.all().forEach(factory -&gt; {    System.out.println(factory.group() + &quot;:&quot; + factory.name());});</code></pre><p>结果是：</p><pre><code class="log">LXM:L32X64MixRandomLXM:L128X128MixRandomLXM:L64X128MixRandomLegacy:SecureRandomLXM:L128X1024MixRandomLXM:L64X128StarStarRandomXoshiro:Xoshiro256PlusPlusLXM:L64X256MixRandomLegacy:RandomXoroshiro:Xoroshiro128PlusPlusLXM:L128X256MixRandomLegacy:SplittableRandomLXM:L64X1024MixRandom</code></pre><p><code>Legacy:Random</code>就是我们常用的<code>java.util.Random</code>，我们来试试看：</p><pre><code class="java">RandomGenerator randomGenerator = RandomGeneratorFactory.of(&quot;Random&quot;)        .create(System.currentTimeMillis());System.out.println(randomGenerator.getClass());System.out.println(randomGenerator.nextInt(10));</code></pre><p>结果是：</p><pre><code class="log">class java.util.Random6 （这个值随不同的运行结果不同）</code></pre><p>我们还可以使用流式编程方式批量获取随机数：</p><pre><code class="java">final IntStream ints = RandomGeneratorFactory.of(&quot;L128X128MixRandom&quot;)        .create()        .ints(10, 0, 100);System.out.println(Arrays.toString(ints.toArray()));</code></pre><p>结果会得到 10 个随机数字数组（每次运行结果不同）：</p><pre><code class="log">[50, 16, 73, 4, 79, 32, 55, 34, 40, 53]</code></pre><h2 id="新的-MacOS-渲染库（JEP-382）"><a href="#新的-MacOS-渲染库（JEP-382）" class="headerlink" title="新的 MacOS 渲染库（JEP 382）"></a>新的 MacOS 渲染库（JEP 382）</h2><p>MacOS 为了提升图形渲染性能，在 2018 年 9 月放弃之前的 OpenGL 渲染库，选用了 Apple Metal。从 Java17 开始，Swing API 内部用于渲染 Java 2D 的 API 开始使用新的 Apple Metal 加速渲染 API。</p><p>默认情况下，这个功能不启用，需要主动开启：</p><pre><code class="sh">-Dsun.java2d.metal=true</code></pre><p>这个特性改动是属于 API 内部实现，使用上没有任何差别。而且对 MacOS 的系统版本有要求，需要在 MacOS10.14 版本或以上，否则还是会使用 OpenGL 渲染图形。</p><h2 id="MacOS-AArch64-端口（JEP-391）"><a href="#MacOS-AArch64-端口（JEP-391）" class="headerlink" title="MacOS/AArch64 端口（JEP 391）"></a>MacOS/AArch64 端口（JEP 391）</h2><p>苹果在 2020 年 6 月的 WWDC 的演讲中宣布，将开启长期将 Macintosh 系列从 x64 过渡到 AArch64 的计划，该特性主要是为了适应这种改变。</p><p>Linux 的 AArch64 支持是在 Java9 提供的（参见 <a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a>），Windows 的 AArch64 支持是在 Java16 提供的（参见 <a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a>）。</p><p>在 Java12 的时候对 AArch64 的支持库进行了统一，只保留了一套维护代码（参见 <a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a>）。</p><h2 id="强封装-JDK-内部-API（JEP-403）"><a href="#强封装-JDK-内部-API（JEP-403）" class="headerlink" title="强封装 JDK 内部 API（JEP 403）"></a>强封装 JDK 内部 API（JEP 403）</h2><p>在 Java16 中为了改进 JDK 的安全性和可维护性，对内部 API 进行了封装，但是也留了后门，可以使用启动参数<code>--illegal-access</code>控制内部 API 的封装程度。（参见 <a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a>）</p><p>到了 Java17 中，除了<code>sun.misc.Unsafe</code>可以使用，其他的内部 API 都变成了强封装模式，而且<code>--illegal-access</code>命令也被移除，如果还在命令中添加该参数，会直接报错：</p><pre><code class="log">~ $ java -versionopenjdk version &quot;17.0.1&quot; 2021-10-19OpenJDK Runtime Environment (build 17.0.1+12-39)OpenJDK 64-Bit Server VM (build 17.0.1+12-39, mixed mode, sharing)~ $ java --illegal-accessUnrecognized option: --illegal-accessError: Could not create the Java Virtual Machine.Error: A fatal exception has occurred. Program will exit.</code></pre><h2 id="密封类（JEP-409）"><a href="#密封类（JEP-409）" class="headerlink" title="密封类（JEP 409）"></a>密封类（JEP 409）</h2><p>密封类特性是在 Java15 提供预览版，Java16 提供第二版预览，终于在 Java17 中成为正式功能。该特性限制哪些其他类或接口可以扩展或实现密封组件。</p><p>JEP 409 并没有对密封类有新的特性，可以参考 <a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a>、<a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a>，这里不再重复。</p><h2 id="上下文特定的反序列化过滤器（JEP-415）"><a href="#上下文特定的反序列化过滤器（JEP-415）" class="headerlink" title="上下文特定的反序列化过滤器（JEP 415）"></a>上下文特定的反序列化过滤器（JEP 415）</h2><p>Java 对象序列化是一个非常重要的功能，可以透明化远程处理，也促进了 JavaEE 的成功。序列化过程没有问题，但是反序列化过程可能存在危险：</p><ul><li>许多情况下传入的数据流内容是通过未知或未经身份验证的客户端获取的；</li><li>序列化数据流中可能携带带有攻击者精心构造的恶意代码。</li></ul><p>终于在 Java17 中增加了反序列化过滤器，允许应用程序使用 JVM 范围的过滤器工厂，配置特定于上下文和动态选择的反序列化过滤器，该工厂用于为每个反序列化操作选择一个过滤器。</p><p>简单点说，就是提前说好可以反序列化哪些类，如果序列化数据流中包含不被允许的类对象，就直接报错。</p><h2 id="预览功能"><a href="#预览功能" class="headerlink" title="预览功能"></a>预览功能</h2><h3 id="Switch-的模式匹配（JEP-406）"><a href="#Switch-的模式匹配（JEP-406）" class="headerlink" title="Switch 的模式匹配（JEP 406）"></a>Switch 的模式匹配（JEP 406）</h3><p>这个特性功能很赞，在 Java14 中正式提供 Switch 表达式特性（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a>），本次提供的是 Switch 模式匹配与 instanceof 模式匹配有些类似，是能够在 Switch 表达式实现类型自动转换。</p><p>比如：</p><pre><code class="java">static String formatterPatternSwitch(Object o) {    return switch (o) {        case null -&gt; &quot;null&quot;;        case Integer i -&gt; String.format(&quot;int %d&quot;, i);        case Long l -&gt; String.format(&quot;long %d&quot;, l);        case Double d -&gt; String.format(&quot;double %f&quot;, d);        case String s -&gt; String.format(&quot;String %s&quot;, s);        default -&gt; o.getClass().getSimpleName() + &quot; &quot; + o;    };}public static void main(String[] args) {    System.out.println(formatterPatternSwitch(null));    System.out.println(formatterPatternSwitch(&quot;1&quot;));    System.out.println(formatterPatternSwitch(2));    System.out.println(formatterPatternSwitch(3L));    System.out.println(formatterPatternSwitch(4.0));    System.out.println(formatterPatternSwitch(new AtomicLong(5)));}</code></pre><p>结果是：</p><pre><code class="log">nullString 1int 2long 3double 4.000000AtomicLong 5</code></pre><p>可以看到，不只是类型自动转换，还可以直接判断是否是<code>null</code>，省了前置判断对象是否是<code>null</code>了。</p><p>期待这个功能早日转正。</p><h2 id="孵化功能"><a href="#孵化功能" class="headerlink" title="孵化功能"></a>孵化功能</h2><h3 id="外部函数和内存-API（JEP-412）"><a href="#外部函数和内存-API（JEP-412）" class="headerlink" title="外部函数和内存 API（JEP 412）"></a>外部函数和内存 API（JEP 412）</h3><p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据互操作。通过有效地调用外部函数（即 JVM 外部的代码），并通过安全地访问外部内存（即不由 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会有 JNI 的脆弱性和危险。</p><p>通过更加优雅的方式访问外部函数是从 Java14 开始的，经历了多个孵化版本：</p><ul><li>Java14 的 JEP 370：外部存储器访问 API（孵化）</li><li>Java15 的 JEP 383：外部存储器访问 API（第二版孵化功能）</li><li>Java16 的 JEP 389：外部链接器 API（孵化功能）</li><li>Java16 的 JEP 393：外部存储器访问 API（第三版孵化功能）</li><li>Java17 的 JEP 412：外部函数和内存 API</li></ul><p>可以看出来，虽然一直在孵化，但是功能越来越强大，这一旦孵出来，岂不是超级神兽了。</p><p>这一系列的功能都是为了能够在 Java 类中调用 C 语言类库：</p><pre><code class="java">private static final SymbolLookup libLookup;static {    // loads a particular C library    var path = JEP412.class.getResource(&quot;/print_name.so&quot;).getPath();    System.load(path);    libLookup = SymbolLookup.loaderLookup();}</code></pre><p>第一步，需要加载我们希望通过 API 调用的目标库。<br>第二步，我们需要指定目标方法的签名，并最终调用它：</p><pre><code class="java">public String getPrintNameFormat(String name) {    var printMethod = libLookup.lookup(&quot;printName&quot;);    if (printMethod.isPresent()) {        var methodReference = CLinker.getInstance()            .downcallHandle(                printMethod.get(),                MethodType.methodType(MemoryAddress.class, MemoryAddress.class),                FunctionDescriptor.of(CLinker.C_POINTER, CLinker.C_POINTER)            );        try {            var nativeString = CLinker.toCString(name, newImplicitScope());            var invokeReturn = methodReference.invoke(nativeString.address());            var memoryAddress = (MemoryAddress) invokeReturn;            return CLinker.toJavaString(memoryAddress);        } catch (Throwable throwable) {            throw new RuntimeException(throwable);        }    }    throw new RuntimeException(&quot;printName function not found.&quot;);}</code></pre><blockquote><p>上面这段代码摘自<a href="https://www.baeldung.com/java-17-new-features" target="_blank" rel="noopener">https://www.baeldung.com/java-17-new-features</a>。</p></blockquote><h3 id="Vector-API（JEP-414，第二版孵化）"><a href="#Vector-API（JEP-414，第二版孵化）" class="headerlink" title="Vector API（JEP 414，第二版孵化）"></a>Vector API（JEP 414，第二版孵化）</h3><p>Vector 向量计算 API 是为了处理 SIMD（Single Instruction Multiple Data，单指令多数据）类型的操作，即并行执行的各种指令集。它利用支持向量指令的专用 CPU 硬件，并允许以管道的形式执行此类指令。这种运算方式可以让开发人员实现更高效的代码，充分利用底层硬件的潜力。日常使用包括科学代数线性应用程序、图像处理、字符处理、繁重的算术应用程序，以及任何需要对多个独立操作数应用一个运算的应用程序。</p><p>Vector 向量计算 API 是在 Java16 引入（参见 <a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a>），可以在运行时借助 CPU 向量运算指令，实现更优的计算能力。在 Java17 中，针对性能和实现进行了改进，包括字节向量与布尔数组之间进行转换。</p><p>原来的向量运算我们需要这样写：</p><pre><code class="java">for (var i = 0; i &lt; a.length; i++) {    c[i] = a[i] * b[i];}</code></pre><p>现在我们可以这样写：</p><pre><code class="java">final VectorSpecies&lt;Float&gt; SPECIES = FloatVector.SPECIES_PREFERRED;for (var i = 0; i &lt; a.length; i += SPECIES.length()) {    var m = SPECIES.indexInRange(i, a.length);    var va = FloatVector.fromArray(SPECIES, a, i, m);    var vb = FloatVector.fromArray(SPECIES, b, i, m);    var vc = va.mul(vb);    vc.intoArray(c, i, m);}</code></pre><h2 id="弃用和删除"><a href="#弃用和删除" class="headerlink" title="弃用和删除"></a>弃用和删除</h2><h3 id="启用-Applet-API（JEP-398）"><a href="#启用-Applet-API（JEP-398）" class="headerlink" title="启用 Applet API（JEP 398）"></a>启用 Applet API（JEP 398）</h3><p>Applet 是用 Java 编写可以嵌入到网页中的小应用，属于已经过时的技术，很多浏览器已经取消支持。Applet API 在 Java9 的时候标记了过期，在 Java17 标记为删除（<code>@Deprecated(since = &quot;9&quot;, forRemoval = true)</code>）。</p><p>记得我上学的时候，课本上还有这部分内容。</p><h3 id="删除-RMI-激活机制（JEP-407）"><a href="#删除-RMI-激活机制（JEP-407）" class="headerlink" title="删除 RMI 激活机制（JEP 407）"></a>删除 RMI 激活机制（JEP 407）</h3><p>RMI 激活机制在 Java15 标记了过期（参见 <a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a>），到 Java17 正式删除。这里只是删除了 RMI 激活机制，对于其他 RMI 功能不受影响。</p><h3 id="删除实验性的-AOT-和-JIT-编译器（JEP-410）"><a href="#删除实验性的-AOT-和-JIT-编译器（JEP-410）" class="headerlink" title="删除实验性的 AOT 和 JIT 编译器（JEP 410）"></a>删除实验性的 AOT 和 JIT 编译器（JEP 410）</h3><p>在 Java9 的 JEP 295 中，引入了实验性的提前编译 jaotc 工具，但是这个特性自从引入依赖用处都不太大，而且需要大量的维护工作，所以在 Java17 中决定删除这个特性。</p><p>但是保留了实验性的 Java 级 JVM 编译器接口（JVMCI），这样开发人员也可以继续使用外部构建的编译器版本，并使用 Graal 编译器（GraalVM）进行 JIT 编译。</p><h3 id="弃用安全管理器（JEP-411）"><a href="#弃用安全管理器（JEP-411）" class="headerlink" title="弃用安全管理器（JEP 411）"></a>弃用安全管理器（JEP 411）</h3><p>Security Manager 在 JDK1.0 时就已经引入，但是它一直都不是保护服务端以及客户端 Java 代码的主要手段，对于如此鸡肋的功能，最终决定标记为删除（<code>@Deprecated(since=&quot;17&quot;, forRemoval=true)</code>）。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java17 新增的特性，完整的特性清单可以从 <a href="https://openjdk.java.net/projects/jdk/17/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/17/</a> 查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>Java17 是 LTS（长期支持版），上个 LTS 版本是 Java11，很多团队已经在生产上切换，相信接下来会有一些团队在测试环境尝鲜。</p><p>有人认为 Java8 是神，有人则喜欢不断地尝鲜，你是哪种呢？欢迎在留言说下你在用哪个版本？</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/By2JoZqAHA6U36PG8qvCcg" target="_blank" rel="noopener">Java17 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-17-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java17 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/124830768" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java17 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Java17 是在 2021 年 9 月发布的一个 LTS 版本（长期支持版本），上一个长期支持版是 Java11，于 2018 年 9 月发布。从目前来看，Java11 在市场占有率已进过半，如果错过了升级 Java11，我们可不要错过这次的升级。接下来我们看看 Java17 为我们带来了哪些新增特性：JEP 306：恢复严格的浮点语义；JEP 356：增强型伪随机数生成器；JEP 382：新的 macOS 渲染管道；JEP 391：macOS/AArch64 端口；JEP 398：弃用 Applet API；JEP 403：强封装 JDK 内部 API；JEP 406：Switch 的模式匹配（预览）；JEP 407：删除 RMI 激活机制；JEP 409：密封类；JEP 410：删除实验性的 AOT 和 JIT 编译器；JEP 411：弃用安全管理器；JEP 412：外部函数和内存 API（孵化）；JEP 414：Vector API（第二版孵化）；JEP 415：上下文特定的反序列化过滤器；接下来我们一起看看这些特性。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java17" scheme="https://www.howardliu.cn/tags/Java17/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java16 的新特性</title>
    <link href="https://www.howardliu.cn/java-16-features/"/>
    <id>https://www.howardliu.cn/java-16-features/</id>
    <published>2022-04-18T23:48:47.000Z</published>
    <updated>2022-04-18T23:48:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/yellow-5219524_1920.jpeg" alt="Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java16 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java16 是在 2021 年 3 月发布的一个短期版本，新增特性如下：</p><ul><li>JEP 338：向量 API（孵化功能）</li><li>JEP 347：启用 C++ 14 语言特性</li><li>JEP 357：从 Mercurial 迁移到 Git</li><li>JEP 369：迁移到 GitGitHub</li><li>JEP 376：ZGC 的并发线程堆栈处理</li><li>JEP 380：支持 Unix 套接字</li><li>JEP 386：Alpine Linux 移植</li><li>JEP 387：弹性元空间</li><li>JEP 388：Windows/AArch64 移植</li><li>JEP 389：外部链接器 API（孵化功能）</li><li>JEP 390：对基于值的类设置“弃用移除”警告</li><li>JEP 392：打包工具</li><li>JEP 393：外部存储器访问 API（第三版孵化功能）</li><li>JEP 394：instanceof 模式匹配</li><li>JEP 395：Record 类型</li><li>JEP 396：默认强封装 JDK 内部元素</li><li>JEP 397：密封类（第二版预览功能）</li></ul><p>接下来我们一起看看这些特性。</p><h2 id="启用-C-14-语言特性（JEP-347）"><a href="#启用-C-14-语言特性（JEP-347）" class="headerlink" title="启用 C++ 14 语言特性（JEP 347）"></a>启用 C++ 14 语言特性（JEP 347）</h2><p>在 JDK15 之前，JDK 中使用的 C++语言限制在 C++98/03 版本，没有办法使用更高级的特性，从 JDK16 开始，可以支持 C++14 的语言特性。</p><p>这一点更新对应用开发者可能关系不大，但是对于底层组件的开发者意义重大。Java 的版本更新迅速，C++的特性也是飞速更新，如果 JDK 还是限制在 C++98/03 版本，没有办法使用 C++11/14 中的高级特性，也是一种损失。</p><h2 id="从-Mercurial-迁移到-Git（JEP-357、JEP-369）"><a href="#从-Mercurial-迁移到-Git（JEP-357、JEP-369）" class="headerlink" title="从 Mercurial 迁移到 Git（JEP 357、JEP 369）"></a>从 Mercurial 迁移到 Git（JEP 357、JEP 369）</h2><p>这是两个提案，JEP 357 是将 OpenJDK 社区的源代码版本控制工具，从 Mercurial（hg）迁移到 Git，JEP 369 是将 OpenJDK 项目定向到 GitHub 中的仓库，我们可以看到从 OpenJDK 的 JIRA 工具中，代码提交和 Issue 预览的都是在 <a href="https://github.com/openjdk" target="_blank" rel="noopener">https://github.com/openjdk</a> 中，有一部分是从 <a href="https://git.openjdk.java.net" target="_blank" rel="noopener">https://git.openjdk.java.net</a> 重定向到 GitHub。</p><p>Mercurial（hg）是一个 Python 编写的跨平台的分布式版本控制软件，与 Git 是同一时代开始的工具，功能也是很强大，只是在发展过程中，有些方面稍弱于 Git，比如元数据的占用、与现代工具链的集成。所以 OpenJDK 转而投向了 Git 的怀抱。</p><h2 id="ZGC-的并发线程堆栈处理（JEP-376）"><a href="#ZGC-的并发线程堆栈处理（JEP-376）" class="headerlink" title="ZGC 的并发线程堆栈处理（JEP 376）"></a>ZGC 的并发线程堆栈处理（JEP 376）</h2><p>ZGC 是在 Java11 引入的（参见 <a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 新特性</a>），在 Java15 中正式特性（参见 <a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 新特性</a>），可以用命令<code>-XX:+UseZGC</code>启用 ZGC。</p><p>ZGC 是一个并发的垃圾回收器，可以极大地提升 GC 的性能，支持任意堆大小而保持稳定的低延迟。在 128G 堆大小的测试中，ZGC 优势明显，找了一张网上的图片：</p><p><img src="https://static.howardliu.cn/java/java-11-1.png" alt="ZGC：可伸缩低延迟垃圾收集器"></p><p>ZGC 的目标是实现垃圾回收与程序同时运行，将 STW 降低为 0，即不存在中断。目前在标记、重定位、参考处理、类卸载和跟处理阶段删除安全点处理。目前 ZGC 中仍然依靠安全点执行的包括部分的根处理和有时间限制的标记终止操作。这些根处理中有一项就是 Java 线程堆栈处理。随着线程数量增加，停顿时间增长。所以，我们需要实现并发的堆栈处理。目标包括：</p><ul><li>ZGC 的安全点不再包含线程堆栈处理。</li><li>使堆栈处理变得惰性、协作、并发和增量。</li><li>从 ZGC 安全点中删除所有其他线程根处理。</li><li>提供一种机制，其他 HotSpot 子系统（如 Loom 和 JFR）可以通过该机制惰性地处理堆栈。</li></ul><h2 id="支持-Unix-套接字（JEP-380）"><a href="#支持-Unix-套接字（JEP-380）" class="headerlink" title="支持 Unix 套接字（JEP 380）"></a>支持 Unix 套接字（JEP 380）</h2><p>对于本地进程间通信，Unix 套接字比 TCP/IP 更加安全高效。Unix 套接字一直是大多数 Unix 平台的一个特性，现在在 Windows 10 和 Windows Server 2019 也提供了支持。</p><p>所以在 Java16 中为<code>java.nio.channels</code>包的<code>SocketChannel</code>和<code>ServerSocketChannel</code>添加了 Unix（AF_UNIX）套接字支持。Unix 套接字用于同一主机上的进程间通信（IPC）, 在很大程度上类似于 TCP/IP，区别在于套接字是通过文件系统路径名而不是 Internet 协议（IP）地址和端口号寻址的。对于本地进程间通信，Unix 套接字比 TCP/IP 环回连接更安全、更有效。</p><h2 id="Alpine-Linux-移植、Windows-AArch64-移植（JEP-386、JEP-388）"><a href="#Alpine-Linux-移植、Windows-AArch64-移植（JEP-386、JEP-388）" class="headerlink" title="Alpine Linux 移植、Windows/AArch64 移植（JEP 386、JEP 388）"></a>Alpine Linux 移植、Windows/AArch64 移植（JEP 386、JEP 388）</h2><p>这些移植的价值不在于移植本身，而在于支持平台的多样性。Java 的口号是一次编写到处运行。既然要到处运行，就得支持各种平台。而且，针对不同的操作系统支持，还能给我们提供更多的选择。</p><p>Alpine Linux 是一个独立非商业的 Linux 发行版，体系非常小，一个容器需要不超过 8MB 的空间，磁盘最小仅需 130MB 存储。如果我们通过 jlink 生产 JDK，Docket 镜像可以减小到 38MB，这样在微服务部署过程中，可以减少很多磁盘占用，也能减少镜像传输、部署时间。</p><h2 id="弹性元空间（JEP-387）"><a href="#弹性元空间（JEP-387）" class="headerlink" title="弹性元空间（JEP 387）"></a>弹性元空间（JEP 387）</h2><p>这是在 HotSpot 中的空间分配上的优化，将未使用的元空间（metaspace，也叫类的元空间）中的内容存返回给操作系统。</p><p>应用程序如果存在大量类加载和类卸载的动作时，会占用大量的元空间内存，这部分内存得不到释放，造成内存利用率低。现在的应用系统为了应对高并发的流量，动辄部署数十上百台实例，这将造成极大的资源浪费。</p><p>元空间的内存方式使用的是基于区域的内存管理方式（Region-based memory management），也就是每个分配的对象都被分配到一个区域中。这里的区域有不同的叫法：zone（区域）、arena（竞技场）、memory context（内存上下文）等。</p><p>当类被回收后，其元空间区域中的内存块会返回自由列表中，以便以后重新使用。当然，可能很长使用不会被重新使用。这样就会造成元空间中很多的内存碎片，这些都是被标记为占用的内存。如果没有碎片的内存空间，是可以返回给操作系统的。</p><p>在 JEP 387 特性中，提出使用基于伙伴的内存分配算法（Buddy memory allocation）改善元空间的内存使用，这种方式是一种在 Linux 内核中经过验证的成熟算法。这种算法是在很小的块（chunk）中分配内存，这会降低类加载器的开销。</p><p>同时，JEP 387 增加了内存延迟提交给内存区域的特性，这样就会减少那种申请了内存却不使用的情况。</p><p>最后，JEP 387 将元空间的内存区域设计为不同大小，可以满足不同大小需求的内存申请。</p><p>这些操作与 Java13 中对 ZGC 的增强特性很类似（参见 <a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a>）。他山之石可以攻玉，我们不妨学习一下这些方式，对我们在以后的开发中提供思路。</p><h2 id="对基于值的类设置“弃用移除”警告（JEP-390）"><a href="#对基于值的类设置“弃用移除”警告（JEP-390）" class="headerlink" title="对基于值的类设置“弃用移除”警告（JEP 390）"></a>对基于值的类设置“弃用移除”警告（JEP 390）</h2><p>将基于值的类的公共构造函数设置启用移除警告。</p><p>比如<code>Interger</code>的构造函数上设置了<code>@Deprecated(since=&quot;9&quot;, forRemoval = true)</code>。如果某个类使用了<code>Integer integer = new Integer(1);</code>这种写法，通过<code>javac</code>命令编译时，会收到<code>警告：[removal] Integer 中的 Integer(int) 已过时，且标记为待删除</code>这种警告信息。</p><p>基于值的类在类定义上都会有<code>@jdk.internal.ValueBased</code>注解，比如<code>java.lang.Integer</code>、<code>java.lang.Double</code>等。这样的改动是为 Valhalla 项目做准备。</p><h2 id="打包工具（JEP-392）"><a href="#打包工具（JEP-392）" class="headerlink" title="打包工具（JEP 392）"></a>打包工具（JEP 392）</h2><p>打包工具是在 Java14 中引入的孵化功能（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a>），可以打包成自包含的 Java 应用程序，比如 Windows 的 exe 和 msi、Mac 的 pkg 和 dmg、Linux 的 deb 和 rpm 等。</p><p>我们可以使用<code>jlink</code>创建一个最小可运行的模块包，然后使用<code>jpackage</code>将其构建成安装包：</p><pre><code class="shell">jpackage --name myapp --input lib --main-jar main.jar</code></pre><p>这里需要注意一点，因为已经成为正式功能，模块名从<code>jdk.incubator.jpackage</code>改为<code>jdk.jpackage</code>。</p><h2 id="instanceof-模式匹配（JEP-394）"><a href="#instanceof-模式匹配（JEP-394）" class="headerlink" title="instanceof 模式匹配（JEP 394）"></a>instanceof 模式匹配（JEP 394）</h2><p>instanceof 模式匹配首先在 Java14 中提供预览功能（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 特性</a>），可以提供<code>instanceof</code>更加简洁高效的实现，在 Java15 中进行了第二次预览，用于收集反馈，终于是多年的媳妇熬成婆，在 Java16 中成为正式功能。</p><p>我们再简单复习一下<code>instanceof</code>模式匹配的功能（详细使用可以移步 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 特性</a>）：</p><pre><code class="java">@Testvoid test1() {    final Object obj1 = &quot;Hello, World!&quot;;    int result = 0;    if (obj1 instanceof String str) {        result = str.length();    } else if (obj1 instanceof Number num) {        result = num.intValue();    }    Assertions.assertEquals(13, result);}</code></pre><h2 id="Record-类型（JEP-395）"><a href="#Record-类型（JEP-395）" class="headerlink" title="Record 类型（JEP 395）"></a>Record 类型（JEP 395）</h2><p>Record 类型用来增强 Java 语言特性，充当不可变数据载体。与 instanceof 模式匹配一样，Record 类型也是在 Java14 中提供预览功能（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 新特性</a>），在 Java15 中进行了第二次预览，用于收集反馈。</p><p>我们再简单复习一下 Record 类型的功能，比如，我们定义一个<code>Person</code>类：</p><pre><code class="java">public record Person(String name, String address) {}</code></pre><p>我们转换为之前的定义会是一坨下面这种代码：</p><pre><code class="java">public final class PersonBefore14 {    private final String name;    private final String address;    public PersonBefore14(String name, String address) {        this.name = name;        this.address = address;    }    public String name() {        return name;    }    public String address() {        return address;    }    @Override    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        PersonBefore14 that = (PersonBefore14) o;        return Objects.equals(name, that.name) &amp;&amp; Objects.equals(address, that.address);    }    @Override    public int hashCode() {        return Objects.hash(name, address);    }    @Override    public String toString() {        return &quot;PersonBefore14{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +                &#39;}&#39;;    }}</code></pre><p>Record 类型特性有四个特性：</p><ol><li>设计一个面向对象的结构，表达简单的信息聚合；</li><li>帮助开发人员专注于建模不可变数据，而不是可扩展的行为；</li><li>自动实现数据驱动的方法，比如<code>equals</code>、<code>getter</code>、<code>setter</code>等方法；</li><li>保留长期存在的 Java 规范，比如迁移兼容性。</li></ol><p>我们不能将 Record 类型简单的理解为去除“样板化”代码的功能，它不是解决 JavaBean 命名约定的中很多模板化方法的冗余繁杂问题，它的目标不是类似 Lombok 等工具自动生成代码的功能，是从开发人员专注模型的角度出发的。</p><h2 id="默认强封装-JDK-内部元素（JEP-396）"><a href="#默认强封装-JDK-内部元素（JEP-396）" class="headerlink" title="默认强封装 JDK 内部元素（JEP 396）"></a>默认强封装 JDK 内部元素（JEP 396）</h2><p>这个功能特性是为了改进 JDK 的安全性和可维护性，是 Jigsaw 项目的主要目标之一。所以在 Java16 中，默认强封装 JDK 的绝大部分内部 API，有些关键性的 API，比如<code>sun.misc.Unsafe</code>暂时可以放心使用。</p><p>我们可以使用启动参数<code>--illegal-access</code>控制内部 API 的封装程度：</p><ul><li><code>--illegal-access=permit</code>：JDK 8 中存在的每个包对未命名模块中的代码开放。也就是放心大胆地使用。Java9 中默认就是这个等级；</li><li><code>--illegal-access=warn</code>：与许可相同，不同之处在于每次非法反射访问操作都会发出警告消息；</li><li><code>--illegal-access=debug</code>：与 warn 相同，不同的是，每个非法反射访问操作都会发出警告消息和堆栈跟踪；</li><li><code>--illegal-access=deny</code>：禁用所有非法访问操作，但由其他命令行选项（例如<code>--add-opens</code>）启用的操作除外。</li></ul><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><h3 id="密封类-预览第二版（JEP-397）"><a href="#密封类-预览第二版（JEP-397）" class="headerlink" title="密封类-预览第二版（JEP 397）"></a>密封类-预览第二版（JEP 397）</h3><p>密封类首次在 Java15 中预览（参见 <a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 新特性</a>），在 Java16 中进行第二次预览，我们在复习一下功能：</p><pre><code class="java">public sealed interface JungleAnimal permits Monkey, Snake  {}public final class Monkey implements JungleAnimal {}public non-sealed class Snake implements JungleAnimal {}</code></pre><p><code>sealed</code>关键字与<code>permits</code>关键字结合使用，以确定允许哪些类实现此接口。在我们的例子中，是<code>Monkey</code>和<code>Snake</code>。</p><ul><li><code>sealed</code>：必须使用<code>permits</code>关键字定义允许继承的子类；</li><li><code>final</code>：最终类，不再有子类；</li><li><code>non-sealed</code>：普通类，任何类都可以继承它。</li></ul><h2 id="孵化"><a href="#孵化" class="headerlink" title="孵化"></a>孵化</h2><h3 id="向量-API（JEP-338）"><a href="#向量-API（JEP-338）" class="headerlink" title="向量 API（JEP 338）"></a>向量 API（JEP 338）</h3><p>这是为向量计算专门定义的 API，可以在运行时可靠地编译为支持的 CPU 架构上的最佳向量硬件指令，从而获得优于同等标量计算的性能，充分利用单指令多数据（SIMD）技术（大多数现代 CPU 上都可以使用的一种指令）。该 API 将使开发人员能够轻松地用 Java 编写可移植的高性能向量算法。</p><p>尽管 HotSpot 支持自动向量化，但是可转换的标量操作集有限且易受代码更改的影响。</p><pre><code class="java">final int[] a = {1, 2, 3, 4};final int[] b = {5, 6, 7, 8};final int[] c = new int[3];IntVector vectorA = IntVector.fromArray(IntVector.SPECIES_128, a, 0);IntVector vectorB = IntVector.fromArray(IntVector.SPECIES_128, b, 0);IntVector vectorC = vectorA.mul(vectorB);vectorC.intoArray(c, 0);</code></pre><p>这个功能在 Java17 中进行了第二次孵化，基于使用安全的考虑，我们在短时间内用不上这个特性了。</p><h3 id="外部链接器-API（JEP-389）"><a href="#外部链接器-API（JEP-389）" class="headerlink" title="外部链接器 API（JEP 389）"></a>外部链接器 API（JEP 389）</h3><p>这个特性提供了静态类型、纯 Java 访问原生代码的 API，大大简化绑定原生库的原本复杂且容易出错的过程。从 Java1.1 开始，我们可以通过原生接口（JNI）调用原生方法，但是并不好用，现在提供了外部链接器 API，可以不再使用 JNI 粘合代码了。</p><p>和向量 API 一样，暂时用不上了，等啥时候转正了，咱们重点说说怎么玩。</p><h3 id="外部存储器访问-API-孵化第三版（JEP-393）"><a href="#外部存储器访问-API-孵化第三版（JEP-393）" class="headerlink" title="外部存储器访问 API-孵化第三版（JEP 393）"></a>外部存储器访问 API-孵化第三版（JEP 393）</h3><p>外部存储器访问 API 在 Java14 开始孵化（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 新特性</a>），在 Java15 中孵化第二版（参见 <a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 新特性</a>），在 Java16 中进行第三版孵化。</p><p>外部存储器访问 API 使 Java 程序能够安全有效地对各种外部存储器（例如本机存储器、持久性存储器、托管堆存储器等）进行操作。外部内存通常是说那些独立 JVM 之外的内存区域，可以不受 JVM 垃圾收集的影响，通常能够处理较大的内存。</p><p>这次带来的特性包括：</p><ul><li><code>MemorySegment</code>和<code>MemoryAddress</code>接口之间更加清晰的职责分离；</li><li>增加了新接口<code>MemoryAccess</code>，提供了常见的静态内存访问器，以便在简单的情况下尽量减少对<code>VarHandle</code> 的需求；</li><li>支持共享 segments，并提供向清理器注册 segments 的能力。</li></ul><p>这些新的 API 虽然不会直接影响多数的应用类开发人员，但是他们可以在内存的第三方库中提供支持，包括分布式缓存、非结构化文档存储、大型字节缓冲区、内存映射文件等。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java16 新增的特性，完整的特性清单可以从 <a href="https://openjdk.java.net/projects/jdk/16/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/16/</a> 查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-16-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java16 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/124264210" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java16 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Java16 是在 2021 年 3 月发布的一个短期版本，新增特性如下：JEP 338：向量 API（孵化功能）、JEP 347：启用 C++ 14 语言特性、JEP 357：从 Mercurial 迁移到 Git、JEP 369：迁移到 GitGitHub、JEP 376：ZGC 的并发线程堆栈处理、JEP 380：支持 Unix 套接字、JEP 386：Alpine Linux 移植、JEP 387：弹性元空间、JEP 388：Windows/AArch64 移植、JEP 389：外部链接器 API（孵化功能）、JEP 390：对基于值的类设置“弃用移除”警告、JEP 392：打包工具、JEP 393：外部存储器访问 API（第三版孵化功能）、JEP 394：instanceof 模式匹配、JEP 395：Record 类型、JEP 396：默认强封装 JDK 内部元素、JEP 397：密封类（第二版预览功能），接下来我们一起看看这些特性。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java16" scheme="https://www.howardliu.cn/tags/Java16/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java15 的新特性</title>
    <link href="https://www.howardliu.cn/java-15-features/"/>
    <id>https://www.howardliu.cn/java-15-features/</id>
    <published>2022-03-07T14:04:28.000Z</published>
    <updated>2022-03-07T14:04:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/eyes-5248678_1920.jpeg" alt="Java15 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java15 是在 2020 年 9 月发布的一个短期版本，新增特性如下：</p><ul><li>JEP 339：Edwards-Curve 数字签名算法</li><li>JEP 360：密封的类和接口（预览功能）</li><li>JEP 371：隐藏类</li><li>JEP 372：移除 Nashorn JavaScript 引擎</li><li>JEP 373：重新实现 DatagramSocket 接口</li><li>JEP 374：禁用偏向锁</li><li>JEP 375：instanceof 匹配模式（第二版预览功能）</li><li>JEP 377：ZGC：可伸缩低延迟垃圾收集器</li><li>JEP 378：文本块</li><li>JEP 379：Shenandoah：低暂停时间垃圾收集器</li><li>JEP 381：移除 Solaris 和 SPARC 端口 API</li><li>JEP 383：外部存储器访问 API（第二版孵化功能）</li><li>JEP 384：Record 类型（第二版预览功能）</li><li>JEP 385：废除 RMI Activation</li></ul><p>接下来我们一起看看这些特性。</p><h2 id="Edwards-Curve-数字签名算法（JEP-339）"><a href="#Edwards-Curve-数字签名算法（JEP-339）" class="headerlink" title="Edwards-Curve 数字签名算法（JEP 339）"></a>Edwards-Curve 数字签名算法（JEP 339）</h2><p>Edwards-Curve 数字签名算法（EdDSA），一种根据 RFC 8032 规范所描述的 Edwards-Curve 数字签名算法（EdDSA）实现加密签名。</p><p>EdDSA 是一种现代的椭圆曲线方案，与 JDK 中的现有签名方案相比，EdDSA 具有更高的安全性和性能，因此备受关注。它已经在 OpenSSL 和 BoringSSL 等加密库中得到支持，目前在区块链领域用的比较多。</p><p>我们看下官方给的例子：</p><pre><code class="java">byte[] msg = &quot;Hello, World!&quot;.getBytes(StandardCharsets.UTF_8);// example: generate a key pair and signKeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;Ed25519&quot;);KeyPair kp = kpg.generateKeyPair();// algorithm is pure Ed25519Signature sig = Signature.getInstance(&quot;Ed25519&quot;);sig.initSign(kp.getPrivate());sig.update(msg);System.out.println(Hex.encodeHexString(sig.sign()));// example: use KeyFactory to contruct a public keyKeyFactory kf = KeyFactory.getInstance(&quot;EdDSA&quot;);NamedParameterSpec paramSpec = new NamedParameterSpec(&quot;Ed25519&quot;);EdECPublicKeySpec pubSpec = new EdECPublicKeySpec(paramSpec, new EdECPoint(true, new BigInteger(&quot;1&quot;)));PublicKey pubKey = kf.generatePublic(pubSpec);System.out.println(pubKey.getAlgorithm());System.out.println(Hex.encodeHexString(pubKey.getEncoded()));System.out.println(pubKey.getFormat());</code></pre><p>例子中 Ed25519 是使用 SHA-512（SHA-2）和 Curve25519 的 EdDSA 签名方案。旨在提供与高质量 128 位对称密码相当的抗攻击能力，公钥长度为 256 位，签名长度为 512 位。</p><h2 id="隐藏类（JEP-371）"><a href="#隐藏类（JEP-371）" class="headerlink" title="隐藏类（JEP 371）"></a>隐藏类（JEP 371）</h2><p>Java15 引入了一个新的特性：隐藏类（Hidden Classes），一个专为框架而设计的特性。大多数开发人员不会直接使用这个特性，一般是通过动态字节码或 JVM 语言来使用隐藏类。</p><p>隐藏类有下面三个特点：</p><ol><li>不可发现：在运行时生成内部类对象；</li><li>访问控制：只能通过反射访问，不能直接被其他字节码访问；</li><li>较短的生命周期：可独立于其他类加载、卸载，且效率很高，能够减少框架的内存占用。</li></ol><p>隐藏类的功能特性还是比较有意思的，会涉及类加载、卸载、不可见、反射等很多内容，后续会开文单独聊，文章会放在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 专栏中。</p><h2 id="重新实现-DatagramSocket-接口（JEP-373）"><a href="#重新实现-DatagramSocket-接口（JEP-373）" class="headerlink" title="重新实现 DatagramSocket 接口（JEP 373）"></a>重新实现 DatagramSocket 接口（JEP 373）</h2><p>老的 DatagramSocket API 在 Java15 中被重写，是继 Java14 重写 Socket API 的后续不走。这个特性是 Loom 项目的先决条件。</p><p>目前，<code>DatagramSocket</code>和<code>MulticastSocket</code>将所有的套接字委托为<code>java.net.DatagramSocketImpl</code>的实现，根据不同的平台，Unix 平台使用<code>PlainDatagramSocketImpl</code>，Windows 平台使用<code>TwoStackPlainDatagramSocketImpl</code>和<code>DualPlainDatagramSocketImpl</code>。抽象类<code>DatagramSocketImpl</code>是 Java1.1 提供的，功能很少且有一些过时方法，阻碍了 NOI 的实现。</p><p>类似于 Java14 中对 Socket API 的重写（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 新特性</a>），会在<code>DatagramSocket</code>内部封装一个<code>DatagramSocket</code>实例，将所有调用直接委托给该实例。包装实例或者使用 NIO 的<code>DatagramChannel::socket</code>创建套接字，或者是使用原始<code>DatagramSocket</code>类的实现<code>DatagramSocketImpl</code>实现功能（用于实现向后兼容）。</p><p>我们可以看下新的依赖图：</p><p><img src="https://static.howardliu.cn/java/ReimplementDS.png" alt="DatagramSocket"></p><h2 id="禁用偏向锁（JEP-374）"><a href="#禁用偏向锁（JEP-374）" class="headerlink" title="禁用偏向锁（JEP 374）"></a>禁用偏向锁（JEP 374）</h2><p>在 Java15 中，默认禁用偏向锁，弃用了所有相关命令行选项。</p><p>偏向锁是 HotSpot 中一种用于减少非竞争锁定开销的优化技术，不过在如今的应用程序中，优化增益不太明显了。</p><p>根据官方说法，使用偏向锁增益最多的是大量使用早期同步组件（比如<code>Hashtable</code>、<code>Vector</code>等），随着新的 API 实现和针对多线程场景引入的支持并发的数据结构，偏向锁的锁定及撤销，会带来性能的开销，从而是优化收益降低。</p><p>而且随着越来越多的功能特性引入，偏向锁在同步子系统中引入的大量代码，侵入 HotSpot 其他组件，带来代码的复杂性和维护成本，成为代码优化的阻碍。所以官方要将其移除。</p><p>不过，有些应用在禁用偏向锁后会出现性能下降，可以使用<code>-XX:+UseBiasedLocking</code>手动开启。</p><h2 id="ZGC：可伸缩低延迟垃圾收集器（JEP-377）"><a href="#ZGC：可伸缩低延迟垃圾收集器（JEP-377）" class="headerlink" title="ZGC：可伸缩低延迟垃圾收集器（JEP 377）"></a>ZGC：可伸缩低延迟垃圾收集器（JEP 377）</h2><p>ZGC 是在 Java11 引入的（参见 <a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 新特性</a>），一直处于试验阶段，想要体验，需要在参数中使用<code>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code>组合启用，在 Java15 中，ZGC 成为正式特性，想要使用可以直接用命令<code>-XX:+UseZGC</code>就行。</p><p>ZGC 是一个重新设计的并发的垃圾回收器，可以极大的提升 GC 的性能，支持任意堆大小而保持稳定的低延迟。从 <a href="https://openjdk.java.net/jeps/333" target="_blank" rel="noopener">https://openjdk.java.net/jeps/333</a> 给出的数据可以看出来，在 128G 堆大小的测试中，ZGC 优势明显，找了一张网上的图片：</p><p><img src="https://static.howardliu.cn/java/java-11-1.png" alt="ZGC：可伸缩低延迟垃圾收集器"></p><p>虽然 ZGC 愿景很好，但是还有很长的路要走，所以默认的垃圾收集器还是 G1。</p><h2 id="Shenandoah：低暂停时间垃圾收集器（JEP-379）"><a href="#Shenandoah：低暂停时间垃圾收集器（JEP-379）" class="headerlink" title="Shenandoah：低暂停时间垃圾收集器（JEP 379）"></a>Shenandoah：低暂停时间垃圾收集器（JEP 379）</h2><p>Shenandoah 是在 Java12 引入的（参见）<a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a>，本次和 ZGC 一起转正。同样的，想要使用 Shenandoah，不再需要参数<code>-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC</code>组合，只使用<code>-XX:+UseShenandoahGC</code>即可。需要注意的是，Shenandoah 只在 OpenJDK 中提供，OracleJDK 中并不包含。</p><h2 id="文本块（JEP-378）"><a href="#文本块（JEP-378）" class="headerlink" title="文本块（JEP 378）"></a>文本块（JEP 378）</h2><p>文本块是千呼万唤终于转正，在 Java13 中首次引入（参见 <a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a>），在 Java14 中又增加了预览特性（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a>），终于在 Java15 确定下来，可以放心使用了。</p><p>我们再复习一下：</p><pre><code class="java">@Testvoid testTextBlock() {    final String singleLine = &quot;你好，我是看山，公众号「看山的小屋」。这行没有换行，而且我的后面多了一个空格 \n 这次换行了&quot;;    final String textBlockSingleLine = &quot;&quot;&quot;            你好，我是看山，公众号「看山的小屋」。\            这行没有换行，而且我的后面多了一个空格、s            这次换行了&quot;&quot;&quot;;    Assertions.assertEquals(singleLine, textBlockSingleLine);}</code></pre><p>这个功能特性是代码可读性的优化。</p><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><h3 id="密封类和接口（JEP-360）"><a href="#密封类和接口（JEP-360）" class="headerlink" title="密封类和接口（JEP 360）"></a>密封类和接口（JEP 360）</h3><p>目前，Java 没有提供对继承的细粒度控制，只有 public、protected、private、包内控制四种非常粗粒度的控制方式。</p><p>为此，密封类的目标是允许单个类声明哪些类型可以用作其子类型。这也适用于接口，并确定哪些类型可以实现它们。该功能特性新增了<code>sealed</code>和<code>non-sealed</code>修饰符和<code>permits</code>关键字。</p><p>我们可以做如下定义：</p><pre><code class="java">public sealed class Person permits Student, Worker, Teacher {}public sealed class Student extends Person        permits Pupil, JuniorSchoolStudent, HighSchoolStudent, CollegeStudent, GraduateStudent {}public final class Pupil extends Student {}public non-sealed class Worker extends Person {}public class OtherClass extends Worker {}public final class Teacher extends Person {}</code></pre><p>我们可以先定义一个<code>sealed</code>修饰的类<code>Person</code>，使用<code>permits</code>指定被继承的子类，这些子类必须是使用<code>final</code>或<code>sealed</code>或<code>non-sealed</code>修饰的类。其中<code>Student</code>是使用<code>sealed</code>修饰，所以也需要使用<code>permits</code>指定被继承的子类。<code>Worker</code>类使用<code>non-sealed</code>修饰，成为普通类，其他类都可以继承它。<code>Teacher</code>使用<code>final</code>修饰，不可再被继承。</p><p>从类图上看没有太多区别：</p><p><img src="https://static.howardliu.cn/java/sealed-class.png" alt="密封类和接口"></p><p>但是从功能特性上，起到了很好的约束作用，我们可以放心大胆的定义可以公开使用，但又不想被非特定类继承的类了。</p><h3 id="instanceof-模式匹配-预览第二版（JEP-375）"><a href="#instanceof-模式匹配-预览第二版（JEP-375）" class="headerlink" title="instanceof 模式匹配-预览第二版（JEP 375）"></a>instanceof 模式匹配-预览第二版（JEP 375）</h3><p>instanceof 模式匹配首先在 Java14 中提供预览功能（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 特性</a>），可以提供<code>instanceof</code>更加简洁高效的实现，在 Java15 中没有新增特性，主要是为了再次收集反馈，根据结果看，大家还是很期待这个功能，在 Java16 中正式提供。</p><p>我们再简单看下<code>instanceof</code>的改进：</p><pre><code class="java">@Testvoid test1() {    final Object obj1 = &quot;Hello, World!&quot;;    int result = 0;    if (obj1 instanceof String str) {        result = str.length();    } else if (obj1 instanceof Number num) {        result = num.intValue();    }    Assertions.assertEquals(13, result);}</code></pre><h3 id="Record-类型-预览第二版（JEP-384）"><a href="#Record-类型-预览第二版（JEP-384）" class="headerlink" title="Record 类型-预览第二版（JEP 384）"></a>Record 类型-预览第二版（JEP 384）</h3><p>Record 类型用来增强 Java 语言特性，充当不可变数据载体。在 Java14 中提供预览功能（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 新特性</a>），在 Java15 中提供第二次预览，这次预览的目标是收集用户反馈。</p><p>比如，我们定义一个<code>Person</code>类：</p><pre><code class="java">public record Person(String name, String address) {}</code></pre><p>我们转换为之前的定义会是一坨下面这种代码：</p><pre><code class="java">public final class PersonBefore14 {    private final String name;    private final String address;    public PersonBefore14(String name, String address) {        this.name = name;        this.address = address;    }    public String name() {        return name;    }    public String address() {        return address;    }    @Override    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        PersonBefore14 that = (PersonBefore14) o;        return Objects.equals(name, that.name) &amp;&amp; Objects.equals(address, that.address);    }    @Override    public int hashCode() {        return Objects.hash(name, address);    }    @Override    public String toString() {        return &quot;PersonBefore14{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +                &#39;}&#39;;    }}</code></pre><p>Record 类型特性有四个特性：</p><ol><li>设计一个面向对象的结构，表达简单的信息聚合；</li><li>帮助开发人员专注于建模不可变数据，而不是可扩展的行为；</li><li>自动实现数据驱动的方法，比如<code>equals</code>、<code>getter</code>、<code>setter</code>等方法；</li><li>保留长期存在的 Java 规范，比如迁移兼容性。</li></ol><p>我们不能将 Record 类型简单的理解为去除“样板化”代码的功能，它不是解决 JavaBean 命名约定的中很多模板化方法的冗余繁杂问题，它的目标不是类似 Lombok 等工具自动生成代码的功能，是从开发人员专注模型的角度出发的。</p><h2 id="孵化"><a href="#孵化" class="headerlink" title="孵化"></a>孵化</h2><h3 id="外部存储器访问-API-孵化第二版（JEP-383）"><a href="#外部存储器访问-API-孵化第二版（JEP-383）" class="headerlink" title="外部存储器访问 API-孵化第二版（JEP 383）"></a>外部存储器访问 API-孵化第二版（JEP 383）</h3><p>外部存储器访问 API 在 Java14 开始孵化（参见 <a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 新特性</a>），在 Java15 中继续孵化状态，这个版本中增加了几个特性：</p><ul><li>新的<code>VarHandle</code>API，用于定制内存访问句柄；</li><li>支持<code>Spliterator</code>接口实现并行处理内存段；</li><li>增强了对映射内存段的支持；</li><li>能够像本机调用一样操作或间接操作内存地址。</li></ul><p>外部内存通常是说那些独立 JVM 之外的内存区域，可以不受 JVM 垃圾收集的影响，通常能够处理较大的内存。</p><p>这些新的 API 虽然不会直接影响多数的应用类开发人员，但是他们可以在内存的第三方库中提供支持，包括分布式缓存、非结构化文档存储、大型字节缓冲区、内存映射文件等。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="移除-Nashorn-JavaScript-引擎（JEP-372）"><a href="#移除-Nashorn-JavaScript-引擎（JEP-372）" class="headerlink" title="移除 Nashorn JavaScript 引擎（JEP 372）"></a>移除 Nashorn JavaScript 引擎（JEP 372）</h3><p>Nashorn JavaScript 引擎最初在 Java8 中引入（参见 <a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 新特性</a>），在 Java11 被标记为过期，在 Java15 中被删除，包括 Nashorn JavaScript 引擎、API、jjs 工具等内容。</p><p>Nashorn JavaScript 引擎是一个 JavaScript 脚本引擎，用来取代 Rhino 脚本引擎，对 ECMAScript-262 5.1 有完整的支持，增强了 Java 和 JavaScript 的兼容性，而且有很强的性能。</p><p>随着 GraalVM 和其他虚拟机技术最近的引入，Nashorn 引擎不再在 JDK 生态系统中占有一席之地。而且，ECMAScript 脚本语言结构、API 改变速度太快，Nashorn JavaScript 引擎维护成本太高，所以，直接删了。</p><h3 id="移除-Solaris-和-SPARC-端口-API（JEP-381）"><a href="#移除-Solaris-和-SPARC-端口-API（JEP-381）" class="headerlink" title="移除 Solaris 和 SPARC 端口 API（JEP 381）"></a>移除 Solaris 和 SPARC 端口 API（JEP 381）</h3><p>Solaris 和 SPARC 都已被 Linux 操作系统和英特尔处理器取代。放弃对 Solaris 和 SPARC 端口的支持将使 OpenJDK 社区的贡献者能够加速开发新功能，从而推动平台向前发展。</p><p>Solaris 和 SPARC 端口 API 在 Java14 中标记过时，在 Java15 中彻底移除。仅仅半年就痛下杀手，可见社区对于维护这些 API 深受折磨。</p><h3 id="废除-RMI-Activation（JEP-385）"><a href="#废除-RMI-Activation（JEP-385）" class="headerlink" title="废除 RMI Activation（JEP 385）"></a>废除 RMI Activation（JEP 385）</h3><p>RMI Activation 在 Java15 中标记为废除，会在未来版本删除。之所以被删除，是因为在现代的 web 应用中，已经不需要这种激活机制，继续维护，增加了 Java 开发人员的维护负担。在 Java8 的时候，已经将其设置为非必选项。</p><p>从开发系统的角度看，虽然 RMI Activation 是一个还不错的设计，但是已经有其他替代方案，继续维护开发下去，成本收益完全不匹配，及早舍弃，可以选择更加优秀的方案。有些类似于零边际成本的思想。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java15 新增的特性，完整的特性清单可以从 <a href="https://openjdk.java.net/projects/jdk/15/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/15/</a> 查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-15-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java15 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/123541149" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java15 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Java15 是在 2020 年 9 月发布的一个短期版本，新增特性如下：Edwards-Curve 数字签名算法；密封的类和接口（预览功能）；隐藏类；移除 Nashorn JavaScript 引擎；重新实现 DatagramSocket 接口；禁用偏向锁；instanceof 匹配模式（第二版预览功能）；ZGC：可伸缩低延迟垃圾收集器；文本块；Shenandoah：低暂停时间垃圾收集器；移除 Solaris 和 SPARC 端口 API；外部存储器访问 API（第二版孵化功能）；Record 类型（第二版预览功能）；废除 RMI Activation；接下来我们一起看看这些特性。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java15" scheme="https://www.howardliu.cn/tags/Java15/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java14 的新特性</title>
    <link href="https://www.howardliu.cn/java-14-features/"/>
    <id>https://www.howardliu.cn/java-14-features/</id>
    <published>2022-03-05T03:37:11.000Z</published>
    <updated>2022-03-05T03:37:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/tree-blossoms-7022041_1920.jpeg" alt="Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java14 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文讲解一下 Java14 的特性，这个版本带来了不少新特性、功能实用性的增强、GC 的尝试、性能优化等：</p><ul><li>JEP 305：instanceof 模式匹配 （预览版）</li><li>JEP 343：打包工具 （孵化）</li><li>JEP 345：G1 的可识别 NUMA 系统的内存分配</li><li>JEP 349：JFR 事件流</li><li>JEP 352：非原子性的字节缓冲区映射</li><li>JEP 358：NullPointerException 的友好提示信息</li><li>JEP 359：Record 声明 （预览版）</li><li>JEP 361：Switch 表达式转正 （第二版预览）</li><li>JEP 362：弃用 Solaris 和 SPARC 端口</li><li>JEP 363：删除 CMS 垃圾回收器</li><li>JEP 364：ZGC 支持 MacOS</li><li>JEP 365：ZGC 支持 Windows</li><li>JEP 366：弃用 ParallelScavenge 和 SerialOld GC 的组合</li><li>JEP 367：移除 Pack200 Tools 和 API</li><li>JEP 368：文本块 （第二版预览）</li><li>JEP 370：外部存储器访问 API（孵化）</li></ul><p>接下来我们一起看看这些特性。</p><h2 id="Switch-表达式转正（JEP-361）"><a href="#Switch-表达式转正（JEP-361）" class="headerlink" title="Switch 表达式转正（JEP 361）"></a>Switch 表达式转正（JEP 361）</h2><p>Switch 表达式在 Java12 和 Java13 都处于功能预览阶段，到 Java14 终于转正了，从另一个角度，我们可以在生产环境中使用这个功能了。</p><p>我们以“判断是否工作日”的例子展示一下，在 Java14 之前：</p><pre><code class="java">@Testvoid testSwitch() {    final DayOfWeek day = DayOfWeek.from(LocalDate.now());    String typeOfDay = &quot;&quot;;    switch (day) {        case MONDAY:        case TUESDAY:        case WEDNESDAY:        case THURSDAY:        case FRIDAY:            typeOfDay = &quot;Working Day&quot;;            break;        case SATURDAY:        case SUNDAY:            typeOfDay = &quot;Rest Day&quot;;            break;    }    Assertions.assertFalse(typeOfDay.isEmpty());}</code></pre><p>在 Java14 中：</p><pre><code class="java">@Testvoid testSwitchExpression() {    final DayOfWeek day = DayOfWeek.SATURDAY;    final String typeOfDay = switch (day) {        case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; {            System.out.println(&quot;Working Day: &quot; + day);            yield &quot;Working Day&quot;;        }        case SATURDAY, SUNDAY -&gt; &quot;Day Off&quot;;    };    Assertions.assertEquals(&quot;Day Off&quot;, typeOfDay);}</code></pre><p>注意看，例子中我们使用了两种写法，一种是通过<code>yield</code>关键字表示返回结果，一种是在<code>-&gt;</code>之后直接返回。</p><h2 id="预览功能"><a href="#预览功能" class="headerlink" title="预览功能"></a>预览功能</h2><p>和前面的版本一样，Java14 中也提供了一些预览功能，我们可以在预览环境中试用一下。</p><p>这次的预览功能包括文本块（第二版预览）、instanceof 模式匹配、Record 声明，接下来我们分别说一下。</p><h3 id="文本块（第二版预览，JEP-368）"><a href="#文本块（第二版预览，JEP-368）" class="headerlink" title="文本块（第二版预览，JEP 368）"></a>文本块（第二版预览，JEP 368）</h3><p>文本块在 Java13 中首次出现（参见 <a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13</a>），本次又提供了两个扩展：</p><ul><li><code>\</code>：表示当前语句未换行，与 shell 脚本中的习惯一致；</li><li><code>\s</code>：表示单个空格。</li></ul><p>我们看个例子：</p><pre><code class="java">@Testvoid testTextBlock() {    final String singleLine = &quot;你好，我是看山，公众号「看山的小屋」。不没有换行，而且我的后面多了一个空格 &quot;;    final String textBlockSingleLine = &quot;&quot;&quot;            你好，我是看山，公众号「看山的小屋」。\            不没有换行，而且我的后面多了一个空格、s&quot;&quot;&quot;;    Assertions.assertEquals(singleLine, textBlockSingleLine);}</code></pre><p>个人感觉、是比较实用的，这个功能在 Java15 中转正，值得期待。</p><h3 id="instanceof-模式匹配（JEP-305）"><a href="#instanceof-模式匹配（JEP-305）" class="headerlink" title="instanceof 模式匹配（JEP 305）"></a>instanceof 模式匹配（JEP 305）</h3><p><code>instanceof</code>主要用来检查对象类型，作为类型强转前的安全检查。</p><p>比如：</p><pre><code class="java">@Testvoid test() {    final Object obj1 = &quot;Hello, World!&quot;;    int result = 0;    if (obj1 instanceof String) {        String str = (String) obj1;        result = str.length();    } else if (obj1 instanceof Number) {        Number num = (Number) obj1;        result = num.intValue();    }    Assertions.assertEquals(13, result);}</code></pre><p>可以看到，我们每次判断类型之后，需要声明一个判断类型的变量，然后将判断参数强制转换类型，赋值给新声明的变量。这种写法显得繁琐且多余。</p><p>于是在 Java14 中对<code>instanceof</code>进行了改进：</p><pre><code class="java">@Testvoid test1() {    final Object obj1 = &quot;Hello, World!&quot;;    int result = 0;    if (obj1 instanceof String str) {        result = str.length();    } else if (obj1 instanceof Number num) {        result = num.intValue();    }    Assertions.assertEquals(13, result);}</code></pre><p>不仅如此，<code>instanceof</code>模式匹配的作用域还可以扩展。在<code>if</code>条件判断中，我们都知道<code>&amp;&amp;</code>与判断是会执行所有的表达式，所以使用<code>instanceof</code>模式匹配定义的局部变量继续判断。</p><p>比如：</p><pre><code class="java">if (obj1 instanceof String str &amp;&amp; str.length() &gt; 20) {    result = str.length();}</code></pre><p>与原来的写法对比，Java14 提供的写法代码更加简洁、可读性更高，能够提出很多冗余繁琐的代码，非常实用的一个特性，这个功能会在 Java16 中转正。</p><h3 id="Record-声明（JEP-359）"><a href="#Record-声明（JEP-359）" class="headerlink" title="Record 声明（JEP 359）"></a>Record 声明（JEP 359）</h3><p>在 Java14 预览功能中新增了一个关键字<code>record</code>，它是定义不可变数据类型封装类的关键字，主要用在特定领域类上。这个关键字最终会在 Java16 中正式提供。</p><p>我们都知道，在 Java 开发中，我们需要定义 POJO 作为数据存储对象，根据规范，POJO 中除了属性是个性化的，其他的比如<code>getter</code>、<code>setter</code>、<code>equals</code>、<code>hashCode</code>、<code>toString</code>都是模板化的写法，所以为了简便，很多类似 Lombok 的组件提供 Java 类编译时增强，通过在类上定义<code>@Data</code>注解自动添加这些模板化方法。在 Java14 中，我们可以直接使用<code>record</code>解决这个问题。</p><p>比如，我们定义一个<code>Person</code>类：</p><pre><code class="java">public record Person(String name, String address) {}</code></pre><p>我们转换为之前的定义会是一坨下面这种代码：</p><pre><code class="java">public final class PersonBefore14 {    private final String name;    private final String address;    public PersonBefore14(String name, String address) {        this.name = name;        this.address = address;    }    public String name() {        return name;    }    public String address() {        return address;    }    @Override    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        PersonBefore14 that = (PersonBefore14) o;        return Objects.equals(name, that.name) &amp;&amp; Objects.equals(address, that.address);    }    @Override    public int hashCode() {        return Objects.hash(name, address);    }    @Override    public String toString() {        return &quot;PersonBefore14{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +                &#39;}&#39;;    }}</code></pre><p>我们可以发现 Record 类有如下特征：</p><ol><li>一个构造方法</li><li>getter 方法名与属性名相同</li><li>有<code>equals()</code>、<code>hashCode()</code>方法</li><li>有<code>toString()</code>方法</li><li>类对象和属性被<code>final</code>修饰，所以构造函数是包含所有属性的，而且没有 setter 方法</li></ol><p>在<code>Class</code>类中也新增了对应的处理方法：</p><ul><li><code>getRecordComponents()</code>：返回一组<code>java.lang.reflect.RecordComponent</code>对象组成的数组，该数组的元素与<code>Record</code>类中的组件相对应，其顺序与在记录声明中出现的顺序相同，可以从该数组中的每个<code>RecordComponent</code>中提取到组件信息，包括其名称、类型、泛型类型、注释及其访问方法。</li><li><code>isRecord()</code>：返回所在类是否是 Record 类型，如果是，则返回 true。</li></ul><p>看起来，Record 类和 Enum 很像，都是一定的模板类，通过语法糖定义，在 Java 编译过程中，将其编译成特定的格式，功能很好，但如果没有习惯使用，可能会觉得限制太多。</p><h2 id="NullPointerException-的友好提示信息（JEP-358）"><a href="#NullPointerException-的友好提示信息（JEP-358）" class="headerlink" title="NullPointerException 的友好提示信息（JEP 358）"></a>NullPointerException 的友好提示信息（JEP 358）</h2><p>在没有考虑完全场景的情况下，很容易碰到空指针异常（NullPointerException，简称 NPE）。一般碰到这个异常，根据异常栈信息我们很容易定位到发生异常的代码行，比如：</p><pre><code class="java">@Testvoid test1() {    Student s = null;    Assertions.assertThrows(NullPointerException.class, ()-&gt; s.getName())            .fillInStackTrace()            .printStackTrace();}</code></pre><p>如果是在 Java14 之前，这个时候打印出来的异常信息是：</p><pre><code class="log">Exception in thread &quot;main&quot; java.lang.NullPointerException    at cn.howardliu.tutorials.java14.NpeTest.test1(NpeTest.java:20)</code></pre><p>对于上面例子，我们可以直接定位到<code>s</code>是<code>null</code>，但是下面这个例子呢：</p><pre><code class="java">@Testvoid test2() {    Student s = new Student();    s.setName(&quot;看山&quot;);    Assertions.assertThrows(NullPointerException.class, ()-&gt; s.getClazz().getNo())            .fillInStackTrace()            .printStackTrace();}</code></pre><p>我们很难判断<code>s</code>或者<code>s</code>中的<code>clazz</code>是<code>null</code>，需要查看上下文代码，或者复杂情况还需要添加日志辅助定位问题。</p><p>在 Java14 中，对 NullPointerException 异常栈信息做了增强，通过分析程序的字节码信息，能够做到准确地定位到出现 NullPointerException 的变量，并且根据实际源代码打印出详细异常信息。此时，上面例子的异常信息是：</p><pre><code class="log">java.lang.NullPointerException: Cannot invoke &quot;cn.howardliu.tutorials.java14.NpeTest$Clazz.getNo()&quot; because the return value of &quot;cn.howardliu.tutorials.java14.NpeTest$Student.getClazz()&quot; is null    at cn.howardliu.tutorials.java14.NpeTest.test2(NpeTest.java:30)</code></pre><p>这样一目了然。</p><h2 id="孵化功能"><a href="#孵化功能" class="headerlink" title="孵化功能"></a>孵化功能</h2><p>孵化功能是 Java 开发团队让我们提前尝鲜、公测的功能，在 Java9 模块化之后，孵化功能会放在<code>jdk.incubator.</code>中。</p><h3 id="外部存储器访问-API（JEP-370）"><a href="#外部存储器访问-API（JEP-370）" class="headerlink" title="外部存储器访问 API（JEP 370）"></a>外部存储器访问 API（JEP 370）</h3><p>Java 对象是驻留在堆上，但是有时候因为其算法或者内存结构的原因，使用效率低下、性能低下、受垃圾收集器 GC 算法影响。所以很多时候我们会使用本机内存或者称为直接内存。</p><p>在 Java14 之前，使用直接内存我们会用到<code>ByteBuffer</code>或者<code>Unsafe</code>，但是这两个都存在一些问题。</p><ul><li><code>ByteBuffer</code>管理内存最大不能够超过 2G；</li><li><code>ByteBuffer</code>管理的这部分内存需要使用垃圾收集器回收内存，使用不当可能造成内存泄漏；</li><li><code>Unsafe</code>是非标准的 Java API，可能会因为不合法的内存使用致使系统崩溃。</li></ul><p>“天下苦秦久矣”，于是在 Java14 中提供了新的 API：</p><ul><li><code>MemorySegment</code>：用来申请内存区域，可以是堆内存，也可以是对外内存；</li><li><code>MemoryAddress</code>：从<code>MemorySegment</code>实例获取已申请内存的内存地址用于执行操作，例如从底层内存段的内存中检索数据；</li><li><code>MemoryLayout</code>：用来描述内存段的内容，它允许我们定义如何将内存分解为元素，并提供每个元素的大小。</li></ul><p>这部分功能截止到 Java17 还是孵化功能，而且内容比较多，后续会单独开一篇介绍。</p><h3 id="打包工具（JEP-343）"><a href="#打包工具（JEP-343）" class="headerlink" title="打包工具（JEP 343）"></a>打包工具（JEP 343）</h3><p>一般来说，Java 程序会以一个 Jar 的形式提供，web 服务可能是 war 或者 ear 包，但是有时候我们的 Java 程序可能是在自己的 PC 机（比如 Windows 或者 MacOS）上运行，期望可以通过双击打开的方式。</p><p>于是 Java14 引入了<code>引入了 jdk.incubator.jpackage.jmod</code>，基于 JavaFX javapackager tool，其目的就是创建一个打包工具，可以将 jar 包构建成 exe、pkg、dmg、deb、rpm 格式的安装文件。</p><p>我们可以使用<code>jlink</code>创建一个最小可运行的模块包，然后使用<code>jpackage</code>将其构建成安装包：</p><pre><code class="shell">jpackage --name myapp --input lib --main-jar main.jar</code></pre><h2 id="JVM-功能"><a href="#JVM-功能" class="headerlink" title="JVM 功能"></a>JVM 功能</h2><h3 id="ZGC-支持-MacOS-和-Windows-系统（JEP-364、JEP-365）"><a href="#ZGC-支持-MacOS-和-Windows-系统（JEP-364、JEP-365）" class="headerlink" title="ZGC 支持 MacOS 和 Windows 系统（JEP 364、JEP 365）"></a>ZGC 支持 MacOS 和 Windows 系统（JEP 364、JEP 365）</h3><p>ZGC 最初是在 Java11 中引入（参见 <a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a>），在后续版本中，不断升级优化，实现可伸缩、低延迟的目标，使用了内存读屏障、染色指针、内存多重映射等技术。在之前，ZGC 只支持 Linux/x64 平台，在 Java14 之后，支持了 macOS/x64 和 Windows/x64 系统中。</p><p>开启参数：</p><pre><code class="shell">-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code></pre><h3 id="G1-的可识别-NUMA-系统的内存分配（JEP-345）"><a href="#G1-的可识别-NUMA-系统的内存分配（JEP-345）" class="headerlink" title="G1 的可识别 NUMA 系统的内存分配（JEP 345）"></a>G1 的可识别 NUMA 系统的内存分配（JEP 345）</h3><p>Java14 改进了非一致性内存访问（Non-uniform Memory Access，NUMA）系统上的 G1 垃圾收集器的整体性能，主要是对年轻代的内存分配做出优化，从而提升 CPU 计算过程中内存访问速度。</p><p>NUMA 主要是指在多插槽物理计算机体系中，处理器一般是多核，且越来越多具备 NUMA 访问体系结构，即内存与每个插槽或内核之间的距离不等。套接字之间的内存访问有不同的性能特征，更远的套接字访问会有更多的时间消耗。这样的结果是，每个核对于某一区域的内存访问速度会随核与物理内存的位置远近有所差异。</p><p>Java 分配内存时，G1 会申请一块 region，作为对象存放区域。如果能够感知 NUMA，就可以优先在当前线程绑定的 NUMA 节点空闲内存执行申请内存操作，用于提升访问速度。</p><p>启用参数是<code>-XX:+UseNUMA</code>。</p><h3 id="JFR-事件流（JEP-349）"><a href="#JFR-事件流（JEP-349）" class="headerlink" title="JFR 事件流（JEP 349）"></a>JFR 事件流（JEP 349）</h3><p>飞行记录器（Flight Recorder）是在 Java11 中引入（参见 <a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a>）。</p><p>本次增强可以实现 JFR 数据的公开访问，可以通过使用<code>jdk.jfr.consumer</code>中的方法持续读取或流式传输读取记录，用于持续监控。这样的话，我们可以与现有监控系统集成，实现 JFR 数据的持续监听，不用非得等着收集完成后再解析分析。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h2 id="非原子性的字节缓冲区映射（JEP-352）"><a href="#非原子性的字节缓冲区映射（JEP-352）" class="headerlink" title="非原子性的字节缓冲区映射（JEP 352）"></a>非原子性的字节缓冲区映射（JEP 352）</h2><p>对<code>FileChannel</code>进行扩展，定义了<code>jdk.nio.mapmode.ExtendedMapMode</code>，用来创建<code>MappedByteBuffer</code>实例，可以对非原子性的字节缓冲区映射（Non-Volatile Mapped Byte Buffers，NVM）实现持久化。</p><h3 id="删除-CMS-垃圾回收器（JEP-363）"><a href="#删除-CMS-垃圾回收器（JEP-363）" class="headerlink" title="删除 CMS 垃圾回收器（JEP 363）"></a>删除 CMS 垃圾回收器（JEP 363）</h3><p>CMS 是老年代垃圾回收算法，通过标记-清除的方式进行内存回收，在内存回收过程中能够与用户线程并行执行。在 G1 之前，CMS 几乎占据了 GC 的全部江山。在使用过程中，一般是 CMS 与 Parallel New 搭配使用。</p><p>CMS 由于其算法特性，会产生内存碎片和浮动垃圾，随着时间推移，可能出现的情况是，虽然老年代还有空间，但是没有办法分配足够内存给大对象。</p><p>所以在 Java9 中开始放弃使用 CMS，在 Java14 中彻底删除，并删除与 CMS 有关的参数。从 Java14 开始，CMS 成为了历史。</p><h3 id="弃用-ParallelScavenge-和-SerialOld-GC-的组合（JEP-366）"><a href="#弃用-ParallelScavenge-和-SerialOld-GC-的组合（JEP-366）" class="headerlink" title="弃用 ParallelScavenge 和 SerialOld GC 的组合（JEP 366）"></a>弃用 ParallelScavenge 和 SerialOld GC 的组合（JEP 366）</h3><p>Parallel Scavenge 是并行收集算法，SerialOld 提供老年代串行收集，这种年轻代使用并行算法、老年代使用串行算法的混搭的方式，使用场景少且有风险。但是却需要大量工作量维护，所以在 Java14 中，删除了这两种 GC 组合。</p><p>删除组合的方式是通过启用组合参数<code>-XX:+UseParallelGC -XX:-UseParallelOldGC</code>，并在单独使用<code>-XX:-UseParallelOldGC</code>时会收到警告信息。</p><h3 id="移除-Pack200-Tools-和-API（JEP-367）"><a href="#移除-Pack200-Tools-和-API（JEP-367）" class="headerlink" title="移除 Pack200 Tools 和 API（JEP 367）"></a>移除 Pack200 Tools 和 API（JEP 367）</h3><p>these were deprecated for removal in Java 11, and now removed</p><p>删除<code>java.util.jar</code>包中的<code>pack200</code>和<code>unpack200</code>工具以及 Pack200 API。这些工具和 API 已在 Java11 时标记弃用，删除也是意料之中。</p><h3 id="弃用-Solaris-和-SPARC-端口（JEP-362）"><a href="#弃用-Solaris-和-SPARC-端口（JEP-362）" class="headerlink" title="弃用 Solaris 和 SPARC 端口（JEP 362）"></a>弃用 Solaris 和 SPARC 端口（JEP 362）</h3><p>Solaris 和 SPARC 都已被 Linux 操作系统和英特尔处理器取代。放弃对 Solaris 和 SPARC 端口的支持将使 OpenJDK 社区的贡献者能够加速开发新功能，从而推动平台向前发展。</p><p>这些 API 在 Java14 中标记弃用，在 Java15 中彻底删除。这样做，也是为了让很多正在进行的项目尽早适应新的架构。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java14 新增的特性，完整的特性清单可以从 <a href="https://openjdk.java.net/projects/jdk/14/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/14/</a> 查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-14-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java14 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/123340900" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java14 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文讲解一下 Java14 的特性，这个版本带来了不少新特性、功能实用性的增强、GC 的尝试、性能优化等：JEP 305：instanceof 模式匹配 （预览版）；JEP 343：打包工具 （孵化）；JEP 345：G1 的可识别 NUMA 系统的内存分配；JEP 349：JFR 事件流；JEP 352：非原子性的字节缓冲区映射；JEP 358：NullPointerException 的友好提示信息；JEP 359：Record 声明 （预览版）；JEP 361：Switch 表达式转正 （第二版预览）；JEP 362：弃用 Solaris 和 SPARC 端口；JEP 363：删除 CMS 垃圾回收器；JEP 364：ZGC 支持 MacOS；JEP 365：ZGC 支持 Windows；JEP 366：弃用 ParallelScavenge 和 SerialOld GC 的组合；JEP 367：移除 Pack200 Tools 和 API；JEP 368：文本块 （第二版预览）；JEP 370：外部存储器访问 API（孵化）。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java14" scheme="https://www.howardliu.cn/tags/Java14/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java13 的新特性</title>
    <link href="https://www.howardliu.cn/java-13-features/"/>
    <id>https://www.howardliu.cn/java-13-features/</id>
    <published>2022-02-14T13:41:37.000Z</published>
    <updated>2022-02-14T13:41:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/bird-6965228_1920.jpeg" alt="Java13 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文讲解一下 Java13 的特性，这个版本在语法特性上增加不多，值得关注的是两个预览功能：Switch 表达式和文本块，另外可以关乎的是性能优化方面的：动态类数据共享（CDS）存档、ZGC 动态释放未使用内存、Socket API 重构。这些方面可以看出，Java 的升级方向有两个，一是增加功能，增加新的语法特性；二是增强功能，提升已有功能性能。</p><h2 id="预览功能"><a href="#预览功能" class="headerlink" title="预览功能"></a>预览功能</h2><p>Java13 引入了两个新的语法特性：Switch 表达式和文本块。这些预览功能是为了让开发者尝鲜的同时，可以快速调整，反馈好就留下，不好就移除。目前来看，这些特性还是挺香的。</p><p><img src="https://static.howardliu.cn/Illustration/zhenxiangdinglv.jpeg" alt="真香定律"></p><h3 id="Switch-表达式"><a href="#Switch-表达式" class="headerlink" title="Switch 表达式"></a>Switch 表达式</h3><p>在 Java12 中 Switch 表达式首次以预览版的身份出现，在 Java13 中又做了增强，在 Java14 正式提供。Java13 添加了<code>yield</code>关键字，用来返回值。</p><p><code>yield</code>与<code>return</code>的区别在于，<code>yield</code>只会跳出<code>switch</code>块，<code>return</code>是跳出当前方法或循环。</p><p>比如下面的例子，在 Java12 之前，要判断日期可以这样写：</p><pre><code class="java">@Testvoid testSwitch() {    final DayOfWeek day = DayOfWeek.from(LocalDate.now());    String typeOfDay = &quot;&quot;;    switch (day) {        case MONDAY:        case TUESDAY:        case WEDNESDAY:        case THURSDAY:        case FRIDAY:            typeOfDay = &quot;Working Day&quot;;            break;        case SATURDAY:        case SUNDAY:            typeOfDay = &quot;Rest Day&quot;;            break;    }    Assertions.assertFalse(typeOfDay.isEmpty());}</code></pre><p>在 Java12 提供的 Switch 表达式预览功能，我们可以简化一下：</p><pre><code class="java">@Testvoid testSwitchExpression() {    final DayOfWeek day = DayOfWeek.SATURDAY;    final String typeOfDay = switch (day) {        case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; &quot;Working Day&quot;;        case SATURDAY, SUNDAY -&gt; &quot;Day Off&quot;;    };    Assertions.assertEquals(&quot;Day Off&quot;, typeOfDay);}</code></pre><p>这样可以实现判断，但是没有办法在表达式中实现其他逻辑了。于是 Java13 补齐了这个功能：</p><pre><code class="java">@Testvoid testSwitchExpression13() {    final DayOfWeek day = DayOfWeek.SATURDAY;    final String typeOfDay = switch (day) {        case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; {            System.out.println(&quot;Working Day: &quot; + day);            yield &quot;Working Day&quot;;        }        case SATURDAY, SUNDAY -&gt; {            System.out.println(&quot;Day Off: &quot; + day);            yield &quot;Day Off&quot;;        }    };    Assertions.assertEquals(&quot;Day Off&quot;, typeOfDay);}</code></pre><p>这里需要说明一下，既然是预览功能，会与正式提供功能有些出入。上面的代码是在 Java14 环境中编写，与 Java13 发布的功能描述有些差异，这点不必深究，已经废弃的约束就是不存在。</p><h3 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h3><p>一直以来，Java 中的字符串定义都是以双引号括起来的形式，不支持多行书写，所以在需要多行字符串中，需要使用转义符表示，既不好看、还不好读，更不好维护。</p><p>千呼万唤始出来，终于有了文本块功能。</p><p>比如，我们想要写一段 Json 格式的数据，Java13 之前需要写成：</p><pre><code class="java">String json = &quot;{\n&quot;        + &quot;  \&quot;wechat\&quot;: \&quot;hellokanshan\&quot;,\n&quot;        + &quot;  \&quot;wechatName\&quot;: \&quot;看山、&quot;,\n&quot;        + &quot;  \&quot;mp\&quot;: \&quot;kanshanshuo\&quot;,\n&quot;        + &quot;  \&quot;mpName\&quot;: \&quot;看山的小屋、&quot;\n&quot;        + &quot;}\n&quot;;</code></pre><p>但是在 Java13 预览版中可以写作：</p><pre><code class="java">String json2 = &quot;&quot;&quot;        {          &quot;wechat&quot;: &quot;hellokanshan&quot;,          &quot;wechatName&quot;: &quot;看山&quot;,          &quot;mp&quot;: &quot;kanshanshuo&quot;,          &quot;mpName&quot;: &quot;看山的小屋&quot;        }        &quot;&quot;&quot;;</code></pre><p>少了很多的+、换行、转移等字符，看着更加直观。</p><p>这个功能在 Java15 中正式提供。</p><h2 id="动态类数据共享（CDS）存档"><a href="#动态类数据共享（CDS）存档" class="headerlink" title="动态类数据共享（CDS）存档"></a>动态类数据共享（CDS）存档</h2><p>CDS 是 Java5 引入的一种类预处理方式，可以将一组类共享到一个归档文件中，借助内存映射加载类数据，减少启动时间，并可实现在多 JVM 之间共享的功能。在 Java10 对其进行扩展，增大了 CDS 使用范围，即 AppCDS（参见 <a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 新特性</a>）。到了 Java12，将 CDS 归档文件作为了默认功能开放出来（参见 <a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 新特性</a>）。</p><p>但是这个功能在使用的时候还是有些麻烦。为了生成归档文件，开发人员必须先对应用程序进行试运行，创建一个类列表，然后将其转储到归档文件中。然后，这个归档才可以用来在 JVM 之间共享元数据。</p><p>Java13 简化了这个过程：允许 Java 应用在运行结束后动态归档，即将已被加载但不属于 CDS 的类（包括自定义类和引用库的类）动态添加到 CDS 归档文件中。不用再提供归档类的列表，通过更加简洁的方式创建包含应用程序的归档。</p><p>我们可以使用<code>-XX:ArchiveClassesAtExit</code>参数控制应用程序退出时创建 CDS 归档文件：</p><pre><code class="shell">java -XX:ArchiveClassesAtExit=&lt;archive filename&gt; -cp &lt;app jar&gt; AppName</code></pre><p>也可以使用<code>-XX:SharedArchiveFile</code>来使用动态存档功能：</p><pre><code class="shell">java -XX:SharedArchiveFile=&lt;archive filename&gt; -cp &lt;app jar&gt; AppName</code></pre><h2 id="ZGC-增强：释放未使用内存"><a href="#ZGC-增强：释放未使用内存" class="headerlink" title="ZGC 增强：释放未使用内存"></a>ZGC 增强：释放未使用内存</h2><p>ZGC 是 Java11 中引入的一个可伸缩、低延迟的垃圾收集器，主要目标包括：GC 停顿时间不超过 10ms；可以处理从几百 MB 的小堆，到几个 TB 的大堆；应用吞吐能力不会下降超过 15%等（参见 <a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a>）。</p><p>但是 ZGC 并没有像 Hotspot 中的 G1 和 Shenandoah 那样，可以主动释放未使用的内存，对于多数应用程序来说，CPU 和内存都是稀缺资源，尤其是现在云上环境和虚拟化技术，如果应用程序占用的内存长期处于空闲状态，还紧握住不释放，就是极大的浪费。</p><p>在 Java13 中对其进行改进，包括：</p><ul><li>可释放空闲内存</li><li>支持的最大堆大小从 4TB 扩大到 16TB</li></ul><p>我们来看下 ZGC 的内部逻辑。</p><p>ZGC 堆由一组称为 ZPages 的堆区域组成，每个 ZPage 都与提交的堆内存的可变数量相关联。当 ZGC 压缩堆时，ZPages 被释放并插入到页面缓存 ZPageCache 中，页面缓存中的 ZPages 可以重新使用，以满足新的堆分配。</p><p>ZPageCache 中的 ZPages 集合代表堆中未使用的部分，这部分可以释放回操作系统。ZPageCache 中的 ZPages 根据 LRU（最近最少使用）排序，并按照大中小进行分组。这样的话就可以根据算法按顺序释放未使用的内存。</p><p>Java13 还提供了<code>-XX:ZUncommitDelay=&lt;seconds&gt;</code>命令，用于指定释放多长时间（默认是 5 分钟）未使用的内存，这个参数类似于 Shenandoah 中的<code>-XX:ShenandoahUncommitDelay=&lt;milliseconds&gt;</code>。</p><p>在 Java13 中，ZGC 内存释放功能默认开启，可通过参数<code>-XX:-ZUncommit</code>关闭该功能。由于 ZGC 释放内存时，不会低于最小堆内存，即当最小堆内存（-Xms）与最大堆内存（-Xmx）一样时，不会自动释放。</p><h2 id="Socket-API-重构"><a href="#Socket-API-重构" class="headerlink" title="Socket API 重构"></a>Socket API 重构</h2><p>Java 中的 Socket 是从 Java1.0 开始就有的，是 Java 中不可或缺的网络 API，算起来已经服役 20 多年了。在这段时间内，信息技术已经发生了很多变化，这些上古 API 有一定的局限性，而且不容易维护和调试。</p><p>Java 的 Socket API 主要包括<code>java.net.ServerSocket</code>和<code>java.net.Socket</code>，<code>ServerSocket</code>用来监听连接请求的端口，连接成功后返回的是<code>Socket</code>对象，可以通过操作<code>Socket</code>对象实现数据发送和读取。Java 是通过<code>SocketImpl</code>实现这些功能。</p><p>在 Java13 之前，通过<code>SocketImpl</code>的子类<code>PlainSocketImpl</code>实现。在 Java13 中，引入<code>NioSocketImpl</code>实现，该实现以 NIO 为基础，与高速缓冲机制集成，实现非阻塞式网络。</p><p>如果想用回<code>PlainSocketImpl</code>，可以设置启动参数<code>-Djdk.net.usePlainSocketImpl=true</code>即可。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java13 新增的特性，完整的特性清单可以从<a href="https://openjdk.java.net/projects/jdk/13/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/13/</a>查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-13-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java13 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122932951" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java13 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文讲解一下 Java13 的特性，这个版本在语法特性上增加不多，值得关注的是两个预览功能：Switch 表达式和文本块，另外可以关乎的是性能优化方面的：动态类数据共享（CDS）存档、ZGC 动态释放未使用内存、Socket API 重构。这些方面可以看出，Java 的升级方向有两个，一是增加功能，增加新的语法特性；二是增强功能，提升已有功能性能。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java13" scheme="https://www.howardliu.cn/tags/Java13/"/>
    
  </entry>
  
  <entry>
    <title>从春运迁徙图看到的一些东西</title>
    <link href="https://www.howardliu.cn/2022-spring-festival/"/>
    <id>https://www.howardliu.cn/2022-spring-festival/</id>
    <published>2022-01-29T11:51:31.000Z</published>
    <updated>2022-01-29T11:51:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/bird-g81ab0101d_1920_20220129150731.jpeg" alt="从春运迁徙图看到的一些东西"></p><p>你好，我是看山。</p><p>腊月二十七宰鸡赶大集，响应国家号召，就地过年。</p><p>难免思乡，于是翻了翻百度地图提供的迁徙数据。我们从迁出地和迁徙趋势看一看这几年的春运变化。</p><a id="more"></a><p>我们先来看看从 2020 年到现在（2022 年）的春运迁徙图：</p><p><img src="https://static.howardliu.cn/raving/2020-spring-festival-travel-rush.png" alt="2020 年春运迁徙图"></p><p><img src="https://static.howardliu.cn/raving/2021-spring-festival-travel-rush.png" alt="2021 年春运迁徙图"></p><p><img src="https://static.howardliu.cn/raving/2022-spring-festival-travel-rush.png" alt="2022 年春运迁徙图"></p><p>从三张图中，我们不难看出一些规律，待我慢慢道来。</p><h2 id="春运热门迁出地"><a href="#春运热门迁出地" class="headerlink" title="春运热门迁出地"></a>春运热门迁出地</h2><p>这几年中，比较热门的迁出地有北京、上海、广州、深圳，稍微热门的是杭州、武汉、重庆、长沙、西安等。不难看出，热门迁出地对应着一线、新一线城市。这些城市的外来务工人员比较多，在春节选择回家过年。</p><p><img src="https://static.howardliu.cn/raving/bsgs.jpg" alt="北上广深"></p><p>其中，北上广深是一线城市，很多人或为生活、或为梦想，选择了一线城市打拼。辛苦一年，趁着年关回到家，无论家乡是好是孬，总归是一个平静的港湾。至于年后，是选择以梦为马潇洒天涯，还是选择背起行囊漂泊他乡，都是年后的事情。</p><p><img src="https://static.howardliu.cn/raving/2020city.jpg" alt="2020 年城市购买排行"></p><p>当人们在寻找工作和生活的平衡点时，很多城市也是快速发展，成为了新一线城市，成为了中国发展的新兴动力城市，也给了我们更多的选择。人们不在单纯的考虑收入，会更多的考虑感受、家人，更多的考虑幸福。</p><p>无论我们在哪，做什么，都是为了追求幸福，幸福才是我们心底最期望的东西。</p><p><img src="https://static.howardliu.cn/raving/happy.jpg" alt="幸福"></p><h2 id="疫情对迁徙的影响在减弱"><a href="#疫情对迁徙的影响在减弱" class="headerlink" title="疫情对迁徙的影响在减弱"></a>疫情对迁徙的影响在减弱</h2><p><img src="https://static.howardliu.cn/raving/2019-spring-festival-line-chart.png" alt="2019 年春运迁徙趋势图"></p><p>疫情发生前（2019 年），我们可以看到，年前迁移流量持续增长，大年初一稍微少了一点，到初六假期结束，迁移量达到峰值。我们以此为参照，看下疫情的影响。</p><p><img src="https://static.howardliu.cn/raving/2020-spring-festival-line-chart.png" alt="2020 年春运迁徙趋势图"></p><p>2020 年疫情爆发，武汉封城，春节期间全国人民上下齐心，共抗疫情。这个时候，春运流动基本上停止。作为普通民众，我们能够做到，就是待在家里，不给国家添麻烦。</p><p><img src="https://static.howardliu.cn/raving/2021-spring-festival-line-chart.png" alt="2021 年春运迁徙趋势图"></p><p>2021 年是疫情第二年，咱们国家提出的“清零”政策取得了好成绩，生活工作基本上恢复正常，也有了十一小长假出行旅游复苏的场景。外国友人们躲在家里看我们堵在路上，心里一定是各种羡慕。而且，在年底开始全员接种疫苗，给我们增加一层保障。</p><p>不过由于冬天天气转冷，病毒的存活能力增强，为了保住来之不易的战果。各地倡导就地过年。所以能够看到，春运的流量比 2019 年减少了将近一半。</p><p><img src="https://static.howardliu.cn/raving/2022-spring-festival-line-chart.png" alt="2022 年春运迁徙趋势图"></p><p>今年的春运刚刚开始，我们只能够根据趋势推测一下，到今天为止，迁徙流量的发展基本上和 2019 年相似。这不得不说在抗疫方面，2021 年取得了好成绩。全民接种加强针疫苗，各地的清零政策也是严格执行。虽然年底有些地方出现了本土疫情，但是都是在控制范围内，没有爆发的征兆。有了 2021 年春运、五一、十一等各种假期迁徙的经验，各地采取“有温度的严格控制”，让远在他乡想在春节回家的游子们，一解乡愁。</p><p>可以预见，等到了 2023 年春运的时候，我们可能就不再纠结能不能回、让不让回，只需要带着必要的证明，正常计划归乡日期就好。</p><p>按照习俗，给大家拜个早年，愿大家新年胜旧年，欢愉且胜意，万事尽可期。</p><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/2022-spring-festival/">从春运迁徙图看到的一些东西</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">从春运迁徙图看到的一些东西</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      腊月二十七宰鸡赶大集，响应国家号召，就地过年。难免思乡，于是翻了翻百度地图提供的迁徙数据。我们从迁出地和迁徙趋势看一看这几年的春运变化。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="春运" scheme="https://www.howardliu.cn/tags/%E6%98%A5%E8%BF%90/"/>
    
      <category term="迁徙" scheme="https://www.howardliu.cn/tags/%E8%BF%81%E5%BE%99/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java12 的新特性</title>
    <link href="https://www.howardliu.cn/java-12-features/"/>
    <id>https://www.howardliu.cn/java-12-features/</id>
    <published>2022-01-15T05:10:35.000Z</published>
    <updated>2022-01-15T05:10:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/lily-gf02d5baa4_1920.jpg" alt="Java12 的新特性"></p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>你好，我是看山。</p><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文讲解一下 Java12 的特性，作为第一个长期支持版 Java11 之后的第一个版本，增加的功能也不少，除了一些小幅度的 API 增强，增加了另一个试验阶段的垃圾收集器 Shenandoah、对 G1 做了优化、增加微基准套件等。</p><h2 id="语法特性"><a href="#语法特性" class="headerlink" title="语法特性"></a>语法特性</h2><p>Java12 提供了很多的语法特性，既有小而美的增强 API，又有特别方便的工具扩展。本节我们跟着代码看看比较好玩的功能。</p><h3 id="String-的增强方法：indent-和-transform"><a href="#String-的增强方法：indent-和-transform" class="headerlink" title="String 的增强方法：indent 和 transform"></a>String 的增强方法：indent 和 transform</h3><p>在 Java12 中，String 又增强了两个方法。之所以说又，是因为在 Java11 中已经增加过小而美的方法，想要详细了解的可以查看 <a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 新特性</a>。</p><p>这次增加的方法是<code>indent</code>（缩进）和<code>transform</code>（转换）。</p><p>顾名思义，<code>indent</code>方法是对字符串每行（使用<code>\r</code>或<code>\n</code>分隔）数据缩进指定空白字符，参数是 int 类型。</p><p>如果参数大于 0，就缩进指定数量的空格；如果参数小于 0，就将左侧的空字符删除指定数量，即右移。</p><p>我们看下源码：</p><pre><code class="java">public String indent(int n) {    if (isEmpty()) {        return &quot;&quot;;    }    Stream&lt;String&gt; stream = lines();    if (n &gt; 0) {        final String spaces = &quot; &quot;.repeat(n);        stream = stream.map(s -&gt; spaces + s);    } else if (n == Integer.MIN_VALUE) {        stream = stream.map(s -&gt; s.stripLeading());    } else if (n &lt; 0) {        stream = stream.map(s -&gt; s.substring(Math.min(-n, s.indexOfNonWhitespace())));    }    return stream.collect(Collectors.joining(&quot;\n&quot;, &quot;&quot;, &quot;\n&quot;));}</code></pre><p>这里会使用到 Java11 增加的<code>lines</code>、<code>repeat</code>、<code>stripLeading</code>等方法。<code>indent</code>最后会将多行数据通过<code>Collectors.joining(&quot;\n&quot;, &quot;&quot;, &quot;\n&quot;)</code>方法拼接，结果会有两点需要注意：</p><ul><li><code>\r</code>会被替换成<code>\n</code>；</li><li>如果原字符串是多行数据，最后一行的结尾没有<code>\n</code>，最后会补上一个<code>\n</code>，即多了一个空行。</li></ul><p>我们看下测试代码：</p><pre><code class="java">@Testvoid testIndent() {    final String text = &quot;\t\t\t 你好，我是看山。\n \u0020\u2005Java12 的 新特性。\r 欢迎三连+关注哟&quot;;    assertEquals(&quot;    \t\t\t 你好，我是看山。\n     \u0020\u2005Java12 的 新特性。\n    欢迎三连+关注哟、n&quot;, text.indent(4));    assertEquals(&quot;\t 你好，我是看山。\n\u2005Java12 的 新特性。\n 欢迎三连+关注哟、n&quot;, text.indent(-2));    final String text2 = &quot;山水有相逢&quot;;    assertEquals(&quot;山水有相逢&quot;, text2);}</code></pre><p>我们再来看看<code>transform</code>方法，源码一目了然：</p><pre><code class="java">public &lt;R&gt; R transform(Function&lt;? super String, ? extends R&gt; f) {    return f.apply(this);}</code></pre><p>通过传入的<code>Function</code>对当前字符串进行转换，转换结果由<code>Function</code>决定。比如，我们要对字符串反转：</p><pre><code class="java">@Testvoid testTransform() {    final String text = &quot;看山是山&quot;;    final String reverseText = text.transform(s -&gt; new StringBuilder(s).reverse().toString());    assertEquals(&quot;山是山看&quot;, reverseText);}</code></pre><p>其实这个方法在 Java8 中提供的<code>Optional</code>实现类似的功能（完整的 Optional 功能可以查看 <a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">Optional 的 6 种操作</a>）：</p><pre><code class="java">@Testvoid testTransform() {    final String text = &quot;看山是山&quot;;    final String reverseText2 = Optional.of(text)            .map(s -&gt; new StringBuilder(s).reverse().toString())            .orElse(&quot;&quot;);    assertEquals(&quot;山是山看&quot;, reverseText2);}</code></pre><h3 id="Files-的增强方法：mismatch"><a href="#Files-的增强方法：mismatch" class="headerlink" title="Files 的增强方法：mismatch"></a>Files 的增强方法：mismatch</h3><p>在 Java12 中，<code>Files</code>增加了<code>mismatch</code>方法，用于对比两个文件中的不相同字符的位置，如果内容相同，返回<code>-1L</code>，是<code>long</code>类型的。</p><p>我们来简单看下怎么用：</p><pre><code class="java">@Testvoid testMismatch() throws IOException {    final Path pathA = Files.createFile(Paths.get(&quot;a.txt&quot;));    final Path pathB = Files.createFile(Paths.get(&quot;b.txt&quot;));    // 写入相同内容    Files.write(pathA, &quot;看山&quot;.getBytes(), StandardOpenOption.WRITE);    Files.write(pathB, &quot;看山&quot;.getBytes(), StandardOpenOption.WRITE);    final long mismatch1 = Files.mismatch(pathA, pathB);    Assertions.assertEquals(-1L, mismatch1);    // 追加不同内容    Files.write(pathA, &quot;是山&quot;.getBytes(), StandardOpenOption.APPEND);    Files.write(pathB, &quot;不是山&quot;.getBytes(), StandardOpenOption.APPEND);    final long mismatch2 = Files.mismatch(pathA, pathB);    Assertions.assertEquals(6L, mismatch2);    Files.deleteIfExists(pathA);    Files.deleteIfExists(pathB);}</code></pre><p>我们可以看到，当第一次在两个文件中写入相同内容，执行<code>mismatch</code>方法返回的是<code>-1L</code>。当第二次追加进去不同的内容后，返回的是<code>6L</code>。之所以是 6，是因为测试代码中使用的字符集是<code>UTF-8</code>，大部分汉子是占用 3 个字符，前两个字相同，从第三个字开始不同，下标从 0 开始，所以开始位置是 6。</p><h3 id="Collectors-的增强方法：teeing"><a href="#Collectors-的增强方法：teeing" class="headerlink" title="Collectors 的增强方法：teeing"></a>Collectors 的增强方法：teeing</h3><p>我们看下<code>teeing</code>的定义：</p><pre><code class="java">public static &lt;T, R1, R2, R&gt; Collector&lt;T, ?, R&gt; teeing(    Collector&lt;? super T, ?, R1&gt; downstream1,    Collector&lt;? super T, ?, R2&gt; downstream2,    BiFunction&lt;? super R1, ? super R2, R&gt; merger)</code></pre><p>这个方法有三个参数，前两个是<code>Collector</code>对象，用于对输入数据进行预处理，第三个参数是<code>BiFunction</code>，用于将前两个处理后的结果作为参数传入<code>BiFunction</code>中，运算得到结果。</p><p>我们来看下例子：</p><pre><code class="java">@Testvoid testTeeing() {    var result = Stream.of(&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;)            .collect(Collectors.teeing(                    Collectors.filtering(n -&gt; n.contains(&quot;u&quot;), Collectors.toList()),                    Collectors.filtering(n -&gt; n.contains(&quot;n&quot;), Collectors.toList()),                    (list1, list2) -&gt; List.of(list1, list2)            ));    assertEquals(2, result.size());    assertTrue(isEqualCollection(List.of(&quot;Sunday&quot;, &quot;Tuesday&quot;), result.get(0)));    assertTrue(isEqualCollection(List.of(&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Wednesday&quot;), result.get(1)));}</code></pre><p>我们对输入的几个字符串进行过滤，然后将过滤结果组成一个新的队列。</p><h3 id="新工具：CompactNumberFormat"><a href="#新工具：CompactNumberFormat" class="headerlink" title="新工具：CompactNumberFormat"></a>新工具：CompactNumberFormat</h3><p>这个工具比较好玩，可以对数字进行按需格式化。提供了<code>public static NumberFormat getCompactNumberInstance(Locale locale, NumberFormat.Style formatStyle)</code>方法用于初始化：</p><ul><li>第一个参数是指定区域，不同区域展示的结果不同，比如中国展示汉字、美国展示英文；</li><li>第二个参数是指定展示结果的模式，分为<code>SHORT</code>和<code>LONG</code>，不过对于中文展示，似乎没啥区别。</li></ul><p>我们一起看下例子：</p><pre><code class="java">@Testvoid testFormat() {    final NumberFormat zhShort = NumberFormat.getCompactNumberInstance(Locale.CHINA, Style.SHORT);    assertEquals(&quot;1 万&quot;, zhShort.format(10_000));    assertEquals(&quot;1 兆&quot;, zhShort.format(1L &lt;&lt; 40));    final NumberFormat zhLong = NumberFormat.getCompactNumberInstance(Locale.CHINA, Style.LONG);    assertEquals(&quot;1 万&quot;, zhLong.format(10_000));    assertEquals(&quot;1 兆&quot;, zhLong.format(1L &lt;&lt; 40));    final NumberFormat usShort = NumberFormat.getCompactNumberInstance(Locale.US, Style.SHORT);    usShort.setMaximumFractionDigits(2);    assertEquals(&quot;10K&quot;, usShort.format(10_000));    assertEquals(&quot;1.1T&quot;, usShort.format(1L &lt;&lt; 40));    final NumberFormat usLong = NumberFormat.getCompactNumberInstance(Locale.US, Style.LONG);    usLong.setMaximumFractionDigits(2);    assertEquals(&quot;10 thousand&quot;, usLong.format(10_000));    assertEquals(&quot;1.1 trillion&quot;, usLong.format(1L &lt;&lt; 40));}</code></pre><p>我们也可以继续使用<code>NumberFormat</code>中的方法定义，比如示例中保留小数点后 2 位。</p><h2 id="Shenandoah：一个低停顿垃圾收集器"><a href="#Shenandoah：一个低停顿垃圾收集器" class="headerlink" title="Shenandoah：一个低停顿垃圾收集器"></a>Shenandoah：一个低停顿垃圾收集器</h2><p>Java12 引入了一个实验阶段的垃圾收集器：Shenandoah，作为一个低停顿的垃圾收集器。</p><p>Shenandoah 垃圾收集器是 RedHat 在 2014 年宣布进行的垃圾收集器研究项目，其工作原理是通过与 Java 应用执行线程同时运行来降低停顿时间。简单的说就是，Shenandoah 工作时与应用程序线程并发，通过交换 CPU 并发周期和空间以改善停顿时间，使得垃圾回收器执行线程能够在 Java 线程运行时进行堆压缩，并且标记和整理能够同时进行，因此避免了在大多数 JVM 垃圾收集器中所遇到的问题。</p><p><img src="https://static.howardliu.cn/java/shenandoah-gc-cycle.png" alt="Shenandoah GC"></p><p>Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200MB 还是 200GB，都将拥有一致的系统暂停时间，不过实际使用性能将取决于实际工作堆的大小和工作负载。</p><p>Java12 中 Shenandoah 处于实验阶段，想要使用需要编译时添加<code>--with-jvm-features=shenandoahgc</code>，然后启动时使用<code>-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC</code>以开启。</p><p>后续会补充 Java 中各种垃圾收集器的文章，其中会有介绍 Shenandoah 的，敬请关注公众号「看山的小屋」。如果想要提前了解，欢迎访问<a href="https://wiki.openjdk.java.net/display/shenandoah" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/shenandoah</a>。</p><h2 id="增加一套基准测试套件"><a href="#增加一套基准测试套件" class="headerlink" title="增加一套基准测试套件"></a>增加一套基准测试套件</h2><p>Java12 中添加一套基准测试套件，该基准测试套件基于 JMH（Java Microbenchmark Harness），使开发人员可以轻松运行现有的基准测试并创建新的基准测试，其目标是提供一个稳定且优化的基准。</p><p>在这套基准测试套件中包括将近 100 个基准测试的初始集合，并且能够轻松添加新基准、更新基准测试和提高查找已有基准测试的便利性。</p><p>微基准套件与 JDK 源代码位于同一个目录中，并且在构建后将生成单个 Jar 文件。它是一个单独的项目，在支持构建期间不会执行，以方便开发人员和其他对构建微基准套件不感兴趣的人在构建时花费比较少的构建时间。</p><h2 id="Switch-表达式扩展（预览版）"><a href="#Switch-表达式扩展（预览版）" class="headerlink" title="Switch 表达式扩展（预览版）"></a>Switch 表达式扩展（预览版）</h2><p>Switch 语句出现的姿势是条件判断、流程控制组件，与现在很流行的新语言对比，其写法显得非常笨拙，所以 Java 推出了 Switch 表达式语法，可以让我们写出更加简化的代码。这个扩展在 Java12 中作为预览版首次引入，需要在编译时增加<code>-enable-preview</code>开启，在 Java14 中正式提供，功能编号是 <a href="https://openjdk.java.net/jeps/361" target="_blank" rel="noopener">JEP 361</a>。</p><p>比如，我们通过 switch 语法简单计算工作日、休息日，在 Java12 之前需要这样写：</p><pre><code class="java">@Testvoid testSwitch() {    final DayOfWeek day = DayOfWeek.from(LocalDate.now());    String typeOfDay = &quot;&quot;;    switch (day) {        case MONDAY:        case TUESDAY:        case WEDNESDAY:        case THURSDAY:        case FRIDAY:            typeOfDay = &quot;Working Day&quot;;            break;        case SATURDAY:        case SUNDAY:            typeOfDay = &quot;Rest Day&quot;;            break;    }    Assertions.assertFalse(typeOfDay.isEmpty());}</code></pre><p>在 Java12 中的 Switch 表达式中，我们可以直接简化：</p><pre><code class="java">@Testvoid testSwitchExpression() {    final DayOfWeek day = DayOfWeek.SATURDAY;    final String typeOfDay = switch (day) {        case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; &quot;Working Day&quot;;        case SATURDAY, SUNDAY -&gt; &quot;Day Off&quot;;    };    Assertions.assertEquals(&quot;Day Off&quot;, typeOfDay);}</code></pre><p>是不是很清爽。文末提供的源码中，<code>pom.xml</code>定义的<code>maven.compiler</code>版本写的是<code>14</code>，这是因为 Switch 表达式是 Java14 正式提供，我没有重新编译 Java，所以只能指定 Java14 来实现这个功能代码的演示。</p><h2 id="引入-JVM-常量-API"><a href="#引入-JVM-常量-API" class="headerlink" title="引入 JVM 常量 API"></a>引入 JVM 常量 API</h2><p>Java12 中引入 JVM 常量 API，用来更容易地对关键类文件和运行时构件的描述信息进行建模，特别是对那些从常量池加载的常量，这是一项非常技术性的变化，能够以更简单、标准的方式处理可加载常量。</p><p>具体来说就是<code>java.base</code>模块新增了<code>java.lang.constant</code>包，引入了<code>ConstantDesc</code>接口以及<code>Constable</code>接口。<code>ConstantDesc</code>的子接口包括：</p><ul><li><code>ClassDesc</code>：Class 的可加载常量标称描述符；</li><li><code>MethodTypeDesc</code>：方法类型常量标称描述符；</li><li><code>MethodHandleDesc</code>：方法句柄常量标称描述符；</li><li><code>DynamicConstantDesc</code>：动态常量标称描述符。</li></ul><p>继续挖坑，这部分内容会在进阶篇再详细介绍，敬请关注公众号「看山的小屋」。</p><h2 id="改进-AArch64-实现"><a href="#改进-AArch64-实现" class="headerlink" title="改进 AArch64 实现"></a>改进 AArch64 实现</h2><p>Java12 中将只保留一套 AArch64 实现，之前版本中，有两个关于 aarch64 的实现，分别是<code>ope/src/hotspot/cpu/arm</code>以及<code>open/src/hotspot/cpu/aarch64</code>，它们的实现重复了。为了集中精力更好地实现 aarch64，删除了<code>open/src/hotspot/cpu/arm</code>中与 arm64（64-bit Arm platform）实现相关的代码，只保留 32 位 ARM 端口和 64 位 aarch64 的端口。</p><p>这样做，可以让开发人员将目标集中在剩下的这个 64 位 ARM 实现上，消除维护两套端口所需的重复工作。</p><p>目标聚焦，力量集中。</p><h2 id="默认使用类数据共享（CDS）存档"><a href="#默认使用类数据共享（CDS）存档" class="headerlink" title="默认使用类数据共享（CDS）存档"></a>默认使用类数据共享（CDS）存档</h2><p>在 <a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a> 中我们介绍过类数据共享（CDS，Class Data Sharing），其作用是通过构建时生成默认类列表，在运行时使用内存映射，减少 Java 的启动时间和减少动态内存占用量，也能在多个 Java 虚拟机之间共享相同的归档文件，减少运行时的资源占用。</p><p>在 Java12 之前，想要使用需要三步走手动开启，到了 Java12，将默认开启 CDS 功能，想要关闭，需要使用参数<code>-Xshare:off</code>。</p><h2 id="改善-G1-垃圾收集器"><a href="#改善-G1-垃圾收集器" class="headerlink" title="改善 G1 垃圾收集器"></a>改善 G1 垃圾收集器</h2><h3 id="能够中止收集"><a href="#能够中止收集" class="headerlink" title="能够中止收集"></a>能够中止收集</h3><p>G1 垃圾收集器可以在大内存多处理器的工作场景中提升回收效率，能够满足用户预期降低 STW 停顿时间。</p><p>其内部是采用一个高级分析引擎来选择在收集期间要处理的工作量，此选择过程的结果是一组称为 GC 回收集（collection set，CSet）的区域。一旦收集器确定了 GC 回收集 并且 GC 回收、整理工作已经开始，则 G1 收集器必须完成收集集合集的所有区域中的所有活动对象之后才能停止；但是如果收集器选择过大的 GC 回收集，可能会导致 G1 回收器停顿时间超过预期时间。</p><p>在 Java12 中，GC 回收集拆分为必需和可选两部分，使 G1 垃圾回收器能中止垃圾回收过程。其中必需处理的部分包括 G1 垃圾收集器不能递增处理的 GC 回收集的部分，同时也可以包含老年代以提高处理效率。在 G1 垃圾回收器完成收集需要必需回收的部分之后，G1 垃圾回收器可以根据剩余时间决定是否停止收集。</p><h3 id="向操作系统自动返回未用堆内存"><a href="#向操作系统自动返回未用堆内存" class="headerlink" title="向操作系统自动返回未用堆内存"></a>向操作系统自动返回未用堆内存</h3><p>在 Java11 中，G1 仅在进行 Full GC 或并发处理周期时才能向操作系统返还堆内存，但是这两种场景都是 G1 极力避免的，所以如果我们使用 G1 收集器，基本上很难返还 Java 堆内存，这样对于那种周期性执行大量占用内存的应用，会造成比较多的内存浪费。</p><p>Java12 中，G1 垃圾收集器将在应用程序不活动期间定期生成或持续循环检查整体 Java 堆使用情况，以便 G1 垃圾收集器能够更及时的将 Java 堆中不使用内存部分返还给操作系统。对于长时间处于空闲状态的应用程序，此项改进将使 JVM 的内存利用率更加高效。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java12 新增的特性，完整的特性清单可以从<a href="https://openjdk.java.net/projects/jdk/12/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/12/</a>查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-12-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java12 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122530460" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java12 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文讲解一下 Java12 的特性，作为第一个长期支持版 Java11 之后的第一个版本，增加的功能也不少，除了一些小幅度的 API 增强，增加了另一个试验阶段的垃圾收集器 Shenandoah、对 G1 做了优化、增加微基准套件等。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java12" scheme="https://www.howardliu.cn/tags/Java12/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java11 的新特性</title>
    <link href="https://www.howardliu.cn/java-11-features/"/>
    <id>https://www.howardliu.cn/java-11-features/</id>
    <published>2022-01-09T14:09:15.000Z</published>
    <updated>2022-01-09T14:09:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/animal-gb69e2a049_1920.jpg" alt="Java11 的新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java11 是 2018 年 9 月发布的，是自 Java8 之后第一个长期支持版（long-term support，LTS）。相比于其他版本 6 个月维护期，长期支持版的维护期是 3 年。</p><p>长期支持版的更新会比较多，而且都是相对稳定的更新。今天我们就一起看看 Java11 都有哪些喜人的变化：增强的 API、全新的 HTTP 客户端、<a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">基于嵌套关系的访问控制优化</a>、低开销的堆性能采用工具、ZGC、Epsilon 垃圾收集器、飞行记录器等。</p><h2 id="增强-String"><a href="#增强-String" class="headerlink" title="增强 String"></a>增强 String</h2><p>首先说下<code>String</code>中新增的方法：<code>repeat</code>、<code>strip</code>、<code>stripLeading</code>、<code>stripTrailing</code>、<code>isBlank</code>、<code>lines</code>。这些方法还是挺有用的，以前我们可能需要借助第三方类库（比如 Apache 出品的 commons-lang）中的工具类，现在可以直接使用嫡亲方法了。</p><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><p><code>repeat</code>是实例方法，顾名思义，这个方法是返回给定字符串的重复值的，参数是<code>int</code>类型，传参的时候需要注意：</p><ul><li>如果重复次数小于 0 会抛出<code>IllegalArgumentException</code>异常；</li><li>如果重复次数为 0 或者字符串本身是空字符串，将返回空字符串；</li><li>如果重复次数为 1 直接返回本身；</li><li>如果字符串重复指定次数后，长度超过<code>Integer.MAX_VALUE</code>，会抛出<code>OutOfMemoryError</code>错误。</li></ul><p>用法很简单：</p><pre><code class="java">@Testvoid testRepeat() {    String output = &quot;foo &quot;.repeat(2) + &quot;bar&quot;;    assertEquals(&quot;foo foo bar&quot;, output);}</code></pre><p>小而美的一个工具方法。</p><h3 id="strip、stripLeading、stripTrailing"><a href="#strip、stripLeading、stripTrailing" class="headerlink" title="strip、stripLeading、stripTrailing"></a>strip、stripLeading、stripTrailing</h3><p><code>strip</code>方法算是<code>trim</code>方法的增强版，<code>trim</code>方法可以删除字符串两侧的空白字符（空格、tab 键、换行符），但是对于<code>Unicode</code>的空白字符无能为力，<code>strip</code>补足这一短板。</p><p>用起来是这样的：</p><pre><code class="java">@Testvoid testTrip() {    final String output = &quot;\n\t  hello   \u2005&quot;.strip();    assertEquals(&quot;hello&quot;, output);    final String trimOutput = &quot;\n\t  hello   \u2005&quot;.trim();    assertEquals(&quot;hello   \u2005&quot;, trimOutput);}</code></pre><p>对比一下可以看到，<code>trim</code>方法的清理功能稍弱。</p><p><code>stripLeading</code>和<code>stripTrailing</code>与<code>strip</code>类似，区别是一个清理头，一个清理尾。用法如下：</p><pre><code class="java">@Testvoid testTripLeading() {    final String output = &quot;\n\t  hello   \u2005&quot;.stripLeading();    assertEquals(&quot;hello   \u2005&quot;, output);}@Testvoid testTripTrailing() {    final String output = &quot;\n\t  hello   \u2005&quot;.stripTrailing();    assertEquals(&quot;\n\t  hello&quot;, output);}</code></pre><h3 id="isBlank"><a href="#isBlank" class="headerlink" title="isBlank"></a>isBlank</h3><p>这个方法是用于判断字符串是否都是空白字符，除了空格、tab 键、换行符，也包括<code>Unicode</code>的空白字符。</p><p>用法很简单：</p><pre><code class="java">@Testvoid testIsBlank() {    assertTrue(&quot;\n\t\u2005&quot;.isBlank());}</code></pre><h3 id="lines"><a href="#lines" class="headerlink" title="lines"></a>lines</h3><p>最后这个方法是将字符串转化为字符串<code>Stream</code>类型，字符串分隔依据是换行符：<code>\n</code>、<code>\r</code>、<code>\r\n</code>，用法如下：</p><pre><code class="java">@Testvoid testLines() {    final String multiline = &quot;This is\n \na multiline\nstring.&quot;;    final String output = multiline.lines()            .filter(Predicate.not(String::isBlank))            .collect(Collectors.joining(&quot; &quot;));    assertEquals(&quot;This is a multiline string.&quot;, output);}</code></pre><h2 id="增强文件读写"><a href="#增强文件读写" class="headerlink" title="增强文件读写"></a>增强文件读写</h2><p>本次更新在<code>Files</code>中增加了两个方法：<code>readString</code>和<code>writeString</code>。<code>writeString</code>作用是将指定字符串写入文件，<code>readString</code>作用是从文件中读出内容到字符串。是一个对<code>Files</code>工具类的增强，封装了对输出流、字节等内容的操作。</p><p>用法比较简单：</p><pre><code class="java">@Testvoid testReadWriteString() throws IOException {    final Path tmpPath = Path.of(&quot;./&quot;);    final Path tempFile = Files.createTempFile(tmpPath, &quot;demo&quot;, &quot;.txt&quot;);    final Path filePath = Files.writeString(tempFile, &quot;看山 howardliu.cn\n 公众号：看山的小屋&quot;);    assertEquals(tempFile, filePath);    final String fileContent = Files.readString(filePath);    assertEquals(&quot;看山 howardliu.cn\n 公众号：看山的小屋&quot;, fileContent);    Files.deleteIfExists(filePath);}</code></pre><p><code>readString</code>和<code>writeString</code>还可以指定字符集，不指定默认使用<code>StandardCharsets.UTF_8</code>字符集，可以应对大部分场景了。</p><h2 id="增强集合的数组操作"><a href="#增强集合的数组操作" class="headerlink" title="增强集合的数组操作"></a>增强集合的数组操作</h2><p><code>java.util.Collection</code>提供了集合转数组的方法有两个：</p><ul><li><code>Object[] toArray()</code>：可以直接转数组，但是转换后是<code>Object</code>类型，后续使用的时候，需要强转，太不优雅了；</li><li><code>&lt;T&gt; T[] toArray(T[] a)</code>：传入一个指定类型的数组，一般会有另种实现：<ul><li>一是，如果传入数组长度小于列表长度，会借助<code>Arrays.copyOf</code>创建列表长度的数组，这个数组与传入数组参数没有关系</li><li>二是，如果传入数组长度大于等于列表长度，会借助<code>System.arraycopy</code>将列表写入数组，超过长度的数组元素置为<code>null</code>。</li></ul></li></ul><p>我们一般这样用：</p><pre><code class="java">@Testvoid testArray() {    final List&lt;String&gt; vars = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);    final Object[] objArray = vars.toArray();    final String[] strArray = vars.toArray(new String[0]);    Assertions.assertTrue(Arrays.asList(strArray).contains(&quot;1&quot;));    Assertions.assertTrue(Arrays.asList(strArray).contains(&quot;2&quot;));    Assertions.assertTrue(Arrays.asList(strArray).contains(&quot;3&quot;));}</code></pre><p>在 Java11 中，又新增了一种实现，相当于对<code>&lt;T&gt; T[] toArray(T[] a)</code>做了增强，其源码是：</p><pre><code class="java">default &lt;T&gt; T[] toArray(IntFunction&lt;T[]&gt; generator) {    return toArray(generator.apply(0));}</code></pre><p>可以看到，是通过传入一个<code>IntFunction</code>类型的函数，然后调用<code>&lt;T&gt; T[] toArray(T[] a)</code>创建数组，其实是采用了我们常用的给<code>toArray</code>传入空数组的方式，用法如下：</p><pre><code class="java">@Testvoid testArray() {    final List&lt;String&gt; vars = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);    final String[] strArray2 = vars.toArray(String[]::new);    Assertions.assertTrue(Arrays.asList(strArray2).contains(&quot;1&quot;));    Assertions.assertTrue(Arrays.asList(strArray2).contains(&quot;2&quot;));    Assertions.assertTrue(Arrays.asList(strArray2).contains(&quot;3&quot;));}</code></pre><p>从使用上，似乎没有太多的提升，但是写法上，使用了函数式编程，是不是很优雅。</p><p><img src="https://static.howardliu.cn/Illustration/smile_1.jpg" alt="优雅的假笑"></p><h2 id="增强函数-Predicate"><a href="#增强函数-Predicate" class="headerlink" title="增强函数 Predicate"></a>增强函数 Predicate</h2><p>这个也是方法增强，在以前，我们在<code>Stream</code>中的<code>filter</code>方法判断否的时候，一般需要<code>!</code>运算，比如我们想要找到字符串列表中的数字，可以这样写：</p><pre><code class="java">final List&lt;String&gt; list = Arrays.asList(&quot;1&quot;, &quot;a&quot;);final List&lt;String&gt; nums = list.stream()        .filter(NumberUtils::isDigits)        .collect(Collectors.toList());Assertions.assertEquals(1, nums.size());Assertions.assertTrue(nums.contains(&quot;1&quot;));</code></pre><p>想要找到非数字的，<code>filter</code>方法写的就会用到<code>!</code>非操作：</p><pre><code class="java">final List&lt;String&gt; notNums = list.stream()        .filter(x -&gt; !NumberUtils.isDigits(x))        .collect(Collectors.toList());Assertions.assertEquals(1, notNums.size());Assertions.assertTrue(notNums.contains(&quot;a&quot;));</code></pre><p>Java11 中为<code>Predicate</code>增加<code>not</code>方法，可以更加简单的实现非操作：</p><pre><code class="java">final List&lt;String&gt; notNums2 = list.stream()        .filter(Predicate.not(NumberUtils::isDigits))        .collect(Collectors.toList());Assertions.assertEquals(1, notNums2.size());Assertions.assertTrue(notNums2.contains(&quot;a&quot;));</code></pre><p>有些教程还会推崇静态引入，比如在头部使用<code>import static java.util.function.Predicate.not</code>，这样在函数式编程时，可以写更少的代码，语义更强，比如：</p><pre><code class="java">final List&lt;String&gt; notNums2 = list.stream()        .filter(not(NumberUtils::isDigits))        .collect(toList());</code></pre><p>喜好随人，没有优劣。</p><h2 id="Lambda-中的局部变量"><a href="#Lambda-中的局部变量" class="headerlink" title="Lambda 中的局部变量"></a>Lambda 中的局部变量</h2><p>局部变量是 Java10 中增加的特性，具体可以查看 <a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a> 中的介绍，但是不支持在 Lambda 中使用局部变量。</p><p>在 Lambda 中，我们可以这样操作：</p><pre><code class="java">(String s1, String s2) -&gt; s1 + s2</code></pre><p>也可以这样：</p><pre><code class="java">(s1, s2) -&gt; s1 + s2</code></pre><p>到 Java11 之后，我们还能这样：</p><pre><code class="java">(var s1, var s2) -&gt; s1 + s2</code></pre><p>单纯从语法上，似乎没啥特点，但是如果再加上一些别的用法，比如：</p><pre><code class="java">(@Nonnull var s1, @Nullable var s2) -&gt; s1 + s2</code></pre><p>是不是就能看出差别了，我们可以有如下的操作：</p><pre><code class="java">@Testvoid testLocalVariable() {    final List&lt;String&gt; sampleList = Arrays.asList(&quot;Hello&quot;, &quot;World&quot;);    final String resultString = sampleList.stream()            .map((@NotNull var x) -&gt; x.toUpperCase())            .collect(Collectors.joining(&quot;, &quot;));    Assertions.assertEquals(&quot;HELLO, WORLD&quot;, resultString);}</code></pre><p>不过，这里还是有一些限制，比如：</p><p>如果是多个参数，不能有的使用<code>var</code>修饰，有的不指定类型：</p><pre><code class="java">// 错误写法(var s1, s2) -&gt; s1 + s2</code></pre><p>或者，不能混合使用，一个使用<code>var</code>修饰，一个使用明确的类型：</p><pre><code class="java">// 错误写法(var s1, String s2) -&gt; s1 + s2</code></pre><p>如果是单个参数，如果是单行操作，我们可以不写<code>{}</code>，但是使用<code>var</code>修饰的时候，就不能省略<code>{}</code>了：</p><pre><code class="java">// 错误写法var s1 -&gt; s1.toUpperCase()</code></pre><p>还是有一些限制的，我们在便利的同时，需要符合一定的约束。自由和规范不冲突。</p><h2 id="转正的-HTTP-客户端"><a href="#转正的-HTTP-客户端" class="headerlink" title="转正的 HTTP 客户端"></a>转正的 HTTP 客户端</h2><p>在 <a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a> 中说过，Java 中有一个全新的 HTTP 客户端，当时还在孵化模块中，到 Java11 可以正式使用了。</p><p>新客户端用法简单、性能可靠，而且支持功能也多。我们先简单看下使用：</p><pre><code class="java">@Testvoid testHttpClient() throws IOException, InterruptedException {    final HttpClient httpClient = HttpClient.newBuilder()            .version(HttpClient.Version.HTTP_2)            .connectTimeout(Duration.ofSeconds(20))            .build();    final HttpRequest httpRequest = HttpRequest.newBuilder()            .GET()            .uri(URI.create(&quot;https://www.howardliu.cn/robots.txt&quot;))            .build();    final HttpResponse&lt;String&gt; httpResponse = httpClient.send(httpRequest, BodyHandlers.ofString());    final String responseBody = httpResponse.body();    assertTrue(responseBody.contains(&quot;Allow&quot;));}</code></pre><h2 id="基于嵌套关系的访问控制优化"><a href="#基于嵌套关系的访问控制优化" class="headerlink" title="基于嵌套关系的访问控制优化"></a>基于嵌套关系的访问控制优化</h2><p>这部分是遗留的技术债务，从 Java1.1 开始，到 Java11 修复，属于 Valhalla 项目的一部分，我们在 <a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a> 一文中有详细解释，这里就不再赘述了。</p><h2 id="增强-java-命令"><a href="#增强-java-命令" class="headerlink" title="增强 java 命令"></a>增强 java 命令</h2><p>在 Java11 之前，想要运行源文件，需要先通过<code>javac</code>命令编译，然后使用<code>java</code>命令运行，先可以直接使用<code>java</code>运行了：</p><pre><code class="java">$ java HelloWorld.javaHello Java 11!</code></pre><h2 id="动态类文件常量"><a href="#动态类文件常量" class="headerlink" title="动态类文件常量"></a>动态类文件常量</h2><p>为了使 JVM 对动态语言更具吸引力，Java 指令集引入了 invokedynamic。</p><p>不过 Java 开发人员通常不会注意到此功能，因为它隐藏在 Java 字节代码中。通过使用 invokedynamic，可以延迟方法调用的绑定。例如，Java 语言使用该技术来实现 Lambda 表达式，这些表达式仅在首次使用时才显示出来。这样做，invokedynamic 已经演变成一种必不可少的语言功能。</p><p>Java 11 引入了类似的机制，扩展了 Java 文件格式，以支持新的常量池：CONSTANT_Dynamic，它在初始化的时候，像 invokedynamic 指令生成代理方法一样，委托给 bootstrap 方法进行初始化创建，对上层软件没有很大的影响，降低开发新形式的可实现类文件约束带来的成本和干扰。</p><p>此功能可提高性能，并面向语言设计人员和编译器实现人员。</p><h2 id="低开销的堆性能采用工具"><a href="#低开销的堆性能采用工具" class="headerlink" title="低开销的堆性能采用工具"></a>低开销的堆性能采用工具</h2><p>Java 11 中提供一种低开销的 Java 堆分配采样方法，能够得到堆分配的 Java 对象信息，并且能够通过 JVMTI 访问堆信息。</p><p>引入这个低开销内存分析工具是为了达到如下目的：</p><ul><li>足够低的开销，可以默认且一直开启；</li><li>能通过定义好的程序接口访问；</li><li>能够对所有堆分配区域进行采样；</li><li>能给出正在和未被使用的 Java 对象信息。</li></ul><p>对用户来说，了解堆中内存分布是非常重要的，特别是遇到生产环境中出现的高 CPU、高内存占用率的情况。目前有一些已经开源的工具，允许用户分析应用程序中的堆使用情况，比如：Java Flight Recorder、jmap、YourKit 以及 VisualVM tools.。但是这些工具都有一个明显的不足之处：无法得到对象的分配位置，headp dump 以及 heap histogram 中都没有包含对象分配的具体信息，但是这些信息对于调试内存问题至关重要，因为它能够告诉开发人员他们的代码中发生的高内存分配的确切位置，并根据实际源码来分析具体问题，这也是 Java 11 中引入这种低开销堆分配采样方法的原因。</p><h2 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h2><p>ZGC 是一个可伸缩、低延迟的垃圾收集器，性能由于 G1 收集器，从 Java11 开始可以在 Linux/x64 平台体验，全平台支持是从 Java17 开始。详细介绍可以从<a href="https://wiki.openjdk.java.net/display/zgc/Main" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/zgc/Main</a>查看。</p><p>在 Java11 中尚处于试验阶段，没有包含在 JDK 构建中，想要启用，需要在 JDK 编译时添加参数<code>--with-jvm-features=zgc</code>。显式启用了 ZGC 之后，我们可以使用构建好的 JDK 启动，需要添加参数<code>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code>。</p><p>ZGC 有下面几个目标：</p><ul><li>GC 停顿时间不超过 10ms</li><li>可以处理从几百 MB 的小堆，到几个 TB 的大堆</li><li>与 G1 回收算法相比，应用吞吐能力不会下降超过 15%</li><li>为未来的 GC 特性和优化有色指针和负载屏障奠定基础</li></ul><p>从<a href="https://openjdk.java.net/jeps/333" target="_blank" rel="noopener">https://openjdk.java.net/jeps/333</a>给出的数据可以看出来，在 128G 堆大小的测试中，ZGC 优势明显，找了一张网上的图片：</p><p><img src="https://static.howardliu.cn/java/java-11-1.png" alt="SPECjbb 2015 的基准测试"></p><p>这里预告一下，Java12 中也增加了一个实现阶段的垃圾收集器 Shenandoah，到时候咱们看一下。</p><h2 id="改进-Aarch64-指令集"><a href="#改进-Aarch64-指令集" class="headerlink" title="改进 Aarch64 指令集"></a>改进 Aarch64 指令集</h2><p>Java 11 优化了 ARM64 或 Arch64 处理器上现有的字符串和数组内部函数。还为<code>java.lang.Math</code>的<code>sin</code>、<code>cos</code>和<code>log</code>方法实现了新的内部函数。</p><p>我们像其他函数一样使用内在函数，但是，编译器会以特殊的方式处理内部函数，将使用 CPU 体系结构特定的汇编代码来提高性能。可以关注一下<code>HotSpotIntrinsicCandidate</code>这个注解。</p><h2 id="Epsilon-垃圾收集器"><a href="#Epsilon-垃圾收集器" class="headerlink" title="Epsilon 垃圾收集器"></a>Epsilon 垃圾收集器</h2><p>Java11 引入了一个新的实验性垃圾收集器：Epsilon。Epsilon 垃圾收集器提供一个完全消极的 GC 实现，分配有限的内存资源，最大限度的降低内存占用和内存吞吐延迟时间，适用于模拟内存不足错误的场景。</p><p>Epsilon 垃圾收集器有几个使用场景：</p><ul><li>性能测试：无操作的垃圾收集器可以过滤因为收集器自身原因造成的性能损失；</li><li>内存压力测试：可以用于验证分配内存的阈值；</li><li>VM 接口测试：以 VM 开发视角，有一个简单的 GC 实现，有助于理解 VM-GC 的最小接口实现。它也用于证明 VM-GC 接口的健全性；</li><li>存活极短的任务：这种生命周期极短的任务，需要实现快速启动、快速释放资源的特性。开发者知道这种任务的内存阈值是多少，很大概率上，任务存活周期内，不会触发垃圾回收，就需要一个什么也不干的收集器站着位置就行。</li></ul><p>可以通过<code>-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC</code>参数开启。</p><h2 id="飞行记录器（Flight-Recorder）"><a href="#飞行记录器（Flight-Recorder）" class="headerlink" title="飞行记录器（Flight Recorder）"></a>飞行记录器（Flight Recorder）</h2><p>飞行记录器（Flight Recorder）可是个好东西，之前是 Oracle JDK 中的一个商用产品，现已在 Open JDK 中开源。这是一种低开销的事件信息收集框架，主要用于对应用程序和 JVM 进行故障检查、分析。</p><p>飞行记录器记录的主要数据源于应用程序、JVM 和操作系统，这些事件信息保存在单独的事件记录文件中，故障发生后，能够从事件记录文件中提取出有用信息对故障进行分析。有些类似于飞机上的黑匣子。</p><p><img src="https://static.howardliu.cn/Illustration/800.jpeg" alt="飞机上的黑匣子"></p><p>比如，我们可以使用以下参数开启一个时长为 120 秒的记录：</p><pre><code class="shell">-XX:StartFlightRecording=duration=120s,settings=profile,filename=recording.jfr</code></pre><p>生成的文件可以使用 JMC 工具可视化查看，也可以自己写代码通过<code>RecordedEvent</code>解析。不过嘛，有可视化的，干嘛还要自己敲代码呢？</p><p>我们也可以在运行时通过<code>jcmd</code>命令启动记录：</p><pre><code class="shell">$ jcmd &lt;pid&gt; JFR.start$ jcmd &lt;pid&gt; JFR.dump filename=recording.jfr$ jcmd &lt;pid&gt; JFR.stop</code></pre><p>收到监控，想推广一下之前写的开源监控组件 Cynomys，源码在<a href="https://github.com/howardliu-cn/cynomys" target="_blank" rel="noopener">https://github.com/howardliu-cn/cynomys</a>，里面包含通过 Netty 实现的 RPC 框架、javaagent 实现的探针、使用 javassist 操作字节码、JMX 实现 JVM 内部监控等，可以对操作系统、网络、JVM、请求、SQL 等内容进行监控。</p><h2 id="移除或过期组件"><a href="#移除或过期组件" class="headerlink" title="移除或过期组件"></a>移除或过期组件</h2><p>社会在发展，技术在进步。又有一些功能或组件不合时宜，要么移除、要么标记过期。标记过期的最好不要再用了，不知道哪天就会被移除，想要升级依赖反而麻烦。</p><ul><li>JavaEE 和 CORBA：单独的 JavaEE 版本可以从第三方站点获取，所以在 JavaSEO 中不再包含。从 Java9 开始，JavaEE 和 CORBA 模块已经标记为过期，到 Java11 就完全移除。</li><li>JMC 从 JDK 中移除，可以单独下载。</li><li>JavaFX 也是这样，从 JDK 模块从中移除，需要单独引入。</li><li>Nashorn JavaScript 引擎标记为废弃</li><li>Jar 包的 Pack200 压缩方案标记为废弃</li></ul><h2 id="其他小改动"><a href="#其他小改动" class="headerlink" title="其他小改动"></a>其他小改动</h2><ul><li>实现了新的 ChaCha20 和 ChaCha20-Poly1305 加密算法，取代不安全的 RC4。</li><li>使用 Curve25519 和 Curve448 支持加密密钥协议，以取代现有的 ECDH 方案</li><li>升级 TLS 版本到 1.3，提升了安全性和性能</li><li>支持 Unicode 10， 带来了更多的字符、符号和表情符号</li></ul><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java11 新增的特性，完整的特性清单可以从<a href="https://openjdk.java.net/projects/jdk/11/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/11/</a>查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-11-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java11 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122401213" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java11 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      今天我们就一起看看 Java11 都有哪些喜人的变化：增强的 API、全新的 HTTP 客户端、[基于嵌套关系的访问控制优化](https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA)、低开销的堆性能采用工具、ZGC、Epsilon 垃圾收集器、飞行记录器等。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java11" scheme="https://www.howardliu.cn/tags/Java11/"/>
    
  </entry>
  
  <entry>
    <title>Java11 中基于嵌套关系的访问控制优化</title>
    <link href="https://www.howardliu.cn/java-11-jep181-nestmate/"/>
    <id>https://www.howardliu.cn/java-11-jep181-nestmate/</id>
    <published>2022-01-05T14:57:16.000Z</published>
    <updated>2022-01-05T14:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/rowan-2098486_1920.jpg" alt="Java11 中基于嵌套的权限控制"></p><p>你好，我是看山。</p><p>Java 语言很强大，但是，有人的地方就有江湖，有猿的地方就有 bug，Java 的核心代码并非十全十美。比如在 <a href="https://mp.weixin.qq.com/s/4jVPnaOr-rve3GQdukDFmA" target="_blank" rel="noopener">JDK 中居然也有反模式接口常量</a> 中介绍的反模式实现，以及本文说到的这个技术债务：嵌套关系（NestMate）调用方式。</p><a id="more"></a><p>在 Java 语言中，类和接口可以相互嵌套，这种组合之间可以不受限制的彼此访问，包括访问彼此的构造函数、字段、方法等。即使是<code>private</code>私有的，也可以彼此访问。比如下面这样定义：</p><pre><code class="java">public class Outer {    private int i;    public void print1() {        print11();        print12();    }    private void print11() {        System.out.println(i);    }    private void print12() {        System.out.println(i);    }    public void callInnerMethod() {        final Inner inner = new Inner();        inner.print4();        inner.print5();        System.out.println(inner.j);    }    public class Inner {        private int j;        public void print3() {            System.out.println(i);            print1();        }        public void print4() {            System.out.println(i);            print11();            print12();        }        private void print5() {            System.out.println(i);            print11();            print12();        }    }}</code></pre><p>上例中，<code>Outer</code>类中的字段<code>i</code>、方法<code>print11</code>和<code>print12</code>都是私有的，但是可以在<code>Inner</code>类中直接访问，<code>Inner</code>类的字段<code>j</code>、方法<code>print5</code>是私有的，也可以在<code>Outer</code>类中使用。这种设计是为了更好的封装，在用户看来，这几个彼此嵌套的类/接口是一体的，分开定义是为了更好的封装自己，隔离不同特性，但是有因为彼此是一体，所以私有元素也应该是共有的。</p><h2 id="Java11-之前的实现方式"><a href="#Java11-之前的实现方式" class="headerlink" title="Java11 之前的实现方式"></a>Java11 之前的实现方式</h2><p>我们使用 Java8 编译，然后借助<code>javap -c</code>命令分别查看<code>Outer</code>和<code>Inner</code>的结果。</p><pre><code class="shell">$ javap -c Outer.class      Compiled from &quot;Outer.java&quot;public class cn.howardliu.tutorials.java8.nest.Outer {  public cn.howardliu.tutorials.java8.nest.Outer();    Code:       0: aload_0       1: invokespecial #4                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V       4: return  public void print1();    Code:       0: aload_0       1: invokespecial #2                  // Method print11:()V       4: aload_0       5: invokespecial #1                  // Method print12:()V       8: return  public void callInnerMethod();    Code:       0: new           #7                  // class cn/howardliu/tutorials/java8/nest/Outer$Inner       3: dup       4: aload_0       5: invokespecial #8                  // Method cn/howardliu/tutorials/java8/nest/Outer$Inner.&quot;&lt;init&gt;&quot;:(Lcn/howardliu/tutorials/java8/nest/Outer;)V       8: astore_1       9: aload_1      10: invokevirtual #9                  // Method cn/howardliu/tutorials/java8/nest/Outer$Inner.print4:()V      13: aload_1      14: invokestatic  #10                 // Method cn/howardliu/tutorials/java8/nest/Outer$Inner.access$000:(Lcn/howardliu/tutorials/java8/nest/Outer$Inner;)V      17: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;      20: aload_1      21: invokestatic  #11                 // Method cn/howardliu/tutorials/java8/nest/Outer$Inner.access$100:(Lcn/howardliu/tutorials/java8/nest/Outer$Inner;)I      24: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V      27: return  static int access$200(cn.howardliu.tutorials.java8.nest.Outer);    Code:       0: aload_0       1: getfield      #3                  // Field i:I       4: ireturn  static void access$300(cn.howardliu.tutorials.java8.nest.Outer);    Code:       0: aload_0       1: invokespecial #2                  // Method print11:()V       4: return  static void access$400(cn.howardliu.tutorials.java8.nest.Outer);    Code:       0: aload_0       1: invokespecial #1                  // Method print12:()V       4: return}</code></pre><p>再来看看<code>Inner</code>的编译结果，这里需要注意的是，内部类会使用特殊的命名方式定义<code>Inner</code>类，最终会将编译结果存储在两个文件中：</p><pre><code class="shell">$ javap -c Outer\$Inner.classCompiled from &quot;Outer.java&quot;public class cn.howardliu.tutorials.java8.nest.Outer$Inner {  final cn.howardliu.tutorials.java8.nest.Outer this$0;  public cn.howardliu.tutorials.java8.nest.Outer$Inner(cn.howardliu.tutorials.java8.nest.Outer);    Code:       0: aload_0       1: aload_1       2: putfield      #3                  // Field this$0:Lcn/howardliu/tutorials/java8/nest/Outer;       5: aload_0       6: invokespecial #4                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V       9: return  public void print3();    Code:       0: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;       3: aload_0       4: getfield      #3                  // Field this$0:Lcn/howardliu/tutorials/java8/nest/Outer;       7: invokestatic  #6                  // Method cn/howardliu/tutorials/java8/nest/Outer.access$200:(Lcn/howardliu/tutorials/java8/nest/Outer;)I      10: invokevirtual #7                  // Method java/io/PrintStream.println:(I)V      13: aload_0      14: getfield      #3                  // Field this$0:Lcn/howardliu/tutorials/java8/nest/Outer;      17: invokevirtual #8                  // Method cn/howardliu/tutorials/java8/nest/Outer.print1:()V      20: return  public void print4();    Code:       0: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;       3: aload_0       4: getfield      #3                  // Field this$0:Lcn/howardliu/tutorials/java8/nest/Outer;       7: invokestatic  #6                  // Method cn/howardliu/tutorials/java8/nest/Outer.access$200:(Lcn/howardliu/tutorials/java8/nest/Outer;)I      10: invokevirtual #7                  // Method java/io/PrintStream.println:(I)V      13: aload_0      14: getfield      #3                  // Field this$0:Lcn/howardliu/tutorials/java8/nest/Outer;      17: invokestatic  #9                  // Method cn/howardliu/tutorials/java8/nest/Outer.access$300:(Lcn/howardliu/tutorials/java8/nest/Outer;)V      20: aload_0      21: getfield      #3                  // Field this$0:Lcn/howardliu/tutorials/java8/nest/Outer;      24: invokestatic  #10                 // Method cn/howardliu/tutorials/java8/nest/Outer.access$400:(Lcn/howardliu/tutorials/java8/nest/Outer;)V      27: return  static void access$000(cn.howardliu.tutorials.java8.nest.Outer$Inner);    Code:       0: aload_0       1: invokespecial #2                  // Method print5:()V       4: return  static int access$100(cn.howardliu.tutorials.java8.nest.Outer$Inner);    Code:       0: aload_0       1: getfield      #1                  // Field j:I       4: ireturn}</code></pre><p>我们可以看到，<code>Outer</code>和<code>Inner</code>中多出了几个方法，方法名格式是<code>access$*00</code>。</p><p><code>Outer</code>中的<code>access$200</code>方法返回了属性<code>i</code>，<code>access$300</code>和<code>access$400</code>分别调用了<code>print11</code>和<code>print12</code>方法。这些新增的方法都是静态方法，作用域是默认作用域，即包内可用。这些方法最终被<code>Inner</code>类中的<code>print3</code>和<code>print4</code>调用，相当于间接调用<code>Outer</code>中的私有属性或方法。</p><p>我们称这些生成的方法为“桥”方法（Bridge Method），是一种实现嵌套关系内部互相访问的方式。</p><p>在编译的时候，Java 为了保持类的单一特性，会将嵌套类编译到多个 class 文件中，同时为了保证嵌套类能够彼此访问，自动创建了调用私有方法的“桥”方法，这样，在保持原有定义不变的情况下，又实现了嵌套语法。</p><h2 id="技术债务"><a href="#技术债务" class="headerlink" title="技术债务"></a>技术债务</h2><p>“桥”方法的实现是比较巧妙的，但是这会造成源码与编译结果访问控制权限不一致，比如，我们可以在<code>Inner</code>中调用<code>Outer</code>中的私有方法，按照道理来说，我们可以在<code>Inner</code>中通过反射调用<code>Outer</code>的方法，但实际上不行，会抛出<code>IllegalAccessException</code>异常。我们验证一下：</p><pre><code class="java">public class Outer {    // 省略其他方法    public void callInnerReflectionMethod()            throws InvocationTargetException, NoSuchMethodException, IllegalAccessException {        final Inner inner = new Inner();        inner.callOuterPrivateMethod(this);    }    public class Inner {        // 省略其他方法        public void callOuterPrivateMethod(Outer outer)                throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {            final Method method = outer.getClass().getDeclaredMethod(&quot;print12&quot;);            method.invoke(outer);        }    }}</code></pre><p>定义测试用例：</p><pre><code class="java">@Testvoid gotAnExceptionInJava8() {    final Outer outer = new Outer();    final Exception e = assertThrows(IllegalAccessException.class, outer::callInnerReflectionMethod);    e.printStackTrace();    assertDoesNotThrow(outer::callInnerMethod);}</code></pre><p>打印的异常信息是：</p><pre><code class="log">java.lang.IllegalAccessException: class cn.howardliu.tutorials.java8.nest.Outer$Inner cannot access a member of class cn.howardliu.tutorials.java8.nest.Outer with modifiers &quot;private&quot;    at java.base/jdk.internal.reflect.Reflection.newIllegalAccessException(Reflection.java:361)    at java.base/java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:591)    at java.base/java.lang.reflect.Method.invoke(Method.java:558)    at cn.howardliu.tutorials.java8.nest.Outer$Inner.callOuterPrivateMethod(Outer.java:62)    at cn.howardliu.tutorials.java8.nest.Outer.callInnerReflectionMethod(Outer.java:36)</code></pre><p>通过反射直接调用私有方法会失败，但是可以直接的或者通过反射访问这些“桥”方法，这样就比较奇怪了。所以提出 <a href="http://openjdk.java.net/jeps/181" target="_blank" rel="noopener">JEP181 改进</a>，修复这个技术债务的同时，为后续的改进铺路。</p><h2 id="Java11-中的实现"><a href="#Java11-中的实现" class="headerlink" title="Java11 中的实现"></a>Java11 中的实现</h2><p>我们再来看看 Java11 编译之后的结果：</p><pre><code class="shell">$ javap -c Outer.class      Compiled from &quot;Outer.java&quot;public class cn.howardliu.tutorials.java11.nest.Outer {  public cn.howardliu.tutorials.java11.nest.Outer();    Code:       0: aload_0       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V       4: return  public void print1();    Code:       0: aload_0       1: invokevirtual #2                  // Method print11:()V       4: aload_0       5: invokevirtual #3                  // Method print12:()V       8: return  public void callInnerMethod();    Code:       0: new           #7                  // class cn/howardliu/tutorials/java11/nest/Outer$Inner       3: dup       4: aload_0       5: invokespecial #8                  // Method cn/howardliu/tutorials/java11/nest/Outer$Inner.&quot;&lt;init&gt;&quot;:(Lcn/howardliu/tutorials/java11/nest/Outer;)V       8: astore_1       9: aload_1      10: invokevirtual #9                  // Method cn/howardliu/tutorials/java11/nest/Outer$Inner.print4:()V      13: aload_1      14: invokevirtual #10                 // Method cn/howardliu/tutorials/java11/nest/Outer$Inner.print5:()V      17: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;      20: aload_1      21: getfield      #11                 // Field cn/howardliu/tutorials/java11/nest/Outer$Inner.j:I      24: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V      27: return}</code></pre><p>是不是很干净，与<code>Outer</code>类的源码结构是一致的。我们再看看<code>Inner</code>有没有什么变化：</p><pre><code class="shell">$ javap -c Outer\$Inner.classCompiled from &quot;Outer.java&quot;public class cn.howardliu.tutorials.java11.nest.Outer$Inner {  final cn.howardliu.tutorials.java11.nest.Outer this$0;  public cn.howardliu.tutorials.java11.nest.Outer$Inner(cn.howardliu.tutorials.java11.nest.Outer);    Code:       0: aload_0       1: aload_1       2: putfield      #1                  // Field this$0:Lcn/howardliu/tutorials/java11/nest/Outer;       5: aload_0       6: invokespecial #2                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V       9: return  public void print3();    Code:       0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;       3: aload_0       4: getfield      #1                  // Field this$0:Lcn/howardliu/tutorials/java11/nest/Outer;       7: getfield      #4                  // Field cn/howardliu/tutorials/java11/nest/Outer.i:I      10: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V      13: aload_0      14: getfield      #1                  // Field this$0:Lcn/howardliu/tutorials/java11/nest/Outer;      17: invokevirtual #6                  // Method cn/howardliu/tutorials/java11/nest/Outer.print1:()V      20: return  public void print4();    Code:       0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;       3: aload_0       4: getfield      #1                  // Field this$0:Lcn/howardliu/tutorials/java11/nest/Outer;       7: getfield      #4                  // Field cn/howardliu/tutorials/java11/nest/Outer.i:I      10: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V      13: aload_0      14: getfield      #1                  // Field this$0:Lcn/howardliu/tutorials/java11/nest/Outer;      17: invokevirtual #7                  // Method cn/howardliu/tutorials/java11/nest/Outer.print11:()V      20: aload_0      21: getfield      #1                  // Field this$0:Lcn/howardliu/tutorials/java11/nest/Outer;      24: invokevirtual #8                  // Method cn/howardliu/tutorials/java11/nest/Outer.print12:()V      27: return}</code></pre><p>同样干净。</p><p>我们在通过测试用例验证一下反射调用：</p><pre><code class="java">@Testvoid doesNotGotAnExceptionInJava11() {    final Outer outer = new Outer();    assertDoesNotThrow(outer::callInnerReflectionMethod);    assertDoesNotThrow(outer::callInnerMethod);}</code></pre><p>结果是正常运行。</p><p>这就是 JEP181 期望的结果，源码和编译结果一致，访问控制一致。</p><h2 id="Nestmate-新增的-API"><a href="#Nestmate-新增的-API" class="headerlink" title="Nestmate 新增的 API"></a>Nestmate 新增的 API</h2><p>在 Java11 中还新增了几个 API，用于嵌套关系的验证：</p><h3 id="getNestHost"><a href="#getNestHost" class="headerlink" title="getNestHost"></a>getNestHost</h3><p>这个方法是返回嵌套主机（NestHost），转成普通话就是找到嵌套类的外层类。对于非嵌套类，直接返回自身（其实也算是返回外层类）。</p><p>我们看下用法：</p><pre><code class="java">@Testvoid checkNestHostName() {    final String outerNestHostName = Outer.class.getNestHost().getName();    assertEquals(&quot;cn.howardliu.tutorials.java11.nest.Outer&quot;, outerNestHostName);    final String innerNestHostName = Inner.class.getNestHost().getName();    assertEquals(&quot;cn.howardliu.tutorials.java11.nest.Outer&quot;, innerNestHostName);    assertEquals(outerNestHostName, innerNestHostName);    final String notNestClass = NotNestClass.class.getNestHost().getName();    assertEquals(&quot;cn.howardliu.tutorials.java11.nest.NotNestClass&quot;, notNestClass);}</code></pre><p>对于<code>Outer</code>和<code>Inner</code>都是返回了<code>cn.howardliu.tutorials.java11.nest.Outer</code>。</p><h3 id="getNestMembers"><a href="#getNestMembers" class="headerlink" title="getNestMembers"></a>getNestMembers</h3><p>这个方法是返回嵌套类的嵌套成员数组，下标是 0 的元素确定是 NestHost 对应的类，其他元素顺序没有给出排序规则。我们看下使用：</p><pre><code class="java">@Testvoid getNestMembers() {    final List&lt;String&gt; outerNestMembers = Arrays.stream(Outer.class.getNestMembers())            .map(Class::getName)            .collect(Collectors.toList());    assertEquals(2, outerNestMembers.size());    assertTrue(outerNestMembers.contains(&quot;cn.howardliu.tutorials.java11.nest.Outer&quot;));    assertTrue(outerNestMembers.contains(&quot;cn.howardliu.tutorials.java11.nest.Outer$Inner&quot;));    final List&lt;String&gt; innerNestMembers = Arrays.stream(Inner.class.getNestMembers())            .map(Class::getName)            .collect(Collectors.toList());    assertEquals(2, innerNestMembers.size());    assertTrue(innerNestMembers.contains(&quot;cn.howardliu.tutorials.java11.nest.Outer&quot;));    assertTrue(innerNestMembers.contains(&quot;cn.howardliu.tutorials.java11.nest.Outer$Inner&quot;));}</code></pre><h3 id="isNestmateOf"><a href="#isNestmateOf" class="headerlink" title="isNestmateOf"></a>isNestmateOf</h3><p>这个方法是用于判断两个类是否是彼此的 NestMate，彼此形成嵌套关系。判断依据还是嵌套主机，只要相同，两个就是 NestMate。我们看下使用：</p><pre><code class="java">@Testvoid checkIsNestmateOf() {    assertTrue(Inner.class.isNestmateOf(Outer.class));    assertTrue(Outer.class.isNestmateOf(Inner.class));}</code></pre><h2 id="后续的改进"><a href="#后续的改进" class="headerlink" title="后续的改进"></a>后续的改进</h2><p>嵌套关系是作为 Valhalla 项目的一部分，这个项目的主要目标之一是改进 JAVA 中的值类型和泛型。后续会有更多的改进：</p><ul><li>在泛型特化（generic specialization）中，每个特化类型（specialized type）可被创建为泛型的一个 Nestmate。</li><li>支持对<code>Unsafe.defineAnonymousClass()</code> API 的安全替换，实现将新类创建为已有类的 Nestmate。</li><li>可能会影响“密封类”（sealed classes），仅允许 Nestmate 的子类作为密封类。</li><li>可能会影响私有嵌套类型。私有嵌套类型当前定义为包内可访问（package-access）。</li></ul><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文阐述了基于嵌套关系的访问控制优化，其中涉及<code>NestMate</code>、<code>NestHost</code>、<code>NestMember</code>等概念。这次优化是 Valhalla 项目中一部分，主要改进 Java 中的值类型和泛型等。文中涉及源码都上传在 GitHub 上，关注公号「看山的小屋」回复“java”获取源码。</p><p>青山不改，绿水长流，咱们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/By2JoZqAHA6U36PG8qvCcg" target="_blank" rel="noopener">Java17 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-11-jep181-nestmate/">Java11 中基于嵌套关系的访问控制优化</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122334212" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Java 语言很强大，但是，有人的地方就有江湖，有猿的地方就有 bug，Java 的核心代码并非十全十美。比如在JDK 中居然也有反模式接口常量中介绍的反模式实现，以及本文说到的这个技术债务：嵌套关系（NestMate）调用方式。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java11" scheme="https://www.howardliu.cn/tags/Java11/"/>
    
  </entry>
  
  <entry>
    <title>这一年很幸运，平平淡淡的|2021 年度总结</title>
    <link href="https://www.howardliu.cn/2021-summary/"/>
    <id>https://www.howardliu.cn/2021-summary/</id>
    <published>2022-01-03T09:10:33.000Z</published>
    <updated>2022-01-03T09:10:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/wine-6688901_1920.jpg" alt="这一年很幸运，平平淡淡的|2021 年度总结"></p><p>你好，我是看山。</p><p>一晃又是一年，果然岁数越大，时间越快。有些内容在 <a href="https://mp.weixin.qq.com/s/_I8NtBk7NvGQt18jlxkW6Q" target="_blank" rel="noopener">原来还能这么干</a> 一文中聊了一些，今天再聊点别的。让我们一起总结过去，把握现在，展望未来。</p><p>总结下来，2021 年还算幸运，平平淡淡过一年。工作上按部就班，生活上一如既往。</p><a id="more"></a><p>如果说有什么可以出牛的，就是开始好好写文了。幸运的是在 2021 年最后一天，得到了 InfoQ 官方认可，成为签约作者。</p><h2 id="按部就班的工作"><a href="#按部就班的工作" class="headerlink" title="按部就班的工作"></a>按部就班的工作</h2><p>2021 年换了一份工作，感谢前司领导同事的帮助，知道了什么是好好工作，怎样做可以做好工作：</p><ol><li>一切用数字说话：if you cannot measure it, you cannot manage it;</li><li>做之前多想想怎么形成闭环：如果在想法上都没有闭环，那结果就经不起推敲；</li><li>方法论很重要：在没有绝对的有效处理事情的能力前，就学习一些方法论，指导工作；</li><li>坦诚待人：做到绝对坦诚不容易，可以先在工作上做到这点；</li><li>结果导向：一个人、一个团队、一个公司，都是为了一个目标在做事，如果没有结果，谈其他的都没有意义。</li></ol><p>到了现司之后，也有了一些感悟：孤胆英雄是没有办法生存的，团队才是能够好好工作的最小单位。</p><p>上面这些，每一条都可以描述很多，既然是年终总结，就先一笔带过，看官可以先自行体会一下。如果有必要，再开文详细聊聊。</p><h2 id="一如既往的生活"><a href="#一如既往的生活" class="headerlink" title="一如既往的生活"></a>一如既往的生活</h2><p>2021 年要好好感谢我媳妇，如果有哪位朋友恰好看到这篇文章，记得给小猪转发一下，我猜她一定忽略了我的这份心意。</p><p><img src="https://static.howardliu.cn/about/zhuzhu-qiqi.jpg" alt="朱朱和七七"></p><p>生活方面没有太多要说的，只有满心的感动和感激。</p><h2 id="其他方面的小确幸"><a href="#其他方面的小确幸" class="headerlink" title="其他方面的小确幸"></a>其他方面的小确幸</h2><p>在 <a href="https://mp.weixin.qq.com/s/IlgvUH79DEuCmUmTmqsqKg" target="_blank" rel="noopener">Geek 青年说北京沙龙分享</a> 中聊过，我是 2013 年开始写博客，2018 年停更一年，从 2021 年开始坚持周更。这个过程中，认识了很多志同道合的朋友，见到了很多优秀的博主。</p><p>一个人可以走的很快，一群人可以走的很远。</p><p>写博客是为了实现自己定的目标，不必太在意结果。不过，正如前面所说，一切用数字说话。下面就晒一下 2021 年的一些成绩（这些成绩和大佬没法比，只能小小的自嗨一下）：</p><p>C 站粉丝达到 17000，访问量有 870000：</p><p><img src="https://static.howardliu.cn/about/csdn-20220103.png" alt="2022 年 1 月 3 日，看山 CSDN 的详细资料"></p><p>C 站 1024 活动时，收货博客专家勋章：</p><p><img src="https://static.howardliu.cn/about/csdn-2021-october-24th.jpg" alt="CSDN1024 活动-博客专家勋章"></p><p>参加知乎海盐计划，直接升级到 4 级；</p><p>参加掘金 11 月更文活动，两次后端模块的周榜前 10；</p><p>参加 InfoQ 写作平台签约作者第二季，成功入选。评选结果是在 12 月 31 号公布的，算是给 2021 年的写作之旅画上一个不错的句号。</p><p><img src="https://static.howardliu.cn/about/InfoQ-xie-kanshan-1.jpg" alt="InfoQ 签约作者第二季"></p><p>除了写博客，今年也开始健身了。一开始是维嘉带着练，后来维嘉回了学校是跟着斌哥练，终于看到了 75 公斤的影子。</p><h2 id="2022-年的计划"><a href="#2022-年的计划" class="headerlink" title="2022 年的计划"></a>2022 年的计划</h2><p>新的一年，为了对自己负责，对家人负责，对朋友负责，我们总要做出新一年的计划。我 2022 年的计划就是搞定 2021 年那些原定于 2020 年未完成的安排，只为兑现 2019 年时要完成 2018 年许下的诺言，曾说 2017 年之后一定不要像 2016 年那样只会跟着 2015 年去做 2014 年没给 2013 年完成的那个目标。</p><p>哈哈哈，上面的文案摘自某音的段子，比较写实。</p><p>我真实的计划就不放出来了，心理学上有个研究结果，当多次向别人描述自己的计划，就会产生一种错觉，以为自己已经完成了计划。计划不广而告之，但是一定要有。</p><p>没有计划的人生不值得过。</p><p>青山不改，绿水长流，咱们下次见。</p><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/2021-summary/">这一年很幸运，平平淡淡的|2021 年度总结</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122334052" target="_blank" rel="noopener">这一年很幸运，平平淡淡的|2021 年度总结</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      一晃又是一年，果然岁数越大，时间越快。总结下来，2021 年还算幸运，平平淡淡过一年。工作上按部就班，生活上一如既往。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="年度总结" scheme="https://www.howardliu.cn/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>原来还能这么干——罗胖2022年《时间的朋友》观后感</title>
    <link href="https://www.howardliu.cn/2022-friends-of-time/"/>
    <id>https://www.howardliu.cn/2022-friends-of-time/</id>
    <published>2022-01-01T16:48:14.000Z</published>
    <updated>2022-01-01T16:48:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/nature-6891549_1920.jpg" alt="原来还能这么干——罗胖2022年《时间的朋友》观后感"></p><p>你好，我是看山。</p><p>就这样 2022 年了，年纪越大，时间越快，又到了罗胖《时间的朋友》直播的时候，看完后想写点什么，奈何腹中墨水太少，索性不难为自己，随便写写。由于疫情原因，罗胖今年的跨年演讲现场的观众全部都是熊猫娃娃，评论区有整场直播的视频回访和文字稿，有些事情，还是要自己亲自感受一下。</p><a id="more"></a><h2 id="打破思维的墙"><a href="#打破思维的墙" class="headerlink" title="打破思维的墙"></a>打破思维的墙</h2><p>整场演讲的主题是“原来还能这么干”，用我能够理解的话，就是打破思维的墙。</p><p>每个人都有自己的思维模式，这是我们赖以生存的根本，也是我们能够更快速、更高效处理普通事务的根本。之前在 <a href="https://mp.weixin.qq.com/s/JbFoEynzykrGBhOgu4Ne4w" target="_blank" rel="noopener">别让非理性思维毁了你的人生</a> 中聊过，我们的大脑为了节省能量，会经常处于自动驾驶模式，这让我们可以更有机会省出能量做其他事情。比如，我看看到知道冒白气的水是热的，不会直接喝；我们知道冷了要穿衣服，否则会生病……但是有些时候，我们用常规的办法解决不了问题，怎么办？</p><p>想要打破思维的墙，我们需要绝对的理性分析限制我们思维的问题是什么？真正要解决的问题有哪些？就不列举罗胖演讲中的例子了，我们考虑一下网约车出来之前那种打车难的问题。</p><p>很多人可能没有经历过打车难的时期，那个时候，我们没有办法知道哪里有出租车，只能就近在路边招手，出租车师傅同样不知道哪有顾客，只能满城转悠，或者在上客概率到的地方等着，比如 CBD、高铁站、机场等。平时还好，等会就等会，如果恰好有急事、或者带着老人小孩、亦或是刮风下雨的时候，就会比较难受。怎么办？</p><p>如果我们可以提前和司机师傅约好，在约定地点上车，是不是就可以了。想法有了，接下来就是实现，于是有了一系列的网约车 APP。现在大家打车记录不需要路边拦车了，直接网上下单，指定地点上车即可，方便快捷。</p><p>这几年，很多互联网公司的崛起，改变了我们的生活方式，比如：外卖、拼团、移动支付……他们的成功，是走了以前没有人走过的路。</p><p>《功勋》中屠呦呦关于常山碱的判断中，认为已经经过反复论证走不通的路，就该果断放弃，立马淘汰，找到更可靠的方式，于是有了后面的青蒿素的发现。</p><p>碰到问题，我们要投入百分之百的努力克服困难，但是如果已经不行了，就该考虑换个方式再上。</p><p>“行就行，不行再想想办法。”</p><h2 id="一切都在变"><a href="#一切都在变" class="headerlink" title="一切都在变"></a>一切都在变</h2><p>唯一不变的就是变化。没有什么是永恒不变的，我们能够应对变化的手段，只有提前预知变化，做好准备，当变化来临时，坦然面对。</p><p>很多 2020 年风生水起的教培行业，在国家出台双减政策后，一夜之间，大厦轰然倒塌。很多教培行业的老师、研发人员，只能重新考虑未来的发展。其实国家一直有这个信号，我在 <a href="https://mp.weixin.qq.com/s/EuNjfAmgQ3G491g6G4PAew" target="_blank" rel="noopener">想躺平不是错</a> 中也谈过相关的问题。很多人抱怨国家手段强硬，但他们真正抱怨的是，国家没有提前告诉他们要行霹雳手段，改变这个畸形发展的行业。</p><p>我们很多人相信风水、星座、命运，其实只是想从中探寻一些未来的可能。罗胖给出了一个观点是，我们没有办法一直追寻改变，只要找到未来的不变，试着靠近他，当未来来临时，我们就已经赶在了潮流的前列。</p><p>那怎么找到未来一定发生的事情？个人愚见是翻翻国家政策，比如“十四五”规划，看看规划的未来目标。跟着国家政策走，绝对不会有太大偏差。找到目标了怎么实现呢？有能力上，没能力提升能力也要上，如果还是上不去，就“打破思维的墙”，再想想别的办法。</p><h2 id="35-岁怎么了？一切刚刚好"><a href="#35-岁怎么了？一切刚刚好" class="headerlink" title="35 岁怎么了？一切刚刚好"></a>35 岁怎么了？一切刚刚好</h2><p>35 岁焦虑是每个程序员都有的？各种营销号中一直鼓吹一个观点，到了 35 岁，就会一下子变成了没有任何价值的抹布。而且给出很多的理由：</p><ol><li>家庭拖累，上有老下有小，会分心；</li><li>体力精力跟不上，没有办法跟刚毕业的小年轻比较；</li><li>变成了老油条，工作中很容易偷懒；</li><li>……</li></ol><p>似乎都有道理，但是总感觉哪里不对。罗胖的观点是，年龄大了之后，除了工作能力之外，我们拼的还有软技能。</p><p>以编程开发为例，简单的 CRUD，刚毕业的小伙子和 35 岁的人开发结果差不多，但是复杂逻辑呢？但凡有些经验的开发人员，会把场景考虑更加完善，会在开发时考虑更多的设计模式，这些经验，会让程序更加健壮，能够应对更多的变化。而且，经历了社会的毒打之后，我们会比较平和的接受一些职场上的不公平，这不是怂，而是一种心态的转变，“世间事，除了生死，哪一件事不是闲事。”</p><p>心态平和了，为人处世才会简单，能够更好的处理人际关系。这就是我们的软技能，如果我们可以在开发之外再有一些亮眼的特点，比如：架构设计、逻辑分析、产品设计、汇报总结等等。</p><p>之前看过一篇文章，里面说到，被辞退的员工，不会被告知被辞退的真正原因，只会说是公司效益不好、发展不畅。其实，很多时候是软技能太弱。</p><p>既然我们没有办法和 20 多岁的年轻人拼精力，那我们以一个更有生活阅历的年轻人身份在职场中打拼。</p><h2 id="此生不悔入华夏"><a href="#此生不悔入华夏" class="headerlink" title="此生不悔入华夏"></a>此生不悔入华夏</h2><p>不知道从什么时候开始，这种情绪就渗进了我们骨子里面。</p><p>写这段内容的时候，写了改，改了删。我企图找到一些证据，证明我的这个想法是对的，我企图找到一个事件，能够代表这种情绪的起点。最后还是删了，这是潜移默化的一个结果。填饱肚子的不是最后一个包子，而是前面 9 个包子的铺垫。</p><p>我只表达这种情绪，其他的交给时间。</p><h2 id="可以常常回味的话"><a href="#可以常常回味的话" class="headerlink" title="可以常常回味的话"></a>可以常常回味的话</h2><p>『1』给重要时刻：</p><p>“行万里路，读万遍经。笨鸭早飞，笨牛勤耕。让小的敬老的，拿次的留好的。宁欺官，不欺贤，宁欺贤，不欺天。人多的地方不去，没人的地方不留。赞美成功的人，安慰失败的人。犯病的东西不吃，犯法的事情不做。不要穿金戴银，只要好好做人。墙倒众人推，我不推；枪打出头鸟，我不打。种瓜得瓜瓜儿大，种豆得豆豆儿多。”————《王鼎钧回忆录》</p><p>『2』给理性乐观派：</p><p>“我的乐观并不需要这些头头是道的逻辑支撑，它就是一种朴素的信念：相信中国会更好。这种信念不是源于学术训练，而是源于司马迁、杜甫、苏轼，源于‘一条大河波浪宽’，源于对中国人勤奋实干的钦佩。它影响了我看待问题的角度和处理信息的方式，我接受这种局限性，没有改变的打算。”————兰小欢</p><p>『3』给犹豫不决的人：</p><p>“什么是事件？事件就是某种超出了原因的结果。”————齐泽克</p><p>『4』给准备出发的人：</p><p>“设计是一个不断生成目标和备选方案的过程。”————赫伯特·西蒙</p><p>『5』给正在路上的人：</p><p>“非常理想，特别现实。”————李希贵</p><p>『6』给正在拓荒的人：</p><p>“提前一个版本遵守法律”————王永治</p><p>『7』给知易行难的人：</p><p>“要改变一个成年人的行为，认知、能力、提醒，三者同样重要”————王建硕</p><p>『8』给身处困境的人：</p><p>“地球上最后一个人独自坐在房间里，这时忽然响起了敲门声……”————弗里蒂克·布朗</p><p>『9』给 2022 年的我们：</p><p>“让我们泰然自若，与自己的时代狭路相逢”————莎士比亚</p><h2 id="我们都要好好的"><a href="#我们都要好好的" class="headerlink" title="我们都要好好的"></a>我们都要好好的</h2><p>生活很难，有时候就需要一种正能量激励我们，哪怕只是轻轻的推一把，齿轮就会转动起来，然后就沿着这种惯性继续下去。</p><p>愿大家 2022 年“各从其欲，皆得所愿”。</p><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/2022-friends-of-time/">原来还能这么干——罗胖2022年《时间的朋友》观后感</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122273004" target="_blank" rel="noopener">原来还能这么干——罗胖2022年《时间的朋友》观后感</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      就这样 2022 年了，年纪越大，时间越快，又到了罗胖《时间的朋友》直播的时候，看完后想写点什么，奈何腹中墨水太少，索性不难为自己，随便写写。由于疫情原因，罗胖今年的跨年演讲现场的观众全部都是熊猫娃娃，评论区有整场直播的视频回访和文字稿，有些事情，还是要自己亲自感受一下。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊，时间的朋友" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A%EF%BC%8C%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java10 的新特性</title>
    <link href="https://www.howardliu.cn/java-10-features/"/>
    <id>https://www.howardliu.cn/java-10-features/</id>
    <published>2021-12-29T14:01:57.000Z</published>
    <updated>2021-12-29T14:01:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/christmas-5740350.png?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="Java10 新特性"></p><p>你好，我是看山。</p><blockquote><p>本文收录在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">《从小工到专家的 Java 进阶之旅》</a> 系列专栏中。</p></blockquote><p>从 2017 年开始，Java 版本更新策略从原来的每两年一个新版本，改为每六个月一个新版本，以快速验证新特性，推动 Java 的发展。从 <a href="https://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf" target="_blank" rel="noopener">《JVM Ecosystem Report 2021》</a> 中可以看出，目前开发环境中有近半的环境使用 Java8，有近半的人转移到了 Java11，随着 Java17 的发布，相信比例会有所变化。</p><a id="more"></a><p>因此，准备出一个系列，配合示例讲解，阐述各个版本的新特性。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>从 Java10 开始，Java 版本正式进入每半年一个版本的更新节奏，更新频率加快，小步快跑。</p><p>接下来我们瞅瞅 Java10 都更新了哪些比较有意思的功能。</p><h2 id="局部变量类型推断"><a href="#局部变量类型推断" class="headerlink" title="局部变量类型推断"></a>局部变量类型推断</h2><p>我们都知道 Java 是强类型语言，有着严格的类型限制。想要定义一个变量，必须明确指明变量类型，用<code>Object</code>抬杠的可以离开了。但是从 Java10 开始，我们可以在定义局部变量时使用<code>var</code>限定变量类型，Java 编译器会根据变量的值推断具体的类型。</p><p>比如，我们定义一个<code>Map</code>对象：</p><pre><code class="java">Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</code></pre><p>现在我们可以写做：</p><pre><code class="java">var idToNameMap = new HashMap&lt;Integer, String&gt;();</code></pre><p>这个功能算是 Java 的一次尝鲜，给 Java 语言增加了更多的可能，让我们的代码更加简洁，更加专注于可读性。</p><p>需要注意的是，新增的<code>var</code>不会把 Java 变成动态语言，在编译时，编译器会自动推断类型，将其转换为确定的类型，不会在运行时动态变化。</p><p>目前<code>var</code>只能用于局部变量，而且等号右侧必须是确定类型的定义，包括：初始化的实例、方法的调用、匿名内部类。</p><p>我们再回到刚才的例子：</p><pre><code class="java">// 以前的写法Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();// 现在可以这么写var idToNameMap = new HashMap&lt;Integer, String&gt;();</code></pre><p>对于参数的名字，我们可以不在关注类型，可以更多的关注参数的意义，这也是编写可读代码的要求。</p><p>这也为我们提出了一些要求，如果是特别长的 Lambda 表达式，还是老老实实的使用明确的类型吧，否则写着写着就迷糊了。</p><p>再就是推断类型时没有那么智能，都是基于最明确的推断，比如：</p><pre><code class="java">var emptyList = new ArrayList&lt;&gt;();</code></pre><p>这个时候推断<code>emptyList</code>的结果是<code>ArrayList&lt;Object&gt;</code>，绝对不会按照我们常用写法推断成<code>List&lt;Object&gt;</code>。</p><p>如果是匿名内部类，比如：</p><pre><code class="java">var obj = new Object() {};</code></pre><p>这个时候<code>obj.getClass()</code>可就不是<code>Object.class</code>了，而且匿名内部类的类型了。</p><p>所以，小刀虽好，但也要好好用，胡乱用容易误伤。</p><h2 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h2><p>从 Java9 开始提供不可变集合的实现，Java10 继续扩展。集合是一个容器，作为一个参数传入方法中，我们并不知道方法是否会对容器中的元素进行修改，有了不可变集合，我们就能够在一定程度上进行控制（毕竟对容器中对象的数据进行修改，我们的控制力就没有那么强了）。</p><p>针对不可变集合，我们摘取<code>java.util.List</code>的描述（其他的描述都是类似的）：</p><blockquote><h2 id="Unmodifiable-Lists"><a href="#Unmodifiable-Lists" class="headerlink" title="Unmodifiable Lists"></a>Unmodifiable Lists</h2><p>The List.of and List.copyOf static factory methods provide a convenient way to create unmodifiable lists. The List instances created by these methods have the following characteristics:</p><ul><li>They are unmodifiable. Elements cannot be added, removed, or replaced. Calling any mutator method on the List will always cause UnsupportedOperationException to be thrown. However, if the contained elements are themselves mutable, this may cause the List’s contents to appear to change.</li><li>They disallow null elements. Attempts to create them with null elements result in NullPointerException.</li><li>They are serializable if all elements are serializable.</li><li>The order of elements in the list is the same as the order of the provided arguments, or of the elements in the provided array.</li><li>They are value-based. Callers should make no assumptions about the identity of the returned instances. Factories are free to create new instances or reuse existing ones. Therefore, identity-sensitive operations on these instances (reference equality (==), identity hash code, and synchronization) are unreliable and should be avoided.</li><li>They are serialized as specified on the Serialized Form page.</li></ul></blockquote><p>简单翻译一下：</p><ul><li>这些集合都不可变，元素不能增、减、替换，调用修改方法都会返回<code>UnsupportedOperationException</code>异常。但是，but，如果集合中的元素是可变的，那就控不住了。比如，元素是<code>AtomInteger</code>就没法控制其中的值，集合只是元素不变；如果是<code>String</code>，那集合是整体不变的。</li><li>不允许<code>null</code>，会抛出<code>NullPointerException</code></li><li>如果集合中的元素是可序列化的，那集合就能够序列化</li><li>集合中元素的顺序是加入的顺序</li><li><code>copyOf</code>和<code>of</code>这些方法中返回的结果可能使用提前定义好的对象，比如空集合、原集合等。换句话说，在不同调用位置返回了相同对象。所以不要相信<code>==</code>、<code>hashCode</code>，也不要对其加锁。</li></ul><h3 id="copyOf"><a href="#copyOf" class="headerlink" title="copyOf"></a>copyOf</h3><p>在<code>java.util.List</code>、<code>java.util.Map</code>、<code>java.util.Set</code>这几个接口中都各自添加了一个<code>copyOf</code>静态方法，用来创建不可变集合，最终都会是<code>ImmutableCollections</code>中定义的几个集合实现，与 Java9 中定义的<code>of</code>方法类似。</p><p>对于<code>java.util.Map</code>、<code>java.util.Set</code>，这里有一个优化，如果传入的本身就是不可变的集合，将直接返回传入的参数，代码如下：</p><pre><code class="java">static &lt;E&gt; Set&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) {    if (coll instanceof ImmutableCollections.AbstractImmutableSet) {        return (Set&lt;E&gt;)coll;    } else {        return (Set&lt;E&gt;)Set.of(new HashSet&lt;&gt;(coll).toArray());    }}</code></pre><h3 id="toUnmodifiableList、toUnmodifiableSet、toUnmodifiableMap"><a href="#toUnmodifiableList、toUnmodifiableSet、toUnmodifiableMap" class="headerlink" title="toUnmodifiableList、toUnmodifiableSet、toUnmodifiableMap"></a>toUnmodifiableList、toUnmodifiableSet、toUnmodifiableMap</h3><p>Java10 很贴心的提供了<code>Stream</code>中的操作，我们直接创建不可变集合了。比如：</p><pre><code class="java">Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;)    .map(x -&gt; &quot;id: &quot; + x)    .collect(Collectors.toUnmodifiableList());</code></pre><p><code>toUnmodifiableList</code>、<code>toUnmodifiableSet</code>、<code>toUnmodifiableMap</code>的用法与<code>toList</code>、<code>toSet</code>、<code>toMap</code>没有太多区别，差别在于返回的是不可变集合。</p><h2 id="Optional-族增加-orElseThrow-方法"><a href="#Optional-族增加-orElseThrow-方法" class="headerlink" title="Optional 族增加 orElseThrow 方法"></a>Optional 族增加 orElseThrow 方法</h2><p>这里说的 Optional 族包括<code>Optional</code>、<code>OptionalInt</code>、<code>OptionalLong</code>、<code>OptionalDouble</code>几个实现。以前有一个<code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code>方法，用于获取不到数据时，抛出<code>exceptionSupplier</code>中定义的异常。</p><p>我们会写成：</p><pre><code class="java">Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;)    .map(x -&gt; &quot;id: &quot; + x)    .findAny()    .orElseThrow(() -&gt; new NoSuchElementException(&quot;No value present&quot;));</code></pre><p>优点是我们可以自定义自己的异常以及异常信息。有时候，我们不关心具体的异常和异常信息，这个时候 Java10 中的新增的<code>orElseThrow</code>方法就派上用场了：</p><pre><code class="java">Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;)    .map(x -&gt; &quot;id: &quot; + x)    .findAny()    .orElseThrow();</code></pre><p>此时如果元素为空，将抛出<code>NoSuchElementException</code>异常。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>Java 当年在性能方面一直被诟病，中间隔着一层虚拟机，实现跨平台运行的功能同时，也致使其执行性能不如 C 语言。所以，Java 一直在性能方面投入大量精力。</p><p>我们看看 Java10 中都有哪些优化点。</p><h3 id="G1-实现并行-Full-GC-算法"><a href="#G1-实现并行-Full-GC-算法" class="headerlink" title="G1 实现并行 Full GC 算法"></a>G1 实现并行 Full GC 算法</h3><p>从 Java9 开始，G1 已经转正，成为默认的垃圾收集器。不过在 Full GC 时，G1 还是采用的单线程串行标记压缩算法，这样 STW 时间会比较长。到 Java10，Full GC 实现了并行标记压缩算法，明显缩短 STW 时间。</p><h3 id="应用程序类数据共享（AppCDS）"><a href="#应用程序类数据共享（AppCDS）" class="headerlink" title="应用程序类数据共享（AppCDS）"></a>应用程序类数据共享（AppCDS）</h3><p>CDS（Class-Data Sharing，类数据共享）是在 Java5 引入的一种类预处理方式，可以将一组类共享到一个归档文件中，在运行时通过内存映射加载类，这样做可以减少启动时间。同时在多个 JVM 之间实现同享同一个归档文件，减少动态内存占用。</p><p>但是 CDS 有一个限制，就是只能是 Bootstrap ClassLoader 使用，这样就将功能限制了类的范围。在 Java10 中，将这个功能扩展到了系统类加载器（System ClassLoader，或者成为应用类加载器，Application ClassLoader）、内置的平台类加载器（Platform ClassLoader），或者是自定义的类加载器。这样就将功能扩展到了应用类。</p><p>想要使用这个功能的话，总共分三步：</p><p><img src="https://static.howardliu.cn/Illustration/BE710605-5206-4D37-8D8C-86E515A6D386.jpg?imageView2/0/q/75%7Cwatermark/2/text/aG93YXJkbGl1LmNuIOeci-WxsQ==/font/5a6L5L2T/fontsize/240/fill/I0IyQjJCMg==/dissolve/60/gravity/South/dx/10/dy/10" alt="总共分三步"></p><ol><li>打包<br>我们把<code>hello.jar</code>中的<code>HelloWorld</code>类使用的类添加到<code>hello.lst</code>中：</li></ol><pre><code class="shell">$ java -Xshare:off -XX:+UseAppCDS -XX:DumpLoadedClassList=hello.lst \    -cp hello.jar HelloWorld</code></pre><ol start="2"><li>创建 AppCDS 归档<br>接下来使用<code>hello.lst</code>中的内容创建 AppCDS 文件<code>hello.jsa</code>：</li></ol><pre><code class="shell">$ java -Xshare:dump -XX:+UseAppCDS -XX:SharedClassListFile=hello.lst \   -XX:SharedArchiveFile=hello.jsa -cp hello.jar</code></pre><ol start="3"><li>使用 AppCDS 归档<br>最后是使用<code>hello.jsa</code>启动<code>HelloWorld</code>：</li></ol><pre><code class="shell">$ java -Xshare:on -XX:+UseAppCDS -XX:SharedArchiveFile=hello.jsa \   -cp hello.jar HelloWorld</code></pre><h3 id="基于-Java-的-JIT-编译器-Graal"><a href="#基于-Java-的-JIT-编译器-Graal" class="headerlink" title="基于 Java 的 JIT 编译器 Graal"></a>基于 Java 的 JIT 编译器 Graal</h3><p><a href="https://github.com/oracle/graal/" target="_blank" rel="noopener">Graal</a> 是使用 Java 编写的与 HotSpot JVM 集成的动态编译器，专注于高性能和可扩展性。是从 JDK9 引入的实验性 AOT 编译器的基础。</p><p>在 JDK10 中，我们可以在 Linux/x64 平台将 Graal 作为 JIT 编译器使用。开启命令如下：</p><pre><code class="shell">-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler</code></pre><p>需要注意的是，这是实验特性，相当于公测阶段，可能在某些场景下，性能不如现有的 JIT 编译器。</p><h2 id="支持容器"><a href="#支持容器" class="headerlink" title="支持容器"></a>支持容器</h2><p>容器化是目前的趋势，在之前，由于 JVM 不能够感知容器，在同一个主机上部署多个虚拟机时，会造成内存占用、CPU 抢占等问题，这点也成为了很多大会上抨击 Java 语言不适合容器时代的一个点。</p><p>现在好了，JVM 可以感知容器了。只是暂时还只支持 Linux 系统（so what，其他平台也还没有用过）。这个功能默认开启，不想使用可以手动关闭：</p><pre><code class="shell">-XX:-UseContainerSupport</code></pre><p>我们还可以手动指定 CPU 核数：</p><pre><code class="shell">-XX:ActiveProcessorCount=1</code></pre><p>还有三个可以控制内存的使用量：</p><pre><code class="shell">-XX:InitialRAMPercentage-XX:MaxRAMPercentage-XX:MinRAMPercentage</code></pre><p>就目前来看，这部分还可以继续完善，相信只是时间问题。</p><h2 id="根证书认证"><a href="#根证书认证" class="headerlink" title="根证书认证"></a>根证书认证</h2><p>自 Java9 起在 keytool 中加入参数 -cacerts，可以查看当前 JDK 管理的根证书。而 Java9 中 cacerts 目录为空，这样就会给开发者带来很多不便。从 Java10 开始，将会在 JDK 中提供一套默认的 CA 根证书。</p><p>作为 JDK 一部分的 cacerts 密钥库旨在包含一组能够用于在各种安全协议的证书链中建立信任的根证书。在 Java10 之前，cacerts 密钥库是空的，默认情况下，关键安全组件（如 TLS）是不起作用的，开发人员需要手动添加一组根证书来使用这些验证。</p><p>Java10 中，Oracle 开放了根证书源码，可以让 OpenJDK 构建对开发人员更有吸引力，并减少这些构建与 Oracle JDK 构建之间的差异。</p><h2 id="启用和删除的功能"><a href="#启用和删除的功能" class="headerlink" title="启用和删除的功能"></a>启用和删除的功能</h2><p>有增有减，这样才能够保证 Java 的与时共进。</p><h3 id="命令行工具和某些参数"><a href="#命令行工具和某些参数" class="headerlink" title="命令行工具和某些参数"></a>命令行工具和某些参数</h3><ul><li>移除<code>javah</code>命令，这个命令用于创建 native 方法所需的 C 的头文件和资源文件的，使用<code>javac -h</code>替代。</li><li>移除<code>policytool</code>工具，这个工具用于创建和管理策略文件。可以直接还使用文本编辑器代替。</li><li>删除<code>java -Xprof</code>参数，这个参数本来是用于评测正在运行的程序，并将评测数据发送到标准输出。可以使用<code>jmap</code>代替。</li></ul><h3 id="某些-API"><a href="#某些-API" class="headerlink" title="某些 API"></a>某些 API</h3><p><code>java.security.acl</code>包标记为过期，标记参数<code>forRemoval</code>是<code>true</code>，将在未来版本中删除。目前，这个包内的功能已经被<code>java.security.Policy</code>取代。<code>java.security</code>包中的<code>Certificate</code>、<code>Identity</code>、<code>IdentityScope</code>、<code>Signer</code>的标记参数<code>forRemoval</code>也是<code>true</code>。这些都将在后续版本中删除。</p><h2 id="基于时间的版本发布模式"><a href="#基于时间的版本发布模式" class="headerlink" title="基于时间的版本发布模式"></a>基于时间的版本发布模式</h2><p>从 Java10 开始，Java 正式进入每半年一个版本的更新节奏，主要改动如下：</p><ol><li>每 6 个月发布一组新特性；</li><li>长期支持版（LTS）将支持 3 年，其他版本支持 6 个月；</li><li>Java11、Java17 是长期支持版；</li><li>采用<code>$FEATURE.$INTERIM.$UPDATE.$PATCH</code>命名机制：<code>$FEATURE</code>，每次版本发布加 1，不考虑具体的版本内容；<code>$INTERIM</code>，中间版本号，在大版本中间发布的，包含问题修复和增强的版本，不会引入非兼容性修改；<code>$PATCH</code>用于快速打补丁的。</li></ol><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文介绍了 Java10 新增的特性，完整的特性清单可以从<a href="https://openjdk.java.net/projects/jdk/10/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/10/</a>查看。后续内容会发布在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a> 系列专栏中。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/NY5-qkfZGdaOvz9iyJ3VSQ" target="_blank" rel="noopener">Java10 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/baBv0mP2JmPE4MoNYESqhA" target="_blank" rel="noopener">Java11 中基于嵌套关系的访问控制优化</a></li><li><a href="https://mp.weixin.qq.com/s/Bn4S2OfMoG19lI-L3nw8cg" target="_blank" rel="noopener">Java11 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/xBjXHC5UWy4JEKaRo6xQsg" target="_blank" rel="noopener">Java12 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/9EdRVPK0GUoQqI7eXcmwEA" target="_blank" rel="noopener">Java13 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/rEAHIf40j_UECLlxK5KW6w" target="_blank" rel="noopener">Java14 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/UESHDzuY3H7p5LLPJfwyAw" target="_blank" rel="noopener">Java15 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/HExV39BU0lSbdtg0aMjbSA" target="_blank" rel="noopener">Java16 的新特性</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4OTU5NTA1Ng==&action=getalbum&album_id=1732392238946533378#wechat_redirect" target="_blank" rel="noopener">从小工到专家的 Java 进阶之旅</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-10-features/">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java10 的新特性</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122225794" target="_blank" rel="noopener">Java 每半年就会更新一次新特性，再不掌握就要落伍了：Java10 的新特性</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      从 Java10 开始，Java 版本正式进入每半年一个版本的更新节奏，更新频率加快，小步快跑。在 Java10 中增加了局部变量类型推断、不可变集合、Optional增强、G1 实现并行 Full GC 算法、支持容器、根证书认证等特性。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="Java10" scheme="https://www.howardliu.cn/tags/Java10/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis-Plus 版本冲突触发“Could not convert argument value of type [java.lang.String] to required type [java.lang.Class]”的 java.lang.NoClassDefFoundError 异常</title>
    <link href="https://www.howardliu.cn/mybatis-plus-conflict-noclassdeffounderror/"/>
    <id>https://www.howardliu.cn/mybatis-plus-conflict-noclassdeffounderror/</id>
    <published>2021-12-25T03:51:38.000Z</published>
    <updated>2021-12-25T03:51:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/cover/dog-2963062_1920.jpg" alt="Mybatis-Plus 版本冲突触发“Could not convert argument value of type [java.lang.String] to required type [java.lang.Class]”的 java.lang.NoClassDefFoundError 异常"></p><p>你好，我是看山。</p><p>今天项目依赖了一个基础组件之后，启动失败，排查过程走了一些弯路，最终确认是因为依赖组件版本冲突造成了<code>java.lang.NoClassDefFoundError</code>异常。下面是排查过程，希望可以给你提供一些思路。</p><a id="more"></a><h2 id="观察异常栈"><a href="#观察异常栈" class="headerlink" title="观察异常栈"></a>观察异常栈</h2><p>下面是打印的异常栈信息，从其中提炼可能的关键信息，能够找到“Could not convert argument value of type [java.lang.String] to required type [java.lang.Class]”，还有“Unresolvable class definition for class [cn.howardliu.demo.AddressMapper]”。继续从异常栈中找一下发生的时机，可以发现是调用<code>AbstractAutowireCapableBeanFactory.createBeanInstance</code>时，这个方法是创建 Bean 实例。</p><pre><code class="log">这块是异常信息（getMessage 的内容，横向太长，手动换行了）：org.springframework.beans.factory.UnsatisfiedDependencyException:    Error creating bean with name &#39;methodValidationPostProcessor&#39; defined in class path resource [org/springframework/boot/autoconfigure/validation/ValidationAutoConfiguration.class]:    Unsatisfied dependency expressed through method &#39;methodValidationPostProcessor&#39; parameter 0;    nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException:    Error creating bean with name &#39;addressMapper&#39; defined in file [/Users/liuxinghao/Documents/work/code/cn.howardliu/effective-spring/target/classes/cn/howardliu/demo/AddressMapper.class]:    Unsatisfied dependency expressed through constructor parameter 0:    Could not convert argument value of type [java.lang.String] to required type [java.lang.Class]:    Failed to convert value of type &#39;java.lang.String&#39; to required type &#39;java.lang.Class&#39;;    nested exception is java.lang.IllegalArgumentException:     Unresolvable class definition for class [cn.howardliu.demo.AddressMapper]下面是异常栈：    at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:799) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:540) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1341) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1181) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:556) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:516) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:324) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:322) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:207) ~[spring-beans-5.2.13.RELEASE.jar:5.2.13.RELEASE]其他异常栈信息可以忽略了</code></pre><p>我们可以根据目前有效的信息进行排查，首先看下我们的<code>cn.howardliu.demo.AddressMapper</code>定义是否有问题，再看看依赖它的 Service 有没有问题，什么问题也没有发现。下一个检查点是配置，比如<code>@MapperScan</code>是否正确、Mapper 类上有没有加上<code>@Mapper</code>注解，发现也没有问题。</p><p>从异常信息找不到思路了，只能从代码入手了。</p><blockquote><p>这里需要说一下，打印异常信息至关重要，直接影响我们排错的思路。如果打印的信息没有办法准确定位，我们将会花费大量的时间查找真正的错误，这就需要走查代码，有时候还需要一些经验。</p></blockquote><h2 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h2><p>我们由异常栈<code>ConstructorResolver.createArgumentArray(ConstructorResolver.java:799)</code>入手，跟着断点往下追，最终会追到<code>org.springframework.util.ClassUtils#forName</code>方法，其中会抛出异常的代码是下面这块：</p><pre><code class="java">try {    return Class.forName(name, false, clToUse);}catch (ClassNotFoundException ex) {    int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);    if (lastDotIndex != -1) {        String innerClassName =                name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);        try {            return Class.forName(innerClassName, false, clToUse);        }        catch (ClassNotFoundException ex2) {            // Swallow - let original exception get through        }    }    throw ex;}</code></pre><p>出现错误的是<code>Class.forName(name, false, clToUse)</code>这句，<code>name</code>传的是”cn.howardliu.demo.AddressMapper”字符串，抛出的异常是<code>java.lang.NoClassDefFoundError</code>，由于不是<code>ClassNotFoundException</code>异常，不会进入<code>catch</code>逻辑，会直接向上抛出。</p><p>找到错误我们就好定位问题了。</p><p>一般来说，<code>java.lang.NoClassDefFoundError</code>错误是需要加载的类能够找到，但是加载时出现了异常，简单说就是，类的定义有问题。我们借助 JD-GUI 反编译一下运行 jar 包，结果如下：</p><pre><code class="java">import com.baomidou.mybatisplus.core.mapper.BaseMapper;import cn.howardliu.demo.Address;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface AddressMapper extends BaseMapper&lt;Address&gt; {}</code></pre><p>观察仔细的话，我们可以看到<code>import com.baomidou.mybatisplus.core.mapper.BaseMapper;</code>这行没有下划线，也就是说，在反编译工具中追溯不到这个接口，推断出来就是在运行环境中，找不到<code>BaseMapper</code>这个类定义。</p><p>所以，当<code>Class.forName</code>加载类的时候抛出了<code>java.lang.NoClassDefFoundError</code>异常。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>如果有一定经验，就会立刻想到，大概率出现了依赖 jar 的版本冲突。</p><p>我们可以借助 maven 命令行找到版本冲突的依赖：</p><pre><code class="shell">mvn dependency:tree -Dverbose | grep conflict</code></pre><p>打印结果为：</p><pre><code class="log">[INFO] |  +- (com.baomidou:mybatis-plus:jar:3.1.2:compile - omitted for conflict with 2.1.6)</code></pre><p>我们也可以借助 IDEA 的可视化工具，在 pom.xml 上打开依赖图：</p><p><img src="https://static.howardliu.cn/java/EF543BDC-9C35-43CF-A181_20211225114104.png" alt="依赖图"></p><p>我们可以看到 mybatis-plus 的红线指示出冲突信息：</p><p><img src="https://static.howardliu.cn/java/F0C16C09-7C27-4D34-99F9-B73B665EF0A3_20211225114132.png" alt="冲突信息"></p><p>结论就是 Mybatis-Plus 版本冲突了，项目中依赖了 mybatis-plus 的 2.1.6 和 3.1.2 两个版本，由于 2.1.6 路径更短，最终被选中。</p><p>此时只需要将低版本的依赖去掉即可。</p><h2 id="复盘问题"><a href="#复盘问题" class="headerlink" title="复盘问题"></a>复盘问题</h2><h3 id="mybatis-plus-的版本问题"><a href="#mybatis-plus-的版本问题" class="headerlink" title="mybatis-plus 的版本问题"></a>mybatis-plus 的版本问题</h3><p>为什么低版本的 mybatis-plus 会造成类加载失败呢？是因为 mybatis-plus 跨版本更新时，把<code>BaseMapper</code>的包路径改了：</p><pre><code class="java">// 3.1.2 版本import com.baomidou.mybatisplus.core.mapper.BaseMapper;// 2.1.6 版本import com.baomidou.mybatisplus.mapper.BaseMapper;</code></pre><p>而且还不止这一个，<code>IService</code>、<code>ServiceImpl</code>、<code>TableName</code>、<code>TableField</code>、<code>Model</code>、<code>TableField</code>等等，很多常用的类都改了位置。所以会造成找不到依赖的类。编译是 3.1.2 依赖还在运行环境中，就会出现编译没有问题，执行时出现加载类异常。</p><p>想要工程化的解决这个问题，我们可以创建基础的依赖 bom 配置，定义好基础依赖包，在项目中不在指定版本。这样做到统一版本，可以有效地避免这类问题。</p><p>我们还可以在 CI/CD 中加入冲突依赖检查，如果发现冲突依赖，就终止流水线。</p><h3 id="真实异常被隐藏问题"><a href="#真实异常被隐藏问题" class="headerlink" title="真实异常被隐藏问题"></a>真实异常被隐藏问题</h3><p>接下来我们看下为什么明明是<code>java.lang.NoClassDefFoundError</code>异常，结果异常栈中打印的是一堆不相干的错误。继续跟着刚才的断点 Debug：</p><p><code>org.springframework.util.ClassUtils#resolveClassName</code>会捕捉<code>LinkageError</code>错误，然后包装成<code>IllegalArgumentException</code>异常，这个时候真是异常还是继续上抛。</p><p>然后在<code>org.springframework.beans.TypeConverterSupport#convertIfNecessary</code>方法会包装成<code>TypeMismatchException</code>异常，此时，真实异常还在异常<code>cause</code>参数中，并没有丢失。</p><p>等回到<code>org.springframework.beans.factory.support.ConstructorResolver#createArgumentArray</code>方法后，捕捉异常的方法是：</p><pre><code class="java">try {    convertedValue = converter.convertIfNecessary(originalValue, paramType, methodParam);}catch (TypeMismatchException ex) {    throw new UnsatisfiedDependencyException(            mbd.getResourceDescription(), beanName, new InjectionPoint(methodParam),            &quot;Could not convert argument value of type [&quot; +                    ObjectUtils.nullSafeClassName(valueHolder.getValue()) +                    &quot;] to required type [&quot; + paramType.getName() + &quot;]: &quot; + ex.getMessage());}</code></pre><p>此时我们可以注意到，在包装成<code>UnsatisfiedDependencyException</code>异常的时候，只是把捕捉到的<code>TypeMismatchException</code>通过<code>getMessage</code>方法追加在异常描述后面，此时经过前面几轮的包装再包装，真实的异常的异常信息仅剩<code>Unresolvable class definition for class [cn.howardliu.demo.AddressMapper]</code>这段经过处理的信息，完全没有<code>java.lang.NoClassDefFoundError</code>的影子了。</p><p>至此，真实异常消失无踪。</p><p>这也给我们一个提醒，我们要保证异常的时候，一定要保留有效信息，否则，排错会非常麻烦。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文是抓虫文，从问题出发，到解决问题，给出完整的思路。<code>java.lang.NoClassDefFoundError</code>一般都是出现在版本冲突的时候，这种异常是编译打包没有问题，在运行时加载类失败。在本文中之所以排查时走了一些弯路，是因为<code>Spring</code>隐藏了真实异常，给我们排错造成了一些阻碍。所以，我们在日常开发时也要重视异常的明确信息，可以给我们排错提供准确的目标。</p><p>青山不改，绿水长流，我们下次见。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/7f5dcjjKLdBYpzS5p7_v7Q" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://mp.weixin.qq.com/s/JOLrw7cbVh8z2czePEfLjw" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></li><li><a href="https://mp.weixin.qq.com/s/Vhw-2lgCvmhNI5aeXOWYNg" target="_blank" rel="noopener">使用 Lambda 表达式实现超强的排序功能</a></li><li><a href="https://mp.weixin.qq.com/s/Srv6733byTYDg7hTrW_tdw" target="_blank" rel="noopener">Java8 的时间库（1）：介绍 Java8 中的时间类及常用 API</a></li><li><a href="https://mp.weixin.qq.com/s/LRydpL89GsjOeTrLrihyYQ" target="_blank" rel="noopener">Java8 的时间库（2）：Date 与 LocalDate 或 LocalDateTime 互相转换</a></li><li><a href="https://mp.weixin.qq.com/s/KmBMLG1y73IUwFuSfUKaEQ" target="_blank" rel="noopener">Java8 的时间库（3）：开始使用 Java8 中的时间类</a></li><li><a href="https://mp.weixin.qq.com/s/PxC0WQMReIeG0Tyl5WiK1Q" target="_blank" rel="noopener">Java8 的时间库（4）：检查日期字符串是否合法</a></li><li><a href="https://mp.weixin.qq.com/s/rjMOq0QAdiWNacKYqHJqXA" target="_blank" rel="noopener">Java8 的新特性</a></li><li><a href="https://mp.weixin.qq.com/s/FHv963s0Qvh2K5r2tdLATA" target="_blank" rel="noopener">Java9 的新特性</a></li></ul><hr><p>你好，我是看山。游于码界，戏享人生。如果文章对您有帮助，请点赞、收藏、关注。我还整理了一些精品学习资料，关注公众号「看山的小屋」，回复“资料”即可获得。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/mybatis-plus-conflict-noclassdeffounderror/">Mybatis-Plus 版本冲突触发“Could not convert argument value of type [java.lang.String] to required type [java.lang.Class]”的 java.lang.NoClassDefFoundError 异常</a><br>CSDN 主页：<a href="https://kanshan.blog.csdn.net/" target="_blank" rel="noopener">https://kanshan.blog.csdn.net/</a><br>CSDN 博文：<a href="https://kanshan.blog.csdn.net/article/details/122203746" target="_blank" rel="noopener">Mybatis-Plus 版本冲突触发“Could not convert argument value of type [java.lang.String] to required type [java.lang.Class]”的 java.lang.NoClassDefFoundError 异常</a></p><center><b>👇🏻欢迎关注我的公众号「看山的小屋」，领取精选资料👇🏻</b></center><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      今天项目依赖了一个基础组件之后，启动失败，排查过程走了一些弯路，最终确认是因为依赖组件版本冲突造成了`java.lang.NoClassDefFoundError`异常。下面是排查过程，希望可以给你提供一些思路。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="NoClassDefFoundError" scheme="https://www.howardliu.cn/tags/NoClassDefFoundError/"/>
    
      <category term="Mybatis-Plus" scheme="https://www.howardliu.cn/tags/Mybatis-Plus/"/>
    
  </entry>
  
</feed>
